

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="GODXQI">
  <meta name="keywords" content="">
  
    <meta name="description" content="01、版权和版本 12345678910111213141516171819202122版权和版本的声明位于头文件和定义文件的开头（参见示例1-1），主要内容有：（1）版权信息。（2）文件名称，标识符，摘要。（3）当前版本号，作者&#x2F;修改者，完成日期。（4）版本历史信息。&#x2F;** Copyright (c) 2001,上海贝尔有限公司网络应用事业部* All rights reserved.**">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言习惯">
<meta property="og:url" content="https://godxqi.github.io/2023/01/15/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E4%B9%A0%E6%83%AF/index.html">
<meta property="og:site_name" content="GODXQI&#39;s Blog">
<meta property="og:description" content="01、版权和版本 12345678910111213141516171819202122版权和版本的声明位于头文件和定义文件的开头（参见示例1-1），主要内容有：（1）版权信息。（2）文件名称，标识符，摘要。（3）当前版本号，作者&#x2F;修改者，完成日期。（4）版本历史信息。&#x2F;** Copyright (c) 2001,上海贝尔有限公司网络应用事业部* All rights reserved.**">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-01-15T12:19:10.735Z">
<meta property="article:modified_time" content="2023-01-15T12:26:02.484Z">
<meta property="article:author" content="GODXQI">
<meta property="article:tag" content="C">
<meta property="article:tag" content="未重构">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>C语言习惯 - GODXQI&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"godxqi.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>GODXQI</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C语言习惯"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-01-15 20:19" pubdate>
          January 15, 2023 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          17k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          143 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">C语言习惯</h1>
            
            
              <div class="markdown-body">
                
                <p>  <strong>01</strong>、版权和版本</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">版权和版本的声明位于头文件和定义文件的开头（参见示例1-1），主要内容有：<br>（1）版权信息。<br>（2）文件名称，标识符，摘要。<br>（3）当前版本号，作者/修改者，完成日期。<br>（4）版本历史信息。<br><br>/*<br><span class="hljs-bullet">* </span>Copyright (c) 2001,上海贝尔有限公司网络应用事业部<br><span class="hljs-bullet">* </span>All rights reserved.<br><span class="hljs-bullet">*</span><br><span class="hljs-bullet"></span><span class="hljs-bullet">* </span>文件名称：filename.h<br><span class="hljs-bullet">* </span>文件标识：见配置管理计划书<br><span class="hljs-bullet">* </span>摘要：简要描述本文件的内容<br><span class="hljs-bullet">*</span><br><span class="hljs-bullet"></span><span class="hljs-bullet">* </span>当前版本：1.1<br><span class="hljs-bullet">* </span>作者：输入作者（或修改者）名字<br><span class="hljs-bullet">* </span>完成日期：2001年7月20日<br><span class="hljs-bullet">*</span><br><span class="hljs-bullet"></span><span class="hljs-bullet">* </span>取代版本：1.0<br><span class="hljs-bullet">* </span>原作者：输入原作者（或修改者）名字<br><span class="hljs-bullet">* </span>完成日期：2001年5月10日<br>*/<br></code></pre></td></tr></table></figure>

<p>      </p>
<p> ** 02**、缩进、空格、换行、空行、对齐</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/eternal_yangyun/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">82936434</span><br><span class="hljs-number">1</span>.括号、运算符号前后加空格，<br><span class="hljs-number">2</span>.<span class="hljs-keyword">if</span>等条件语句判断条件多或者函数参数多，活用换行并对齐<br>iii) 换行。<br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;len; i++) &#123;<br>        <span class="hljs-keyword">if</span> ( ( a[i] &lt; <span class="hljs-string">&#x27;0&#x27;</span> || a[i] &gt; <span class="hljs-string">&#x27;9&#x27;</span> ) &amp;&amp;<br>             ( a[i] &lt; <span class="hljs-string">&#x27;a&#x27;</span> || a[i] &gt; <span class="hljs-string">&#x27;z&#x27;</span> ) ) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>函数参数多的时候，最好也换行，如：<br>    CreateProcess(<br>                  NULL,<br>                  cmdbuf,<br>                  NULL,<br>                  NULL,<br>                  bInhH,<br>                  dwCrtFlags,<br>                  envbuf,<br>                  NULL,<br>                  &amp;siStartInfo,<br>                  &amp;prInfo<br>                 );<br>    条件语句也应该在必要时换行：<br>    <span class="hljs-keyword">if</span> ( ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> || ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span> ||<br>         ch &gt;= <span class="hljs-string">&#x27;a&#x27;</span> || ch &lt;= <span class="hljs-string">&#x27;z&#x27;</span> ||<br>         ch &gt;= <span class="hljs-string">&#x27;A&#x27;</span> || ch &lt;= <span class="hljs-string">&#x27;Z&#x27;</span> )<br><br>对齐。用TAB键对齐你的一些变量的声明或注释，一样会让你的程序好看一些。如：<br>typedef struct _pt_man_t_ &#123;<br>    int     numProc;    <span class="hljs-regexp">/* Number of processes                 */</span><br>    int     maxProc;    <span class="hljs-regexp">/* Max Number of processes             */</span><br>    int     numEvnt;    <span class="hljs-regexp">/* Number of events                    */</span><br>    int     maxEvnt;    <span class="hljs-regexp">/* Max Number of events                */</span><br>    HANDLE* pHndEvnt;   <span class="hljs-regexp">/* Array of events                     */</span><br>    DWORD   timeout;    <span class="hljs-regexp">/* Time out interval                   */</span><br>    HANDLE  hPipe;      <span class="hljs-regexp">/* Namedpipe                           */</span><br>    TCHAR   usr[MAXUSR];<span class="hljs-regexp">/* User name of the process            */</span><br>    int     numMsg;     <span class="hljs-regexp">/* Number of Message                   */</span><br>    int     Msg[MAXMSG];<span class="hljs-regexp">/* Space for intro process communicate */</span><br>&#125; PT_MAN_T;<br></code></pre></td></tr></table></figure>

<p>       </p>
<p> <strong>03</strong>、程序注释</p>
<p>少用&#x2F;&#x2F;注释</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/**/</span>(块注释)与<span class="hljs-regexp">//</span>(行注释)嵌套使用<br>但是一些老版本的C编译器并不支持行注释，所以为了你的程序的移植性，请你还是尽量使用块注释<br><br>你也许会为块注释的不能嵌套而不爽，那么你可以用预编译来完成这个功能。使用“<span class="hljs-comment">#if 0”和“#endif”括起来的代码，将不被编译，而且还可以嵌套。</span><br></code></pre></td></tr></table></figure>

<p>      </p>
<p>  <strong>04</strong>、函数的[in][out]参数</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/z_cqupt/article/details/89153852">https://blog.csdn.net/z_cqupt&#x2F;article&#x2F;details&#x2F;89153852</a></p>
<p>函数名实际上是一个指针常量，即这个函数的地址。</p>
<p>函数的返回值经常并不是函数的输出部分，而多用于返回0或1表示是否成功。</p>
<p>函数的形参既可以用来输入也可以用作输出，在函数需要多个返回值的时候就使用形参进行输出。形参参数可以分为输入型参数与输出型参数，传入的普通变量就一定是输入型的参数，但只有传入的指针才可能是输出型参数。</p>
<p>常常在指针形参前加上一个const表示这是个输入型参数，例如const int *p表示p指向的地址可以改变，p本身不能改变，作者：“这是我的输入参数，你改我输入干嘛”</p>
<p><strong>05</strong>、对系统调用的返回进行判断</p>
<p>对于一些系统调用，调用结束后需要进行判断后再使用，比如：文件句柄、socket返回的socket号，malloc返回的内存。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">    fp = fopen(<span class="hljs-string">&quot;log.txt&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>);<br>    <span class="hljs-keyword">if</span> ( fp == <span class="hljs-literal">NULL</span> )&#123;<br>        printf(<span class="hljs-string">&quot;Error: open file error/n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><strong>06</strong>、if 语句对出错的处理</p>
<p>if语句中判断条件放出错的条件，这样可以突出错误，让别人一眼看到错误条件而下意识避免错误操作</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lasso">    <span class="hljs-keyword">if</span> ( ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span> )&#123;<br>        <span class="hljs-comment">/* 输出错误信息 */</span><br>        printf(<span class="hljs-string">&quot;error ......\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> ( <span class="hljs-literal">FALSE</span> );<br>    &#125;<br>   <br>    <span class="hljs-comment">/* 正常处理代码 */</span><br>    <span class="hljs-params">...</span><span class="hljs-params">...</span><br></code></pre></td></tr></table></figure>

<p><strong>07</strong>、头文件中的#ifndef</p>
<p>在大型的软件工程中，可能有多个文件包含一个头文件，当这些文件编译链接成一个可执行文件时，就会出现大量的“重定义”错误，所以在头文件头部就使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> <span class="hljs-string">&lt;标识&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> <span class="hljs-string">&lt;标识&gt;</span></span><br>...<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<p>标识的命名规则一般是头文件名全大写，前后加下划线，并把文件名中的“.”也变成下划线，如：stdio.h应为_STDIO_H_</p>
<p><strong>08</strong>、在堆上分配内存要及时释放(malloc和free)</p>
<p>stack上分配的内存系统自动释放，heap上分配的内存，除非手动释放系统永远不自动释放，哪怕程序退出，那一块内存还是在那里。stack一般是静态分配内存，heap上一般是动态分配内存。</p>
<p>由malloc系统函数分配的内存就是从堆上分配内存。从堆上分配的内存一定要自己用free释放。不然就是术语——“内存泄露”—— Memory Leak。系统的可分配内存会随malloc越来越少，直到系统崩溃。下面是“栈内存”和“堆内存”的差别。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    栈内存分配<br>    —————<br>    <span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">AllocStrFromStack</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">char</span> pstr[<span class="hljs-number">100</span>];<br>        <span class="hljs-keyword">return</span> pstr;<br>    &#125;<br>   <br>    堆内存分配<br>    —————<br>    <span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">AllocStrFromHeap</span><span class="hljs-params">(<span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">char</span> *pstr;<br>       <br>        <span class="hljs-keyword">if</span> ( len &lt;= <span class="hljs-number">0</span> ) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> ( <span class="hljs-type">char</span>* ) <span class="hljs-built_in">malloc</span>( len );<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>对于第一个函数，那块pstr的内存在函数返回时就被系统释放了。于是所返回的char*什么也没有。而对于第二个函数，是从堆上分配内存，所以哪怕是程序退出时，也不释放，所以第二个函数的返回的内存没有问题，可以被使用。但一定要调用free释放，不然就是Memory Leak！</p>
<p>在堆上分配内存很容易造成内存泄漏，这是C&#x2F;C++的最大的“克星”，如果你的程序要稳定，那么就不要出现Memory Leak。所以，我还是要在这里千叮咛万嘱付，在使用malloc系统函数（包括calloc，realloc）时千万要小心。</p>
<p>   </p>
<p>对于malloc和free的操作有以下规则：</p>
<p>1) 配对使用，有一个malloc，就应该有一个free。</p>
<p>2) 尽量在同一层上使用，不要malloc在函数中，而free在函数外。最好在同一调用层上使用这两个函数。</p>
<p>3) malloc分配的内存一定要初始化(malloc前，将指针置NULL，NULL指不指向任何实体)。free后的指针一定要设置为NULL(free后，将指针置NULL)。   </p>
<p><strong>09</strong>、变量一定要被初始化再使用(包括全局变量和静态变量)</p>
<p>如：</p>
<p>    1) 对malloc分配的内存进行memset清零操作。（可以使用calloc分配一块全零的内存）</p>
<p>    2) 对一些栈上分配的struct或数组进行初始化。（最好也是清零）</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs gradle">memset:<br>功 能: 将s所指向的某一块内存中的每个字节的内容全部设置为ch指定的ASCII值,块的大小由第三个参数指定,这个函数通常为新申请的内存做初始化工作<br><span class="hljs-keyword">void</span> *memset(<span class="hljs-keyword">void</span> *s,<span class="hljs-keyword">int</span> c,size_t n)<br>作用：将已开辟内存空间 s 的首 n 个字节的值设为值 c（给空间初始化）；<br>C语言需要包含头文件string.h；C++需要包含cstring 或 string.h<br><br>calloc:<br><span class="hljs-keyword">void</span>* calloc (size_t num, size_t <span class="hljs-keyword">size</span>);<br>calloc() 函数用来动态地分配 num 个长度为 <span class="hljs-keyword">size</span> 字节内存空间并初始化为 <span class="hljs-number">0</span>，分配成功返回指向该内存的地址，失败则返回 <span class="hljs-keyword">NULL</span>。<br>函数的返回值类型是 <span class="hljs-keyword">void</span> *，所以在使用 calloc() 时通常需要进行强制类型转换。<br>calloc() 与 malloc() 的一个重要区别是：calloc() 在动态分配完内存后，自动初始化该内存空间为零，而<br>malloc() 不初始化，里边数据是未知的垃圾数据。<br><br><span class="hljs-comment">// calloc() 分配内存空间并初始化 </span><br><span class="hljs-keyword">char</span> *str1 = (<span class="hljs-keyword">char</span> *)calloc(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>); <br><span class="hljs-comment">// malloc() 分配内存空间并用 memset() 初始化 </span><br><span class="hljs-keyword">char</span> *str2 = (<span class="hljs-keyword">char</span> *)malloc(<span class="hljs-number">20</span>); <br>memset(str2, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure>

<p>但初始化也会造成系统运行时间有一定的开销，所以，也不需要对所有的变量做初始化。如：以下这种情况，则不需要。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">        char *pstr;  <span class="hljs-regexp">/* 一个字符串 */</span><br>        pstr = ( char* ) malloc( <span class="hljs-number">50</span> );<br>        <span class="hljs-keyword">if</span> ( pstr == NULL ) <span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>        strcpy( pstr, <span class="hljs-string">&quot;Hello Wrold&quot;</span> );<br></code></pre></td></tr></table></figure>

<p>但如果是下面一种情况，最好进行内存初始化。（指针也一定要初始化，赋值NULL或一个有效值）</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">        char **pstr;  <span class="hljs-regexp">/* 一个字符串数组 */</span><br>        pstr = ( char** ) malloc( <span class="hljs-number">50</span>*sizeof(char*) );<br>        <span class="hljs-keyword">if</span> ( pstr == NULL ) <span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>       <br>        <span class="hljs-regexp">/* 让数组中的指针都指向NULL */</span><br>        memset( pstr, <span class="hljs-number">0</span>, <span class="hljs-number">50</span>*sizeof(char*) );<br></code></pre></td></tr></table></figure>

<p>而对于全局变量，和静态变量，一定要声明时就初始化</p>
<p><strong>10</strong>、h和c文件的使用</p>
<p>带初始化的全局变量不要放在H文件中，会造成每个包含该头文件的文件都有这个全局变量。因为C语言的include是直接将文件嵌入到include这个地方。</p>
<span style="background-color: #ffaaaa">

</span>

<p><strong>11</strong>、重要的出错信息统一处理</p>
<p>出错信息或是提示信息，应该统一处理。如果要管理错误信息，那就要有以下的处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-comment">/* 声明出错代码 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_NO_ERROR    0  <span class="hljs-comment">/* No error                 */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_OPEN_FILE   1  <span class="hljs-comment">/* Open file error          */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_SEND_MESG   2  <span class="hljs-comment">/* sending a message error  */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_BAD_ARGS    3  <span class="hljs-comment">/* Bad arguments            */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_MEM_NONE    4  <span class="hljs-comment">/* Memeroy is not enough    */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_SERV_DOWN   5  <span class="hljs-comment">/* Service down try later   */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_UNKNOW_INFO 6  <span class="hljs-comment">/* Unknow information       */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_SOCKET_ERR  7  <span class="hljs-comment">/* Socket operation failed  */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_PERMISSION  8  <span class="hljs-comment">/* Permission denied        */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_BAD_FORMAT  9  <span class="hljs-comment">/* Bad configuration file   */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_TIME_OUT   10  <span class="hljs-comment">/* Communication time out   */</span></span><br>   <br>    <span class="hljs-comment">/* 声明出错信息 */</span><br>    <span class="hljs-type">char</span>* errmsg[] = &#123;<br>        <span class="hljs-comment">/* 0 */</span>       <span class="hljs-string">&quot;No error&quot;</span>,               <br>        <span class="hljs-comment">/* 1 */</span>       <span class="hljs-string">&quot;Open file error&quot;</span>,       <br>        <span class="hljs-comment">/* 2 */</span>       <span class="hljs-string">&quot;Failed in sending/receiving a message&quot;</span>,<br>        <span class="hljs-comment">/* 3 */</span>       <span class="hljs-string">&quot;Bad arguments&quot;</span>,<br>        <span class="hljs-comment">/* 4 */</span>       <span class="hljs-string">&quot;Memeroy is not enough&quot;</span>,<br>        <span class="hljs-comment">/* 5 */</span>       <span class="hljs-string">&quot;Service is down; try later&quot;</span>,<br>        <span class="hljs-comment">/* 6 */</span>       <span class="hljs-string">&quot;Unknow information&quot;</span>,<br>        <span class="hljs-comment">/* 7 */</span>       <span class="hljs-string">&quot;A socket operation has failed&quot;</span>,<br>        <span class="hljs-comment">/* 8 */</span>       <span class="hljs-string">&quot;Permission denied&quot;</span>,<br>        <span class="hljs-comment">/* 9 */</span>       <span class="hljs-string">&quot;Bad configuration file format&quot;</span>,<br>        <span class="hljs-comment">/* 10 */</span>      <span class="hljs-string">&quot;Communication time out&quot;</span>,<br>    &#125;;<br>                             <br>    <span class="hljs-comment">/* 声明错误代码全局变量 */</span><br>    <span class="hljs-type">long</span> errno = <span class="hljs-number">0</span>;<br>   <br>    <span class="hljs-comment">/* 打印出错信息函数 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">perror</span><span class="hljs-params">( <span class="hljs-type">char</span>* info )</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> ( info )&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: %s\n&quot;</span>, info, errmsg[errno] );<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error: %s\n&quot;</span>, errmsg[errno] );<br>    &#125;<br>这个基本上是ANSI的错误处理实现细节了，于是当你程序中有错误时你就可以这样处理：<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CheckPermission</span><span class="hljs-params">( <span class="hljs-type">char</span>* userName )</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">strcpy</span>(userName, <span class="hljs-string">&quot;root&quot;</span>) != <span class="hljs-number">0</span> )&#123;<br>            errno = ERR_PERMISSION_DENIED;<br>            <span class="hljs-keyword">return</span> (FALSE);<br>        &#125;<br>        ...<br>    &#125;<br>   <br>    <span class="hljs-built_in">main</span>()<br>    &#123;<br>        ...<br>        <span class="hljs-keyword">if</span> (! <span class="hljs-built_in">CheckPermission</span>( username ) )&#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;main()&quot;</span>);<br>        &#125;<br>        ...<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>一个即有共性，也有个性的错误信息处理，这样做有利同种错误出一样的信息，统一用户界面，而不会因为文件打开失败，A程序员出一个信息，B程序员又出一个信息。而且这样做，非常容易维护。代码也易读。</p>
<p>当然，物极必反，也没有必要把所有的输出都放到errmsg中，抽取比较重要的出错信息或是提示信息是其关键，但即使这样，这也包括了大多数的信息。</p>
<p><span style="background-color: #ffaaaa"><strong>12</strong>、常用函数和循环语句中的被计算量</span></p>
<p>看一下下面这个例子：</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl">    <span class="hljs-function"><span class="hljs-title">for</span>( <span class="hljs-variable">i</span>=<span class="hljs-number">0</span>; <span class="hljs-variable">i</span>&lt;<span class="hljs-number">1000</span>; <span class="hljs-variable">i</span>++ )&#123;</span><br><span class="hljs-function">        <span class="hljs-title">GetLocalHostName</span>( <span class="hljs-variable">hostname</span> );</span><br><span class="hljs-function">        ...d<span class="hljs-string">&#x27;t</span></span><br><span class="hljs-string"><span class="hljs-function">    &#125;</span></span><br></code></pre></td></tr></table></figure>

<p>GetLocalHostName的意思是取得当前计算机名，在循环体中，它会被调用1000次啊。这是多么的没有效率的事啊。应该把这个函数拿到循环体外，这样只调用一次，效率得到了很大的提高。虽然，我们的编译器会进行优化，会把循环体内的不变的东西拿到循环外面，但是，你相信所有编译器会知道哪些是不变的吗？我觉得编译器不可靠。最好还是自己动手吧。</p>
<p>同样，对于常用函数中的不变量，如：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">GetLocalHostName(<span class="hljs-params">char</span><span class="hljs-operator">*</span> <span class="hljs-params">name</span>)</span><br>&#123;<br>    <span class="hljs-built_in">char</span> funcName<span class="hljs-literal">[]</span> = <span class="hljs-string">&quot;GetLocalHostName&quot;</span>;<br>   <br>    sys<span class="hljs-constructor">_log( <span class="hljs-string">&quot;%s begin......&quot;</span>, <span class="hljs-params">funcName</span> )</span>;<span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator">    </span>sys<span class="hljs-constructor">_log( <span class="hljs-string">&quot;%s end......&quot;</span>, <span class="hljs-params">funcName</span> )</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果这是一个经常调用的函数，每次调用时都要对funcName进行分配内存，这个开销很大啊。把这个变量声明成static吧，当函数再次被调用时，就会省去了分配内存的开销，执行效率也很好。</p>
<p><strong>13</strong>、函数名和变量名的命名</p>
<p>参考linux内核规范</p>
<p><strong>14</strong>、函数的传值和传指针</p>
<p>向函数传参数时，一般而言，传入非const的指针时，就表示，在函数中要修改这个指针把指内存中的数据。如果是传值，那么无论在函数内部怎么修改这个值，也影响不到传过来的值，因为传值是只内存拷贝。</p>
<p>什么？你说这个特性你明白了，好吧，让我们看看下面的这个例程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GetVersion</span><span class="hljs-params">(<span class="hljs-type">char</span>* pStr)</span></span><br><span class="hljs-function"></span>&#123;<br>    pStr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">strcpy</span> ( pStr, <span class="hljs-string">&quot;2.0&quot;</span> );<br>&#125;<br><span class="hljs-built_in">main</span>()<br>&#123;<br>    <span class="hljs-type">char</span>* ver = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">GetVersion</span> ( ver );<br>    ...<br>    ...<br>    <span class="hljs-built_in">free</span> ( ver );<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我保证，类似这样的问题是一个新手最容易犯的错误。程序中妄图通过函数GetVersion给指针ver分配空间，但这种方法根本没有什么作用，原因就是——这是传值，不是传指针。你或许会和我争论，我分明传的时指针啊？再仔细看看，其实，你传的是指针其实是在传值。</p>
<p><strong>15</strong>、修改别人程序的修养</p>
<p>当你维护别人的程序时，请不要非常主观臆断的把已有的程序删除或是修改。我经常看到有的程序员直接在别人的程序上修改表达式或是语句。修改别人的程序时，请不要删除别人的程序，如果你觉得别人的程序有所不妥，请注释掉，然后添加自己的处理程序，必竟，你不可能100%的知道别人的意图，所以为了可以恢复，请不依赖于CVS或是SourceSafe这种版本控制软件，还是要在源码上给别人看到你修改程序的意图和步骤。这是程序维护时，一个有修养的程序员所应该做的。</p>
<p>如下所示，这就是一种比较好的修改方法：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino">    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * ----- commented by haoel 2003/04/12 ------</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *   char* p = ( char* ) malloc( 10 );</span><br><span class="hljs-comment">     *   memset( p, 0, 10 );</span><br><span class="hljs-comment">     */</span><br>    <br>    <span class="hljs-comment">/* ------ Added by haoel   2003/04/12 ----- */</span><br>     <span class="hljs-type">char</span>* p = ( <span class="hljs-type">char</span>* )<span class="hljs-built_in">calloc</span>( <span class="hljs-number">10</span>, <span class="hljs-keyword">sizeof</span> <span class="hljs-type">char</span> );<br>    <span class="hljs-comment">/* ---------------------------------------- */</span><br>    ...<br></code></pre></td></tr></table></figure>

<p>当然，这种方法是在软件维护时使用的，这样的方法，可以让再维护的人很容易知道以前的代码更改的动作和意图，而且这也是对原作者的一种尊敬。</p>
<p>以“注释 — 添加”方式修改别人的程序，要好于直接删除别人的程序。</p>
<p><strong>16</strong>、把相同或近乎相同的代码形成函数和宏</p>
<p>有人说，最好的程序员，就是最喜欢“偷懒”的程序，其中不无道理。</p>
<p>如果你有一些程序的代码片段很相似，或直接就是一样的，请把他们放在一个函数中。而如果这段代码不多，而且会被经常使用，你还想避免函数调用的开销，那么就把他写成宏吧。</p>
<p>千万不要让同一份代码或是功能相似的代码在多个地方存在，不然如果功能一变，你就要修改好几处地方，这种会给维护带来巨大的麻烦，所以，做到“一改百改”，还是要形成函数或是宏。</p>
<p><strong>17</strong>、表达式中的括号</p>
<p>如果一个比较复杂的表达式中，你并不是很清楚各个操作符的忧先级，即使是你很清楚优先级，也请加上括号，不然，别人或是自己下一次读程序时，一不小心就看走眼理解错了，为了避免这种“误解”，还有让自己的程序更为清淅，还是加上括号吧。</p>
<p>比如，对一个结构的成员取地址：</p>
<p>    GetUserAge( &amp;( UserInfo-&gt;age ) );</p>
<p>虽然，&amp;UserInfo-&gt;age中，-&gt;操作符的优先级最高，但加上一个括号，会让人一眼就看明白你的代码是什么意思。</p>
<p>再比如，一个很长的条件判断：</p>
<p>if ( ( ch[0] &gt;&#x3D; ‘0’ || ch[0] &lt;&#x3D; ‘9’ ) &amp;&amp;</p>
<p>     ( ch[1] &gt;&#x3D; ‘a’ || ch[1] &lt;&#x3D; ‘z’ ) &amp;&amp;</p>
<p>     ( ch[2] &gt;&#x3D; ‘A’ || ch[2] &lt;&#x3D; ‘Z’ )    )</p>
<p>括号，再加上空格和换行，你的代码是不是很容易读懂了？    </p>
<p><strong>18</strong>、函数参数中的const</p>
<p>对于一些函数中的指针参数，如果在函数中只读，请将其用const修饰，这样，别人一读到你的函数接口时，就会知道你的意图是这个参数是[in]，如果没有const时，参数表示[in&#x2F;out]，注意函数接口中的const使用，利于程序的维护和避免犯一些错误。</p>
<p>虽然，const修饰的指针，如：const char* p，在C中一点用也没有，因为不管你的声明是不是const，指针的内容照样能改，因为编译器会强制转换，但是加上这样一个说明，有利于程序的阅读和编译。因为在C中，修改一个const指针所指向的内存时，会报一个Warning。这会引起程序员的注意。</p>
<p>C++中对const定义的就很严格了，所以C++中要多多的使用const，const的成员函数，const的变量，这样会对让你的代码和你的程序更加完整和易读。（关于C++的const我就不多说了）</p>
<p><strong>19</strong>、函数的参数个数</p>
<p>函数的参数个数最好不要太多，一般来说6个左右就可以了，众多的函数参数会让读代码的人一眼看上去就很头昏，而且也不利于维护。如果参数众多，还请使用结构来传递参数。这样做有利于数据的封装和程序的简洁性。</p>
<p>也利于使用函数的人，因为如果你的函数个数很多，比如12个，调用者很容易搞错参数的顺序和个数，而使用结构struct来传递参数，就可以不管参数的顺序。</p>
<p>而且，函数很容易被修改，如果需要给函数增加参数，不需要更改函数接口，只需更改结构体和函数内部处理，而对于调用函数的程序来说，这个动作是透明的。</p>
<p><strong>20</strong>、函数的返回类型，不要省略</p>
<p>我看到很多程序写函数时，在函数的返回类型方面不太注意。如果一个函数没有返回值，也请在函数前面加上void的修饰。而有的程序员偷懒，在返回int的函数则什么不修饰（因为如果不修饰，则默认返回int），这种习惯很不好，还是为了原代码的易读性，加上int吧。</p>
<p>所以函数的返回值类型，请不要省略。</p>
<p>另外，对于void的函数，我们往往会忘了return，由于某些C&#x2F;C++的编译器比较敏感，会报一些警告，所以即使是void的函数，我们在内部最好也要加上return的语句，这有助于代码的编译。</p>
<p><strong>21</strong>、goto语句的使用</p>
<p>N年前，软件开发的一代宗师——迪杰斯特拉(Dijkstra)说过：“goto statment is harmful !!”，并建议取消goto语句。因为goto语句不利于程序代码的维护性。</p>
<p>这里我也强烈建议不要使用goto语句，除非下面的这种情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-meta">#<span class="hljs-keyword">define</span> FREE(p) <span class="hljs-keyword">if</span>(p) &#123; \</span><br><span class="hljs-meta">                        free(p); \</span><br><span class="hljs-meta">                        p = NULL; \</span><br><span class="hljs-meta">                    &#125;</span><br>    <span class="hljs-built_in">main</span>()<br>    &#123;<br>        <span class="hljs-type">char</span> *fname=<span class="hljs-literal">NULL</span>, *lname=<span class="hljs-literal">NULL</span>, *mname=<span class="hljs-literal">NULL</span>;<br>        fname = ( <span class="hljs-type">char</span>* ) <span class="hljs-built_in">calloc</span> ( <span class="hljs-number">20</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) );<br>        <span class="hljs-keyword">if</span> ( fname == <span class="hljs-literal">NULL</span> )&#123;<br>            <span class="hljs-keyword">goto</span> ErrHandle;<br>        &#125;<br>        lname = ( <span class="hljs-type">char</span>* ) <span class="hljs-built_in">calloc</span> ( <span class="hljs-number">20</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) );<br>        <span class="hljs-keyword">if</span> ( lname == <span class="hljs-literal">NULL</span> )&#123;<br>            <span class="hljs-keyword">goto</span> ErrHandle;<br>        &#125;<br>        mname = ( <span class="hljs-type">char</span>* ) <span class="hljs-built_in">calloc</span> ( <span class="hljs-number">20</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) );<br>        <span class="hljs-keyword">if</span> ( mname == <span class="hljs-literal">NULL</span> )&#123;<br>            <span class="hljs-keyword">goto</span> ErrHandle;<br>        &#125;<br>       <br>        ......<br>    <br>       <br>     ErrHandle:<br>        <span class="hljs-built_in">FREE</span>(fname);<br>        <span class="hljs-built_in">FREE</span>(lname);<br>        <span class="hljs-built_in">FREE</span>(mname);<br>        <span class="hljs-built_in">ReportError</span>(ERR_NO_MEMOEY);<br>     &#125;<br></code></pre></td></tr></table></figure>

<p>也只有在这种情况下，goto语句会让你的程序更易读，更容易维护。（在用嵌C来对数据库设置游标操作时，或是对数据库建立链接时，也会遇到这种结构）</p>
<p><strong>22</strong>、宏的使用</p>
<p>很多程序员不知道C中的“宏”到底是什么意思？特别是当宏有参数的时候，经常把宏和函数混淆。我想在这里我还是先讲讲“宏”，宏只是一种定义，他定义了一个语句块，当程序编译时，编译器首先要执行一个“替换”源程序的动作，把宏引用的地方替换成宏定义的语句块，就像文本文件替换一样。这个动作术语叫“宏的展开”</p>
<p>使用宏是比较“危险”的，因为你不知道宏展开后会是什么一个样子。例如下面这个宏：</p>
<p>    #define  MAX(a, b)     a&gt;b?a:b</p>
<p>当我们这样使用宏时，没有什么问题： MAX( num1, num2 ); 因为宏展开后变成 num1&gt;num2?num1:num2；。 但是，如果是这样调用的，MAX( 17+32, 25+21 ); 呢，编译时出现错误，原因是，宏展开后变成：17+32&gt;25+21?17+32:25+21，哇，这是什么啊？</p>
<p>所以，宏在使用时，参数一定要加上括号，上述的那个例子改成如下所示就能解决问题了。</p>
<p>    #define  MAX( (a), (b) )     (a)&gt;(b)?(a):(b)</p>
<p>   </p>
<p>即使是这样，也不这个宏也还是有Bug，因为如果我这样调用 MAX(i++, j++); ， 经过这个宏以后，i和j都被累加了两次，这绝不是我们想要的。</p>
<p>   </p>
<p>所以，在宏的使用上还是要谨慎考虑，因为宏展开是的结果是很难让人预料的。而且虽然，宏的执行很快（因为没有函数调用的开销），但宏会让源代码澎涨，使目标文件尺寸变大，（如：一个50行的宏，程序中有1000个地方用到，宏展开后会很不得了），相反不能让程序执行得更快（因为执行文件变大，运行时系统换页频繁）。</p>
<p>因此，在决定是用函数，还是用宏时得要小心。</p>
<p><strong>23</strong>、static的使用</p>
<p>static关键字，表示了“静态”，一般来说，他会被经常用于变量和函数。一个static的变量，其实就是全局变量，只不过他是有作用域的全局变量。比如一个函数中的static变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">char</span>*</span><br><span class="hljs-function"><span class="hljs-title">getConsumerName</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>   <br>    ....<br>    cnt++;<br>    ....<br>&#125;<br></code></pre></td></tr></table></figure>

<p>cnt变量的值会跟随着函数的调用次而递增，函数退出后，cnt的值还存在，只是cnt只能在函数中才能被访问。而cnt的内存也只会在函数第一次被调用时才会被分配和初始化，以后每次进入函数，都不为static分配了，而直接使用上一次的值。</p>
<p>对于一些被经常调用的函数内的常量，最好也声明成static（参见第12条）</p>
<p>但static的最多的用处却不在这里，其最大的作用的控制访问，在C中<strong>如果一个函数或是一个全局变量被声明为static，那么，这个函数和这个全局变量，将只能在这个C文件中被访问，如果别的C文件中调用这个C文件中的函数，或是使用其中的全局（用extern关键字），将会发生链接时错误。这个特性可以用于数据和程序保密。</strong></p>
<p><strong>24</strong>、函数中的代码尺寸</p>
<p>一个函数完成一个具体的功能，一般来说，一个函数中的代码最好不要超过600行左右，越少越好，最好的函数一般在100行以内，300行左右的孙函数就差不多了。有证据表明，一个函数中的代码如果超过500行，就会有和别的函数相同或是相近的代码，也就是说，就可以再写另一个函数。</p>
<p>另外，函数一般是完成一个特定的功能，千万<strong>忌讳在一个函数中做许多件不同的事</strong>。函数的功能<strong>越单一越好</strong>，一方面有利于函数的易读性，另一方面更有利于代码的维护和重用，功能越单一表示这个函数就越可能给更多的程序提供服务，也就是说共性就越多。</p>
<p>虽然函数的调用会有一定的开销，但比起软件后期维护来说，增加一些运行时的开销而换来更好的可维护性和代码重用性，是很值得的一件事。</p>
<p><strong>25</strong>、typedef的使用</p>
<p>typedef是一个给类型起别名的关键字。不要小看了它，它对于你代码的维护会有很好的作用。比如C中没有bool，于是在一个软件中，一些程序员使用int，一些程序员使用short，会比较混乱，最好就是用一个typedef来定义，如：</p>
<p>    typedef char bool;</p>
<p>   </p>
<p>一般来说，一个C的工程中一定要做一些这方面的工作，因为你会涉及到跨平台，不同的平台会有不同的字长，所以利用预编译和typedef可以让你最有效的维护你的代码，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SOLARIS2_5</span><br>      <span class="hljs-keyword">typedef</span> <span class="hljs-type">boolean_t</span>     BOOL_T;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      <span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span>           BOOL_T;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>   <br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">short</span>           INT16_T;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>  UINT16_T;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span>             INT32_T;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>    UINT32_T;<br>   <br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> WIN32</span><br>      <span class="hljs-keyword">typedef</span> _int64        INT64_T;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      <span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>     INT64_T;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>   <br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">float</span>           FLOAT32_T;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span>*           STRING_T;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>   BYTE_T;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">time_t</span>          TIME_T;<br>    <span class="hljs-keyword">typedef</span> INT32_T         PID_T;<br></code></pre></td></tr></table></figure>

<p>   </p>
<p>使用typedef的其它规范是，在结构和函数指针时，也最好用typedef，这也有利于程序的易读和可维护性。如：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs elm">    typedef struct _hostinfo &#123;<br>        <span class="hljs-type">HOSTID_T</span>   host;<br>        <span class="hljs-type">INT32_T</span>    hostId;<br>        <span class="hljs-type">STRING_T</span>   hostType;<br>        <span class="hljs-type">STRING_T</span>   hostModel;<br>        <span class="hljs-type">FLOAT32_T</span>  cpuFactor;<br>        <span class="hljs-type">INT32_T</span>    numCPUs;<br>        <span class="hljs-type">INT32_T</span>    nDisks;<br>        <span class="hljs-type">INT32_T</span>    memory;<br>        <span class="hljs-type">INT32_T</span>    swap;<br>    &#125; <span class="hljs-type">HostInfo</span>;<br>    typedef <span class="hljs-type">INT32_T</span> (*<span class="hljs-type">RsrcReqHandler</span>)(<br>     void *info,<br>     <span class="hljs-type">JobArray</span> *jobs,<br>     <span class="hljs-type">AllocInfo</span> *allocInfo,<br>     <span class="hljs-type">AllocList</span> *allocList);<br></code></pre></td></tr></table></figure>

<p>C++中这样也是很让人易读的：</p>
<p>    typedef CArray&lt;HostInfo, HostInfo&amp;&gt; HostInfoArray;</p>
<p>于是，当我们用其定义变量时，会显得十分易读。如：</p>
<p>    HostInfo* phinfo;</p>
<p>    RsrcReqHandler* pRsrcHand;</p>
<p>这种方式的易读性，在函数的参数中十分明显。</p>
<p>关键是在程序种使用typedef后，几乎所有的程序中的类型声明都显得那么简洁和清淅，而且易于维护，这才是typedef的关键。</p>
<p><strong>26</strong>、为常量声明宏</p>
<p>最好不要在程序中出现数字式的“硬编码”，如：</p>
<p>    int user[120];</p>
<p>   </p>
<p>为这个120声明一个宏吧。为所有出现在程序中的这样的常量都声明一个宏吧。比如TimeOut的时间，最大的用户数量，还有其它，只要是常量就应该声明成宏。如果，突然在程序中出现下面一段代码，</p>
<p>    for ( i&#x3D;0; i&lt;120; i++){</p>
<p>        ….</p>
<p>    }</p>
<p>120是什么？为什么会是120？这种“硬编码”不仅让程序很读，而且也让程序很不好维护，如果要改变这个数字，得同时对所有程序中这个120都要做修改，这对修改程序的人来说是一个很大的痛苦。所以还是把常量声明成宏，这样，一改百改，而且也很利于程序阅读。</p>
<p>    #define MAX_USR_CNT 120</p>
<p>   </p>
<p>    for ( i&#x3D;0; i&lt;MAX_USER_CNT; i++){</p>
<p>        ….</p>
<p>    }</p>
<p>这样就很容易了解这段程序的意图了。</p>
<p>有的程序员喜欢为这种变量声明全局变量，其实，全局变量应该尽量的少用，全局变量不利于封装，也不利于维护，而且对程序执行空间有一定的开销，一不小心就造成系统换页，造成程序执行速度效率等问题。所以声明成宏，即可以免去全局变量的开销，也会有速度上的优势。</p>
<p><strong>27</strong>、不要为宏定义加分号</p>
<p>有许多程序员不知道在宏定义时是否要加分号，有时，他们以为宏是一条语句，应该要加分号，这就错了。当你知道了宏的原理，你会赞同我为会么不要为宏定义加分号的。看一个例子：</p>
<p>    #define MAXNUM 1024;</p>
<p>这是一个有分号的宏，如果我们这样使用：</p>
<p>    half &#x3D; MAXNUM&#x2F;2;</p>
<p>   </p>
<p>    if ( num &lt; MAXNUM )</p>
<p>等等，都会造成程序的编译错误，因为，当宏展开后，他会是这个样子的：</p>
<p>    half &#x3D; 1024;&#x2F;2;</p>
<p>   </p>
<p>    if ( num &lt; 1024; )</p>
<p>   </p>
<p>是的，分号也被展进去了，所以造成了程序的错误。请相信我，有时候，一个分号会让你的程序出现成百个错误。所以还是不要为宏加最后一个分号，哪怕是这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-meta">#<span class="hljs-keyword">define</span> LINE    <span class="hljs-string">&quot;=================================&quot;</span></span><br>   <br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT_LINE  printf(LINE)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT_NLINE(n)  while ( n-- &gt;0 ) &#123; PRINT_LINE; &#125;</span><br></code></pre></td></tr></table></figure>

<p>都不要在最后加上分号，当我们在程序中使用时，为之加上分号，</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">    main()<br>    &#123;<br>        char *p <span class="hljs-operator">=</span> LINE<span class="hljs-comment">;</span><br>        PRINT_LINE<span class="hljs-comment">;</span><br>    &#125;<br></code></pre></td></tr></table></figure>

<p>这一点非常符合习惯，而且，如果忘加了分号，编译器给出的错误提示，也会让我们很容易看懂的。</p>
<p><strong>28</strong>、||和&amp;&amp;的语句执行顺序</p>
<p>条件语句中的这两个“与”和“或”操作符一定要小心，它们的表现可能和你想像的不一样，这里条件语句中的有些行为需要和说一下：</p>
<p>    express1 || express2</p>
<p>       </p>
<p>    先执行表达式express1如果为“真”，express2将不被执行，express2仅在express1为“假”时才被执行。因为第一个表达式为真了，整个表达式都为真，所以没有必要再去执行第二个表达式了。</p>
<p>    express1 &amp;&amp; express2</p>
<p>    先执行表达式express1如果为“假”，express2将不被执行，express2仅在express1为“真”时才被执行。因为第一个表达式为假了，整个表达式都为假了，所以没有必要再去执行第二个表达式了。</p>
<p>于是，他并不是你所想像的所有的表达式都会去执行，这点一定要明白，不然你的程序会出现一些莫明的运行时错误。</p>
<p>例如，下面的程序：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lisp">    if ( <span class="hljs-name">sum</span> &gt; <span class="hljs-number">100</span> <span class="hljs-symbol">&amp;&amp;</span><br>         ( ( <span class="hljs-name">fp=fopen</span>( <span class="hljs-name">filename</span>,<span class="hljs-string">&quot;a&quot;</span> ) ) != NULL )   &#123;<br>        <br>         fprintf(<span class="hljs-name">fp</span>, <span class="hljs-string">&quot;Warring: it beyond one hundred\n&quot;</span>)<span class="hljs-comment">;</span><br>         ......<br>    &#125;<br>   <br>    fprintf( <span class="hljs-name">fp</span>, <span class="hljs-string">&quot; sum is %id \n&quot;</span>, sum )<span class="hljs-comment">;</span><br>    fclose( <span class="hljs-name">fp</span> )<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>本来的意图是，如果sum &gt; 100 ，向文件中写一条出错信息，为了方便，把两个条件判断写在一起，于是，如果sum&lt;&#x3D;100时，打开文件的操作将不会做，最后，fprintf和fclose就会发现未知的结果。</p>
<p>再比如，如果我想判断一个字符是不是有内容，我得判断这个字符串指针是不为空（NULL）并且其内容不能为空（Empty），一个是空指针，一个是空内容。我也许会这样写：</p>
<p>    if ( ( p !&#x3D; NULL ) &amp;&amp; ( strlen(p) !&#x3D; 0 ))</p>
<p>于是，如果p为NULL，那么strlen(p)就不会被执行，于是，strlen也就不会因为一个空指针而“非法操作”或是一个“Core Dump”了。</p>
<p>记住一点，条件语句中，并非所有的语句都会执行，当你的条件语句非常多时，这点要尤其注意。</p>
<p><strong>29</strong>、尽量用for而不是while做循环</p>
<p>基本上来说，for可以完成while的功能，我是建议尽量使用for语句，而不要使用while语句，特别是当循环体很大时，for的优点一下就体现出来了。</p>
<p>因为在for中，循环的初始、结束条件、循环的推进，都在一起，一眼看上去就知道这是一个什么样的循环。刚出学校的程序一般对于链接喜欢这样来：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">    p <span class="hljs-operator">=</span> pHead<span class="hljs-comment">;</span><br>   <br>    while ( p )&#123;<br>        ...<br>        ...<br>        p <span class="hljs-operator">=</span> p-&gt;next<span class="hljs-comment">;</span><br>    &#125;<br></code></pre></td></tr></table></figure>

<p>当while的语句块变大后，你的程序将很难读，用for就好得多：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">    <span class="hljs-keyword">for</span> ( <span class="hljs-attribute">p</span>=pHead;  p; <span class="hljs-attribute">p</span>=p-&gt;next )&#123;<br>    <span class="hljs-built_in">..</span><br>    &#125;<br></code></pre></td></tr></table></figure>

<p>一眼就知道这个循环的开始条件，结束条件，和循环的推进。大约就能明白这个循环要做个什么事？而且，程序维护进来很容易，不必像while一样，在一个编辑器中上上下下的捣腾。</p>
<p><strong>30</strong>、请sizeof类型而不是变量</p>
<p>许多程序员在使用sizeof中，喜欢sizeof变量名，例如：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">int score<span class="hljs-selector-attr">[100]</span>;<br>char filename<span class="hljs-selector-attr">[20]</span>;<br>struct UserInfo usr<span class="hljs-selector-attr">[100]</span>;<br></code></pre></td></tr></table></figure>

<p>在sizeof这三个的变量名时，都会返回正确的结果，于是许多程序员就开始sizeof变量名。这个习惯很虽然没有什么不好，但我还是建议sizeof类型。</p>
<p>我看到过这个的程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    pScore = (<span class="hljs-type">int</span>*) <span class="hljs-built_in">malloc</span>( SUBJECT_CNT );<br>    <span class="hljs-built_in">memset</span>( pScore, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(pScore) );<br>    ...<br></code></pre></td></tr></table></figure>

<p>此时，sizeof(pScore)返回的就是4（指针的长度），不会是整个数组，于是，memset就不能对这块内存进行初始化。为了程序的易读和易维护，我强烈建议使用类型而不是变量，如：</p>
<p>对于score：     sizeof(int) * 100   &#x2F;* 100个int *&#x2F;</p>
<p>对于filename：  sizeof(char) * 20   &#x2F;* 20个char *&#x2F;</p>
<p>对于usr：       sizeof(struct UserInfo) * 100   &#x2F;* 100个UserInfo *&#x2F;</p>
<p>这样的代码是不是很易读？一眼看上去就知道什么意思了。</p>
<p>另外一点，sizeof一般用于分配内存，这个特性特别在多维数组时，就能体现出其优点了。如，给一个字符串数组分配内存，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 分配一个有20个字符串，</span><br><span class="hljs-comment"> * 每个字符串长100的内存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">char</span>* *p;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 错误的分配方法</span><br><span class="hljs-comment"> */</span><br>p = (<span class="hljs-type">char</span>**)<span class="hljs-built_in">calloc</span>( <span class="hljs-number">20</span>*<span class="hljs-number">100</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) );<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 正确的分配方法</span><br><span class="hljs-comment"> */</span><br>p = (<span class="hljs-type">char</span>**) <span class="hljs-built_in">calloc</span> ( <span class="hljs-number">20</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>*) );<br><span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">20</span>; i++)&#123;<br>    <span class="hljs-comment">/*p = (char*) calloc ( 100, sizeof(char) );*/</span><br>    p[i] = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">calloc</span> ( <span class="hljs-number">100</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) );<br>&#125;<br></code></pre></td></tr></table></figure>

<p>（注：上述语句被注释掉的是原来的，是错误的，由dasherest朋友指正，谢谢）</p>
<p>为了代码的易读，省去了一些判断，请注意这两种分配的方法，有本质上的差别。</p>
<p><strong>31</strong>、不要忽略Warning</p>
<p>对于一些编译时的警告信息，请不要忽视它们。虽然，这些Warning不会妨碍目标代码的生成，但这并不意味着你的程序就是好的。必竟，并不是编译成功的程序才是正确的，编译成功只是×××长征的第一步，后面还有大风大浪在等着你。从编译程序开始，不但要改正每个error，还要修正每个warning。这是一个有修养的程序员该做的事。</p>
<p>一般来说，一面的一些警告信息是常见的：</p>
<p>1). 声明了未使用的变量。（虽然编译器不会编译这种变量，但还是把它从源程序中注释或是删除吧）</p>
<p>2). 使用了隐晦声明的函数。（也许这个函数在别的C文件中，编译时会出现这种警告，你应该这使用之前使用extern关键字声明这个函数）</p>
<p>3). 没有转换一个指针。（例如malloc返回的指针是void的，你没有把之转成你实际类型而报警，还是手动的在之前明显的转换一下吧）</p>
<p>4). 类型向下转换。（例如：float f &#x3D; 2.0; 这种语句是会报警告的，编译会告诉你正试图把一个double转成float，你正在阉割一个变量，你真的要这样做吗？还是在2.0后面加个f吧，不然，2.0就是一个double，而不是float了）</p>
<p><strong>32</strong>、书写Debug版和Release版的程序</p>
<p>程序在开发过程中必然有许多程序员加的调试信息。我见过许多项目组，当程序开发结束时，发动群众删除程序中的调试信息，何必呢？为什么不像VC++那样建立两个版本的目标代码？一个是debug版本的，一个是Release版的。那些调试信息是那么的宝贵，在日后的维护过程中也是很宝贵的东西，怎么能说删除就删除呢？</p>
<p>利用预编译技术吧，如下所示声明调试函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEBUG</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TRACE</span><span class="hljs-params">(<span class="hljs-type">char</span>* fmt, ...)</span></span><br><span class="hljs-function">        </span>&#123;<br>            ......<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        <span class="hljs-meta">#<span class="hljs-keyword">define</span> TRACE(char* fmt, ...)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<p>于是，让所有的程序都用TRACE输出调试信息，只需要在在编译时加上一个参数“-DDEBUG”，如：</p>
<p>    cc -DDEBUG -o target target.c</p>
<p>于是，预编译器发现DEBUG变量被定义了，就会使用TRACE函数。而如果要发布给用户了，那么只需要把取消“-DDEBUG”的参数，于是所有用到TRACE宏，这个宏什么都没有，所以源程序中的所有TRACE语言全部被替换成了空。一举两得，一箭双雕，何乐而不为呢？</p>
<p>顺便提一下，两个很有用的系统宏，一个是“__FILE__”，一个是“__LINE__”，分别表示，所在的源文件和行号，当你调试信息或是输出错误时，可以使用这两个宏，让你一眼就能看出你的错误，出现在哪个文件的第几行中。这对于用C&#x2F;C++做的大工程非常的管用。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/C%E8%AF%AD%E8%A8%80/" class="category-chain-item">C语言</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/C/">#C</a>
      
        <a href="/tags/%E6%9C%AA%E9%87%8D%E6%9E%84/">#未重构</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C语言习惯</div>
      <div>https://godxqi.github.io/2023/01/15/C语言/C语言习惯/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>GODXQI</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>January 15, 2023</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/01/15/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/" title="C语言知识补充">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">C语言知识补充</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/01/15/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" title="C语言基础">
                        <span class="hidden-mobile">C语言基础</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
