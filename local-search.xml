<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>桩函数</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/%E6%A1%A9%E5%87%BD%E6%95%B0/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/%E6%A1%A9%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位操作</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/%E4%BD%8D%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>一、置位操作：</p><p>7,8位置1：将想置位的数与0xc0(1100 0000)相或</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">a <span class="hljs-string">|= 0xc0;</span><br></code></pre></td></tr></table></figure><p>但算出0xc0太麻烦，可以直接这么用</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span> |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure><p>二、清位操作：</p><p>7,8位置0：将想清位的数与0x3f(0011 1111)相与，即与0xc0的取反值相与</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">a <span class="hljs-meta">&amp;= ~(0xc0);</span><br></code></pre></td></tr></table></figure><p>但算出0x3f太麻烦，可以直接这么用</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span> &amp;= ~((<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">8</span>));<br></code></pre></td></tr></table></figure><p>三、取位操作</p><p>把第8位取出来放在b中：想取位的数与0x80相与(1000 0000)</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">b</span> = a &amp; <span class="hljs-number">0</span>x80<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>但算出0x80太麻烦，可以直接这么用</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">b</span> = a &amp; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">8</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>形如：取X的低八位</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">X <span class="hljs-meta">&amp; 0xff</span><br></code></pre></td></tr></table></figure><p>四、任意位取反</p><p>a ^&#x3D; 1&lt;&lt;17</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>条件编译指令</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。</p><p>指令用途</p><ul><li># 空指令，无任何效果</li><li>#include 包含一个源代码文件</li><li>#define 定义宏</li><li>#undef 取消已定义的宏</li><li>#if 如果给定条件为真，则编译下面代码</li><li>#ifdef 如果宏已经定义，则编译下面代码</li><li>#ifndef 如果宏没有定义，则编译下面代码</li><li>#elif 如果前面的#if给定条件不为真，当前条件为真，则编译下面代码</li><li>#endif 结束一个#if……#else条件编译块</li><li>#error 停止编译并显示错误信息</li></ul><p>条件编译指令将决定那些代码被编译，而哪些是不被编译的。可以根据表达式的值或者某个特定的宏是否被定义来确定编译条件。</p><ol><li>#if指令</li></ol><p>#if指令检测跟在制造另关键字后的常量表达式。如果表达式为真，则编译后面的代码，知道出现#else、#elif或#endif为止；否则就不编译。</p><ol><li>#endif指令</li></ol><p>#endif用于终止#if预处理指令。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG 0</span><br><span class="hljs-built_in">main</span>()<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Debugging\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Running\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于程序定义DEBUG宏代表0，所以#if条件为假，不编译后面的代码直到#endif，所以程序直接输出Running。</p><p>如果去掉#define语句，效果是一样的。</p><ol><li>#ifdef和#ifndef</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG</span><br><span class="hljs-built_in">main</span>()<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEBUG</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;yes\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DEBUG</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;no\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined等价于#<span class="hljs-keyword">ifdef</span>; #<span class="hljs-keyword">if</span> !defined等价于#<span class="hljs-keyword">ifndef</span></span><br></code></pre></td></tr></table></figure><ol><li>#else指令</li></ol><p>#else指令用于某个#if指令之后，当前面的#if指令的条件不为真时，就编译#else后面的代码。#endif指令将中指上面的条件块。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG</span><br><span class="hljs-built_in">main</span>()<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEBUG</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Debugging\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Not debugging\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Running\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>#elif指令</li></ol><p>#elif预处理指令综合了#else和#if指令的作用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TWO</span><br><span class="hljs-built_in">main</span>()<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ONE</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined TWO</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;3\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>程序很好理解，最后输出结果是2。</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>条件编译</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<p>条件编译使用分析</p><p>使用一拨人开发一份代码，根据一份代码产生高中低三种产品</p><p>一、基本概念</p><p>条件编译的行为类似于C语言中的if..else…，但不同的是if..else…语句在运行期进行分支判断，条件编译指令在预编译期进行分支判断。预编译器根据条件编译指令有选择的删除代码，到编译器时，编译器不知道代码分支的存在。</p><p>即条件编译为预编译指示命令,用于控制是否编译某段代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> C 1</span><br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span>* s;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span>( C == 1 )</span><br>        s = <span class="hljs-string">&quot;This is first printf...\n&quot;</span>;    <span class="hljs-comment">//进入编译</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        s = <span class="hljs-string">&quot;This is second printf...\n&quot;</span>;    <span class="hljs-comment">//不进入编译</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">// printf(&quot;%s&quot;, s);</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* test.i */</span><br><span class="hljs-meta"># 1 &quot;test.c&quot;</span><br><span class="hljs-meta"># 1 &quot;&lt;built-in&gt;&quot;</span><br><span class="hljs-meta"># 1 &quot;&lt;command-<span class="hljs-keyword">line</span>&gt;&quot;</span><br><span class="hljs-meta"># 1 &quot;test.c&quot;</span><br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span>* s;<br>        s = <span class="hljs-string">&quot;This is first printf...\n&quot;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过#if #else指示预处理器保存哪段代码，判定执行的代码才留下</p><p>二、可以通过命令行定义宏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 在函数中并不定义宏C */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* s;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span>( C == 1 )</span><br>        s = <span class="hljs-string">&quot;This is first printf...\n&quot;</span>;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        s = <span class="hljs-string">&quot;This is second printf...\n&quot;</span>;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* 格式 */</span><br>gcc -Dmacro=value file.c <br><br><span class="hljs-regexp">/* 在命令行中定义宏 */</span><br>gcc -DC=<span class="hljs-number">1</span> test.c<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 定义C作为宏标识符 */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* s;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> C</span><br>        s = <span class="hljs-string">&quot;This is first printf...\n&quot;</span>;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        s = <span class="hljs-string">&quot;This is second printf...\n&quot;</span>;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//printf(&quot;%s&quot;, s);</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>三、#include的本质</p><p>（1）</p><p>#include的本质是将已经存在的文件内容嵌入到当前文件中，但#include的间接包含同样会产生嵌入文件内容的操作，如下：</p><p><img src="/image/0d02d40684aeee981de901baa4201f04.png" alt="0d02d40684aeee981de901baa4201f04.png"></p><p>而间接包含同一个头文件会产生编译错误，因为重复包含会造成重复定义。</p><p>（2）条件编译可以解决头文件重复包含的编译错误</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#ifndef_ HEADER_ _FILE_ H_</span><br><span class="hljs-comment">#define_ HEADER_ FILE_ _H_</span><br><span class="hljs-regexp">//</span> source code<br><span class="hljs-comment">#endif</span><br></code></pre></td></tr></table></figure><p>四、条件编译的意义</p><p>条件编译使得我们可以按不同的条件编译不同的代码段，因而可以产生不同的目标代码</p><p>#if.. #else… #endif被预编译器处理,而if.. .else..语句被编译器处理,必然被编译进目标代码</p><p>实际工程中条件编译主要用于一下两种情况:</p><p>-不同的产品线共用一份代码</p><p>-区分编译产品的调试版和发布版</p><p>例：产品线区分及调试代码应用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* product.h </span><br><span class="hljs-comment"> * 文件指示了这是调试版的高端产品</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HIGH  1</span><br><br><span class="hljs-comment">/* test.c */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;product.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG    <span class="hljs-comment">//指示当前编译出来的可执行程序是调试版还是可发行版</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG(s) printf(<span class="hljs-string">&quot;[%s:%d] %s\n&quot;</span>, __FILE__, __LINE__, s)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG(s) NULL</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> HIGH    <span class="hljs-comment">//指示当前编译出来的可执行程序是高端产品还是低端产品</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is the high level product!\n&quot;</span>);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">LOG</span>(<span class="hljs-string">&quot;Enter main() ...&quot;</span>);<br>    <br>    <span class="hljs-built_in">f</span>();<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1. Query Information.\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2. Record Information.\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;3. Delete Information.\n&quot;</span>);<br>    <br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> HIGH    <span class="hljs-comment">//高端产品才有功能4，5</span></span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;4. High Level Query.\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;5. Mannul Service.\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;6. Exit.\n&quot;</span>);<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;4. Exit.\n&quot;</span>);<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <br>    <span class="hljs-built_in">LOG</span>(<span class="hljs-string">&quot;Exit main() ...&quot;</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>小结：</p><p>通过编译器命令行能够定义预处理器使用的宏</p><p>条件编译可以避免重复包含头同一个头文件</p><p>条件编译是在工程开发中可以区别不同产品线的代码</p><p>条件编译可以定义产品的发布版和调试版</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆与栈</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/%E5%A0%86%E4%B8%8E%E6%A0%88/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/%E5%A0%86%E4%B8%8E%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<p>堆与栈的比较：</p><p>1.1 申请方式：</p><ul><li>栈：系统自动分配</li><li>堆：程序员自己申请</li></ul><p>1.2 申请后系统的响应</p><ul><li>栈：只要有足够空间给你，系统就会为程序提供内存，否则报异常</li><li>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</li></ul><p>1.3 申请大小的限制</p><ul><li>栈：栈是向低地址扩展的数据结构，是一块连续的内存的区域。即栈顶的地址和栈的最大容量是系统预先规定好的</li><li>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</li></ul><p>1.4 申请效率的比较</p><ul><li>栈：系统自动分配，速度较快。但程序员无法控制。</li><li>堆：由new分配的内存，一般速度比较慢，容易产生内存碎片,不过用起来最方便。</li></ul><p>1.5 存储内容</p><ul><li>栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。</li></ul><p>当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</p><ul><li>堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。</li></ul><p>1.6 总结：</p><p>　　堆和栈的主要区别由以下几点：</p><p>　　1、管理方式不同；</p><p>　　2、空间大小不同；</p><p>　　3、能否产生碎片不同；</p><p>　　4、生长方向不同；</p><p>　　5、分配方式不同；</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">堆都是动态分配的<br>栈有2种分配方式：静态分配和动态分配。静态分配和动态分配都是编译器完成的<br></code></pre></td></tr></table></figure><p>　　6、分配效率不同；</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>断言</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/%E6%96%AD%E8%A8%80/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/%E6%96%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<p>if和断言区别：</p><p>（1）if是在最终发布的版本中真实存在的，用于处理程序运行过程中产生的错误（例如处理用户错误输入），以提高程序的健壮性。</p><p>（2）断言用于开发阶段的调试，捕捉不应该发生的非法情况，并迅速定位问题。发布的时候需要把断言去掉</p><p>背景：</p><p>写有参数的函数时，首要工作，就是要对传进来的所有参数进行合法性检查。而对于传出的参数也应该进行检查，这个动作当然应该在函数的外部，也就是说，调用完一个函数后，应该对其传出的值进行检查。这时使用assert进行调试</p><p>一、断言概况</p><p>1、断言</p><p>（1）在使用C语言编写工程代码时，我们总会对某种假设条件进行检查，断言就是用于在代码中捕捉这些假设，可以将断言看作是异常处理的一种高级形式。</p><p>（2）断言表示为一些布尔表达式，程序员相信在程序中的某个特定点该表达式值为真。可以在任何时候启用和禁用断言验证，因此可以在测试时启用断言，而在部署时禁用断言。</p><p>（3）同样，程序投入运行后，最终用户在遇到问题时可以重新起用断言。它可以快速发现并定位软件问题，同时对系统错误进行自动报警。断言可以对在系统中隐藏很深，用其它手段极难发现的问题可以用断言来进行定位，从而缩短软件问题定位时间，提高系统的可测性。实际应用时，可根据具体情况灵活地设计断言。</p><p>2、一般使用的地方</p><p>（1）在函数的入口处，使用断言检查参数的有效性（合法性）。</p><p>（2）在编写函数时，要进行反复的考查，并且自问：“我打算做哪些假定？”一旦确定了的假定，就要使用断言对假定进行检查。</p><p>（3）可以在预计正常情况下程序不会到达的地方放置断言。（如assert (0);）</p><p>（4）使用断言测试方法执行的前置条件和后置条件 。</p><p>（5）使用断言检查类的不变状态，确保任何情况下，某个变量的状态必须满足。（如某个变量的变化范围）</p><p>二、断言的使用方式</p><p>1、使用库函数中的断言</p><p>（1）assert宏的原型定义在&lt;assert.h&gt;中，其作用是先计算表达式expression，如果expression的值为假（即为0），那么它打印出错表达式，并且定位出错的文件位置以及出错行数，最后调用abort()函数，终止程序</p><p>（2）禁止断言的方法</p><p>在#include&lt;assert.h&gt;的前面加上#define NDEBUG</p><p>注意：一定是要在该头文件之前添加#define NDEBUG，在头文件之后添加是不能禁止断言的</p><p>三、例子</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs markdown">/<span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">**</span><br><span class="hljs-strong"><span class="hljs-emphasis">* using_assert.c                     *</span></span><br><span class="hljs-strong"><span class="hljs-emphasis">*                                    *</span></span><br><span class="hljs-strong"><span class="hljs-emphasis">* C语言的错误检测机制：断言          *</span></span><br><span class="hljs-strong">**</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>/<br><br><span class="hljs-section">#include <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">stdio.h</span>&gt;</span></span></span><br><span class="hljs-section">#include <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">assert.h</span>&gt;</span></span></span><br><br>int main()<br>&#123;<br>  int x;<br>  printf(&quot;请输入一个正整数：&quot;);<br>  scanf(&quot;%d&quot;, &amp;x);<br><br>  assert(x &gt; 0);<br><br>  printf(&quot;输入的数符合要求!\n&quot;);<br><br>  return 0;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">clone_string</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">char</span> *source )</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">char</span> *result;<br>        <span class="hljs-built_in">assert</span>( source != <span class="hljs-literal">NULL</span> );<br>        result = ( <span class="hljs-type">char</span>* )<span class="hljs-built_in">malloc</span>( <span class="hljs-built_in">strlen</span>(source) + <span class="hljs-number">1</span> );<br>        <span class="hljs-keyword">if</span>( result != <span class="hljs-literal">NULL</span> )<br>        &#123;<br>            <span class="hljs-built_in">strcpy</span>( result, source );<br>            <span class="hljs-built_in">assert</span>( <span class="hljs-built_in">strcmp</span>(result, source) == <span class="hljs-number">0</span> );<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>（1）注意到我对source是否为NULL是用assert检查的，但对result是不是为NULL是用if语句判断的</p><p>（2）这是因为在调用代码正确的情况下source必然不为NULL，如果断言失败，说明调用代码中有错误，需要修改；但result作为malloc的返回值则不一定，在malloc代码无误的情况下仍然可能返回NULL——当内存块不足时。</p><p>（3）最后又用assert对strcpy的结果进行检查，因为只要代码正确，无论什么情况strcpy应该正常完成复制，它没有malloc那种异常情况存在。</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变量在存储器中的存放形式</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/%E5%8F%98%E9%87%8F%E5%9C%A8%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AD%98%E6%94%BE%E5%BD%A2%E5%BC%8F/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/%E5%8F%98%E9%87%8F%E5%9C%A8%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AD%98%E6%94%BE%E5%BD%A2%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>一、不同位宽的存储器：</p><p>1.1 存储器的位宽</p><p>存储器的位宽表示</p><p>存储器位宽表示了每个地址下有多少位数据，与它的数据线根数相等；</p><p>如：32位机器一个地址下就有32位数据，即4个字节（这4个字节称为一个字，字就是机器字长）</p><p><img src="/image/aebf2a992bb87aca50c5faf53d1777fd.png" alt="aebf2a992bb87aca50c5faf53d1777fd.png"></p><p>1.2 存储器的存储器容量</p><p>存储器容量是位宽与2^N的乘积，此处单位为bit。</p><p>如：2M * 32bit的存储器中，2M个存储空间，一个空间32位数据。即2^21，21个地址线。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2M</span> * <span class="hljs-number">32</span> bit = <span class="hljs-number">8</span>MB = <span class="hljs-number">8</span> * <span class="hljs-number">2</span>^<span class="hljs-number">10</span> KB = <span class="hljs-number">8</span> * <span class="hljs-number">2</span>^<span class="hljs-number">20</span> B = <span class="hljs-number">8</span> * <span class="hljs-number">8</span> * <span class="hljs-number">2</span>^<span class="hljs-number">20</span> bit = <span class="hljs-number">32</span> * <span class="hljs-number">2</span>^<span class="hljs-number">21</span> bit<br></code></pre></td></tr></table></figure><p>即地址线为21根</p><p>1.3 寻址方式</p><p>所谓的CPU按字寻址还是按字节寻址实际上是指CPU 发出的每一个地址信号实际得到的数据是一个字节还是一个字。这并不是由CPU决定的，而是由CPU与存储器之间的连线决定的。</p><p>CPU发出的地址体现在与存储器相连的地址线上，存储器收到地址线传来的信号后，再把对应存储单元里的数据发送出去，但CPU与存储器收发都是对应位宽的数据，即使CPU想要的是一个8位数据，但它的数据线收到的还是对应存储器位宽的数据（可以看作存储器地址线收到信号，数据线读出信号）。</p><p>但一个16位的存储器，收到地址信号后发出一个16位的数据，这个数据不会直接到CPU手里，会到内存控制器这里（S3C2440），内存控制器再看看CPU实际想要多大的数据，若需要8位，它再根据存储器没有收到的地址来决定把16位数据里的哪8位给CPU。这样CPU输出一个地址，收到了一个8位数据，就可以说CPU是按字节编制的。</p><p>（1）按字寻址：字作为一个寻址单元，CPU得到了一个字</p><p><img src="/image/0b7f8205de9809573dee910458df3d88.png" alt="0b7f8205de9809573dee910458df3d88.png"></p><p><img src="/image/7a75ed64159614d23fa9c4ee59e10a37.png" alt="7a75ed64159614d23fa9c4ee59e10a37.png"></p><p>CPU发出地址 000000、000001、000010、000011，存储器收到的都是对应的000000、000001、000010、000011。存储器直接把数据发出去，内存控制器一看不需要它筛选，直接将32位数据给CPU，即CPU按字寻址。</p><p>（2）按字节寻址：字节作为一个寻址单元，CPU得到了一个字节</p><p><img src="/image/f305d9f5ccad0fca8beaa97116e81254.png" alt="f305d9f5ccad0fca8beaa97116e81254.png"></p><p><img src="/image/79c1cbf8709888869a7476f13bed3984.png" alt="79c1cbf8709888869a7476f13bed3984.png"></p><p>CPU发出地址 000000、000001、000010、000011，由于A0与A1都没接到存储器上，所以无论发出哪个地址存储器收到的都是0000，然后它把对应的32位数据给出去，内存控制器再根据A0A1判断CPU要的是32位里的哪8位（涉及到大小端），即CPU按字节寻址。</p><p>1.3 存储器的地址编号范围</p><p>存储器的地址线根数(N)决定了它的地址编号范围（2^N）</p><p>若按字节寻址：24根地址线，每一位都可以用来编号，范围为2^24 &#x3D; 16M</p><p>若按字寻址：   24根地址线，需要预留几根地址线区分每个字节的位置，若是32位设备，需要预留2根线，22根线寻址范围为2^22 &#x3D; 4M</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变量的存储位置/程序文件与程序进程中数据的位置</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/%E5%8F%98%E9%87%8F%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE-%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%BF%9B%E7%A8%8B%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BD%8D%E7%BD%AE/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/%E5%8F%98%E9%87%8F%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE-%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%BF%9B%E7%A8%8B%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BD%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>一、程序进程与程序文件：</p><p>程序进程就是程序运行时的程序（如在内存上运行）</p><p>程序文件是编译后生成的可执行文件，比如.bin文件等</p><p>二、冯诺依曼结构和哈佛结构：</p><p>2.1 简介</p><p>（1）冯诺依曼结构：提出了二进制逻辑、程序存储思想和计算机由五个部分组成。将指令存储器与数据存储器合在一起，使指令和数据共享一条总线。</p><p>指令的执行为顺序执行，无法重叠执行，只有完成一个再执行下一个，使得信息流传输成为限制性能的瓶颈。</p><p>（2）哈佛结构：将程序指令和数据分开存储，指令存储器与数据存储器采用两条独立的总线，这两条总线之间毫无关联。</p><p>中央处理器首先到指令存储器中读取程序指令内容，解码后得到数据地址，再到相应的数据存储器中读取数据，并进行下一步的操作（通常是执行）。</p><p>在指令执行时可以预先读下一条指令，取指令和存取数据分别由不同的存储空间和总线，这样也就克服了信息流传输的瓶颈。</p><p>2.2 二者区别：</p><p>区别：程序空间和数据空间是否为一体的。冯诺依曼结构的程序空间和数据空间不分开，哈佛结构数据空间和地址空间是分开的。</p><p>优缺点：哈佛结构略为复杂，对外围设备的连接与处理要求高，十分不适合外围存储器的扩展。所以早期通用CPU难以采用这种结构。而对于单片机来说，由于内部集成了所需的存储器，所以采用哈佛结构也未尝不可。现在的处理器，依托cache的存在，已经很好的将二者统一起来了（cache的出现，是为了缓解CPU和内存之间速度的不匹配问题（结构：cpu -&gt; cache -&gt; memory））。</p><p>2.3 改进型哈佛结构：</p><p>将程序指令和数据分开存储，具有一条独立的地址总线和一条独立的数据总线，利用公用地址总线访问两个存储模块（程序存储模块和数据存储模块），公用数据总线则被用来完成程序存储模块或数据存储模块与CPU之间的数据传输；两条总线由程序存储器和数据存储器分时共用。</p><p>2.4 常见芯片</p><p>Intel的x86处理器：大多为冯诺依曼结构，之所以其早期能快速占领市场，正是采用了这种实现简单、成本低的结构</p><p>51单片机：程序进程的逻辑代码段放在ROM中，而变量部分则放在RAM中，取ROM中的指令和RAM中的变量是两套总线。即数据指令存储区是分开的，总线是分时复用的，所以采用的是改进型哈佛结构。</p><p>ARM9、S3C2440：ARM9被称为是哈佛结构是从它拥有指令cache和数据cache角度来说的，实际上它现在称之为“改进的哈佛结构”，因为这两个cache是独立的，可以并行运行。</p><p>ARM：从ARM9开始以后所有的ARM处理器内核都是改进型的哈佛结构。ARM的逻辑代码和变量都是存放在RAM中的，但是，它在内存中划分了两部分的空间，其中一部分放逻辑代码，另一部分存放变量，之间不会相互干扰。</p><p>DSP：大多采用改进型哈佛结构。</p><p>2.5 从代码角度理解：</p><p>在编写程序时，可以对程序的代码分为两个部分，一部分是程序编写完成后就不再需要对其进行修改了的（也就是逻辑代码部分）另一部分就是在程序编写完毕后其内容会随着程序的运行而不断变化的部分（也就是变量数据部分）。而哈佛结构和冯诺依曼结构就是对于这个两部分代码的存储方式的区别。</p><p>哈佛结构：将程序的逻辑代码和变量分开存放，他们存放的位置可以是形同的（ARM）也可以是不同的（51），只要是分成两个部分单独访问的结构都可以叫哈佛结构。这种结构大量应用在嵌入式编程当中。</p><p>冯诺依曼结构：冯诺依曼结构则是将逻辑代码段和变量统一都存储在内存当中，他们之间一般是按照代码的执行顺序依次存储。</p><p>三、程序文件中的分区</p><p>一般情况下，一个程序本质上都是由 bss段、data段、text段三个组成的。</p><p>3.1 相关概念：</p><p>Code，RO_data，RW_data，ZI_data，RO，RW等常出现在嵌入式程序编译完成后的名词。比如Keil中</p><p><img src="/image/20150717122223189.jpg" alt="20150717122223189.jpg"></p><ul><li>Code：即代码域，也称.text段。它指的是编译器生成的机器指令。</li><li>RO_data：即只读数据域，也称.rodata段。它指程序中用到的只读数据，例如const关键字定义的全局变量、字符串字面量。</li><li>RW_data：即可读写数据域，也称.data段。它指初始化为“非0值”的可读写数据，程序刚运行时，这些数据具有非0的初始值，且运行的时候它们会常驻在RAM区，因而应用程序可以修改其内容。例如全局变量或者静态变量，且定义时赋予“非0值”给该变量进行初始化。</li><li>ZI_data：ZeroInitialie data即0初始化数据，也称.bss段。它指初始化为“0值”的可读写数据域，它与RW_data的区别是程序刚运行时这些数据初始值全都为0，而后续运行过程与RW-data的性质一样，它们也常驻在RAM区，因而应用程序可以更改其内容。包括未初始化的全局变量，和初始化为0的全局变量。并不给该段的数据分配空间，只是记录数据所需空间的大小。</li></ul><p>注：RO为只读区域，包括RO_data和code。应与RO_data区分开来。</p><p>3.2 ARM映像文件 </p><p>bin文件和hex都被称为ARM映像文件，即linux的可执行文件，被烧入到<span style="background-color: #ffaaaa">ROM（Nor,Nand）</span>中，它之中包含了Code、RO_data与RW_data。一般来说，在程序运行的最初阶段，RO中的指令完成了这两项工作</p><ol><li>将RW从ROM中搬到RAM中，因为RW是变量，变量不能存在ROM中。</li><li>将ZI所在的RAM区域全部清零，因为ZI区域并不在映像文件中，所以需要程序根据编译器给出的ZI地址及大小来将相应得RAM区域清零。ZI中也是变量，同理：变量不能存在ROM中</li></ol><p>完成了工作后C程序才能正常访问变量。否则只能运行不含变量的代码。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">从这里就可以看出<span class="hljs-meta">ARM</span>为哈佛结构，程序与代码分别在两个位置访问<br></code></pre></td></tr></table></figure><p>程序存储在ROM中时，所占用的大小为Code + RO_data + RW_data</p><p>当程序执行时，RW_data和 ZI_data在RAM中，RO_data和Code视cpu架构（51、arm、x86）处于ROM或者RAM中。</p><p>四、程序进程中的分区（假如bin直接在SRAM上运行）</p><p>程序加载运行时，.text段和.rodata段合并到一个Segment中，即代码段（text Segment），操作系统将这个Segment的页面只读保护起来，防止意外的改写。</p><p>BSS段的大小从可执行文件中(bin)得到，然后链接器得到这个大小的内存块，紧跟在数据段后面。当这个内存区进入程序的地址空间后全部清零。</p><p><img src="/image/25114105_Xc9r.jpg" alt="25114105_Xc9r.jpg"></p><ul><li>代码段：代码段（code segment&#x2F;text segment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</li><li>数据段：数据段（data segment）通常是指用来存放程序中已初始化且不为0的全局变量的一块内存区域。</li><li>BSS段：BSS段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。</li><li>堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。</li><li>栈(stack)：栈又称堆栈，用户存放程序临时创建的局部变量。在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的后进先出特点，所以栈特别方便用来保存&#x2F;恢复调用现场。</li></ul><p>五、从内存地址的角度描述变量存储位置</p><ul><li>代码区：存放二进制代码的区域</li><li>（文字）常量区：存放常量的区域，程序结束时，系统回收。const修饰的全局变量在区域中的低地址，字符串字面量紧随其后</li><li>全局&#x2F;静态存储区：存放全局变量和静态变量。全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。</li><li>堆：由程序员分配和释放，如果程序员不释放，会有内存泄漏，程序结束时，由操作系统回收。容量大, 速度慢, 无序。</li><li>栈：系统自动分配并释放，存放函数的参数值，局部变量等。容量小,速度快,有序. 栈是系统数据结构，对应线程&#x2F;进程是唯一的。</li></ul><p>这种描述方式将bss段和数据段合并在一起称呼，同时又将.rodata段从代码段中分离</p><p>六、我的观点</p><p>常量区在内存中分配的地址由编译器（链接阶段）决定，可能在全局存储区前，也可能插入全局存储区中放在数据段后bss段之前。我们也可以写lds链接脚本自己规定</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">链接脚本主要用于规定如何把输入文件内的section放入输出文件内, 并控制输出文件内各部分在程序地址空间内的布局<br>输入文件: 目标文件或链接脚本文件.<br>输出文件: 目标文件或可执行文件.<br></code></pre></td></tr></table></figure><p><img src="/image/84e7fa5e6f971cce295713ef9dd3fde2.png" alt="84e7fa5e6f971cce295713ef9dd3fde2.png"></p><p>在vc6.0中，常量区在全局存储区之前；在gcc编译器中，常量区在全局存储区中放在数据段后bss段之前。</p><hr><p><a href="https://blog.csdn.net/u014600626/article/details/81533125?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_utm_term-0&spm=1001.2101.3001.4242">https://blog.csdn.net/u014600626/article/details/81533125?utm_medium&#x3D;distribute.pc_relevant.none-task-blog-baidujs_utm_term-0&amp;spm&#x3D;1001.2101.3001.4242</a></p><p><a href="https://blog.csdn.net/zhy557/article/details/80832268?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">https://blog.csdn.net/zhy557/article/details/80832268?utm_medium&#x3D;distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;dist_request_id&#x3D;&amp;depth_1-utm_source&#x3D;distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control</a></p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>volatile</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/volatile/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/volatile/</url>
    
    <content type="html"><![CDATA[<ol><li>程序的硬件优化：</li></ol><p>（1）由于CPU处理速度远大于内存访问速度，CPU直接从内存中存取数据需要等待一定的时间，所以为了提高整体性能，在硬件上引入高速Cache。Cache保存有CPU刚用过或者循环使用的一部分数据，CPU再需要使用这些数据时直接从Cache调用，减少CPU的等待时间。</p><p>（2）在现代CPU中指令的执行并不一定严格按照顺序，没有相关性的指令可以乱序执行，以充分利用CPU的指令流水线，提高执行速度。</p><ol><li>程序的软件优化：</li></ol><p>（1）程序员优化</p><p>（2）编译器优化：</p><p>①将内存变量缓存到寄存器</p><p>②调整指令顺序优化流水线，例如重新排序读写指令</p><p>有些时候这些优化并不是程序所需要的，这时候就可以使用volatile禁止这些优化：防止优化编译器把变量从内存装入CPU寄存器中。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int obj <span class="hljs-operator">=</span> <span class="hljs-number">10</span><span class="hljs-comment">;</span><br><br>int a <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>int b <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br><br><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span> obj<span class="hljs-comment">;    //编译器认为在此之前obj没有出现在赋值号左边，值没有变化，故直接把10赋值给a</span><br><br>sleep(<span class="hljs-number">100</span>)<span class="hljs-comment">;    //有可能obj的内存空间被其他线程或某一个中断处理程序所改变，造成obj的值意外被改变</span><br><br><span class="hljs-attribute">b</span> <span class="hljs-operator">=</span> obj<span class="hljs-comment">;    //编译器认为在此之前obj没有出现在赋值号左边，值没有变化，依旧直接把10赋值给b</span><br></code></pre></td></tr></table></figure><p>volatile强制编译器对访问该变量的代码不去优化，即使它前面的指令刚刚从该处读取过数据。因为每次必须从内存中取值，所以用多了会造成程序变慢</p><p><a href="https://blog.csdn.net/qq_29350001/article/details/54024070">https://blog.csdn.net/qq_29350001&#x2F;article&#x2F;details&#x2F;54024070</a></p><p>用法一：并行设备的硬件寄存器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPC1CON *((volatile unsigned int*)0xE0200080)</span><br></code></pre></td></tr></table></figure><p>GPC1CON 为寄存器名称、0xE0200080 为寄存器地址、(volatile unsigned int*) 为强制类型转换。</p><p>如果不加上volatile，那在使用GPC1CON的时候就会从速度较快的寄存器中取值，而寄存器的值是来自之前访问过的GPC1CON，之前就从内存中取出GPC1CON的值保存到这个寄存器里。使用volatile就表示这个寄存器里的值是随时变化的，每次都要去内存里取它的值，不要对其做优化</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">int</span>  *<span class="hljs-keyword">output</span> = (<span class="hljs-keyword">unsigned</span>  <span class="hljs-keyword">int</span> *)<span class="hljs-number">0</span>xff800000;<span class="hljs-comment">//定义一个IO端口；</span><br><span class="hljs-keyword">int</span>   init(<span class="hljs-keyword">void</span>)<br>&#123;<br>      <span class="hljs-keyword">int</span> i;<br>      <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt; <span class="hljs-number">10</span>;i++)&#123;<br>         *<span class="hljs-keyword">output</span> = i;<br>&#125;<br>&#125;<br><br>优化后，编译器认为之前都是废话，对结果无影响<br><span class="hljs-keyword">int</span>  init(<span class="hljs-keyword">void</span>)<br>&#123;<br>      *<span class="hljs-keyword">output</span> = <span class="hljs-number">9</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>用法二：中断服务程序中会访问到的非自动变量</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">static</span> <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;     <span class="hljs-comment">//i为非自动变量</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i) <span class="hljs-built_in">dosomething</span>();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/* 中断服务程序 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ISR_2</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>      i=<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序原意在触发中断后，i的值被修改，然后dosomething。但其实编译器判断在main中没有修改过i，因此可能只执行一次将i读到某寄存器的读操作，下次再访问i的时候也是访问寄存器上的”i副本”，导致dosomething永远不会被掉用。所以应该加上volatile。</p><p>用法三：多线程中被几个任务共享的变量</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">volatile</span>  <span class="hljs-type">BOOL</span>  bStop  =  <span class="hljs-literal">FALSE</span>;  <span class="hljs-comment">//bStop  为共享全局变量</span><br>(<span class="hljs-number">1</span>) 在一个线程中：  <br>  <span class="hljs-keyword">while</span>(  !bStop  )  &#123;  ...  &#125;  <br>  bStop  =  <span class="hljs-literal">FALSE</span>;  <br>  <span class="hljs-keyword">return</span>;    <br>(<span class="hljs-number">2</span>) 在另外一个线程中，要终止上面的线程循环：  <br>  bStop  =  <span class="hljs-literal">TRUE</span>;  <br>  <span class="hljs-keyword">while</span>(  bStop  );<br></code></pre></td></tr></table></figure><p>当两个线程都用到一个变量且这个变量的值会被改变时，应该使用volatile声明。这样就不会把变量从内存装入CPU寄存器，就不会它们在访问的时候访问的不是一个地方的变量。</p><p>在访问a的时候（把a赋值给其他变量或直接使用a）认清是访问a保存在寄存器里的值，还是a在内存里的值。用volatile修饰就是访问a在内存的值。如果a有可能被中断或不同线程，或硬件改动，那就要用volatile修饰。如果a只是同一线程的一个普通变量则没必要用volatile修饰。</p><p>例：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">for ( i=0; i</span>&lt;<span class="hljs-comment">1000; i</span><span class="hljs-literal">++</span> <span class="hljs-comment">)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    a</span><span class="hljs-literal">++</span><span class="hljs-comment">;</span><br><span class="hljs-comment">&#125;</span><br></code></pre></td></tr></table></figure><p>会被优化成a+&#x3D;1000。这时就可以加上一个volatile表示这个a有可能在a++的过程中被改变，让编译器老老实实一个一个加。但其实这里只是为了防止优化</p><p><strong>问题一</strong>：一个参数既可以是const还可以是volatile吗？</p><p>答：可以，例如只读的状态寄存器。它是 volatile 因为它可能被意想不到地改变。它是 const 因为 程序不应该试图去修改它。</p><p><strong>问题二</strong>：一个指针可以是 volatile 吗？</p><p>答：可以，当一个中服务子程序修改一个指向一个 buffer 的指针时。</p><p><strong>问题三</strong>：下面的函数有什么错误？</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-built_in">int</span> square(<span class="hljs-keyword">volatile</span> <span class="hljs-built_in">int</span> *<span class="hljs-built_in">ptr</span>)<br>&#123;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-built_in">ptr</span> * *<span class="hljs-built_in">ptr</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autoit">  <span class="hljs-built_in">int</span> square(<span class="hljs-keyword">volatile</span> <span class="hljs-built_in">int</span> *<span class="hljs-built_in">ptr</span>)  <br>    &#123;<br>         <span class="hljs-built_in">int</span> a,b<span class="hljs-comment">;</span><br>         a = *<span class="hljs-built_in">ptr</span><span class="hljs-comment">;</span><br>         b = *<span class="hljs-built_in">ptr</span><span class="hljs-comment">;</span><br>         <span class="hljs-keyword">return</span> a * b<span class="hljs-comment">;</span><br>     &#125;<br></code></pre></td></tr></table></figure><p>  由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> *ptr)</span>  </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a;<br>    a = *ptr;<br>    <span class="hljs-keyword">return</span> a * a;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><p>volatile 关键字是一种类型修饰符。volatile 提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。如 果没有 volatile 关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。所以遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typedef</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/typedef/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/typedef/</url>
    
    <content type="html"><![CDATA[<p>用途：</p><p>1.定义一种类型的别名，而不只是简单的宏替换</p><p>需要注意的是int 和 unsigned int是不同的类型，需要起不同的别名</p><p>2.帮助struct声明新对象</p><p>3.用typedef来定义与平台无关的类型。</p><p>比如定义一个叫 REAL 的浮点类型，在目标平台一上，让它表示最高精度的类型为：</p><p>typedef long double REAL;</p><p>在不支持 long double 的平台二上，改为：</p><p>typedef double REAL;</p><p>在连 double 都不支持的平台三上，改为：</p><p>typedef float REAL;</p><p>也就是说，当跨平台时，只要改下 typedef 本身就行，不用对其他源码做任何修改。</p><p>例如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> int64;<br></code></pre></td></tr></table></figure><p>要给long long改名的原因是，VC6没有long long，只有__int64。于是在其它编译器写好的代码一弄到VC6里面就不能编译过了，所以在开始位置加一个</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> int64;<br></code></pre></td></tr></table></figure><p>当移到VC6中编译时，只用改成</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">typedef</span> __int64 <span class="hljs-built_in">int64</span>;<br></code></pre></td></tr></table></figure><p>4.typedef和#define</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E9%94%99%E8%AF%AF%E7%A0%81/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E9%94%99%E8%AF%AF%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux内核中的指针函数返回错误码"><a href="#Linux内核中的指针函数返回错误码" class="headerlink" title="Linux内核中的指针函数返回错误码"></a>Linux内核中的指针函数返回错误码</h1><p>在linux内核中，一个返回指针的函数如何表示错误返回呢？</p><p>首先任何一个指针必然有三种情况：有效指针、NULL或空指针、错误指针或无效指针。显然使用一个空指针NULL是无法表示和区分各种执行错误的，应该将无效指针对应着内核中的错误号。</p><p>内核中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_ERRNO    4095    <span class="hljs-comment">/* 4k */</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IS_ERR_VALUE(x) unlikely((x) &gt;= (unsigned long)-MAX_ERRNO)  <span class="hljs-comment">/* &gt;=0xfffff001 */</span></span><br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> *<span class="hljs-title">ERR_PTR</span><span class="hljs-params">(<span class="hljs-type">long</span> error)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *) error;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> <span class="hljs-title">PTR_ERR</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *ptr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">long</span>) ptr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> <span class="hljs-title">IS_ERR</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *ptr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">IS_ERR_VALUE</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)ptr);<br>&#125;<br></code></pre></td></tr></table></figure><p>所有的驱动程序都运行在内核空间，在内核空间中的最后一个page是被保留的(假设4k一个page)，用于内核捕捉错误。比如对于32位的系统来说，内核最高地址为0xff ff ff ff，那么最后一个page就是0xff ff f0 00~0xff ff ff ff(最后一page最少为4k)。如果发现你的一个指针指向这个范围内的一个地址，那么这个指针就是个无效指针，于是内核使用IS_ERR()来判断当前指针是否在这个范围内([0xfffff001, 0xffffffff])。</p><p>而PTR_ERR(), ERR_PTR()只是强制转换一下，PTR 是单词 pointer 的缩写，ERR 是单词 errno   的缩写，PTR_ERR 即将指针转换为错误码，ERR_PTR 即将错误码转换为指针。若你只需要知道是否出错，而不在乎为什么出错，那你就可以不调用PTR_ERR()。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _ASM_GENERIC_ERRNO_BASE_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPERM        1  <span class="hljs-comment">/* Operation not permitted */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENOENT       2  <span class="hljs-comment">/* No such file or directory */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ESRCH        3  <span class="hljs-comment">/* No such process */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EINTR        4  <span class="hljs-comment">/* Interrupted system call */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EIO      5  <span class="hljs-comment">/* I/O error */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENXIO        6  <span class="hljs-comment">/* No such device or address */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> E2BIG        7  <span class="hljs-comment">/* Argument list too long */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENOEXEC      8  <span class="hljs-comment">/* Exec format error */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EBADF        9  <span class="hljs-comment">/* Bad file number */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ECHILD      10  <span class="hljs-comment">/* No child processes */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EAGAIN      11  <span class="hljs-comment">/* Try again */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENOMEM      12  <span class="hljs-comment">/* Out of memory */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EACCES      13  <span class="hljs-comment">/* Permission denied */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EFAULT      14  <span class="hljs-comment">/* Bad address */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENOTBLK     15  <span class="hljs-comment">/* Block device required */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EBUSY       16  <span class="hljs-comment">/* Device or resource busy */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EEXIST      17  <span class="hljs-comment">/* File exists */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXDEV       18  <span class="hljs-comment">/* Cross-device link */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENODEV      19  <span class="hljs-comment">/* No such device */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENOTDIR     20  <span class="hljs-comment">/* Not a directory */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EISDIR      21  <span class="hljs-comment">/* Is a directory */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EINVAL      22  <span class="hljs-comment">/* Invalid argument */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENFILE      23  <span class="hljs-comment">/* File table overflow */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EMFILE      24  <span class="hljs-comment">/* Too many open files */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENOTTY      25  <span class="hljs-comment">/* Not a typewriter */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ETXTBSY     26  <span class="hljs-comment">/* Text file busy */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EFBIG       27  <span class="hljs-comment">/* File too large */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENOSPC      28  <span class="hljs-comment">/* No space left on device */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ESPIPE      29  <span class="hljs-comment">/* Illegal seek */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EROFS       30  <span class="hljs-comment">/* Read-only file system */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EMLINK      31  <span class="hljs-comment">/* Too many links */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPIPE       32  <span class="hljs-comment">/* Broken pipe */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EDOM        33  <span class="hljs-comment">/* Math argument out of domain of func */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERANGE      34  <span class="hljs-comment">/* Math result not representable */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>page = <span class="hljs-built_in">__get_free_pages</span>(GFP_KERNEL,<span class="hljs-number">3</span>);<br><span class="hljs-keyword">if</span> (!page)&#123;<br>        <span class="hljs-comment">/*没有足够的内存：你必须处理这种错误！*/</span><br>        <span class="hljs-keyword">return</span> -ENOMEM;    <span class="hljs-comment">/* 错误码加负号 */</span><br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核代码风格</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/Linux%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/Linux%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<p>一、缩进</p><p>1.1 switch</p><p>（1）switch和case标签从属一列</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">switch</span> (suffix)&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;G&#x27;</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;g&#x27;</span>:<br>        mem &lt;&lt;= <span class="hljs-number">30</span>;<br>        <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;M&#x27;</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;m&#x27;</span>:<br>        mem &lt;&lt;= <span class="hljs-number">20</span>;<br>        <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）不要把多个语句放一行，除非想隐藏什么</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if (condition) do_this<span class="hljs-comment">;</span><br>    do_something_everytime<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>（3）不要一行放多个赋值语句，防止别人误读</p><p>1.2 长的行与字符串应该打乱</p><p>每一行的长度的限制是 80 列，长于 80 列的语句要打散成有意义的片段。</p><p>1.3 大括号和空格的放置</p><p>（1）起始大括号放在行尾，而把结束大括号放在行首，适用于所有的<strong>非函数</strong>语句块 (if, switch, for, while, do)。这种大括号的放置方式也能使空行的数量最小化。</p><p>（2）空格</p><p>①关键字后要加一个空格（除了sizeof, typeof, alignof 和 __attribute__这些更像函数的关键字）</p><p>②不要在小括号里的表达式两侧加空格</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">s</span> <span class="hljs-operator">=</span> sizeof( struct file )<span class="hljs-comment">;    //反例</span><br></code></pre></td></tr></table></figure><p>③ * 的首选使用方式是使之靠近变量名或函数名，而不是类型名</p><p>④在大多数二元和三元操作符两侧使用一个空格</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">=  +  -  &lt;  &gt;  *  /  %  |  &amp;  ^  &lt;=  &gt;=  ==  !=  ?  <span class="hljs-symbol">:</span><br></code></pre></td></tr></table></figure><p>⑤一元操作符后不要加空格</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">&amp;  *  +  -  ~  !  <span class="hljs-built_in">sizeof</span>  <span class="hljs-built_in">typeof</span>  alignof  <span class="hljs-variable">__attribute__</span>  defined<br></code></pre></td></tr></table></figure><p>⑥. 和 -&gt; 结构体成员操作符前后不加空格。</p><p>1.4 命名</p><p>不混用大小写，使用全小写简称，能够表达相关含义。且全局变量需要一个具有描述性的名字，如有一个可以计算活动用户数量的函数，你应该叫它 count_active_users() 或者类似的名字，你不应该叫它 cntuser() 。</p><p>1.5 typedef</p><p>（1）不要对结构体或指针使用typedef</p><p>（2）只在下列情况下使用：</p><p>① 清楚的整数类型</p><p>②完全不透明的对象，真的是完全没有任何共用的可访问信息。</p><p><span style="background-color: #ffaaaa">③当你使用 sparse 按字面的创建一个新类型来做类型检查的时候。</span></p><p><span style="background-color: #ffaaaa">④</span><span style="background-color: #ffaaaa">和标准 C99 类型相同的类型。</span><span style="background-color: #ffaaaa">当编辑已经使用了某个类型集的已有代码时，你应该遵循那些代码中已经做出的选择。</span></p><p><span style="background-color: #ffaaaa">⑤</span><span style="background-color: #ffaaaa">可以在用户空间安全使用的类型</span></p><span style="background-color: #ffaaaa"></span><p>1.6 函数</p><p>（1）函数应该简短而漂亮，并且只完成一件事情，函数应该可以一屏或者两屏显示完 。</p><p>（2）复杂的函数遵守前面提到的长度限制，使用辅助函数，并为之取个具描述性的名字（如果你觉得它们的性能很重要的话，可以让编译器内联它们，直接把机器码插入调用它们的地方）</p><p>（3）本地变量的数量不应超过 5－10 个</p><p><span style="background-color: #ffaaaa">（4）如果该函数需要被导出，它的 EXPORT 宏应该紧贴在它的结束大括号之下。</span></p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nsis">int <span class="hljs-params">system</span>_is_up(void)<br>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-params">system</span>_state == <span class="hljs-params">SYSTEM</span>_RUNNING<span class="hljs-comment">;</span><br>&#125;<br>EXPORT_SYMBOL(<span class="hljs-params">system</span>_is_up)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>1.7 集中的函数退出途径</p><p>当一个函数从多个位置退出，并且需要做一些类似清理的常见操作时，使用goto 语句很方便。</p><p>（1）goto需要一个描述性标签名（别去使用像 err1: 和 err2: 的 名称，因为你添加退出路径后，你就必须对它们重新编号）</p><p>（2）注意一个常见错误，先释放结构体成员，然后释放结构体</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">err:<br>        <span class="hljs-built_in">kfree</span>(foo-&gt;bar);<br>        <span class="hljs-built_in">kfree</span>(foo);<br>        return ret;<br></code></pre></td></tr></table></figure><p>这段代码的错误是，在某些退出路径上 foo 是 NULL。通常情况下，通过把它分离 成两个错误标签 err_free_bar: 和 err_free_foo: 来修复这个错误：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">err_free_bar:<br>       <span class="hljs-built_in">kfree</span>(foo-&gt;bar);err_free_foo:<br>       <span class="hljs-built_in">kfree</span>(foo);<br>       return ret;<br></code></pre></td></tr></table></figure><p>理想情况下，你应该模拟错误来测试所有退出路径。</p><p>1.8 注释</p><p>（1）告诉别人你的代码做了什么，而不是怎么做的。</p><p>（2）做一些小注释来注明或警告某些很聪明(或者槽糕)的做法，但不要加太多。</p><p>（3）把注释放在函数的头部。告诉人们它做了什么， 也可以加上它做这些事情的原因。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This is the preferred style for multi-line</span><br><span class="hljs-comment"> * comments in the Linux kernel source code.</span><br><span class="hljs-comment"> * Please use it consistently.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Description:  A column of asterisks on the left side,</span><br><span class="hljs-comment"> * with beginning and ending almost-blank lines.</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>（4）一行应只声明一个数据，对数据进行注释</p><p>1.9 宏，枚举和RTL</p><p>定义常量的宏的名字及枚举里的标签需要大写。在定义几个相关的常量时，最好用枚举。</p><p>（1）少写宏函数。</p><p>（2）依赖于一个本地名字的宏</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">FOO</span>(val) <span class="hljs-built_in">bar</span>(index, val)<br></code></pre></td></tr></table></figure><p>（3）带参数的宏避免称为左值</p><p>（4）忘记了优先级：使用表达式定义常量的宏必须将表达式置于一对小括号之内。带参数的宏也要注意此类问题</p><p>1.10 分配内存</p><p>（1）传递结构体大小的首选形式</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">p</span> = <span class="hljs-built_in">kmalloc</span>(<span class="hljs-built_in">sizeof</span>(*p), ...)<br></code></pre></td></tr></table></figure><p>（2）分配一个数组的首选形式</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">p = kmalloc<span class="hljs-constructor">_array(<span class="hljs-params">n</span>, <span class="hljs-params">sizeof</span>(<span class="hljs-operator">...</span>)</span>, ...)<br></code></pre></td></tr></table></figure><p>（3）分配一个零长数组的首选形式</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">p</span> = <span class="hljs-built_in">kmalloc</span>(n, <span class="hljs-built_in">sizeof</span>(...), ...)<br></code></pre></td></tr></table></figure><p>两种形式检查分配大小 n * sizeof(…) 的溢出，如果溢出返回 NULL。</p><p>1.11 内联弊病</p><p>inline 的过度使用会使内核变大，从而使整个系统运行速度变慢。</p><p>一个基本的原则是如果一个函数有 3 行以上，就不要把它变成内联函数。</p><p>1.12 函数返回值及命名</p><p>如果函数的名字是一个动作或者强制性的命令，那么这个函数应该返回错误代码整数。如果是一个判断，那么函数应该返回一个 “成功” 布尔值。</p><p>返回值是实际计算结果而不是计算是否成功的标志的函数不受此惯例的限制。一般的， 他们通过返回一些正常值范围之外的结果来表示出错。典型的例子是返回指针的函数， 他们使用 NULL 或者 ERR_PTR 机制来报告错误。</p><p>1.13 条件编译</p><p>只要可能，不要在.c文件里使用预处理条件(#if，#ifdef)，这样使代码更难阅读。</p><p>最好倾向于编译整个函数，而不是函数或表达式的一部分。与其放一个 ifdef 在表达式内，不如分解出部分或全部表达式，放进一个单独的辅助函数，并应用预处理条件到这个辅助函数内。</p><p>如果你有一个在特定配置中，可能变成未使用的函数或变量，编译器会警告它定义了但 未使用，把它标记为 __maybe_unused 而不是将它包含在一个预处理条件中。</p><p>在任何有意义的 #if 或 #ifdef 块的末尾 (超过几行的)，在 #endif 同一行的后面写下 注解，注释这个条件表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SOMETHING</span><br>...<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_SOMETHING */</span></span><br></code></pre></td></tr></table></figure><p>1.14 数据结构</p><p>如果一个数据结构，在创建和销毁它的单线执行环境之外可见，那么它必须要有一个引用计数器。</p><p>1.15你已经把事情弄糟了</p><p>GNU indent 和 GNU emacs</p><p>1.16 Kconfig 配置文件</p><p>1.17打印内核消息</p><p>1.18 不要重新发明内核宏</p><hr><p><a href="https://www.kernel.org/doc/html/v4.13/translations/zh_CN/coding-style.html#id2">https://www.kernel.org/doc/html/v4.13/translations/zh_CN&#x2F;coding-style.html#id2</a></p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux_C</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/Linux_C/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/Linux_C/</url>
    
    <content type="html"><![CDATA[<p>open函数属于Linux中系统IO，用于“打开”文件，代码打开一个文件意味着获得了这个文件的访问句柄。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> fd = open（参数<span class="hljs-number">1</span>，参数<span class="hljs-number">2</span>，参数<span class="hljs-number">3</span>）；<br></code></pre></td></tr></table></figure><p>包含头文件：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br></code></pre></td></tr></table></figure><p>参数1（pathname）</p><p>即将要打开的文件路径,例如：“a.txt”当前目录下的a.txt文件</p><p>参数2（flags）</p><p>flags分为两类：主类，副类</p><p>主类：O_RDONLY 以只读方式打开 &#x2F; O_WRONLY 以只写方式打开 &#x2F;O_RDWR 以可读可写方式打开</p><p>参数3（mode）</p><p>mode：如果文件被新建，指定其权限为mode</p><p>mode是八进制权限码，0777表示文件所有者 该文件用户组 其他用户都有可读可写可执行权限</p><p>打开失败返回-1</p><hr><p>int main(int argc, char **argv)</p><p>argc、argv的具体含义:argc和argv参数在用命令行编译程序时有用。</p><p>main( int argc, char* argv[], char **env ) 中</p><p>第一个参数，int型的argc，为整型，用来统计程序运行时发送给main函数的命令行参数的个数，在VS中默认值为1。</p><p>第二个参数，char*型的argv[]，为字符串数组，用来存放指向的字符串参数的指针数组，每一个元素指向一个参数。各成员含义如下：</p><p>argv[0]指向程序运行的全路径名</p><p>argv[1]指向在DOS命令行中执行程序名后的第一个字符串</p><p>argv[2]指向执行程序名后的第二个字符串</p><p>argv[3]指向执行程序名后的第三个字符串</p><p>argv[argc]为NULL</p><hr><p>链表、队列、结构体、宏定义</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gcc指令与程序的预编译编译汇编链接运行</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/gcc%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E7%BC%96%E8%AF%91%E6%B1%87%E7%BC%96%E9%93%BE%E6%8E%A5%E8%BF%90%E8%A1%8C/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/gcc%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E7%BC%96%E8%AF%91%E6%B1%87%E7%BC%96%E9%93%BE%E6%8E%A5%E8%BF%90%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">hello.c<span class="hljs-function"><span class="hljs-params">(预处理)</span> -&gt;</span> hello.i<span class="hljs-function"><span class="hljs-params">(编译)</span> -&gt;</span> hello.s<span class="hljs-function"><span class="hljs-params">(汇编)</span> -&gt;</span> hello.o<span class="hljs-function"><span class="hljs-params">(链接)</span> -&gt;</span> hello<br></code></pre></td></tr></table></figure><p>一，预编译</p><p>1.1 操作步骤：gcc -E hello.c -o hello.i</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">使用预处理命令时，最好将c文件中的<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>注释掉，这样结果更加直观</span><br></code></pre></td></tr></table></figure><p>1.2 主要作用：处理关于 “#” 的指令</p><p>（1）删除#define，展开所有宏定义。例#define portnumber 3333</p><p>（2）处理条件预编译 #if, #ifdef, #if, #elif,#endif</p><p>（3）处理“#include”预编译指令，将包含的“.h”文件插入对应位置。这可是递归进行的，文件内可能包含其他“.h”文件。</p><p>（4）删除所有注释。&#x2F;**&#x2F;，&#x2F;&#x2F;。</p><p>（5）添加行号和文件标识符。用于显示调试信息：错误或警告的位置。</p><p>（6）保留#pragma编译器指令。（1）设定编译器状态，（2）指示编译器完成一些特定的动作。</p><p>二、编译（编译器主要做了什么）</p><p>2.1 操作步骤：gcc -s hello.c -o hello.s</p><p>2.2 主要作用：1.扫描（词法分析），2.语法分析，3.语义分析，4.源代码优化（中间语言生成），5.代码生成，目标代码优化。</p><p>（1）将源代码程序输入扫描器，将源代码的字符序列分割成一系列记号。例array[index] &#x3D;  (index + 4) * (2 + 6);</p><p>（2）基于词法分析得到的一系列记号，生成语法树。</p><p>（3）由语义分析器完成，指示判断是否合法，并不判断对错。又分静态语义：隐含浮点型到整形的转换，会报warning，</p><p>  动态语义：在运行时才能确定：例1除以3</p><p>（4）中间代码（语言）使得编译器分为前端和后端，前端产生与机器（或环境）无关的中间代码，编译器的后端将中间代码转换为目标机器代码，目的：一个前端对多个后端，适应不同平台。</p><p>（5）编译器后端主要包括：代码生成器:依赖于目标机器，依赖目标机器的不同字长，寄存器，数据类型等</p><p>    目标代码优化器:选择合适的寻址方式，左移右移代替乘除，删除多余指令。</p><p>三，汇编</p><p>操作步骤：gcc -c hello.c -o hello.o</p><p>主要作用：汇编器是将汇编代码转变成可以执行的指令，生成目标文件。</p><p><span style="background-color: #ffaaaa">四，链接（参考狄泰）</span></p><p>操作步骤：gcc hello.o -o hello</p><p>主要作用：链接过程使用链接器将该目标文件与其他目标文件、库文件、启动文件等链接起来生成可执行文件。</p><p>附加的目标文件包括静态连接库和动态连接库。</p><p>链接所完成的任务是合并段表，然后把符号表合并并且对符号表进行重定位。</p><p>所谓合并段表，源代码编译生成的a.out会包含很多段，数据段文本段bss段等等，这些段是合并出来的，在编译过程中划分出来出来的，不同的数据会对应到不同的段中，在.o文件中其实已经发生了分段。</p><p>符号表合并和重定位说的是最后只生成了一个符号表，这个符号表是由前面汇编形成的多个符号表进行合并。在这里不在同一个符号表的符号，要对他们进行重定位。链接完成以后，也就生成了我们所说的.exe文件重点内容。</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言知识补充</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/</url>
    
    <content type="html"><![CDATA[<figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs thrift"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tagPoint</span></span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-type">double</span> x;<br><span class="hljs-type">double</span> y;<br><span class="hljs-type">double</span> z;<br>&#125; Point;<br></code></pre></td></tr></table></figure><p>在上面的代码中，实际上完成了两个操作：</p><p>1、定义了一个新的结构类型，代码如下所示：</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs thrift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tagPoint</span></span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-type">double</span> x;<br><span class="hljs-type">double</span> y;<br><span class="hljs-type">double</span> z;<br>&#125; ;<br></code></pre></td></tr></table></figure><p>其中，struct 关键字和 tagPoint 一起构成了这个结构类型，无论是否存在 typedef 关键字，这个结构都存在。</p><p>2、使用 typedef 为这个新的结构起了一个别名，叫 Point，即：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">tagPoint</span> Point<br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">typedef struct tagNode<br>&#123;<br>char *pItem<span class="hljs-comment">;</span><br>pNode pNext<span class="hljs-comment">;</span><br>&#125; *pNode<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>从表面上看，上面的示例代码与前面的定义方法相同，所以应该没有什么问题。但是编译器却报了一个错误，为什么呢？莫非 C 语言不允许在结构中包含指向它自己的指针？</p><p>其实问题并非在于 struct 定义的本身，大家应该都知道，C 语言是允许在结构中包含指向它自己的指针的，我们可以在建立链表等数据结构的实现上看到很多这类例子。那问题在哪里呢？其实，根本问题还是在于 typedef 的应用。</p><p>在上面的代码中，新结构建立的过程中遇到了 pNext 声明，其类型是 pNode。这里要特别注意的是，pNode 表示的是该结构体的新别名。于是问题出现了，在结构体类型本身还没有建立完成的时候，编译器根本就不认识 pNode，因为这个结构体类型的新别名还不存在，所以自然就会报错。因此，我们要做一些适当的调整，比如将结构体中的 pNext 声明修改成如下方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">tagNode</span><br>&#123;<br><span class="hljs-type">char</span> *pItem;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">tagNode</span> *pNext;<br>&#125; *pNode;<br></code></pre></td></tr></table></figure><hr><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">    #<span class="hljs-keyword">define</span> FREE(p) if(p) &#123; \<br>                        <span class="hljs-keyword">free</span>(p)<span class="hljs-comment">; \</span><br>                        p <span class="hljs-operator">=</span> NULL<span class="hljs-comment">; \</span><br>                    &#125;<br></code></pre></td></tr></table></figure><hr><p>形参列表</p><p>虽然可以在形参列表中定义多个参数，但是，在编写程序的时候，要考虑函数模块之间的“耦合性”和“扩展性”。不要传递太多的参数。如果项目需求改动，需要修改某个参数，就会导致函数接口的改动，函数接口的改动对程序的改动很大，这种操作应该极力避免。</p><p>当学习到结构体之后，我们可以把多个参数封装到一个结构体中，函数的参数只需要传递一个结构体变量就OK了。那么，当有数据需要改动，只需要修改结构体的定义和数据，函数的接口不需要修改，那么，函数模块之间的耦合性就降低，提高程序函数模块之间的扩展性。这就是函数模块扩展性好的一个表现形式，也是定义函数时需要思考的注意点。</p><hr><p>关系运算符巧记</p><hr><p>赋值小于关系判断，小于算术运算。</p><p>关系判断大于算术运算。</p><p>++优先集相当大，仅次于（）</p><p>比如c&#x3D;getchar()&#x3D;&#x3D;’a’</p><p>这个算相当经典的了。根据上面说的。要先计算关系判断，所以相当于</p><p>c&#x3D;(getchar()&#x3D;&#x3D;’a’)</p><p>你可以找几个式子带一下，不清楚再来hi我</p><p>其次要记住这些符号的结合性。也就是从左到右还是从右到左</p><p>比如赋值。就是从右向左</p><p>x&#x3D;a&#x3D;b&#x3D;3;</p><p>相当于b&#x3D;3</p><p>a&#x3D;b</p><p>x&#x3D;a</p><p>所以最后 是x&#x3D;3</p><p><a href="https://blog.csdn.net/EI_Capitan/article/details/109533417?utm_medium=distribute.pc_relevant_bbs_down.none-task--2~all~first_rank_v2~rank_v29-1.nonecase&depth_1-utm_source=distribute.pc_relevant_bbs_down.none-task--2~all~first_rank_v2~rank_v29-1.nonecase">https://blog.csdn.net/EI_Capitan&#x2F;article&#x2F;details&#x2F;109533417?utm_medium&#x3D;distribute.pc_relevant_bbs_down.none-task--2<del>all</del>first_rank_v2<del>rank_v29-1.nonecase&amp;depth_1-utm_source&#x3D;distribute.pc_relevant_bbs_down.none-task--2</del>all<del>first_rank_v2</del>rank_v29-1.nonecase</a></p><hr><p>#include &lt;filename&gt;</p><p>尖括号是预处理到系统规定的路径中去获得这个文件（即 C 编译系统所提供的并存放在指定的子目录下的头文件）。找到文件后，用文件内容替换该语句。如stdio.h</p><p>#include“filename”</p><p>“”则是预处理我们自己第三方的文件，如程序员小刘写的Date.h，我们就可以include“Date.h”</p><hr><p>（1）一个有10个指针的数组，该指针是指向一个整型数的</p><p>（2）一个指向有10个整型数数组的指针</p><p>（3） 一个指向函数的指针，该函数有一个整型参数并返回一个整型数</p><p>（4） 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数</p><p>（1）int *a[10]; </p><p>（2）int (*a)[10]; </p><p>（3）int (*a)(int); </p><p>（4）int (*a[10])(int);</p><hr><p>数组：</p><p>1.int a[10] &#x3D; {0};这个常见的数组初始化语句其实是将数组的第一个元素初始化为0，然后数组本身的特性是将其余未初始化的数据初始化为0，故做到了将数组全部元素初始化为0</p><p>2.数组首元素的地址值虽然与数组的地址值相同，但数组首元素的地址与数组的地址是两个不同的概念。</p><p>我们常说的地址实际包含了起始地址和所占内存的长度。</p><p>数组名指向的数组名”指向”的是内存中数组首元素的起始位置，即数组名不包含数组的长度信息</p><hr><p>指针：</p><p>1.指针与指针之间只支持减法运算，且参与减法运算的指针类型必须相同。</p><p>2.只有当两个指针指向同一个数组中的元素时,指针相减才有意义,其意义为指针所指元素的下标差。若是指向两个数组的同类型指针相减则语法正确，但结果未知没有意义。</p><p>数组的边界位置：</p><p>指针可以指向数组最后一个元素后面的位置，这个位置是属于c语言的“擦边球”边界位置，在这个边界位置上我们认为这个指针是合法的，但这个位置再后面的元素都是没有意义的了</p><hr><p><strong>数组和指针的可交换性：数组并非指针</strong></p><p>一、声明和定义</p><p>定义：只能存在于一个地方。<strong>确定</strong>对象的类型并分配内存，用于创建新的对象。例如：int my_array[100]</p><p>声明：可以多次出现。<strong>描述</strong>对象的类型，<strong>用于指代</strong>其他地方定义的对象（例如在其他文件里），例：extern int my_array[]；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">文件<span class="hljs-number">1</span>：<br><span class="hljs-type">int</span> p[<span class="hljs-number">100</span>];        <span class="hljs-comment">//定义</span><br>文件<span class="hljs-number">2</span>：<br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> *p;     <span class="hljs-comment">//错误声明</span><br></code></pre></td></tr></table></figure><p>定义与声明必须匹配。</p><p>二、数组和指针的不可互换</p><p>2.1 数组和指针的引用方式</p><p>指针：间接访问，首先取得指针的内容，把它作为地址，然后从这个地址提取数据。如果指针有一个下标[I]，就把指针的内容加上I作为地址，从中提取数据</p><p>数组：直接访问数据，a[I]只是简单地以a+I为地址取得数据</p><p> 例：</p><p>每个符号的地址在编译时可知，存在符号表中。该表记录了变量和内存地址的一一对应关系。</p><p>（1）定义为数组并引用</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">char a[<span class="hljs-number">9</span>] <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcdef&quot;</span><span class="hljs-comment">;</span><br><span class="hljs-attribute">c</span> <span class="hljs-operator">=</span> a[i]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>编译器符号表中有一个地址9980</p><ul><li>运行时步骤一：取i的值，将它与9980相加</li><li>运行时步骤二：取地址（9980+i）的内容</li></ul><p>（2）定义为指针并引用</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">char *p <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcdef&quot;</span><span class="hljs-comment">;</span><br><span class="hljs-attribute">c</span> <span class="hljs-operator">=</span> *p<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>编译器符号表中有一个符号p，地址为4624</p><ul><li>运行时步骤一：取地址4624的值，得到’5081’</li><li>运行时步骤二：取地址5081的内容</li></ul><p>（3）定义为指针，但以数组方式引用</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">char *p <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcdef&quot;</span><span class="hljs-comment">;</span><br><span class="hljs-attribute">c</span> <span class="hljs-operator">=</span> p[i]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>编译器符号表中有一个符号p，地址为4624</p><ul><li>运行时步骤一：取地址4624的值，得到’5081’</li><li>运行时步骤二：取i的值，将它与5081相加</li><li>运行时步骤三：取地址（5081+i）的内容</li></ul><p>（4）定义为数组，外部文件声明为指针并引用</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">文件<span class="hljs-number">1</span>：<br>int p[<span class="hljs-number">100</span>] <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcdef&quot;</span><span class="hljs-comment">;        //定义</span><br>文件<span class="hljs-number">2</span>：<br>extern int *p<span class="hljs-comment">;     //错误声明</span><br><span class="hljs-attribute">c</span> <span class="hljs-operator">=</span> *p<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>编译器符号表中有一个符号p，地址为4624</p><ul><li>运行时步骤一：取地址4624的值，得到’a’<ul><li>原意取指针p上保存的数组地址，实际上取得了一个ASCII字符</li></ul></li><li>运行时步骤二：取地址’a’的内容<ul><li>ASCII字符解释为地址，结果未定义</li></ul></li></ul><p>故这样不能改写成指针的形式</p><p>2.2 使用字符串常量初始化</p><p>（1）定义指针时，编辑器并不为指针所指向的对象分配空间，它只分配指针自身的空间，除非在定义时同时赋给指针一个字符串常量进行初始化。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">char *p <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcdefg&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>但这个字符串常量被定义为只读，若试图通过指针修改这个字符串的值，程序就会出现未定义的行为</p><p>（2）定义数组时，也可以使用字符串常量进行初始化，且由字符串常量初始化的数组是可以修改的。</p><p>三、数组和指针可互换</p><p>3.1 “表达式中的数组名”就是指针</p><p>在表达式中，指针与数组是可以互换的，因为它们在编译器里的最终形式都是指针，且都可以进行取下标操作</p><p>3.2 C语言把数组下标作为指针的偏移量</p><p>用a[i]这样的形式对数组进行访问总是被编译器”改写”或解释为像*(a+1)这样的指针访问</p><p>3.3 “作为函数参数的数组名”等同于指针</p><p>C语言中所有非数组形式的数据实参均以传值形式（将实参做一份拷贝供函数使用修改）调用，但要拷贝整个数组需要的开销是非常大的。出于效率考虑，属于函数实参的数组在编译时被编译器改写为指针。类似的函数的返回值也不可以是个数组，而只能是指向数组或函数的指针。</p><p>（1）形参中：以下三种形式完全等同，但我们倾向于始终把参数定义为指针，因为这是编译器内部使用的形式。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">my<span class="hljs-constructor">_func(<span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">p</span>)</span>&#123;<span class="hljs-operator"> ... </span>&#125;<br>my<span class="hljs-constructor">_func(<span class="hljs-params">int</span> <span class="hljs-params">p</span>[])</span>&#123;<span class="hljs-operator"> ... </span>&#125;<br>my<span class="hljs-constructor">_func(<span class="hljs-params">int</span> <span class="hljs-params">p</span>[200])</span>&#123;<span class="hljs-operator"> ... </span>&#125;<br></code></pre></td></tr></table></figure><p>故没有办法把数组本身传递给函数，所有属于函数实参的数组在编译时被编译器改写为指针</p><p>（2）实参中：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">char my_array<span class="hljs-selector-attr">[10]</span>;<br>char *my_ptr;<br><span class="hljs-built_in">printf</span>(&quot;%s %s&quot;, my_ptr, my_array);<br></code></pre></td></tr></table></figure><p>总结：</p><p>1.用a[i]这样的形式对数组进行访问总是被编译器”改写”或解释为像*(a+1)这样的指针访问</p><p>2.指针始终不可改写成数组，当使用下标形式访问指针时，一般都是指针作为函数参数，且你知道实际传递给函数的是一个数组</p><p>3.在一个函数的调用中，作为函数参数的数组始终会被编译器修改成为指向数组第一个元素的指针</p><p>4.因此，当把一个数组定义为函数的参数时，可以选择把它定义为数组，也可以定义为指针。不管如何，函数内部事实上获得的都是一个指针</p><hr><p>.h与.c文件</p><p>在.c文件中使用全局变量记录其他文件会需要的变量，然后在.h文件中使用extern声明，这样别的文件只要包含.h文件就可以使用.c中的全局变量</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言习惯</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E4%B9%A0%E6%83%AF/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E4%B9%A0%E6%83%AF/</url>
    
    <content type="html"><![CDATA[<p>  <strong>01</strong>、版权和版本</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">版权和版本的声明位于头文件和定义文件的开头（参见示例1-1），主要内容有：<br>（1）版权信息。<br>（2）文件名称，标识符，摘要。<br>（3）当前版本号，作者/修改者，完成日期。<br>（4）版本历史信息。<br><br>/*<br><span class="hljs-bullet">* </span>Copyright (c) 2001,上海贝尔有限公司网络应用事业部<br><span class="hljs-bullet">* </span>All rights reserved.<br><span class="hljs-bullet">*</span><br><span class="hljs-bullet"></span><span class="hljs-bullet">* </span>文件名称：filename.h<br><span class="hljs-bullet">* </span>文件标识：见配置管理计划书<br><span class="hljs-bullet">* </span>摘要：简要描述本文件的内容<br><span class="hljs-bullet">*</span><br><span class="hljs-bullet"></span><span class="hljs-bullet">* </span>当前版本：1.1<br><span class="hljs-bullet">* </span>作者：输入作者（或修改者）名字<br><span class="hljs-bullet">* </span>完成日期：2001年7月20日<br><span class="hljs-bullet">*</span><br><span class="hljs-bullet"></span><span class="hljs-bullet">* </span>取代版本：1.0<br><span class="hljs-bullet">* </span>原作者：输入原作者（或修改者）名字<br><span class="hljs-bullet">* </span>完成日期：2001年5月10日<br>*/<br></code></pre></td></tr></table></figure><p>      </p><p> ** 02**、缩进、空格、换行、空行、对齐</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/eternal_yangyun/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">82936434</span><br><span class="hljs-number">1</span>.括号、运算符号前后加空格，<br><span class="hljs-number">2</span>.<span class="hljs-keyword">if</span>等条件语句判断条件多或者函数参数多，活用换行并对齐<br>iii) 换行。<br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;len; i++) &#123;<br>        <span class="hljs-keyword">if</span> ( ( a[i] &lt; <span class="hljs-string">&#x27;0&#x27;</span> || a[i] &gt; <span class="hljs-string">&#x27;9&#x27;</span> ) &amp;&amp;<br>             ( a[i] &lt; <span class="hljs-string">&#x27;a&#x27;</span> || a[i] &gt; <span class="hljs-string">&#x27;z&#x27;</span> ) ) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>函数参数多的时候，最好也换行，如：<br>    CreateProcess(<br>                  NULL,<br>                  cmdbuf,<br>                  NULL,<br>                  NULL,<br>                  bInhH,<br>                  dwCrtFlags,<br>                  envbuf,<br>                  NULL,<br>                  &amp;siStartInfo,<br>                  &amp;prInfo<br>                 );<br>    条件语句也应该在必要时换行：<br>    <span class="hljs-keyword">if</span> ( ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> || ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span> ||<br>         ch &gt;= <span class="hljs-string">&#x27;a&#x27;</span> || ch &lt;= <span class="hljs-string">&#x27;z&#x27;</span> ||<br>         ch &gt;= <span class="hljs-string">&#x27;A&#x27;</span> || ch &lt;= <span class="hljs-string">&#x27;Z&#x27;</span> )<br><br>对齐。用TAB键对齐你的一些变量的声明或注释，一样会让你的程序好看一些。如：<br>typedef struct _pt_man_t_ &#123;<br>    int     numProc;    <span class="hljs-regexp">/* Number of processes                 */</span><br>    int     maxProc;    <span class="hljs-regexp">/* Max Number of processes             */</span><br>    int     numEvnt;    <span class="hljs-regexp">/* Number of events                    */</span><br>    int     maxEvnt;    <span class="hljs-regexp">/* Max Number of events                */</span><br>    HANDLE* pHndEvnt;   <span class="hljs-regexp">/* Array of events                     */</span><br>    DWORD   timeout;    <span class="hljs-regexp">/* Time out interval                   */</span><br>    HANDLE  hPipe;      <span class="hljs-regexp">/* Namedpipe                           */</span><br>    TCHAR   usr[MAXUSR];<span class="hljs-regexp">/* User name of the process            */</span><br>    int     numMsg;     <span class="hljs-regexp">/* Number of Message                   */</span><br>    int     Msg[MAXMSG];<span class="hljs-regexp">/* Space for intro process communicate */</span><br>&#125; PT_MAN_T;<br></code></pre></td></tr></table></figure><p>       </p><p> <strong>03</strong>、程序注释</p><p>少用&#x2F;&#x2F;注释</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/**/</span>(块注释)与<span class="hljs-regexp">//</span>(行注释)嵌套使用<br>但是一些老版本的C编译器并不支持行注释，所以为了你的程序的移植性，请你还是尽量使用块注释<br><br>你也许会为块注释的不能嵌套而不爽，那么你可以用预编译来完成这个功能。使用“<span class="hljs-comment">#if 0”和“#endif”括起来的代码，将不被编译，而且还可以嵌套。</span><br></code></pre></td></tr></table></figure><p>      </p><p>  <strong>04</strong>、函数的[in][out]参数</p><p><a href="https://blog.csdn.net/z_cqupt/article/details/89153852">https://blog.csdn.net/z_cqupt&#x2F;article&#x2F;details&#x2F;89153852</a></p><p>函数名实际上是一个指针常量，即这个函数的地址。</p><p>函数的返回值经常并不是函数的输出部分，而多用于返回0或1表示是否成功。</p><p>函数的形参既可以用来输入也可以用作输出，在函数需要多个返回值的时候就使用形参进行输出。形参参数可以分为输入型参数与输出型参数，传入的普通变量就一定是输入型的参数，但只有传入的指针才可能是输出型参数。</p><p>常常在指针形参前加上一个const表示这是个输入型参数，例如const int *p表示p指向的地址可以改变，p本身不能改变，作者：“这是我的输入参数，你改我输入干嘛”</p><p><strong>05</strong>、对系统调用的返回进行判断</p><p>对于一些系统调用，调用结束后需要进行判断后再使用，比如：文件句柄、socket返回的socket号，malloc返回的内存。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">    fp = fopen(<span class="hljs-string">&quot;log.txt&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>);<br>    <span class="hljs-keyword">if</span> ( fp == <span class="hljs-literal">NULL</span> )&#123;<br>        printf(<span class="hljs-string">&quot;Error: open file error/n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>06</strong>、if 语句对出错的处理</p><p>if语句中判断条件放出错的条件，这样可以突出错误，让别人一眼看到错误条件而下意识避免错误操作</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lasso">    <span class="hljs-keyword">if</span> ( ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span> )&#123;<br>        <span class="hljs-comment">/* 输出错误信息 */</span><br>        printf(<span class="hljs-string">&quot;error ......\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> ( <span class="hljs-literal">FALSE</span> );<br>    &#125;<br>   <br>    <span class="hljs-comment">/* 正常处理代码 */</span><br>    <span class="hljs-params">...</span><span class="hljs-params">...</span><br></code></pre></td></tr></table></figure><p><strong>07</strong>、头文件中的#ifndef</p><p>在大型的软件工程中，可能有多个文件包含一个头文件，当这些文件编译链接成一个可执行文件时，就会出现大量的“重定义”错误，所以在头文件头部就使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> <span class="hljs-string">&lt;标识&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> <span class="hljs-string">&lt;标识&gt;</span></span><br>...<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>标识的命名规则一般是头文件名全大写，前后加下划线，并把文件名中的“.”也变成下划线，如：stdio.h应为_STDIO_H_</p><p><strong>08</strong>、在堆上分配内存要及时释放(malloc和free)</p><p>stack上分配的内存系统自动释放，heap上分配的内存，除非手动释放系统永远不自动释放，哪怕程序退出，那一块内存还是在那里。stack一般是静态分配内存，heap上一般是动态分配内存。</p><p>由malloc系统函数分配的内存就是从堆上分配内存。从堆上分配的内存一定要自己用free释放。不然就是术语——“内存泄露”—— Memory Leak。系统的可分配内存会随malloc越来越少，直到系统崩溃。下面是“栈内存”和“堆内存”的差别。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    栈内存分配<br>    —————<br>    <span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">AllocStrFromStack</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">char</span> pstr[<span class="hljs-number">100</span>];<br>        <span class="hljs-keyword">return</span> pstr;<br>    &#125;<br>   <br>    堆内存分配<br>    —————<br>    <span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">AllocStrFromHeap</span><span class="hljs-params">(<span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">char</span> *pstr;<br>       <br>        <span class="hljs-keyword">if</span> ( len &lt;= <span class="hljs-number">0</span> ) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> ( <span class="hljs-type">char</span>* ) <span class="hljs-built_in">malloc</span>( len );<br>    &#125;<br></code></pre></td></tr></table></figure><p>对于第一个函数，那块pstr的内存在函数返回时就被系统释放了。于是所返回的char*什么也没有。而对于第二个函数，是从堆上分配内存，所以哪怕是程序退出时，也不释放，所以第二个函数的返回的内存没有问题，可以被使用。但一定要调用free释放，不然就是Memory Leak！</p><p>在堆上分配内存很容易造成内存泄漏，这是C&#x2F;C++的最大的“克星”，如果你的程序要稳定，那么就不要出现Memory Leak。所以，我还是要在这里千叮咛万嘱付，在使用malloc系统函数（包括calloc，realloc）时千万要小心。</p><p>   </p><p>对于malloc和free的操作有以下规则：</p><p>1) 配对使用，有一个malloc，就应该有一个free。</p><p>2) 尽量在同一层上使用，不要malloc在函数中，而free在函数外。最好在同一调用层上使用这两个函数。</p><p>3) malloc分配的内存一定要初始化(malloc前，将指针置NULL，NULL指不指向任何实体)。free后的指针一定要设置为NULL(free后，将指针置NULL)。   </p><p><strong>09</strong>、变量一定要被初始化再使用(包括全局变量和静态变量)</p><p>如：</p><p>    1) 对malloc分配的内存进行memset清零操作。（可以使用calloc分配一块全零的内存）</p><p>    2) 对一些栈上分配的struct或数组进行初始化。（最好也是清零）</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs gradle">memset:<br>功 能: 将s所指向的某一块内存中的每个字节的内容全部设置为ch指定的ASCII值,块的大小由第三个参数指定,这个函数通常为新申请的内存做初始化工作<br><span class="hljs-keyword">void</span> *memset(<span class="hljs-keyword">void</span> *s,<span class="hljs-keyword">int</span> c,size_t n)<br>作用：将已开辟内存空间 s 的首 n 个字节的值设为值 c（给空间初始化）；<br>C语言需要包含头文件string.h；C++需要包含cstring 或 string.h<br><br>calloc:<br><span class="hljs-keyword">void</span>* calloc (size_t num, size_t <span class="hljs-keyword">size</span>);<br>calloc() 函数用来动态地分配 num 个长度为 <span class="hljs-keyword">size</span> 字节内存空间并初始化为 <span class="hljs-number">0</span>，分配成功返回指向该内存的地址，失败则返回 <span class="hljs-keyword">NULL</span>。<br>函数的返回值类型是 <span class="hljs-keyword">void</span> *，所以在使用 calloc() 时通常需要进行强制类型转换。<br>calloc() 与 malloc() 的一个重要区别是：calloc() 在动态分配完内存后，自动初始化该内存空间为零，而<br>malloc() 不初始化，里边数据是未知的垃圾数据。<br><br><span class="hljs-comment">// calloc() 分配内存空间并初始化 </span><br><span class="hljs-keyword">char</span> *str1 = (<span class="hljs-keyword">char</span> *)calloc(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>); <br><span class="hljs-comment">// malloc() 分配内存空间并用 memset() 初始化 </span><br><span class="hljs-keyword">char</span> *str2 = (<span class="hljs-keyword">char</span> *)malloc(<span class="hljs-number">20</span>); <br>memset(str2, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure><p>但初始化也会造成系统运行时间有一定的开销，所以，也不需要对所有的变量做初始化。如：以下这种情况，则不需要。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">        char *pstr;  <span class="hljs-regexp">/* 一个字符串 */</span><br>        pstr = ( char* ) malloc( <span class="hljs-number">50</span> );<br>        <span class="hljs-keyword">if</span> ( pstr == NULL ) <span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>        strcpy( pstr, <span class="hljs-string">&quot;Hello Wrold&quot;</span> );<br></code></pre></td></tr></table></figure><p>但如果是下面一种情况，最好进行内存初始化。（指针也一定要初始化，赋值NULL或一个有效值）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">        char **pstr;  <span class="hljs-regexp">/* 一个字符串数组 */</span><br>        pstr = ( char** ) malloc( <span class="hljs-number">50</span>*sizeof(char*) );<br>        <span class="hljs-keyword">if</span> ( pstr == NULL ) <span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>       <br>        <span class="hljs-regexp">/* 让数组中的指针都指向NULL */</span><br>        memset( pstr, <span class="hljs-number">0</span>, <span class="hljs-number">50</span>*sizeof(char*) );<br></code></pre></td></tr></table></figure><p>而对于全局变量，和静态变量，一定要声明时就初始化</p><p><strong>10</strong>、h和c文件的使用</p><p>带初始化的全局变量不要放在H文件中，会造成每个包含该头文件的文件都有这个全局变量。因为C语言的include是直接将文件嵌入到include这个地方。</p><span style="background-color: #ffaaaa"></span><p><strong>11</strong>、重要的出错信息统一处理</p><p>出错信息或是提示信息，应该统一处理。如果要管理错误信息，那就要有以下的处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-comment">/* 声明出错代码 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_NO_ERROR    0  <span class="hljs-comment">/* No error                 */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_OPEN_FILE   1  <span class="hljs-comment">/* Open file error          */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_SEND_MESG   2  <span class="hljs-comment">/* sending a message error  */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_BAD_ARGS    3  <span class="hljs-comment">/* Bad arguments            */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_MEM_NONE    4  <span class="hljs-comment">/* Memeroy is not enough    */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_SERV_DOWN   5  <span class="hljs-comment">/* Service down try later   */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_UNKNOW_INFO 6  <span class="hljs-comment">/* Unknow information       */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_SOCKET_ERR  7  <span class="hljs-comment">/* Socket operation failed  */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_PERMISSION  8  <span class="hljs-comment">/* Permission denied        */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_BAD_FORMAT  9  <span class="hljs-comment">/* Bad configuration file   */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_TIME_OUT   10  <span class="hljs-comment">/* Communication time out   */</span></span><br>   <br>    <span class="hljs-comment">/* 声明出错信息 */</span><br>    <span class="hljs-type">char</span>* errmsg[] = &#123;<br>        <span class="hljs-comment">/* 0 */</span>       <span class="hljs-string">&quot;No error&quot;</span>,               <br>        <span class="hljs-comment">/* 1 */</span>       <span class="hljs-string">&quot;Open file error&quot;</span>,       <br>        <span class="hljs-comment">/* 2 */</span>       <span class="hljs-string">&quot;Failed in sending/receiving a message&quot;</span>,<br>        <span class="hljs-comment">/* 3 */</span>       <span class="hljs-string">&quot;Bad arguments&quot;</span>,<br>        <span class="hljs-comment">/* 4 */</span>       <span class="hljs-string">&quot;Memeroy is not enough&quot;</span>,<br>        <span class="hljs-comment">/* 5 */</span>       <span class="hljs-string">&quot;Service is down; try later&quot;</span>,<br>        <span class="hljs-comment">/* 6 */</span>       <span class="hljs-string">&quot;Unknow information&quot;</span>,<br>        <span class="hljs-comment">/* 7 */</span>       <span class="hljs-string">&quot;A socket operation has failed&quot;</span>,<br>        <span class="hljs-comment">/* 8 */</span>       <span class="hljs-string">&quot;Permission denied&quot;</span>,<br>        <span class="hljs-comment">/* 9 */</span>       <span class="hljs-string">&quot;Bad configuration file format&quot;</span>,<br>        <span class="hljs-comment">/* 10 */</span>      <span class="hljs-string">&quot;Communication time out&quot;</span>,<br>    &#125;;<br>                             <br>    <span class="hljs-comment">/* 声明错误代码全局变量 */</span><br>    <span class="hljs-type">long</span> errno = <span class="hljs-number">0</span>;<br>   <br>    <span class="hljs-comment">/* 打印出错信息函数 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">perror</span><span class="hljs-params">( <span class="hljs-type">char</span>* info )</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> ( info )&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: %s\n&quot;</span>, info, errmsg[errno] );<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error: %s\n&quot;</span>, errmsg[errno] );<br>    &#125;<br>这个基本上是ANSI的错误处理实现细节了，于是当你程序中有错误时你就可以这样处理：<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CheckPermission</span><span class="hljs-params">( <span class="hljs-type">char</span>* userName )</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">strcpy</span>(userName, <span class="hljs-string">&quot;root&quot;</span>) != <span class="hljs-number">0</span> )&#123;<br>            errno = ERR_PERMISSION_DENIED;<br>            <span class="hljs-keyword">return</span> (FALSE);<br>        &#125;<br>        ...<br>    &#125;<br>   <br>    <span class="hljs-built_in">main</span>()<br>    &#123;<br>        ...<br>        <span class="hljs-keyword">if</span> (! <span class="hljs-built_in">CheckPermission</span>( username ) )&#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;main()&quot;</span>);<br>        &#125;<br>        ...<br>    &#125;<br></code></pre></td></tr></table></figure><p>一个即有共性，也有个性的错误信息处理，这样做有利同种错误出一样的信息，统一用户界面，而不会因为文件打开失败，A程序员出一个信息，B程序员又出一个信息。而且这样做，非常容易维护。代码也易读。</p><p>当然，物极必反，也没有必要把所有的输出都放到errmsg中，抽取比较重要的出错信息或是提示信息是其关键，但即使这样，这也包括了大多数的信息。</p><p><span style="background-color: #ffaaaa"><strong>12</strong>、常用函数和循环语句中的被计算量</span></p><p>看一下下面这个例子：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl">    <span class="hljs-function"><span class="hljs-title">for</span>( <span class="hljs-variable">i</span>=<span class="hljs-number">0</span>; <span class="hljs-variable">i</span>&lt;<span class="hljs-number">1000</span>; <span class="hljs-variable">i</span>++ )&#123;</span><br><span class="hljs-function">        <span class="hljs-title">GetLocalHostName</span>( <span class="hljs-variable">hostname</span> );</span><br><span class="hljs-function">        ...d<span class="hljs-string">&#x27;t</span></span><br><span class="hljs-string"><span class="hljs-function">    &#125;</span></span><br></code></pre></td></tr></table></figure><p>GetLocalHostName的意思是取得当前计算机名，在循环体中，它会被调用1000次啊。这是多么的没有效率的事啊。应该把这个函数拿到循环体外，这样只调用一次，效率得到了很大的提高。虽然，我们的编译器会进行优化，会把循环体内的不变的东西拿到循环外面，但是，你相信所有编译器会知道哪些是不变的吗？我觉得编译器不可靠。最好还是自己动手吧。</p><p>同样，对于常用函数中的不变量，如：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">GetLocalHostName(<span class="hljs-params">char</span><span class="hljs-operator">*</span> <span class="hljs-params">name</span>)</span><br>&#123;<br>    <span class="hljs-built_in">char</span> funcName<span class="hljs-literal">[]</span> = <span class="hljs-string">&quot;GetLocalHostName&quot;</span>;<br>   <br>    sys<span class="hljs-constructor">_log( <span class="hljs-string">&quot;%s begin......&quot;</span>, <span class="hljs-params">funcName</span> )</span>;<span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator">    </span>sys<span class="hljs-constructor">_log( <span class="hljs-string">&quot;%s end......&quot;</span>, <span class="hljs-params">funcName</span> )</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果这是一个经常调用的函数，每次调用时都要对funcName进行分配内存，这个开销很大啊。把这个变量声明成static吧，当函数再次被调用时，就会省去了分配内存的开销，执行效率也很好。</p><p><strong>13</strong>、函数名和变量名的命名</p><p>参考linux内核规范</p><p><strong>14</strong>、函数的传值和传指针</p><p>向函数传参数时，一般而言，传入非const的指针时，就表示，在函数中要修改这个指针把指内存中的数据。如果是传值，那么无论在函数内部怎么修改这个值，也影响不到传过来的值，因为传值是只内存拷贝。</p><p>什么？你说这个特性你明白了，好吧，让我们看看下面的这个例程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GetVersion</span><span class="hljs-params">(<span class="hljs-type">char</span>* pStr)</span></span><br><span class="hljs-function"></span>&#123;<br>    pStr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">strcpy</span> ( pStr, <span class="hljs-string">&quot;2.0&quot;</span> );<br>&#125;<br><span class="hljs-built_in">main</span>()<br>&#123;<br>    <span class="hljs-type">char</span>* ver = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">GetVersion</span> ( ver );<br>    ...<br>    ...<br>    <span class="hljs-built_in">free</span> ( ver );<br>&#125;<br></code></pre></td></tr></table></figure><p>我保证，类似这样的问题是一个新手最容易犯的错误。程序中妄图通过函数GetVersion给指针ver分配空间，但这种方法根本没有什么作用，原因就是——这是传值，不是传指针。你或许会和我争论，我分明传的时指针啊？再仔细看看，其实，你传的是指针其实是在传值。</p><p><strong>15</strong>、修改别人程序的修养</p><p>当你维护别人的程序时，请不要非常主观臆断的把已有的程序删除或是修改。我经常看到有的程序员直接在别人的程序上修改表达式或是语句。修改别人的程序时，请不要删除别人的程序，如果你觉得别人的程序有所不妥，请注释掉，然后添加自己的处理程序，必竟，你不可能100%的知道别人的意图，所以为了可以恢复，请不依赖于CVS或是SourceSafe这种版本控制软件，还是要在源码上给别人看到你修改程序的意图和步骤。这是程序维护时，一个有修养的程序员所应该做的。</p><p>如下所示，这就是一种比较好的修改方法：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino">    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * ----- commented by haoel 2003/04/12 ------</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *   char* p = ( char* ) malloc( 10 );</span><br><span class="hljs-comment">     *   memset( p, 0, 10 );</span><br><span class="hljs-comment">     */</span><br>    <br>    <span class="hljs-comment">/* ------ Added by haoel   2003/04/12 ----- */</span><br>     <span class="hljs-type">char</span>* p = ( <span class="hljs-type">char</span>* )<span class="hljs-built_in">calloc</span>( <span class="hljs-number">10</span>, <span class="hljs-keyword">sizeof</span> <span class="hljs-type">char</span> );<br>    <span class="hljs-comment">/* ---------------------------------------- */</span><br>    ...<br></code></pre></td></tr></table></figure><p>当然，这种方法是在软件维护时使用的，这样的方法，可以让再维护的人很容易知道以前的代码更改的动作和意图，而且这也是对原作者的一种尊敬。</p><p>以“注释 — 添加”方式修改别人的程序，要好于直接删除别人的程序。</p><p><strong>16</strong>、把相同或近乎相同的代码形成函数和宏</p><p>有人说，最好的程序员，就是最喜欢“偷懒”的程序，其中不无道理。</p><p>如果你有一些程序的代码片段很相似，或直接就是一样的，请把他们放在一个函数中。而如果这段代码不多，而且会被经常使用，你还想避免函数调用的开销，那么就把他写成宏吧。</p><p>千万不要让同一份代码或是功能相似的代码在多个地方存在，不然如果功能一变，你就要修改好几处地方，这种会给维护带来巨大的麻烦，所以，做到“一改百改”，还是要形成函数或是宏。</p><p><strong>17</strong>、表达式中的括号</p><p>如果一个比较复杂的表达式中，你并不是很清楚各个操作符的忧先级，即使是你很清楚优先级，也请加上括号，不然，别人或是自己下一次读程序时，一不小心就看走眼理解错了，为了避免这种“误解”，还有让自己的程序更为清淅，还是加上括号吧。</p><p>比如，对一个结构的成员取地址：</p><p>    GetUserAge( &amp;( UserInfo-&gt;age ) );</p><p>虽然，&amp;UserInfo-&gt;age中，-&gt;操作符的优先级最高，但加上一个括号，会让人一眼就看明白你的代码是什么意思。</p><p>再比如，一个很长的条件判断：</p><p>if ( ( ch[0] &gt;&#x3D; ‘0’ || ch[0] &lt;&#x3D; ‘9’ ) &amp;&amp;</p><p>     ( ch[1] &gt;&#x3D; ‘a’ || ch[1] &lt;&#x3D; ‘z’ ) &amp;&amp;</p><p>     ( ch[2] &gt;&#x3D; ‘A’ || ch[2] &lt;&#x3D; ‘Z’ )    )</p><p>括号，再加上空格和换行，你的代码是不是很容易读懂了？    </p><p><strong>18</strong>、函数参数中的const</p><p>对于一些函数中的指针参数，如果在函数中只读，请将其用const修饰，这样，别人一读到你的函数接口时，就会知道你的意图是这个参数是[in]，如果没有const时，参数表示[in&#x2F;out]，注意函数接口中的const使用，利于程序的维护和避免犯一些错误。</p><p>虽然，const修饰的指针，如：const char* p，在C中一点用也没有，因为不管你的声明是不是const，指针的内容照样能改，因为编译器会强制转换，但是加上这样一个说明，有利于程序的阅读和编译。因为在C中，修改一个const指针所指向的内存时，会报一个Warning。这会引起程序员的注意。</p><p>C++中对const定义的就很严格了，所以C++中要多多的使用const，const的成员函数，const的变量，这样会对让你的代码和你的程序更加完整和易读。（关于C++的const我就不多说了）</p><p><strong>19</strong>、函数的参数个数</p><p>函数的参数个数最好不要太多，一般来说6个左右就可以了，众多的函数参数会让读代码的人一眼看上去就很头昏，而且也不利于维护。如果参数众多，还请使用结构来传递参数。这样做有利于数据的封装和程序的简洁性。</p><p>也利于使用函数的人，因为如果你的函数个数很多，比如12个，调用者很容易搞错参数的顺序和个数，而使用结构struct来传递参数，就可以不管参数的顺序。</p><p>而且，函数很容易被修改，如果需要给函数增加参数，不需要更改函数接口，只需更改结构体和函数内部处理，而对于调用函数的程序来说，这个动作是透明的。</p><p><strong>20</strong>、函数的返回类型，不要省略</p><p>我看到很多程序写函数时，在函数的返回类型方面不太注意。如果一个函数没有返回值，也请在函数前面加上void的修饰。而有的程序员偷懒，在返回int的函数则什么不修饰（因为如果不修饰，则默认返回int），这种习惯很不好，还是为了原代码的易读性，加上int吧。</p><p>所以函数的返回值类型，请不要省略。</p><p>另外，对于void的函数，我们往往会忘了return，由于某些C&#x2F;C++的编译器比较敏感，会报一些警告，所以即使是void的函数，我们在内部最好也要加上return的语句，这有助于代码的编译。</p><p><strong>21</strong>、goto语句的使用</p><p>N年前，软件开发的一代宗师——迪杰斯特拉(Dijkstra)说过：“goto statment is harmful !!”，并建议取消goto语句。因为goto语句不利于程序代码的维护性。</p><p>这里我也强烈建议不要使用goto语句，除非下面的这种情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-meta">#<span class="hljs-keyword">define</span> FREE(p) <span class="hljs-keyword">if</span>(p) &#123; \</span><br><span class="hljs-meta">                        free(p); \</span><br><span class="hljs-meta">                        p = NULL; \</span><br><span class="hljs-meta">                    &#125;</span><br>    <span class="hljs-built_in">main</span>()<br>    &#123;<br>        <span class="hljs-type">char</span> *fname=<span class="hljs-literal">NULL</span>, *lname=<span class="hljs-literal">NULL</span>, *mname=<span class="hljs-literal">NULL</span>;<br>        fname = ( <span class="hljs-type">char</span>* ) <span class="hljs-built_in">calloc</span> ( <span class="hljs-number">20</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) );<br>        <span class="hljs-keyword">if</span> ( fname == <span class="hljs-literal">NULL</span> )&#123;<br>            <span class="hljs-keyword">goto</span> ErrHandle;<br>        &#125;<br>        lname = ( <span class="hljs-type">char</span>* ) <span class="hljs-built_in">calloc</span> ( <span class="hljs-number">20</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) );<br>        <span class="hljs-keyword">if</span> ( lname == <span class="hljs-literal">NULL</span> )&#123;<br>            <span class="hljs-keyword">goto</span> ErrHandle;<br>        &#125;<br>        mname = ( <span class="hljs-type">char</span>* ) <span class="hljs-built_in">calloc</span> ( <span class="hljs-number">20</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) );<br>        <span class="hljs-keyword">if</span> ( mname == <span class="hljs-literal">NULL</span> )&#123;<br>            <span class="hljs-keyword">goto</span> ErrHandle;<br>        &#125;<br>       <br>        ......<br>    <br>       <br>     ErrHandle:<br>        <span class="hljs-built_in">FREE</span>(fname);<br>        <span class="hljs-built_in">FREE</span>(lname);<br>        <span class="hljs-built_in">FREE</span>(mname);<br>        <span class="hljs-built_in">ReportError</span>(ERR_NO_MEMOEY);<br>     &#125;<br></code></pre></td></tr></table></figure><p>也只有在这种情况下，goto语句会让你的程序更易读，更容易维护。（在用嵌C来对数据库设置游标操作时，或是对数据库建立链接时，也会遇到这种结构）</p><p><strong>22</strong>、宏的使用</p><p>很多程序员不知道C中的“宏”到底是什么意思？特别是当宏有参数的时候，经常把宏和函数混淆。我想在这里我还是先讲讲“宏”，宏只是一种定义，他定义了一个语句块，当程序编译时，编译器首先要执行一个“替换”源程序的动作，把宏引用的地方替换成宏定义的语句块，就像文本文件替换一样。这个动作术语叫“宏的展开”</p><p>使用宏是比较“危险”的，因为你不知道宏展开后会是什么一个样子。例如下面这个宏：</p><p>    #define  MAX(a, b)     a&gt;b?a:b</p><p>当我们这样使用宏时，没有什么问题： MAX( num1, num2 ); 因为宏展开后变成 num1&gt;num2?num1:num2；。 但是，如果是这样调用的，MAX( 17+32, 25+21 ); 呢，编译时出现错误，原因是，宏展开后变成：17+32&gt;25+21?17+32:25+21，哇，这是什么啊？</p><p>所以，宏在使用时，参数一定要加上括号，上述的那个例子改成如下所示就能解决问题了。</p><p>    #define  MAX( (a), (b) )     (a)&gt;(b)?(a):(b)</p><p>   </p><p>即使是这样，也不这个宏也还是有Bug，因为如果我这样调用 MAX(i++, j++); ， 经过这个宏以后，i和j都被累加了两次，这绝不是我们想要的。</p><p>   </p><p>所以，在宏的使用上还是要谨慎考虑，因为宏展开是的结果是很难让人预料的。而且虽然，宏的执行很快（因为没有函数调用的开销），但宏会让源代码澎涨，使目标文件尺寸变大，（如：一个50行的宏，程序中有1000个地方用到，宏展开后会很不得了），相反不能让程序执行得更快（因为执行文件变大，运行时系统换页频繁）。</p><p>因此，在决定是用函数，还是用宏时得要小心。</p><p><strong>23</strong>、static的使用</p><p>static关键字，表示了“静态”，一般来说，他会被经常用于变量和函数。一个static的变量，其实就是全局变量，只不过他是有作用域的全局变量。比如一个函数中的static变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">char</span>*</span><br><span class="hljs-function"><span class="hljs-title">getConsumerName</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>   <br>    ....<br>    cnt++;<br>    ....<br>&#125;<br></code></pre></td></tr></table></figure><p>cnt变量的值会跟随着函数的调用次而递增，函数退出后，cnt的值还存在，只是cnt只能在函数中才能被访问。而cnt的内存也只会在函数第一次被调用时才会被分配和初始化，以后每次进入函数，都不为static分配了，而直接使用上一次的值。</p><p>对于一些被经常调用的函数内的常量，最好也声明成static（参见第12条）</p><p>但static的最多的用处却不在这里，其最大的作用的控制访问，在C中<strong>如果一个函数或是一个全局变量被声明为static，那么，这个函数和这个全局变量，将只能在这个C文件中被访问，如果别的C文件中调用这个C文件中的函数，或是使用其中的全局（用extern关键字），将会发生链接时错误。这个特性可以用于数据和程序保密。</strong></p><p><strong>24</strong>、函数中的代码尺寸</p><p>一个函数完成一个具体的功能，一般来说，一个函数中的代码最好不要超过600行左右，越少越好，最好的函数一般在100行以内，300行左右的孙函数就差不多了。有证据表明，一个函数中的代码如果超过500行，就会有和别的函数相同或是相近的代码，也就是说，就可以再写另一个函数。</p><p>另外，函数一般是完成一个特定的功能，千万<strong>忌讳在一个函数中做许多件不同的事</strong>。函数的功能<strong>越单一越好</strong>，一方面有利于函数的易读性，另一方面更有利于代码的维护和重用，功能越单一表示这个函数就越可能给更多的程序提供服务，也就是说共性就越多。</p><p>虽然函数的调用会有一定的开销，但比起软件后期维护来说，增加一些运行时的开销而换来更好的可维护性和代码重用性，是很值得的一件事。</p><p><strong>25</strong>、typedef的使用</p><p>typedef是一个给类型起别名的关键字。不要小看了它，它对于你代码的维护会有很好的作用。比如C中没有bool，于是在一个软件中，一些程序员使用int，一些程序员使用short，会比较混乱，最好就是用一个typedef来定义，如：</p><p>    typedef char bool;</p><p>   </p><p>一般来说，一个C的工程中一定要做一些这方面的工作，因为你会涉及到跨平台，不同的平台会有不同的字长，所以利用预编译和typedef可以让你最有效的维护你的代码，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SOLARIS2_5</span><br>      <span class="hljs-keyword">typedef</span> <span class="hljs-type">boolean_t</span>     BOOL_T;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      <span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span>           BOOL_T;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>   <br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">short</span>           INT16_T;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>  UINT16_T;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span>             INT32_T;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>    UINT32_T;<br>   <br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> WIN32</span><br>      <span class="hljs-keyword">typedef</span> _int64        INT64_T;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      <span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>     INT64_T;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>   <br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">float</span>           FLOAT32_T;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span>*           STRING_T;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>   BYTE_T;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">time_t</span>          TIME_T;<br>    <span class="hljs-keyword">typedef</span> INT32_T         PID_T;<br></code></pre></td></tr></table></figure><p>   </p><p>使用typedef的其它规范是，在结构和函数指针时，也最好用typedef，这也有利于程序的易读和可维护性。如：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs elm">    typedef struct _hostinfo &#123;<br>        <span class="hljs-type">HOSTID_T</span>   host;<br>        <span class="hljs-type">INT32_T</span>    hostId;<br>        <span class="hljs-type">STRING_T</span>   hostType;<br>        <span class="hljs-type">STRING_T</span>   hostModel;<br>        <span class="hljs-type">FLOAT32_T</span>  cpuFactor;<br>        <span class="hljs-type">INT32_T</span>    numCPUs;<br>        <span class="hljs-type">INT32_T</span>    nDisks;<br>        <span class="hljs-type">INT32_T</span>    memory;<br>        <span class="hljs-type">INT32_T</span>    swap;<br>    &#125; <span class="hljs-type">HostInfo</span>;<br>    typedef <span class="hljs-type">INT32_T</span> (*<span class="hljs-type">RsrcReqHandler</span>)(<br>     void *info,<br>     <span class="hljs-type">JobArray</span> *jobs,<br>     <span class="hljs-type">AllocInfo</span> *allocInfo,<br>     <span class="hljs-type">AllocList</span> *allocList);<br></code></pre></td></tr></table></figure><p>C++中这样也是很让人易读的：</p><p>    typedef CArray&lt;HostInfo, HostInfo&amp;&gt; HostInfoArray;</p><p>于是，当我们用其定义变量时，会显得十分易读。如：</p><p>    HostInfo* phinfo;</p><p>    RsrcReqHandler* pRsrcHand;</p><p>这种方式的易读性，在函数的参数中十分明显。</p><p>关键是在程序种使用typedef后，几乎所有的程序中的类型声明都显得那么简洁和清淅，而且易于维护，这才是typedef的关键。</p><p><strong>26</strong>、为常量声明宏</p><p>最好不要在程序中出现数字式的“硬编码”，如：</p><p>    int user[120];</p><p>   </p><p>为这个120声明一个宏吧。为所有出现在程序中的这样的常量都声明一个宏吧。比如TimeOut的时间，最大的用户数量，还有其它，只要是常量就应该声明成宏。如果，突然在程序中出现下面一段代码，</p><p>    for ( i&#x3D;0; i&lt;120; i++){</p><p>        ….</p><p>    }</p><p>120是什么？为什么会是120？这种“硬编码”不仅让程序很读，而且也让程序很不好维护，如果要改变这个数字，得同时对所有程序中这个120都要做修改，这对修改程序的人来说是一个很大的痛苦。所以还是把常量声明成宏，这样，一改百改，而且也很利于程序阅读。</p><p>    #define MAX_USR_CNT 120</p><p>   </p><p>    for ( i&#x3D;0; i&lt;MAX_USER_CNT; i++){</p><p>        ….</p><p>    }</p><p>这样就很容易了解这段程序的意图了。</p><p>有的程序员喜欢为这种变量声明全局变量，其实，全局变量应该尽量的少用，全局变量不利于封装，也不利于维护，而且对程序执行空间有一定的开销，一不小心就造成系统换页，造成程序执行速度效率等问题。所以声明成宏，即可以免去全局变量的开销，也会有速度上的优势。</p><p><strong>27</strong>、不要为宏定义加分号</p><p>有许多程序员不知道在宏定义时是否要加分号，有时，他们以为宏是一条语句，应该要加分号，这就错了。当你知道了宏的原理，你会赞同我为会么不要为宏定义加分号的。看一个例子：</p><p>    #define MAXNUM 1024;</p><p>这是一个有分号的宏，如果我们这样使用：</p><p>    half &#x3D; MAXNUM&#x2F;2;</p><p>   </p><p>    if ( num &lt; MAXNUM )</p><p>等等，都会造成程序的编译错误，因为，当宏展开后，他会是这个样子的：</p><p>    half &#x3D; 1024;&#x2F;2;</p><p>   </p><p>    if ( num &lt; 1024; )</p><p>   </p><p>是的，分号也被展进去了，所以造成了程序的错误。请相信我，有时候，一个分号会让你的程序出现成百个错误。所以还是不要为宏加最后一个分号，哪怕是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-meta">#<span class="hljs-keyword">define</span> LINE    <span class="hljs-string">&quot;=================================&quot;</span></span><br>   <br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT_LINE  printf(LINE)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT_NLINE(n)  while ( n-- &gt;0 ) &#123; PRINT_LINE; &#125;</span><br></code></pre></td></tr></table></figure><p>都不要在最后加上分号，当我们在程序中使用时，为之加上分号，</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">    main()<br>    &#123;<br>        char *p <span class="hljs-operator">=</span> LINE<span class="hljs-comment">;</span><br>        PRINT_LINE<span class="hljs-comment">;</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>这一点非常符合习惯，而且，如果忘加了分号，编译器给出的错误提示，也会让我们很容易看懂的。</p><p><strong>28</strong>、||和&amp;&amp;的语句执行顺序</p><p>条件语句中的这两个“与”和“或”操作符一定要小心，它们的表现可能和你想像的不一样，这里条件语句中的有些行为需要和说一下：</p><p>    express1 || express2</p><p>       </p><p>    先执行表达式express1如果为“真”，express2将不被执行，express2仅在express1为“假”时才被执行。因为第一个表达式为真了，整个表达式都为真，所以没有必要再去执行第二个表达式了。</p><p>    express1 &amp;&amp; express2</p><p>    先执行表达式express1如果为“假”，express2将不被执行，express2仅在express1为“真”时才被执行。因为第一个表达式为假了，整个表达式都为假了，所以没有必要再去执行第二个表达式了。</p><p>于是，他并不是你所想像的所有的表达式都会去执行，这点一定要明白，不然你的程序会出现一些莫明的运行时错误。</p><p>例如，下面的程序：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lisp">    if ( <span class="hljs-name">sum</span> &gt; <span class="hljs-number">100</span> <span class="hljs-symbol">&amp;&amp;</span><br>         ( ( <span class="hljs-name">fp=fopen</span>( <span class="hljs-name">filename</span>,<span class="hljs-string">&quot;a&quot;</span> ) ) != NULL )   &#123;<br>        <br>         fprintf(<span class="hljs-name">fp</span>, <span class="hljs-string">&quot;Warring: it beyond one hundred\n&quot;</span>)<span class="hljs-comment">;</span><br>         ......<br>    &#125;<br>   <br>    fprintf( <span class="hljs-name">fp</span>, <span class="hljs-string">&quot; sum is %id \n&quot;</span>, sum )<span class="hljs-comment">;</span><br>    fclose( <span class="hljs-name">fp</span> )<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>本来的意图是，如果sum &gt; 100 ，向文件中写一条出错信息，为了方便，把两个条件判断写在一起，于是，如果sum&lt;&#x3D;100时，打开文件的操作将不会做，最后，fprintf和fclose就会发现未知的结果。</p><p>再比如，如果我想判断一个字符是不是有内容，我得判断这个字符串指针是不为空（NULL）并且其内容不能为空（Empty），一个是空指针，一个是空内容。我也许会这样写：</p><p>    if ( ( p !&#x3D; NULL ) &amp;&amp; ( strlen(p) !&#x3D; 0 ))</p><p>于是，如果p为NULL，那么strlen(p)就不会被执行，于是，strlen也就不会因为一个空指针而“非法操作”或是一个“Core Dump”了。</p><p>记住一点，条件语句中，并非所有的语句都会执行，当你的条件语句非常多时，这点要尤其注意。</p><p><strong>29</strong>、尽量用for而不是while做循环</p><p>基本上来说，for可以完成while的功能，我是建议尽量使用for语句，而不要使用while语句，特别是当循环体很大时，for的优点一下就体现出来了。</p><p>因为在for中，循环的初始、结束条件、循环的推进，都在一起，一眼看上去就知道这是一个什么样的循环。刚出学校的程序一般对于链接喜欢这样来：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">    p <span class="hljs-operator">=</span> pHead<span class="hljs-comment">;</span><br>   <br>    while ( p )&#123;<br>        ...<br>        ...<br>        p <span class="hljs-operator">=</span> p-&gt;next<span class="hljs-comment">;</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>当while的语句块变大后，你的程序将很难读，用for就好得多：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">    <span class="hljs-keyword">for</span> ( <span class="hljs-attribute">p</span>=pHead;  p; <span class="hljs-attribute">p</span>=p-&gt;next )&#123;<br>    <span class="hljs-built_in">..</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>一眼就知道这个循环的开始条件，结束条件，和循环的推进。大约就能明白这个循环要做个什么事？而且，程序维护进来很容易，不必像while一样，在一个编辑器中上上下下的捣腾。</p><p><strong>30</strong>、请sizeof类型而不是变量</p><p>许多程序员在使用sizeof中，喜欢sizeof变量名，例如：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">int score<span class="hljs-selector-attr">[100]</span>;<br>char filename<span class="hljs-selector-attr">[20]</span>;<br>struct UserInfo usr<span class="hljs-selector-attr">[100]</span>;<br></code></pre></td></tr></table></figure><p>在sizeof这三个的变量名时，都会返回正确的结果，于是许多程序员就开始sizeof变量名。这个习惯很虽然没有什么不好，但我还是建议sizeof类型。</p><p>我看到过这个的程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    pScore = (<span class="hljs-type">int</span>*) <span class="hljs-built_in">malloc</span>( SUBJECT_CNT );<br>    <span class="hljs-built_in">memset</span>( pScore, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(pScore) );<br>    ...<br></code></pre></td></tr></table></figure><p>此时，sizeof(pScore)返回的就是4（指针的长度），不会是整个数组，于是，memset就不能对这块内存进行初始化。为了程序的易读和易维护，我强烈建议使用类型而不是变量，如：</p><p>对于score：     sizeof(int) * 100   &#x2F;* 100个int *&#x2F;</p><p>对于filename：  sizeof(char) * 20   &#x2F;* 20个char *&#x2F;</p><p>对于usr：       sizeof(struct UserInfo) * 100   &#x2F;* 100个UserInfo *&#x2F;</p><p>这样的代码是不是很易读？一眼看上去就知道什么意思了。</p><p>另外一点，sizeof一般用于分配内存，这个特性特别在多维数组时，就能体现出其优点了。如，给一个字符串数组分配内存，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 分配一个有20个字符串，</span><br><span class="hljs-comment"> * 每个字符串长100的内存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">char</span>* *p;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 错误的分配方法</span><br><span class="hljs-comment"> */</span><br>p = (<span class="hljs-type">char</span>**)<span class="hljs-built_in">calloc</span>( <span class="hljs-number">20</span>*<span class="hljs-number">100</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) );<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 正确的分配方法</span><br><span class="hljs-comment"> */</span><br>p = (<span class="hljs-type">char</span>**) <span class="hljs-built_in">calloc</span> ( <span class="hljs-number">20</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>*) );<br><span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">20</span>; i++)&#123;<br>    <span class="hljs-comment">/*p = (char*) calloc ( 100, sizeof(char) );*/</span><br>    p[i] = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">calloc</span> ( <span class="hljs-number">100</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) );<br>&#125;<br></code></pre></td></tr></table></figure><p>（注：上述语句被注释掉的是原来的，是错误的，由dasherest朋友指正，谢谢）</p><p>为了代码的易读，省去了一些判断，请注意这两种分配的方法，有本质上的差别。</p><p><strong>31</strong>、不要忽略Warning</p><p>对于一些编译时的警告信息，请不要忽视它们。虽然，这些Warning不会妨碍目标代码的生成，但这并不意味着你的程序就是好的。必竟，并不是编译成功的程序才是正确的，编译成功只是×××长征的第一步，后面还有大风大浪在等着你。从编译程序开始，不但要改正每个error，还要修正每个warning。这是一个有修养的程序员该做的事。</p><p>一般来说，一面的一些警告信息是常见的：</p><p>1). 声明了未使用的变量。（虽然编译器不会编译这种变量，但还是把它从源程序中注释或是删除吧）</p><p>2). 使用了隐晦声明的函数。（也许这个函数在别的C文件中，编译时会出现这种警告，你应该这使用之前使用extern关键字声明这个函数）</p><p>3). 没有转换一个指针。（例如malloc返回的指针是void的，你没有把之转成你实际类型而报警，还是手动的在之前明显的转换一下吧）</p><p>4). 类型向下转换。（例如：float f &#x3D; 2.0; 这种语句是会报警告的，编译会告诉你正试图把一个double转成float，你正在阉割一个变量，你真的要这样做吗？还是在2.0后面加个f吧，不然，2.0就是一个double，而不是float了）</p><p><strong>32</strong>、书写Debug版和Release版的程序</p><p>程序在开发过程中必然有许多程序员加的调试信息。我见过许多项目组，当程序开发结束时，发动群众删除程序中的调试信息，何必呢？为什么不像VC++那样建立两个版本的目标代码？一个是debug版本的，一个是Release版的。那些调试信息是那么的宝贵，在日后的维护过程中也是很宝贵的东西，怎么能说删除就删除呢？</p><p>利用预编译技术吧，如下所示声明调试函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEBUG</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TRACE</span><span class="hljs-params">(<span class="hljs-type">char</span>* fmt, ...)</span></span><br><span class="hljs-function">        </span>&#123;<br>            ......<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        <span class="hljs-meta">#<span class="hljs-keyword">define</span> TRACE(char* fmt, ...)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>于是，让所有的程序都用TRACE输出调试信息，只需要在在编译时加上一个参数“-DDEBUG”，如：</p><p>    cc -DDEBUG -o target target.c</p><p>于是，预编译器发现DEBUG变量被定义了，就会使用TRACE函数。而如果要发布给用户了，那么只需要把取消“-DDEBUG”的参数，于是所有用到TRACE宏，这个宏什么都没有，所以源程序中的所有TRACE语言全部被替换成了空。一举两得，一箭双雕，何乐而不为呢？</p><p>顺便提一下，两个很有用的系统宏，一个是“__FILE__”，一个是“__LINE__”，分别表示，所在的源文件和行号，当你调试信息或是输出错误时，可以使用这两个宏，让你一眼就能看出你的错误，出现在哪个文件的第几行中。这对于用C&#x2F;C++做的大工程非常的管用。</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言基础</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>（一）变量和数据类型</p><p>1.变量</p><p>变量的本质是一段实际连续存储空间的别名；程序中通过变量来申请并命名存储空间，通过变量的名字可以使用存储空间</p><p>2.变量的字节数：不同字长的机器的地址所占字节不同，为机器字长&#x2F;8位</p><p>char    short    int     long    long long    指针</p><p>16位平台         1          2        2         4              &#x2F;              2</p><p>32位平台         1          2        4         4             8              4</p><p>64位平台         1          2        4         8             8              8</p><p>由于实际编程需要确定的结果，而不是一般的情况，所以建议使用int8，int16，int32之类的预定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span>           <span class="hljs-type">char</span> <span class="hljs-type">int8_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-type">short</span>      <span class="hljs-type">int</span> <span class="hljs-type">int16_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span>            <span class="hljs-type">int</span> <span class="hljs-type">int32_t</span>;    <span class="hljs-comment">//此处Int为4字节</span><br><span class="hljs-meta"># <span class="hljs-keyword">if</span> __WORDSIZE == 64</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-type">long</span>       <span class="hljs-type">int</span> <span class="hljs-type">int64_t</span>;<br><span class="hljs-meta"># <span class="hljs-keyword">else</span></span><br>__extension__<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>  <span class="hljs-type">int</span> <span class="hljs-type">int64_t</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>3.有符号数无符号数</p><p>C语言中只有整数类型能够声明unsigned变量，且直接int声明时默认为带符号整型</p><p>（1）有符号数(signed)</p><p>对于有符号数，若其为负数，则存储单元中最高位必为1；若其为正数，则存储单元中最高位必为0</p><p>计算机内部用补码表示有符号数</p><p>-正数的补码为正数本身</p><p>-负数的补码为负数的绝对值各位取反后加1</p><p>例1 有符号数的加法(32位)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a,b,c,d=<span class="hljs-number">-1</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *p=(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>*)&amp;a, *q=(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>*)&amp;b, *z=(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>*)&amp;c, *v=(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>*)&amp;d;<br>   <br>    a = <span class="hljs-number">2147483647</span>;<br>    b = a + <span class="hljs-number">1</span>;<br>    c = b + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//打印abcd的值和其所在内存中的样子（十六进制表示）</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%12d,0x%08X\n&quot;</span>, a,*p);    <span class="hljs-comment">//a=  2147483647,0x7FFFFFF</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b=%12d,0x%08X\n&quot;</span>, b,*q);    <span class="hljs-comment">//b= -2147483648,0x80000000</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c=%12d,0x%08X\n&quot;</span>, c,*z);    <span class="hljs-comment">//c= -2147483647,0x80000001</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;d=%12d,0x%08X\n&quot;</span>, d,*v);    <span class="hljs-comment">//d=          -1,0xFFFFFFFF</span><br>&#125;<br>可以看到<span class="hljs-type">int</span>为<span class="hljs-number">4</span>字节，表示范围为<span class="hljs-number">-2147483648</span>~<span class="hljs-number">2147483647</span><br>当一个数达到<span class="hljs-number">2147483647</span>（<span class="hljs-number">0x7FFFFFF</span> = <span class="hljs-number">2</span>^<span class="hljs-number">31</span> - <span class="hljs-number">1</span>）时，它再加一，变成<span class="hljs-number">-2147483648</span>（<span class="hljs-number">0x80000000</span>）<br>虽然内存中末位加一变成<span class="hljs-number">0x80000000</span>，但它是有符号数，表示出来的数字不是<span class="hljs-number">0x80000000</span>对应的<span class="hljs-number">2147483648</span>，而是<span class="hljs-number">-2147483648</span><br>令这数字再加一，变成<span class="hljs-number">0x80000001</span>，它表示出来的数字不是<span class="hljs-number">0x80000001</span>对应的<span class="hljs-number">2147483649</span>，而是-(<span class="hljs-number">0x80000000</span> + <span class="hljs-number">1</span>)<span class="hljs-number">-2147483647</span><br>故：<span class="hljs-type">int</span> a，a逐渐加一，其内存里变化和表现出十进制数字如下<br><span class="hljs-number">0x0000</span> <span class="hljs-number">0000</span>        <span class="hljs-number">0x0000</span> <span class="hljs-number">0001</span>        ...        <span class="hljs-number">0x7FFF</span> FFFF    <span class="hljs-number">0x8000</span> <span class="hljs-number">0000</span>    <span class="hljs-number">0x8000</span> <span class="hljs-number">0001</span>    ...    <span class="hljs-number">0xFFFF</span> FFFF<br>     <span class="hljs-number">0</span>               <span class="hljs-number">1</span>               <span class="hljs-number">2147483647</span>     <span class="hljs-number">-2147483648</span>    <span class="hljs-number">-2147483647</span>                <span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><p>（2）无符号数(unsigned)</p><p>计算机内部用原码表示无符号数，存储单元中全部二进制位用来存放数本身</p><p>unsigned int b;    b的范围为0~65535</p><p>无符号数若为0再减一，就会变成当前字节数的最大值</p><p>有符号数和无符号数，char举例(32位)</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache">                        <span class="hljs-attribute">unsigned</span>                signed<br><span class="hljs-attribute">char</span>：<span class="hljs-number">1</span>字节    <span class="hljs-number">8</span>位    <span class="hljs-number">0000</span> <span class="hljs-number">0000</span>~<span class="hljs-number">1111</span> <span class="hljs-number">1111</span>    <span class="hljs-number">0000</span> <span class="hljs-number">0000</span>~<span class="hljs-number">1000</span> <span class="hljs-number">0000</span>~<span class="hljs-number">1000</span> <span class="hljs-number">0001</span>~<span class="hljs-number">1111</span> <span class="hljs-number">1111</span><br>                            <span class="hljs-attribute">0</span> ~ <span class="hljs-number">255</span>                <span class="hljs-number">0</span> ~ <span class="hljs-number">128</span>     ~    -<span class="hljs-number">127</span> ~ -<span class="hljs-number">1</span>   <br>                         <span class="hljs-attribute">0x00</span> ~ <span class="hljs-number">0</span>xFF<br><span class="hljs-attribute">unsigned</span> char a = <span class="hljs-number">0</span>xFF; a += <span class="hljs-number">1</span>; //a = <span class="hljs-number">0</span>x100，但char为<span class="hljs-number">1</span>字节<span class="hljs-number">8</span>位，所以它屏蔽了<span class="hljs-number">8</span>位以上的数字，读取的应该是<span class="hljs-number">0</span>x100 = <span class="hljs-number">0</span>，所以用%u打印出后是<span class="hljs-number">0</span><br>  <span class="hljs-attribute">signed</span> char a = <span class="hljs-number">0</span>x7F; a += <span class="hljs-number">1</span>; //a = <span class="hljs-number">0</span>x80，但signed char为有符号型，所以它首先读取最高位为<span class="hljs-number">1</span>，确定此为负数，然后得到此为-(<span class="hljs-number">0</span>x80) = -<span class="hljs-number">128</span>，再次+<span class="hljs-number">1</span>，为<span class="hljs-number">0</span>x80 + <span class="hljs-number">1</span> = <span class="hljs-number">0</span>x81，再次读取最高位发现为<span class="hljs-number">1</span>，即为-(<span class="hljs-number">0</span>x80) + <span class="hljs-number">0</span>x01 = -<span class="hljs-number">127</span>，再次+<span class="hljs-number">1</span>.........最后<span class="hljs-number">0</span>xFE + <span class="hljs-number">1</span> = <span class="hljs-number">0</span>xFF = -(<span class="hljs-number">0</span>x80) + <span class="hljs-number">0</span>x7F = -<span class="hljs-number">1</span>，再+<span class="hljs-number">1</span>即为<span class="hljs-number">0</span>x100 <br></code></pre></td></tr></table></figure><p>例1 当无符号数遇到有符号数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">5</span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-10</span>;    <br>    <span class="hljs-keyword">if</span>((i + j) &gt; <span class="hljs-number">0</span>)    <span class="hljs-comment">//j被看成无符号数，即1111 1111 1111 1111 1111 1111 1111 0110,若看成无符号数即为一个很大的数</span><br>        &#123;<br>             <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i + j &gt; 0\n&quot;</span>);   <br>        &#125;<br>    <span class="hljs-keyword">if</span>((i + j) &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i + j &lt;= 0\n&quot;</span>);   <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>编译结果：i + j &gt; <span class="hljs-number">0</span><br>当无符号数与有符号数混合运算的时候，会将有符号数转换成无符号数后再进行计算，结果为无符号数<br></code></pre></td></tr></table></figure><p>例2 错误使用unsigned</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">9</span>; i&gt;=<span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %u\n&quot;</span>, i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>编译结果：不停输出<br>错误点：不该用无符号类型作为循环变量，因为循环结束条件是i变成一个负数，但无符号数不可能得到负数，最小值是<span class="hljs-number">0</span>，再减一会变成最大值，然后产生死循环<br></code></pre></td></tr></table></figure><p>4.浮点数</p><p>（1）浮点数在内存的存储方式</p><p>（2）浮点数的转换（十进制浮点数转换为计算机内部浮点数）</p><p>①将浮点数转换成二进制</p><p>②用科学计数法表示二进制浮点数</p><p>③计算指数偏移后的值（float偏移量为127，double偏移量为1023）</p><p>例：实数8.25在内存中的float表示</p><p>8.25的二进制表示：1000.01</p><p>科学计数法表示：1.00001*(2^3)    &#x2F;&#x2F;此处2表示此为二进制</p><p>-符号位：0</p><p>-指数：127 + 3 → 130 → 10000010</p><p>-小数：00001</p><p>内存中8.25的float表示为：0 10000010 0000100000000000000 → 0x41040000</p><p>（3）浮点类型的秘密</p><p>int类型的范围：[-2^31,2^31-1]</p><p>float类型的范围：[-3.4*10^38,3.4*10^38]</p><p>int和float都占4个字节的内存，为什么float却比int的范围大的多？</p><p>-因为所占字节数相同，所以他们所能表示的具体数字个数是相同的</p><p>-float可表示的数字之间不是连续的，存在间隙</p><p>-float只是一种近似的表示法，所以在软件开发的时候不能作为精确数使用</p><p>-由于内存表示法相对复杂，float将一个数分成了三个位，而int只由两部分组成，所以float的运算速度比int慢的多</p><p>-同理，double与float具有相同的内存表示法，因此double也是不精确的，但由于double占用的内存较多，所能表示的精度比float高</p><p>例：float类型的不精确性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> f = <span class="hljs-number">3.1415f</span>;    <span class="hljs-comment">//浮点常数默认为double类型，后面加f表示float类型浮点常数！</span><br>        <span class="hljs-type">float</span> f1 = <span class="hljs-number">123456789</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%0.10f\n&quot;</span>, f);    <span class="hljs-comment">//预期结果3.1415f00000            实际结果3.1414999962</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%0.10f\n&quot;</span>, f);    <span class="hljs-comment">//预期结果123456789.0000000000    实际结果123456792.0000000000</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>第一个打印告诉我们：浮点数是一个不精确的表示法<br>第二个打印告诉我们：浮点数虽然表示范围比<span class="hljs-type">int</span>多，但是它是不连续的<br></code></pre></td></tr></table></figure><p>4.变量在内存中的存放形式</p><p>整型变量：见上”3.有符号数无符号数”</p><p>实型变量：浮点数在内存的存储方式为：符号位，指数，尾数</p><p><img src="/image/2e292cc73a5052dc40963d8f7b3cfd9a.png" alt="2e292cc73a5052dc40963d8f7b3cfd9a.png"></p><p>float与double类型的数据在计算机内部的表示法是相同的，但由于所占存储空间的不同，其分别能够表示的数值范围和精度不同。</p><p>字符型变量：内存中存放的是该字符的ASCII码</p><p>字符串常量：字符串中的每个字符以其ASCII码值的二进制形式存储在内存中，并且系统自动在该字符串末尾加一个字符’\0’而额外多占一个字节(ACSII值为0)</p><p>5.变量的数据类型的本质</p><p>数据类型本质就是固定内存大小的别名</p><p>数据类型相当于创建变量的模子（需要1字节内存的时候就是用char模型放在内存上ka一下）</p><p>6.变量不同类型之间的转换</p><p>（1）强制类型转换</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    <span class="hljs-built_in">long</span> l = <span class="hljs-number">800</span>;<br>    <span class="hljs-built_in">int</span> i = (<span class="hljs-built_in">int</span>)l;<br>&#125;<br></code></pre></td></tr></table></figure><p>①强制类型转换的结果</p><p>-目标类型能够容纳目标值：结果不变</p><p>-目标类型不能容纳目标值：结果将产生截断（高位省略，优先截低位）</p><p>（不是所有的强制类型转换都能成功，当不能进行强制类型转换时，编译器将产生错误信息）</p><p>例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TS</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">int</span> j;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TS</span> ts;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">short</span> s = <span class="hljs-number">0x1122</span>;<br><br>    <span class="hljs-type">char</span> c = (<span class="hljs-type">char</span>)s;<br><br>    <span class="hljs-type">int</span> i = (<span class="hljs-type">int</span>)s;<br><br>    <span class="hljs-type">int</span> j = (<span class="hljs-type">int</span>)<span class="hljs-number">3.1415</span>;<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> p = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)&amp;ts;    <span class="hljs-comment">//32位机器上全局变量占4个字节，不会截断</span><br>                                                                                <span class="hljs-comment">//64位机器上全局变量占8个字节，会截断</span><br>    <span class="hljs-type">long</span> l =(<span class="hljs-type">long</span>) ts;    <span class="hljs-comment">//error，结构体类型不能转换成基本类型</span><br><br>    ts = (<span class="hljs-keyword">struct</span> TS)l;    <span class="hljs-comment">//error，基本类型不能转换成结构体类型</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;s = %x\n&quot;</span>, s);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c = %x\n&quot;</span>, c);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %x\n&quot;</span>, i);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;j = %x\n&quot;</span>, j);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p = %x\n&quot;</span>, p);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&amp;ts = %p\n&quot;</span>, &amp;ts);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）隐式类型转换：编译器主动进行的类型转换</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int main()<br>&#123;<br>    char c <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>    <br>    short s <span class="hljs-operator">=</span> c<span class="hljs-comment">;</span><br>    int i <span class="hljs-operator">=</span> s<span class="hljs-comment">;</span><br>    long l <span class="hljs-operator">=</span> i<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意：低到高是安全的，不会产生截断；高到低是不安全的，导致不正确的结果 （低指占用字节数少）</p><p>发生点：</p><p>-算术运算式中，低类型转换为高类型</p><p>当遇到char,short时，统一转换成int来进行运算，当遇到float时，统一当作double来运算</p><p>-赋值表达式中，表达式的值转换为左边变量的类型</p><p>-函数调用时，实参转换为形参的类型</p><p>-函数返回值，return表达式转换为返回值类型</p><p>例：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> main()<br>&#123;<br>    char c = <span class="hljs-string">&#x27;a&#x27;</span>;<br>    <br>    <span class="hljs-keyword">int</span> i = c;    <span class="hljs-regexp">//sa</span>fe<br><br>    unsigned <span class="hljs-keyword">int</span> j = <span class="hljs-number">0x11223344</span>;<br><br>    short s = j;    <span class="hljs-regexp">//unsa</span>fe<br><br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;c = %c\n&quot;</span>, c);<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;i = %c\n&quot;</span>, i);<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;j = %c\n&quot;</span>, j);<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;s = %c\n&quot;</span>, s);<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;sizeof(c + s) = %d\n&quot;</span>, sieof(c + s));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>7.变量的属性</p><p>在定义变量的时候可以加上”属性”关键字，其将指明变量的特有意思</p><p>（1）语法：</p><p>property type var_name;</p><p>例：auto char i;    register int i;</p><p>（2）auto关键字</p><p>auto即C语言中局部变量的默认属性；</p><p>auto表明将被修饰的变量存储于栈上；</p><p>编译器默认所有的局部变量都是auto的；</p><p>（3）register关键字</p><p>寄存器变量的意义是请求编译器将这个变量存储于寄存器中，而不是内存中。寄存器个数是有限的，故不可能将程序中所有变量都声明为寄存器变量。所以在C语言中，register关键字只是请求，但不一定成功。</p><p>-register关键字指明将局部变量存储与寄存器中；</p><p>-register只是请求寄存器变量，但不一定成功；</p><p>-register变量的必须是CPU寄存器可以接受的值；</p><p>-不能用&amp;运算符获取register变量的地址；（取址运算符取的是内存的地址，寄存器的寻址方式跟内存不同，自然没有内存地址一说）</p><p>例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">register <span class="hljs-built_in">int</span> g_v;    <span class="hljs-comment">//error</span><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    register <span class="hljs-built_in">char</span> <span class="hljs-keyword">var</span>;<br>    print(<span class="hljs-string">&quot;0x%08X&quot;</span>, &amp;<span class="hljs-keyword">var</span>);    <span class="hljs-comment">//error</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>全局变量的生存周期是程序运行到程序结束，如果说全局变量占据了寄存器，代表从程序开始到结束都要占用这个寄存器，由于寄存器变量有限，长时间占用，会导致CPU无法正常工作。</p><p>（4）static关键字</p><p>static关键字指明变量的“静态属性”</p><p>- static修饰的局部变量存储在程序静态区。（从栈上挪到静态数据区，生命周期和全局变量相同，只是作用域是局部的）</p><p>static关键字同时具有“作用域限定符”的意义；</p><p>- static修饰的全局变量作用域只是声明的文件中；</p><p>- static修饰的函数作用域只是声明的文件中；</p><p>例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> g_v;                <span class="hljs-comment">//全局变量，程序的任意地方均能访问</span><br><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> g_vs;        <span class="hljs-comment">//静态全局变量，只有当前文件中可以访问</span><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-keyword">var</span>;            <span class="hljs-comment">//局部变量，在栈上分配空间</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> svar;    <span class="hljs-comment">//静态局部变量，在静态数据区分配空间</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>例：auto,register,static对比分析</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;<br>    r++;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;<br>    r++;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-comment">//显示声明auto属性，i为栈变量</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;      <span class="hljs-comment">//局部变量k的存储区位于静态区，作用域位于main中</span><br>    <span class="hljs-keyword">register</span> <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;    <span class="hljs-comment">//向编译器申请将j存储于寄存器中</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;i);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;k);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;j);    <span class="hljs-comment">//error</span><br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">f1</span>());<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">f2</span>());<br>    &#125;<br>&#125;<br>编译结果：<br><span class="hljs-number">0xbfcf007c</span><br><span class="hljs-number">0x804a01c</span><br>它们本是相邻定义，但此处却发现地址所差甚远，因为它们一个存储在栈上，一个存储在存储区<br></code></pre></td></tr></table></figure><p>（5）extern关键字</p><p>extern用于声明“外部”定义的变量和函数：</p><p>- extern变量在文件的其他地方分配空间；</p><p>- extern函数在文件的其他地方定义；</p><p>（告诉编译器这个变量是存在的）</p><p>extern用于“告诉”编译器用C方式编译：</p><p>       C++编译器和一些变种C编译器默认会按“自己”的方式编译函数和变量，通过extern关键字可以命令编译器“以标准C方式进行编译”。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, g_i);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> g_i;    <br>编译结果：报错与全局变量定义无关，故全局变量可以定义在任意位置<br>错误原因：全局变量有效范围从定义处开始到源程序结束，在第三行时g_i还未定义<br></code></pre></td></tr></table></figure><p>例2：我们怎么在main中调用定义在main函数下方的全局变量？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> g_i;    <span class="hljs-comment">//告诉程序我们定义了一个g_i，它是在其他地方定义的，可以放心使用</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, g_i);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> g_i;<br>编译通过！<br></code></pre></td></tr></table></figure><p>例3：在其他文件中定义全局变量g_i</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* test.c */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> g_i;    <span class="hljs-comment">//告诉程序我们定义了一个g_i，它是在其他地方定义的，可以放心使用</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, g_i);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* g.c */</span><br><span class="hljs-type">int</span> g_i;<br>编译通过<br><br><span class="hljs-comment">/* g.c */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> g_i;    <span class="hljs-comment">//static修饰的全局变量作用域只是声明的文件中</span><br>编译错误<br></code></pre></td></tr></table></figure><p>例4：调用其他文件中定义的函数</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">/* test.c */</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getI</span>()</span>;    <br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    printf(<span class="hljs-string">&quot;%d\n&quot;</span>, getI());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* g.c */</span><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">getI</span>()</span><br>&#123;<br>    <span class="hljs-keyword">return</span> g_i;<br>&#125;<br></code></pre></td></tr></table></figure><p>（二）C语言的基本语句</p><p>1.部分格式说明符</p><p>%c：一个字符</p><p>%d：有符号十进制整数</p><p>%u：无符号十进制整数</p><p>%o：八进制整数</p><p>%x(%X)：十六进制整数0f(0F)</p><p>%p：以十六进制整数方式输出指针的值，附加前缀0x</p><p>2.整数格式说明符的应用</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">PAGES=<span class="hljs-number">732</span>;<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;*%d*\n&quot;</span>,PAGES);          <span class="hljs-regexp">//</span>*<span class="hljs-number">732</span>*<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;*%2d*\n&quot;</span>,PAGES);         <span class="hljs-regexp">//</span>*<span class="hljs-number">732</span>*<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;*%10d*\n&quot;</span>,PAGES);        <span class="hljs-regexp">//</span>*       <span class="hljs-number">732</span>* <br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;*%-10d*\n&quot;</span>,PAGES);       <span class="hljs-regexp">//</span>*<span class="hljs-number">732</span>       *<br></code></pre></td></tr></table></figure><p>例：printf(“0x%08X\n”, *p);</p><p>（三）选择与循环结构程序设计</p><p>1.运算符优先级</p><p>高到低：!（非）→算术运算符→关系运算符（&#x3D;&#x3D;与!&#x3D;优先级最低，其他优先级相同）→&amp;&amp;→||→赋值运算符</p><p>2.for循环</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(i=<span class="hljs-number">0</span>; i&lt;n; i++)</span></span>    <span class="hljs-comment">//n次</span><br><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(i=<span class="hljs-number">1</span>; i&lt;n; i++)</span></span>    <span class="hljs-comment">//n-1次</span><br><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(i=<span class="hljs-number">0</span>; i&lt;=n; i++)</span></span>    <span class="hljs-comment">//n+1次</span><br><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(i=x; i&lt;=n; i++)</span></span>    <span class="hljs-comment">//n-x+1次</span><br></code></pre></td></tr></table></figure><p>3.if语句中零值比较的注意点</p><p>（1）bool型变量直接出现于条件中，不要进行比较</p><p>（2）变量和0值比较时，0值应该出现在比较符号左边（if(0 &#x3D;&#x3D; i)，为了避免写错成一个等于号，0在左边的时候若写错则可以直接找到错误位置）</p><p>（3）float型变量不能直接进行0值比较，需要定义精度</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-id">#define</span> EPSINON <span class="hljs-number">0.00000001</span><br><span class="hljs-attribute">float</span> f = <span class="hljs-number">0.0</span>;<br><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">((-EPSINON &lt;= f)</span></span> &amp;&amp;(f &lt;= EPSINON))<br>&#123;<br>    <span class="hljs-comment">//statement 1</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-comment">//statement 1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>4.switch语句</p><p>（1）case语句</p><p>①case语句中的值只能是整型或者字符型；（只能是常量）</p><p>②case语句分支必须有break，否则会导致分支重叠；</p><p>③case语句的排列顺序</p><p>-按字母或数字顺序排列</p><p>-正常情况放在前面，异常情况放在后面</p><p>（2）default语句</p><p>-必需加上，以处理特殊情况，且default后面也得加break；（为空也要加上）</p><p>-default语句只用于处理真正的默认情况，而非程序逻辑；（case无法处理时，default处理）</p><p>例：if和switch程序举例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs bash">void f1(int i)<br>&#123;<br>    <span class="hljs-keyword">if</span>( i &lt; 6 )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed!\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( (6 &lt;= i) &amp;&amp; (i &lt;= 8) )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Good!\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Perfect!\n&quot;</span>);<br>    &#125;<br>/*<br>    switch( i &lt; 6 )    //上面<span class="hljs-keyword">if</span>语句用switch写，括号里也可以是表达式<br>    &#123;<br>        <span class="hljs-keyword">case</span> 1:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed!\n&quot;</span>);<br>        default:<br>            switch( (6 &lt;= i) &amp;&amp; (i &lt;= 8) )        <br>            &#123;<br>                <span class="hljs-keyword">case</span> 1:<br>                  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Good!\n&quot;</span>);<br>                  <span class="hljs-built_in">break</span>;<br><br>                default:<br>                  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Perfect!\n&quot;</span>);<br>                  <span class="hljs-built_in">break</span>;<br>            &#125;<br>            <span class="hljs-built_in">break</span>;<br>    &#125;*/<br>&#125;<br><br>void f2(char i)<br>&#123;<br>    switch(i)<br>    &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Compile\n&quot;</span>);<br>            <span class="hljs-built_in">break</span>;   <br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Debug\n&quot;</span>);<br>            <span class="hljs-built_in">break</span>;   <br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;o&#x27;</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Object\n&quot;</span>);<br>            <span class="hljs-built_in">break</span>;   <br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;r&#x27;</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Run\n&quot;</span>);<br>            <span class="hljs-built_in">break</span>;   <br>         default:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;unknown\n&quot;</span>);<br>            <span class="hljs-built_in">break</span>;   <br>    &#125;<br>/*<br>    <span class="hljs-keyword">if</span>( <span class="hljs-string">&#x27;c&#x27;</span> == i )    //上面switch语句用<span class="hljs-keyword">if</span>写，常量写在左边也是为了防止出错<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Compile\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( <span class="hljs-string">&#x27;d&#x27;</span> == i )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Debug\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( <span class="hljs-string">&#x27;o&#x27;</span> == i )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Object\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( <span class="hljs-string">&#x27;r&#x27;</span> == i )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Run\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;unknown\n&quot;</span>);<br>    &#125;  */  <br>&#125;<br><br>int <span class="hljs-function"><span class="hljs-title">main</span></span>()<br>&#123;<br>    f1(5);<br>    f1(9);<br>    f1(7);<br><br>    f2(<span class="hljs-string">&#x27;o&#x27;</span>);<br>    f2(<span class="hljs-string">&#x27;d&#x27;</span>);<br>    f2(<span class="hljs-string">&#x27;e&#x27;</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span>语句和switch语句从功能上可以互相替代，C语言在设计的时候提供了<span class="hljs-keyword">if</span>和switch两种分支语句，就是希望我们有选择地去判断使用何种语句<br></code></pre></td></tr></table></figure><p>5.if和switch语句区别</p><p>（1）if语句适用于复杂逻辑进行判断的情形；</p><p>（2）switch语句适用于对离散值进行判断的情形中；</p><p>（3）if语句和switch语句在功能上可以进行互换；</p><p>（4）if语句对于“按片”分支判断的情形更加简洁；（一个范围）</p><p>（5）switch语句对于单值多分支的情形；</p><p>6.循环语句do,while，for的区别</p><p>-do先执行，后判断；</p><p>-while先判断，后执行；适用于循环次数不定的场合</p><p>-for先判断，后执行，比while更简洁；适用于循环次数固定的场合，比如累加</p><p>7.break和continue的区别</p><p>-break表示终止循环的执行</p><p>-continue表示终止本次循环，进入下次循环</p><p>例：do和break的妙用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;malloc.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> *p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * n)<br><br>    <span class="hljs-keyword">do</span> <br>    &#123;<br>        <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == p ) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>( n &lt; <span class="hljs-number">5</span> ) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>( n &gt; <span class="hljs-number">100</span> ) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>        &#123;<br>            p[i] = i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, p[i]);<br>        &#125;<br>        ret = <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">while</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">free</span>(p);    <span class="hljs-comment">//free函数也可以释放空指针，但实际上它什么也不执行</span><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( <span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>) )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OK&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（四）数组</p><p>1.数组初始化</p><p>int a[]&#x3D;{1,2,3,4,5};    int b[10]&#x3D;{0};</p><p>2.字符数组</p><p>C语言中没有专门的字符串变量，通常用一个字符数组来存放一个字符串。</p><p>（1）初始化：逐个给数组中各元素赋初值&#x2F;用字符串直接给字符数组赋初值</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">char</span> parr[] = <span class="hljs-string">&quot;zifuchuanshuzu&quot;</span>;    <span class="hljs-comment">//sizeof(parr) == 15</span><br><span class="hljs-type">char</span> charr[] = &#123; <span class="hljs-string">&#x27;z&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;z&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span> &#125;;    <span class="hljs-comment">//sizeof(charr) == 14</span><br></code></pre></td></tr></table></figure><p>字符串方式赋初值比逐个赋值多占一个字节，用来存放字符串结束标志\0</p><p>（2）输入与输入：</p><p>输入：scanf%s输入时字符串结束标志为空格；gets()输入时字符串结束标志为回车</p><p>输出：puts()只能输出字符串, 不能输出数值或进行格式变换。且识别到\0才停止输出，输出后会自动输出一个回车符</p><p>（可以将字符串直接写入puts()函数中。如:puts(“Hello, world！”);</p><p>（3）字符串处理函数（以下字符串指字符串常量或已赋值的字符数组名）</p><p>strlen(字符串)：测量指定字符串的长度（字符串结束标志前的所有字符的个数）</p><p>返回值：字符串的长度</p><p>strcat(字符数组名1,字符数组名2)：取消1的\0标志，将2连接到1后</p><p>返回值：字符数组1的首地址</p><p>strcpy(字符数组名,字符串)：将字符串存入到字符数组</p><p>返回值：字符数组的首地址</p><p>strcmp(字符串1,字符串2)：按ASCII码的顺序比较两个字符串，并由函数返回值返回比较结果</p><p>返回值：1&lt;2    返回小于0的整数</p><p>   1&#x3D;2    返回0</p><p>   1&gt;2    返回大于0的整数 </p><p>strupr(字符串)：将字符串中的所有小写字母转换成大写字母</p><p>返回值：替换后字符串的首地址</p><p>strlwr(字符串)：将字符串中的所有大写字母转换成小写字母</p><p>返回值：替换后字符串的首地址</p><p>（五）函数与编译预处理</p><p>1.全局变量</p><p>在程序的执行过程中始终都占用存储单元，建议不必要时不要用（如果用，尽可能地加上const）；</p><p>在同一个源文件中，全局变量与局部变量同名，则在局部变量的作用范围内，全局变量被屏蔽</p><p>2.变量的存储方式</p><p>（1）静态存储方式和动态存储方式</p><p>静态：在程序运行期间分配固定的存储空间的方式</p><p>动态：在程序运行期间根据需要进行动态地分配，使用完毕后立即释放</p><p>（2）自动变量：函数中的局部变量，如不专门声明为static存储类别，都是动态地分配存储空间的</p><p>（不赋初值的话，其值时不确定的）</p><p>（3）静态局部变量static：在结束函数调用时依然存在，每次调用函数时不用重新赋值而是保留上次函数调用结束时的值</p><p>（不赋初值的话，编译时默认自动赋值0或空字符）</p><p>（4）寄存器变量register：前面都是内存变量，都是由编译程序在内存中分配单元。而寄存器变量使用CPU中的寄存器存放数据，存取速度大于内存变量，但寄存器变量是无法取地址的。</p><p>（寄存器数目有限，C语言中设定个数以2个为宜，超出的当成自动变量处理）</p><p>（5）外部变量：在函数外部定义的全局变量。</p><p>外部变量的作用域是从变量的定义处开始，到本程序文件的结尾。在此作用域内，全局变量可为各个函数所引用。编译时将外部变量分配在静态存储区。</p><p>①extern用来声明一个变量（或函数），并指出它具有外部链接（它的名字在其他文件里是可见的，若使外部变量不可被其它文件看到则使用static），被extern修饰的变量在程序开始运行时被分配内存（静态存储区），程序运行结束才被回收。</p><p>②使用extern来引用函数：如在main.c中extern int fun (int num)，相比较包含头文件要简洁的多，也会加速程序预处理时间</p><p>③extern修饰符可用于指示C或者C＋＋函数的调用规范：比如在C＋＋中调用C库函数，就需要在C＋＋程序中用extern “C”声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同。</p><p>3.变量的存储位置<a href="https://www.cnblogs.com/yasmi/articles/4933842.html">https://www.cnblogs.com/yasmi/articles/4933842.html</a></p><p>（1）凡是在任何代码块之外声明的变量总是存储在静态内存中。不属于堆栈内存，这类变量称为静态变量。静态变量在函数运行之前创建。</p><p>（2）在代码块内部声明的变量的缺省存储类型是自动的，存储在堆栈中。</p><p>（3）对于在代码块内部声明的变量，如果给它加上 static 关键字，可以使它的存储类型由自动转变为静态。具有静态存储类型的变量在整个执行过程中一直存在。而不仅仅是它所在的代码块执行的时候存在。</p><p>（六）指针</p><p>1.定义</p><p>指针也是变量，不过它存储的是另外一个内存地址</p><p>unsigned int *ptr1;    &#x2F;&#x2F;ptr1是一个指向整型变量的指针变量，而它的值是某个整型变量的地址</p><p>                                  &#x2F;&#x2F;指针变量的值是地址，所以默认是无符号整型</p><p>（指向容易让人混淆，可以理解成将变量的地址赋值给了指针变量）</p><p>2.初始化：将一个地址或同类型(或相兼容的类型)的指针赋给它，而不管这个地址是怎么取得的</p><p>（1）采用NULL或空指针常量，如：int *p &#x3D; NULL;或 char *p &#x3D; 2-2; 或float *p &#x3D; 0;</p><p>（2）取一个对象的地址然后赋给一个指针，如：int i &#x3D; 3;  int *ip &#x3D; &amp;i；</p><p>（3）将一个指针常量（地址）赋给一个指针，如：long *p &#x3D; (long *)0xfffffff0;</p><p>（4）将一个T类型数组的名字赋给一个相同类型的指针，如：char array[100]; char *cp &#x3D; ary;</p><p>（5）将一个指针的地址赋给一个指针，如：int i &#x3D; 3;  int *ip &#x3D; &amp;i；int **pp &#x3D; &amp;ip;</p><p>（6）将一个字符串常量赋给一个字符指针，如：char *cp &#x3D; “abcdefg”;</p><p>（int *p;    *p&#x3D;7    &#x2F;&#x2F;编译无问题，但运行显示Segmentation fault (core dumped)，因为将7赋值给p指向的地址，而p并没有初始化，所以p指向的内存位置是随机的，无法赋值）</p><p>提示使用了未初始化的变量p，这里并不是使p指向7的地址，而是。）</p><p>（int* p&#x3D;1;    &#x2F;&#x2F;编译器弹出警告，告诉我们初始化来自于一个整数而不是一个地址，）</p><p>3.指针与一维数组</p><p>int *ptr &#x3D; a;</p><p>若ptr指向了一维数组a,则：数组元素a[i] &#x3D; *(a+i) &#x3D; *(ptr+i) &#x3D; ptr[i]</p><p>4.指针与多维数组</p><p>int a[3][4] &#x3D; {0};</p><p>int (*ptr)[4] &#x3D; a;</p><p>若ptr指向了二维数组a,则：a[i][j] &#x3D; *(a[i]+j) &#x3D; *(*(a+i)+j) &#x3D; (*(a+i))[j]</p><p>5.指针与函数</p><p>（1）指针作为函数的参数</p><p>使用指针类型做函数的参数，实际向函数传递的是变量的地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *pa,<span class="hljs-type">int</span> *pb)</span>    <span class="hljs-comment">//函数的形参是指针，其实际值就是地址</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a1=<span class="hljs-number">3</span>,b1=<span class="hljs-number">5</span>;<br>    <span class="hljs-type">int</span> a2=<span class="hljs-number">3</span>,b2=<span class="hljs-number">5</span>;<br>    <span class="hljs-type">int</span> *p1=&amp;a2,*p2=&amp;b2;<br>    <span class="hljs-type">int</span> a3=<span class="hljs-number">3</span>,b3=<span class="hljs-number">5</span>;<br>    <span class="hljs-built_in">swap</span>(&amp;a1,&amp;b1);    <span class="hljs-comment">//我们可以直接取变量的地址传递给函数</span><br>    <span class="hljs-built_in">swap</span>(p1,p2);    <span class="hljs-comment">//也可以使用指针指向需要传递地址的变量，然后将指针作为实参传递，因为指针实际值就是地址</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）指向函数的指针</p><p>int (*pf)() &#x3D; 函数名;</p><p>（3）指针型函数</p><p>int *pfun(int x, int y){}</p><p>返回值为一个指针，类型说明符说明返回的指针值指向的数据类型</p><p>例：[ ] </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">void fnSum(int x);<br>void (*pfnSum)(int x);<br><br>int main()<br>&#123;<br>    pfnSum = &amp;fnSum;    <span class="hljs-regexp">//</span>把两者关系当作简单的指针关系<br><span class="hljs-regexp">//</span>    pfnSum = fnSum;    <span class="hljs-regexp">//</span>直接指向<br><br>    fnSum(<span class="hljs-number">10</span>);    <span class="hljs-regexp">//</span>直接调用<br>    pfnSum(<span class="hljs-number">10</span>);    <span class="hljs-regexp">//</span>直接调用<br>    (*pfnSum)(<span class="hljs-number">10</span>);    <span class="hljs-regexp">//</span>通过函数指针变量调用fnSum<br>    (*fnSum)(<span class="hljs-number">10</span>);    <span class="hljs-regexp">//</span>函数名也可以使用这种调用模式<br>&#125;<br></code></pre></td></tr></table></figure><p>结论：</p><p>-fnSum的函数名与pfnSum函数指针都是一样的，即都是函数指针。fnSum函数名是一个函数指针常量，而pfnSum是一个函数指针变量</p><p>-函数名调用如果都得如(*fnSum)(10)这样，那书写与读起来都是不方便和不习惯的。所以C语言的设计者们才会设计成又可允许(*fnSum)(10)这种形式地调用</p><p>-为统一起见，pfnSum函数指针变量也可以FunP（10）的形式来调用</p><p>-赋值时 ，即可pfnSum&#x3D;&amp;fnSum形式，也可pfnSum&#x3D;fnSum</p><p>6.指针与字符串</p><p>（1）字符串指针变量</p><p>char *str &#x3D; “C language”;</p><p>char a[20];    *str &#x3D; a;</p><p>（2）字符指针作为函数参数</p><p>（3）指针数组与命令行参数</p><p>int main(int argc, char *argv[])：Ｃ语言规定main函数的参数只能有两个， 习惯上这两个参数写为argc和argv，其中，argc的值是在输入命令行时由系统按实际参数的个数自动赋予；而argv参数是字符串指针数组，其各元素值为命令行中各字符串(参数均按字符串处理)的首地址,指针数组的长度即为参数个数。</p><p>但main函数不能被其他函数调用，所以如果我们想给这两个形参赋值，需要运行一个此程序的可执行文件时，在DOS提示符下键入文件名，再输入实际参数即可把这些实参传送到main的形参中去。</p><p>DOS提示符下命令行的一般形式为： C:\&gt;可执行文件名 参数 参数……;如：C:\&gt;a:e24 BASIC dBASE FORTRAN，这里argc值为4（文件名a:e24本身也算一个参数）。</p><p>（七）结构体与共用体</p><p>1.结构体的定义方式</p><p>（1）最常用定义方式：定义结构体data，此时结构体相当于一个类型，比如int，如需使用此结构体，方法同int</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">data</span><br>&#123;<br>    <span class="hljs-type">char</span> aa;<br>    <span class="hljs-type">char</span> bb;<br>    <span class="hljs-type">char</span> cc;<br>    <span class="hljs-type">int</span> dd;<br>&#125;;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">data</span> sum1, sum2;<br></code></pre></td></tr></table></figure><p>（2）定义结构体data同时，定义需要使用的结构体变量sum1，sum2。如后面再需要定义结构体变量，方法同1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">data</span><br>&#123;<br>    <span class="hljs-type">char</span> aa;<br>    <span class="hljs-type">char</span> bb;<br>    <span class="hljs-type">char</span> cc;<br>    <span class="hljs-type">int</span> dd;<br>&#125;sum1, sum2;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">data</span> sum3;<br></code></pre></td></tr></table></figure><p>（3）定义结构体时，结构体名称缺省，同时定义结构体变量sum1，sum2。但后面不可再定义结构体变量！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span><br>&#123;<br>    <span class="hljs-type">char</span> aa;<br>    <span class="hljs-type">char</span> bb;<br>    <span class="hljs-type">char</span> cc;<br>    <span class="hljs-type">int</span> dd;<br>&#125;sum1, sum2;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sum3</span>;  &lt;-  编译器报错<br></code></pre></td></tr></table></figure><p>（4）使用typedef 定义结构体，定义结构体data时，使用typedef，此种形式几乎不使用，再定义结构体变量时，仍需加struct，否则编译器报错！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">data</span><br>&#123;<br>    <span class="hljs-type">char</span> aa;<br>    <span class="hljs-type">char</span> bb;<br>    <span class="hljs-type">char</span> cc;<br>    <span class="hljs-type">int</span> dd;<br>&#125;;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">data</span> sum3;<br></code></pre></td></tr></table></figure><p>（5）使用typedef定义结构体同时，给data结构体别名DATA，后续定义可不用使用struct data，直接使用DATA即可。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs fortran">typedef struct <span class="hljs-keyword">data</span><br>&#123;<br>    <span class="hljs-built_in">char</span> aa;<br>    <span class="hljs-built_in">char</span> bb;<br>    <span class="hljs-built_in">char</span> cc;<br>    <span class="hljs-built_in">int</span> dd;<br>&#125;<span class="hljs-keyword">DATA</span>;<br>    struct <span class="hljs-keyword">data</span> sum3; &lt;- 可用，但不推荐<br>    <span class="hljs-keyword">DATA</span> sum1; &lt;- 最常用方式<br></code></pre></td></tr></table></figure><p>（6）使用typedef定义结构体时，省掉结构体第一个别名data，直接在后面加DATA，使用方法同5。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    <span class="hljs-type">char</span> aa;<br>    <span class="hljs-type">char</span> bb;<br>    <span class="hljs-type">char</span> cc;<br>    <span class="hljs-type">int</span> dd;<br>&#125;DATA;<br>    DATA sum3<br></code></pre></td></tr></table></figure><p>2.结构体内存对齐</p><p>（1）结构体的第一个数据成员在偏移量为0的地址处。</p><p>（2）结构体变量的起始地址能够被其最宽的成员大小整除</p><p>（3）结构体每个成员相对于起始地址的偏移能够被其自身大小整除，如果不能则在前一个成员后面补充字节</p><p>（4）结构体总体大小能够被最宽的成员的大小整除，如不能则在后面补充字节</p><p>（5）若结构体里没有成员变量：不占用任何内存，sizeof()为0（gcc编译器）；编译出错（vc10.0编译器，bcc编译器）</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">    struct s1<br>    &#123;<br>        <span class="hljs-type">double</span> a;<br>        <span class="hljs-type">char</span> b;<br>        <span class="hljs-type">int</span> c;<br>    &#125;;<br>    printf(&quot;%d\n&quot;, sizeof(struct s1));<br><br>数据成员对齐数 = min( 编译器默认对齐数，该数据类型大小 )<br><span class="hljs-number">1.</span> <span class="hljs-type">double</span> a; // 地址从<span class="hljs-number">0</span>开始，前<span class="hljs-number">8</span>个字节存的是<span class="hljs-type">double</span><br><span class="hljs-number">2.</span> <span class="hljs-type">char</span> b; // min(<span class="hljs-number">8</span> ，<span class="hljs-number">1</span>) = <span class="hljs-number">1</span> ，此时下标是<span class="hljs-number">8</span>，<span class="hljs-number">8</span>是<span class="hljs-number">1</span>的整数倍，第<span class="hljs-number">9</span>个字节存的是<span class="hljs-type">char</span><br><span class="hljs-number">3.</span> <span class="hljs-type">int</span> c; // min(<span class="hljs-number">8</span>，<span class="hljs-number">4</span>) = <span class="hljs-number">4</span> ，此时下标是<span class="hljs-number">9</span>，<span class="hljs-number">9</span>不是<span class="hljs-number">4</span>的整数倍，补<span class="hljs-number">3</span>个字节，此时下标是<span class="hljs-number">12</span>，存入<span class="hljs-type">int</span><br><span class="hljs-number">4.</span>共存了<span class="hljs-number">8</span>+<span class="hljs-number">4</span>+<span class="hljs-number">4</span>=<span class="hljs-number">16</span>个字节，整体对齐系数 = min(<span class="hljs-number">8</span>，max( <span class="hljs-type">double</span>, <span class="hljs-type">char</span>, <span class="hljs-type">int</span> )) = <span class="hljs-number">8</span>，<span class="hljs-number">16</span>是<span class="hljs-number">8</span>的整数倍，不用补空字节，分析完成。<br>综上所述，该结构体占有<span class="hljs-number">16</span>个字节。<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">    struct s2<br>    &#123;<br>        <span class="hljs-type">char</span> a;<br>        struct s1 s11;<br>        <span class="hljs-type">double</span> b;<br>    &#125;;<br>    printf(&quot;%d\n&quot;, sizeof(struct s2));<br><br>数据成员对齐数 = min( 编译器默认对齐数，该数据类型大小 )<br><span class="hljs-number">1.</span> <span class="hljs-type">char</span> a; // 地址从<span class="hljs-number">0</span>开始，第一个字节存的是<span class="hljs-type">char</span><br><span class="hljs-number">2.</span> struct s1 s11; // min( <span class="hljs-number">8</span> ，max(<span class="hljs-type">double</span>,<span class="hljs-type">char</span>,<span class="hljs-type">int</span>)) = <span class="hljs-number">8</span> ，此时下标是<span class="hljs-number">1</span>，<span class="hljs-number">1</span>不是<span class="hljs-number">8</span>的整数倍，补<span class="hljs-number">7</span>个空字节，再存入s11（<span class="hljs-number">16</span>个字节）<br><span class="hljs-number">3.</span> <span class="hljs-type">double</span> b; // min(<span class="hljs-number">8</span>，<span class="hljs-number">8</span>) = <span class="hljs-number">8</span> ，此时下标是<span class="hljs-number">24</span>，<span class="hljs-number">24</span>是<span class="hljs-number">8</span>的整数倍，再存入<span class="hljs-type">double</span><br><span class="hljs-number">4.</span> 共存了<span class="hljs-number">1</span>+<span class="hljs-number">7</span>+<span class="hljs-number">16</span>+<span class="hljs-number">8</span>=<span class="hljs-number">32</span>个字节，整体对齐数 = min( <span class="hljs-number">8</span>，max( <span class="hljs-type">char</span>, struct s1, <span class="hljs-type">double</span> )) = <span class="hljs-number">8</span>，<span class="hljs-number">32</span>是<span class="hljs-number">8</span>的整数倍，不用补空字节，分析完成。<br>综上所述，该结构体占有<span class="hljs-number">32</span>个字节。<br></code></pre></td></tr></table></figure><p>3.结构体的成员引用</p><p>（1）一般情况下用“.”，只需要声明一个结构体。格式是，结构体类型名+结构体名。然后用结构体名加“.”加域名就可以引用域 了。因为自动分配了结构体的内存。如同 int a;一样。</p><p>（2）用“-&gt;”，则要声明一个结构体的指针，还要手动开辟一个该结构体的内存，然后把返回的指针给声明的结构体指针，才能用“-&gt;”正确引用。否则内存中只分配了指针的内存，没有分配结构体的内存，导致想要的结构体实际上是不存在。这时候用“-&gt;”引用自然出错了，因为没有结构体，自然没有结构体的域了。</p><p>4.结构体与柔性数组</p><p>-柔性数组即数组大小待定的数组。</p><p>-C语言中可以由结构体产生柔性数组；</p><p>-C语言结构体的最后一个元素可以是大小未知的数组，且柔性数组成员前面必须至少一个其它成员</p><p>-柔性数组成员只作为一个符号地址存在，sizeof返回的这种结构大小不包括柔性数组的内存</p><p>-包含柔性数组成员的结构用malloc()函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">struct</span> SoftArray<br>&#123;<br>    <span class="hljs-built_in">int</span> len;<br>    <span class="hljs-built_in">int</span> array[];<br>&#125;<br><span class="hljs-keyword">sizeof</span>( <span class="hljs-keyword">struct</span> SoftArray ) = <span class="hljs-number">4</span>    <span class="hljs-comment">//结构体中的柔性数组仅是一个待使用的标识符，不占用存储空间</span><br></code></pre></td></tr></table></figure><p>柔性数组的用法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">struct</span> SoftArray<br>&#123;<br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-type">int</span> array[];<br>&#125;<br><br><span class="hljs-keyword">struct</span> SoftArray* sa = <span class="hljs-literal">NULL</span>;<br>sa = (<span class="hljs-keyword">struct</span> SoftArray*)malloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> SoftArray) + <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">5</span>);<br>sa-&gt;len = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>r柔性数组的使用分析</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;malloc.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SoftArray</span><br>&#123;<br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-type">int</span> array[];<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SoftArray</span>* <span class="hljs-built_in">create_soft_array</span>(<span class="hljs-type">int</span> size)<br>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SoftArray</span>* ret = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span>(size &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        ret = (<span class="hljs-keyword">struct</span> SoftArray*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> SoftArray) + <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * size);<br>        ret-&gt;len = size;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">delete_soft_array</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> SoftArray* sa)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">free</span>(sa);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> SoftArray* sa)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> != sa)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;sa-&gt;len; i++)<br>        &#123;<br>            sa-&gt;array[i] = i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SoftArray</span>* sa = <span class="hljs-built_in">create_soft_array</span>(<span class="hljs-number">10</span>);<br><br>    <span class="hljs-built_in">func</span>(sa);<br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;sa-&gt;len; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, sa-&gt;array[i]);<br>    &#125;<br><br>    <span class="hljs-built_in">delete_soft_array</span>(sa);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><p>5.共用体</p><p>（1）概念</p><p>当需要把不同类型的变量存放到同一段内存单元或对同一段内存单元的数据按不同类型处理时，需要使用共用体数据结构。</p><p>（2）定义：在语法上与struct相似</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">union</span> 共用体名<br>&#123;<br>    类型说明符 成员项<span class="hljs-number">1</span>；<br>    ...<br>&#125;变量列表；<br></code></pre></td></tr></table></figure><p>（3）特点</p><p>①共用体各成员占相同的起始地址所占内存长度等于最长的成员所占内存</p><p>②只能引用共用体变量的成员，不能整体引用共用体变量</p><p>③共用体变量中起作用的成员是最后一次存放的成员</p><p>④可以对共用体变量初始化，但初始化表中只能有一个常量，即只能初始化一个成员</p><p>（4）注意事项</p><p>-union的使用受系统大小端影响</p><p>地址的高地位：有一段连续的地址：0x00、0x01、0x02、0x03，很简单，值小的就低，大的就高，那就是0x00是低地址，往右递增。</p><p>小端模式：数据的低字节存放到内存的低地址中，高字节存到高地址中。并且小端模式下优先将数据填充到内存的低地址中。（适合计算机理解）</p><p>   地址：0x00 | 0x01 | 0x02 | 0x03       内存地址从左到右由低到高</p><p>   数据：0x78 | 0x56 | 0x34 | 0x12       数据字节从左到右由低到高</p><p>大端模式：数据的低字节存放到内存的高地址中，高字节存到低地址中，且数据优先填充到高地址上。（适合人类理解）</p><p>   地址：0x00 | 0x01 | 0x02 | 0x03       内存地址从左到右由低到高</p><p>   数据：0x12 | 0x34 | 0x56 | 0x78       数据字节从左到右由高到低</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs llvm">union <span class="hljs-keyword">c</span><br>&#123;<br>    int i<span class="hljs-comment">;</span><br>    char <span class="hljs-keyword">c</span><span class="hljs-comment">;    //不管是大端还是小端，都是从低地址取数据</span><br>&#125;<span class="hljs-comment">;</span><br><span class="hljs-comment"></span><br>union C <span class="hljs-keyword">c</span><span class="hljs-comment">;</span><br><span class="hljs-comment"></span><br><span class="hljs-keyword">c</span>.i <span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-comment">;</span><br><span class="hljs-comment"></span><br>printf(<span class="hljs-string">&quot;%d\n&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">c</span>.<span class="hljs-keyword">c</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>例：编程判断系统大小端</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">system_mode</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">union</span> <span class="hljs-title class_">SM</span><br>    &#123;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-type">char</span> c;<br>    &#125;;  <br><br>    <span class="hljs-keyword">union</span> <span class="hljs-title class_">SM</span> sm;<br><br>    sm.i = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">return</span> sm.c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;System mode:%d\n&quot;</span>,<span class="hljs-built_in">system_mode</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用联合体的时候要注意系统大小端</p><p>6.枚举</p><p>（1）概念</p><p>enum是C语言中的一种自定义类型，一个被命名的整型常数的集合,</p><p>（2）定义</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs prolog">enum 枚举名&#123;<br>    标识符[=整型常数],<br>    标识符[=整型常数],<br>    ...<br>    标识符[=整型常数],<br>    &#125; 枚举变量;<br>如果枚举没有初始化, 则从第一个标识符开始, 顺次赋给标识符<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, ...（即默认值依次为<span class="hljs-number">0</span>，<span class="hljs-number">1</span>，<span class="hljs-number">2.</span>...）。<br>但当枚举中的某个成员赋值后, 其后的成员若无赋值则按依次加<span class="hljs-number">1</span>的规则确定其值。<br></code></pre></td></tr></table></figure><p>（3）特点</p><p>①枚举就是给这些常量值，规定一个名字（和define很像）</p><p>②枚举量可以直接作为值使用 </p><p>③枚举类型可以直接作为类型使用</p><p>用这个关键字来一次定义许多标记整型常量，其实它相当于定义一个整型常量的表，方便应用时查找</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">enum</span>                    <span class="hljs-comment">//无名枚举，用于定义常量</span><br>&#123;<br>    ARRAY_SIZE = <span class="hljs-number">10</span>;    <span class="hljs-comment">//定义数组大小</span><br>&#125;;<br><br><span class="hljs-built_in">int</span> <span class="hljs-built_in">array</span>[ARRAY_SIZE] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;ARRAY_SIZE; i++)<br>&#123;<br>    <span class="hljs-built_in">array</span>[i] = i + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>例：enum的用法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-keyword">enum</span>                    <br>&#123;<br>    ARRAY_SIZE = <span class="hljs-number">10</span>;            <span class="hljs-comment">//枚举用法1：定义常量</span><br>&#125;;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span><br>&#123;<br>    RED   = <span class="hljs-number">0x00FF0000</span>;        <span class="hljs-comment">//枚举用法2：定义离散的整形值内容</span><br>    GREEN = <span class="hljs-number">0x0000FF00</span>;<br>    BLUE  = <span class="hljs-number">0x000000FF</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintColor</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> Color c)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">switch</span>(c)<br>    &#123;<br>        <span class="hljs-keyword">case</span> RED:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Color:RED (0x%08X)\n&quot;</span>, c);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> GREEN:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Color:GREEN (0x%08X)\n&quot;</span>, c);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> BLUE:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Color:BLUE (0x%08X)\n&quot;</span>, c);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitArray</span><span class="hljs-params">(<span class="hljs-type">int</span> array[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;ARRAY_SIZE; i++)<br>    &#123;<br>        array[i] = i + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintArray</span><span class="hljs-params">(<span class="hljs-type">int</span> array[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;ARRAY_SIZE; i++)<br>    &#123;<br>        <span class="hljs-built_in">pritf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, array[i]);<br>    &#125;    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> c = GREEN;<br><br>    <span class="hljs-type">int</span> array[ARRAY_SIZE] = &#123;<span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-built_in">PrintArray</span>(c);<br><br>    <span class="hljs-built_in">InitArray</span>(array);<br><br>    <span class="hljs-built_in">PrintColor</span>(array);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）枚举和宏定义</p><p>枚举和宏其实非常类似：宏在预处理阶段将名字替换成对应的值，枚举在编译阶段将名字替换成对应的值。我们可以将枚举理解为编译阶段的宏。</p><p>使用宏定义看起来代码会比较松散，使用枚举时的代码更简洁紧凑。</p><p>（5）enum和const</p><p>const定义的不是真正意义上的常量，它定义的仅仅是一个只读变量</p><p>enum定义的是真正意义上的常量</p><p>（八）位运算</p><p><a href="evernote:///view/18988257/s16/6762374f-ef73-42c2-acd3-afe19171e528/6762374f-ef73-42c2-acd3-afe19171e528/">第008课_第1个ARM裸板程序及引申(部分免费)</a>006节</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>const</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/const/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/const/</url>
    
    <content type="html"><![CDATA[<p> 一、概念</p><p>const不能定义真正意义上的常量，const定义的只是一个只读变量，告诉编译器变量不能出现在赋值符号的左边，本质还是变量。</p><p>二、用法</p><p>2.1 修饰常变量</p><p>（1）用于定义常变量时，需要初始化。</p><p>（2）数据类型对于const而言是透明的</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;   等价于 <span class="hljs-built_in">int</span> <span class="hljs-keyword">const</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> *p1 = &amp;a; 等价于 <span class="hljs-built_in">int</span> <span class="hljs-keyword">const</span> *p1 = &amp;a;   但不等价于<span class="hljs-built_in">int</span> *<span class="hljs-keyword">const</span> p1=&amp;a;<br></code></pre></td></tr></table></figure><p>（3）const用于封锁直接修饰的内容，使该内容变为只读，在程序中不能作为左值（左值：放在赋值号‘&#x3D;’的左边，使用变量的写权限）</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const int a <span class="hljs-operator">=</span> <span class="hljs-number">10</span><span class="hljs-comment">;    //const封锁a</span><br><br><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span><span class="hljs-comment">;             //a作为左值，使用a的写权限，非法</span><br>int b <span class="hljs-operator">=</span> a<span class="hljs-comment">;           //使用a的读权限，合法</span><br></code></pre></td></tr></table></figure><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs smali">int<span class="hljs-built_in"> const </span>*p1 = &amp;a;<span class="hljs-built_in"></span><br><span class="hljs-built_in">const </span>int *p1 = &amp;a;     //const修饰*p1，将*p1作为左值非法，将p1作为左值合法<br><br>p1 = &amp;b;                //使用p1做左值，合法<br>*p1 = 200；             //使用*p1做左值，非法<br></code></pre></td></tr></table></figure><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smali">int *const p2 = &amp;a;     //const修饰p2,将p2作为左值非法，将*p2作为左值合法<br><br>p2 = &amp;b;                //使用p2做左值，非法<br>*p2 = 100;              //使用*p2做左值，合法<br></code></pre></td></tr></table></figure><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smali">const<span class="hljs-built_in"> int </span>*const p3 = &amp;a;    //const分别修饰*p3,p3,将*p3，p2作为左值都非法<br><br>p3 = &amp;b;                      //使用p3做左值，非法<br>*p3 = 100;                    //使用*p3做左值，非法<br></code></pre></td></tr></table></figure><p>2.2 修饰函数的参数</p><p>（1）用作函数的输入参数，防止输入内容被修改。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StringCopy</span>(<span class="hljs-params"><span class="hljs-built_in">char</span> *<span class="hljs-keyword">out</span>, <span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> *<span class="hljs-keyword">in</span></span>)</span>;<br></code></pre></td></tr></table></figure><p>其中in 是输入参数，out是输出参数。给in加上 const 修饰后，如果函数体内的语句试图改动 strSource 的内容，编译器将指出错误。</p><p>（2）防止修改指针指向的地址</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">void</span> swap ( <span class="hljs-built_in">int</span> *<span class="hljs-keyword">const</span> p1 , <span class="hljs-built_in">int</span> *<span class="hljs-keyword">const</span> p2 )<br></code></pre></td></tr></table></figure><p>指针p1和指针p2指向的地址都不能被修改。</p><p>（3）以上两种的结合</p><p>2.3 修饰函数的返回值</p><p>表示返回值不可改变，多用于返回值为指针的情形，且该返回值只能被赋给加const 修饰的同类型指针。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> * GetString(<span class="hljs-keyword">void</span>);<br><span class="hljs-built_in">char</span> *<span class="hljs-built_in">str</span> = GetString();    <span class="hljs-comment">//编译错误</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> *<span class="hljs-built_in">str</span> = GetString();    <span class="hljs-comment">//编译成功</span><br></code></pre></td></tr></table></figure><p>2.4 修饰全局变量</p><p>首先我们要尽量避免使用全局变量，它不仅在程序结束前一直占用数据段上的空间，而且可以在任何地方更改，减少软件的安全性。所以我们尽量使用const进行修饰，以防止不必要的人为修改。</p><p>三、const和编译器</p><p>早期的标准C语言编译器(bcc)中const修饰的全局变量在全局数据区分配空间，其值依然可以改变；在现代C语言编译器(如gcc,vc6.0)中，将const修饰的全局变量存储于只读存储区，无法通过指针修改其值。</p><p>四、const的变量本质</p><p>4.1 本质一</p><p>const修饰的局部变量在栈上分配空间，虽然不可通过赋值号改变其值，但可以通过指针改变其值；</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs perl">const <span class="hljs-keyword">int</span> g_cc = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">int</span> main()<br>&#123;<br>    const <span class="hljs-keyword">int</span> cc = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">int</span>* p = (<span class="hljs-keyword">int</span>*)&amp;cc;<br><br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;cc = %d\n&quot;</span>, cc);<br><br>    *p = <span class="hljs-number">3</span>;        <span class="hljs-regexp">//</span>编译通过<br>//    cc = <span class="hljs-number">3</span>;    <span class="hljs-regexp">//</span>error:assignment of <span class="hljs-keyword">read</span>-only variable <span class="hljs-string">&#x27;cc&#x27;</span><br><br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;cc = %d\n&quot;</span>, cc);<br><br>    p = (<span class="hljs-keyword">int</span>*)&amp;g_cc;<br><br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;g_cc = %d\n&quot;</span>, g_cc);<br><br>    *p = <span class="hljs-number">4</span>;    <span class="hljs-regexp">//</span>编译通过，但程序崩溃<br>               /*因为现代编译器都对const进行了优化，const修饰的全局变量会被编译进入只读存储区，一旦程序对只读存储区的内容进行修改，就会发生崩溃；但早期编译器是可以修改const全局变量的内存空间的，const修饰的全局变量没有编译进入只读存储区*<span class="hljs-regexp">/</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">    printf(&quot;g_cc = %d\n&quot;, g_cc);    /</span>/error:assignment of <span class="hljs-keyword">read</span>-only variable <span class="hljs-string">&#x27;cc&#x27;</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>-现代C编译器中的const将具有全局生命周期的变量存储于只读存储区。</p><p>（全局生命周期的变量有全局变量和static修饰的局部变量。）</p><p>4.2 本质二</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> g_array[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span>* p, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    *p = v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-type">const</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-type">const</span> array[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-built_in">modify</span>((<span class="hljs-type">int</span>*)&amp;i, <span class="hljs-number">1</span>);             <span class="hljs-comment">//ok</span><br>    <span class="hljs-built_in">modify</span>((<span class="hljs-type">int</span>*)&amp;j, <span class="hljs-number">2</span>);             <span class="hljs-comment">//error(gcc编译器)</span><br>    <span class="hljs-built_in">modify</span>((<span class="hljs-type">int</span>*)&amp;array[<span class="hljs-number">0</span>], <span class="hljs-number">3</span>);      <span class="hljs-comment">//ok</span><br>    <span class="hljs-built_in">modify</span>((<span class="hljs-type">int</span>*)&amp;g_array[<span class="hljs-number">0</span>], <span class="hljs-number">4</span>);    <span class="hljs-comment">//error(gcc编译器)</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %d\n&quot;</span>, i);    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;j = %d\n&quot;</span>, j);    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;array[0] = %d\n&quot;</span>, array[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;g_array[0] = %d\n&quot;</span>, g_array[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><p>注意：C语言中的字符串字面量（字符串常量）存储于只读存储区，在程序中需要使用const char*指针指向。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* s = <span class="hljs-string">&quot;Delphi Tanf&quot;</span><br></code></pre></td></tr></table></figure><p>（三）和宏定义define的区别：宏常量本质为字面量（字面量不占用内存）</p><p>#define指令是另一种创建名字常量的机制。例如，下面这两个声明都为50这个值创建了名字常量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_ELEMENTS 50</span><br><span class="hljs-type">int</span> <span class="hljs-type">const</span> max_elements <span class="hljs-number">50</span>;<br></code></pre></td></tr></table></figure><p>在这种情况下，使用#define比使用const变量更好。#define定义的宏常量本质为字面量（字面量不占用内存），因为只要允许使用字面值常量的地方，都可以使用前者，比如声明数组的长度。const变量只能用于允许使用变量的地方。</p><p><span style="background-color: #ffaaaa">3.编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。</span></p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>attribute</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/-attribute-/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/-attribute-/</url>
    
    <content type="html"><![CDATA[<p>本文为C语言attribute语法的记录#<br><strong>attribute</strong></p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运算符:#和##</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/%E8%BF%90%E7%AE%97%E7%AC%A6#%E5%92%8C##/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/%E8%BF%90%E7%AE%97%E7%AC%A6#%E5%92%8C##/</url>
    
    <content type="html"><![CDATA[<p>一、#运算符</p><p>#运算符用于在预处理期将宏参数转换为字符串，且#的转换作用是在预处理期完成的,因此只在宏定义中有效，编译器并不知道#的转换作用。</p><p>1.1 用法</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso">#define <span class="hljs-built_in">STRING</span>(x) #X<br>printf(<span class="hljs-string">&quot; %s\n&quot;</span>, <span class="hljs-built_in">STRING</span>(Hello World!)); .<br></code></pre></td></tr></table></figure><p>运算符的基本用法</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><br><span class="hljs-comment">#define STRING(x) #x</span><br><br><span class="hljs-keyword">int</span> main()<br>&#123;<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, STRING(Hello world!));<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, STRING(<span class="hljs-number">100</span>));<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, STRING(<span class="hljs-keyword">while</span>));<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, STRING(<span class="hljs-keyword">return</span>));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>/* test.i */<br><span class="hljs-comment"># 1 &quot;test.c&quot;</span><br><span class="hljs-comment"># 1 &quot;&lt;built-in&gt;&quot;</span><br><span class="hljs-comment"># 1 &quot;&lt;command-line&gt;&quot;</span><br><span class="hljs-comment"># 1 &quot;test.c&quot;</span><br><br><span class="hljs-keyword">int</span> main()<br>&#123;<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, <span class="hljs-string">&quot;Hello world!&quot;</span>);<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, <span class="hljs-string">&quot;100&quot;</span>);<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, <span class="hljs-string">&quot;while&quot;</span>);<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, <span class="hljs-string">&quot;return&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>1.2 运算符的妙用</p><p>打印函数名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">/* 通过#运算符将f这个函数名转换为字符串打印出来 */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CALL(f, p) (printf(<span class="hljs-string">&quot;Call function %s\n&quot;</span>, #f), f(p))</span><br>   <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> n * n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <br>    result = <span class="hljs-built_in">CALL</span>(square, <span class="hljs-number">4</span>);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;result = %d\n&quot;</span>, result);<br>    <br>    result = <span class="hljs-built_in">CALL</span>(func, <span class="hljs-number">10</span>);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;result = %d\n&quot;</span>, result);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* test.i */</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;test.c&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;&lt;built-in&gt;&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;&lt;command-line&gt;&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;test.c&quot;</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> n * n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><br>    result = (<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Call function %s\n&quot;</span>, <span class="hljs-string">&quot;square&quot;</span>), <span class="hljs-built_in">square</span>(<span class="hljs-number">4</span>));<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;result = %d\n&quot;</span>, result);<br><br>    result = (<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Call function %s\n&quot;</span>, <span class="hljs-string">&quot;func&quot;</span>), <span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>));<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;result = %d\n&quot;</span>, result);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>二、##运算符</p><p>##运算符用于在预处理期粘连两个标识符，##的连接作用是在预处理期完成的,因此只在宏定义中有效，编译器并不知道##的连接作用</p><p>2.1 用法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#define <span class="hljs-constructor">CONNECT(<span class="hljs-params">a</span>, <span class="hljs-params">b</span>)</span> a##b<br><span class="hljs-built_in">int</span> <span class="hljs-constructor">CONNECT(<span class="hljs-params">a</span>, 1)</span>;<br><span class="hljs-comment">// int al;</span><br>.a1= <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>运算符的基本用法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NAME(n) name##n</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">NAME</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;    <span class="hljs-comment">//name1</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">NAME</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;    <span class="hljs-comment">//name2</span><br>    <br>    <span class="hljs-built_in">NAME</span>(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span>;    <span class="hljs-comment">//name1 = 1;</span><br>    <span class="hljs-built_in">NAME</span>(<span class="hljs-number">2</span>) = <span class="hljs-number">2</span>;    <span class="hljs-comment">//name2 = 2;</span><br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">NAME</span>(<span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">NAME</span>(<span class="hljs-number">2</span>));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.2 运算符的工程运用</p><p>结合#define简单定义结构体</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">#include <span class="hljs-operator">&lt;</span>stdio.h<span class="hljs-operator">&gt;</span><br><br><span class="hljs-operator">/*</span> 达到两个效果，首先使用一个typedef定义一个结构体标签，然后再定义一个结构体 <span class="hljs-operator">*/</span><br>#define STRUCT(<span class="hljs-keyword">type</span>) typedef <span class="hljs-keyword">struct</span> _tag_##<span class="hljs-keyword">type</span> <span class="hljs-keyword">type</span>;\<br>                     <span class="hljs-keyword">struct</span> _tag_##<span class="hljs-keyword">type</span><br><br>STRUCT(Student)<br>&#123;<br>    char<span class="hljs-operator">*</span> name;<br>    int <span class="hljs-built_in">id</span>;<br>&#125;;<br><br><span class="hljs-operator">/*</span> test.i中上面代码<br> <span class="hljs-operator">*</span> typedef <span class="hljs-keyword">struct</span> _tag_Student Student; <br> <span class="hljs-operator">*</span> <span class="hljs-keyword">struct</span> _tag_Student<br> <span class="hljs-operator">*/</span><br><br>int main()<br>&#123;<br>    <br>    Student s1;<br>    Student s2;<br>    <br>    s1.name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;s1&quot;</span>;<br>    s1.<span class="hljs-built_in">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <br>    s2.name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;s2&quot;</span>;<br>    s2.<span class="hljs-built_in">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;s1.name = %s\n&quot;</span>, s1.name);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;s1.id = %d\n&quot;</span>, s1.<span class="hljs-built_in">id</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;s2.name = %s\n&quot;</span>, s2.name);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;s2.id = %d\n&quot;</span>, s2.<span class="hljs-built_in">id</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义结构体后使用结构体需要重复写上struct student，所以应用typedef来节省时间，但结构体数目一多，又要定义很多typedef，这时就可以使用##连接符和#define。</p><p>小结</p><p>#运算符用于在预处理期将宏参数转换为字符串</p><p>##运算符用于在预处理期粘连两个标识符</p><p>编译器不知道#和##运算符的存在</p><p>#和##运算符只在宏定义中有效.</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>宏定义:#pragma</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/%E5%AE%8F%E5%AE%9A%E4%B9%89#pragma/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/%E5%AE%8F%E5%AE%9A%E4%B9%89#pragma/</url>
    
    <content type="html"><![CDATA[<p>一、简介</p><p>#pragma用于指示编译器完成一些特定的动作。</p><p>特点：</p><ul><li><p>#pragma所定义的很多指示字是编译器特有的，在不同的编译器间不可移植。</p></li><li><p>预处理器将忽略它不认识的#pragma指令</p></li><li><p>不同的编译器可能以不同的方式解释同一条#pragma指令</p></li></ul><p>一般用法:#pragma parameter</p><p>注:不同的parameter参数语法和意义各不相同.</p><p>二、#pragma message</p><p>message参数在编译时输出消息到编译输出窗口中，类似#error和#warining。</p><p>message大多用于条件编译中可提示代码的版本信息，且message参数在大多数的编译器中都有相似的实现</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(ANDROID20)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> message(&quot;Compile Android SDK 2.0...&quot;)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> VERSION &quot;Android 2.0”</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>与#error和#warning不同，#pragma message仅仅代表一条编译消息，不代表程序错误。</p><p>例：#pragma message使用实例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(ANDROID20)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> message(<span class="hljs-string">&quot;Compile Android SDK 2.0...&quot;</span>)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> VERSION <span class="hljs-string">&quot;Android 2.0&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(ANDROID23)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> message(<span class="hljs-string">&quot;Compile Android SDK 2.3...&quot;</span>)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> VERSION <span class="hljs-string">&quot;Android 2.3&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(ANDROID40)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> message(<span class="hljs-string">&quot;Compile Android SDK 4.0...&quot;</span>)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> VERSION <span class="hljs-string">&quot;Android 4.0&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">error</span> Compile Version is not provided!</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, VERSION);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* gcc： */</span>    <br><span class="hljs-comment">#pragma message：Compile Android SDK 4.0...</span><br><span class="hljs-regexp">/* vc4.0 */</span><br>Compile Android SDK <span class="hljs-number">4.0</span>...<br><span class="hljs-regexp">/* bcc */</span><br>Compile Android SDK <span class="hljs-number">2.3</span>...<br></code></pre></td></tr></table></figure><p>#pragma message在不同的编译器实现方式不同</p><p>三、#pragma once</p><p>#pragma once用于保证头文件只被编译器包含（打开）一次，预处理器下次遇到包含此文件的命令就不会执行。但#pragma once是编译器相关的，不一定被支持</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#ifndef_ HEADER FILE_ H_</span><br><span class="hljs-comment">#define_ HEADER_ FILE_ H_</span><br><span class="hljs-regexp">//</span> source code<br><span class="hljs-comment">#endif</span><br></code></pre></td></tr></table></figure><p>VS</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br></code></pre></td></tr></table></figure><p>#ifdef的优点是一致性，但效率慢。#pragma once的优点是效率高，但不一定被编译器支持。</p><p>#ifdef在每个文件里都要通过宏的方式来判断文件是否被包含，预处理器处理了多次，效率慢</p><p>#pragma once直接告诉预处理器这个文件只编译一次，一次include后再include预处理器就不会处理。</p><p>例：#pragma once使用分析</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;global.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;global.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;g_value = %d\n&quot;</span>, g_value);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">gcc、vc2010支持<span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br>bcc不支持<span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br></code></pre></td></tr></table></figure><p>可以这样写就结合#ifdef和#pragma的优点，既保证了编译效率，又保证了一致性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _GLOBAL_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GLOBAL_H_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-type">int</span> g_value = <span class="hljs-number">1</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>四、#pragma pack</p><p>#pragma pack用于指定结构、联合和类成员的封装对齐，改变编译器的内存对齐方式。</p><p>如果未设置编译器选项，windows默认为8，linux默认为4。且指定时应注意编译器是否支持，比如gcc编译器不支持8字节对齐。</p><p>4.1 #pragma pack使用示例：</p><p>#pragma pack(1)</p><p>strust Test1</p><p>{</p><p>    char c1;</p><p>    short s;</p><p>    char c2;</p><p>    int i;</p><p>};</p><p>#pragma pack()</p><p>#pragma pack(1)</p><p>strust Test2</p><p>{</p><p>    char c1;</p><p>    char c2;</p><p>    short s;</p><p>    int i;</p><p>};</p><p>#pragma pack()</p><p>sizeof(struct Test1) &#x3D; 8，不对齐为12</p><p>sizeof(struct Test2) &#x3D; 8，不对齐为8</p><p>4.2 什么是内存对齐?</p><p>不同类型的数据在内存中按照一定的规则排列，而不一定是顺序的一一个接一个的排列</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs abnf">strust Test1<br>&#123;<br>    char c1<span class="hljs-comment">;</span><br>    short s<span class="hljs-comment">;</span><br>    char c2<span class="hljs-comment">;</span><br>    int i<span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br>strust Test2<br>&#123;<br>    char c1<span class="hljs-comment">;</span><br>    char c2<span class="hljs-comment">;</span><br>    short s<span class="hljs-comment">;</span><br>    int i<span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>Testl和Test2所占的内存空间是否相同?</p><p>不同，Test1占用12，Test2占用8</p><p><img src="/image/81457ebe9ab393c3beb307a562a51431.png" alt="81457ebe9ab393c3beb307a562a51431.png"></p><p>4.2 为什么需要内存对齐?</p><ul><li>CPU对内存的读取不是一个一个字节取出，而是根据自己的字长分成块读取的，比如32位处理器将取出4个字节的内存块进行处理，取多了也是由内存处理器帮忙完成数据挑拣再传送给CPU。</li><li>当读取操作的数据未对齐,则需要两次总线周期来访问内存,性能会大打折扣，因此CPU保证用尽量少的CPU周期将它们从内存读进来。比如下面这样就要读两次：<img src="/image/20180313012805740.png" alt="20180313012805740.png"></li><li>某些硬件平台只能从规定的相对地址处读取特定类型的数据,否则产生硬件异常</li></ul><p>4.3 struct占用的内存大小对齐规则</p><ul><li>第一个成员起始于0偏移处</li><li>每个成员按其类型大小和pack参数中较小的一个进行对齐<ul><li>偏移地址必须能被对齐参数整除</li><li>结构体成员的大小取其内部长度最大的数据成员作为其大小</li></ul></li><li>结构体总长度必须为所有对齐参数的整数倍</li></ul><p>编译器在默认情况下按照4字节对齐，即#pragma pack(4)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(2)</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test1</span><br>&#123;<br>    <span class="hljs-type">char</span>  c1;<br>    <span class="hljs-type">short</span> s;<br>    <span class="hljs-type">char</span>  c2;<br>    <span class="hljs-type">int</span>   i;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack()</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(4)</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test2</span><br>&#123;<br>    <span class="hljs-type">char</span>  c1;<br>    <span class="hljs-type">char</span>  c2;<br>    <span class="hljs-type">short</span> s;<br>    <span class="hljs-type">int</span>   i;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack()</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(Test1) = %d\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> Test1));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(Test2) = %d\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> Test2));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(8)</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S1</span><br>&#123;                <span class="hljs-comment">//对齐参数     偏移地址     大小</span><br>    <span class="hljs-type">short</span> a;     <span class="hljs-comment">//2            8           2</span><br>    <span class="hljs-type">long</span> b;      <span class="hljs-comment">//4            4           4</span><br>&#125;;  <br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S2</span><br>&#123;                <span class="hljs-comment">//对齐参数     偏移地址     大小</span><br>    <span class="hljs-type">char</span> c;      <span class="hljs-comment">//1            0           1</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">S1</span> d; <span class="hljs-comment">//4            4           8</span><br>    <span class="hljs-type">double</span> e;    <span class="hljs-comment">//9            16          9</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack()</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> S1));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> S2));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>小结</p><p>#pragma用于指示编译器完成- -些特定的动作</p><p>#pragma所定义的很多指示字是编译器特有的</p><ul><li>#pragma message用于自定义编译消息</li><li>#pragma once用于保证头文件只被编译-次</li><li>#pragma pack用于指定内存对齐方式</li></ul>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>宏定义:#error和#line</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/%E5%AE%8F%E5%AE%9A%E4%B9%89#error%E5%92%8C#line/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/%E5%AE%8F%E5%AE%9A%E4%B9%89#error%E5%92%8C#line/</url>
    
    <content type="html"><![CDATA[<p>一、#error的用法</p><p>1.1 #error用于生成一个编译错误消息</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sas">#<span class="hljs-keyword">error</span> <span class="hljs-keyword">message</span><br><span class="hljs-keyword">message</span>不需要用双弓|号包围<br></code></pre></td></tr></table></figure><p>#error编译用于自定义程序员特需的编译错误消息（一些不影响程序运行但不符合我们预期的错误）。类似的, #warning用于生成编译警告信息。</p><p>比如可用于提示编译条件是否满足</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#ifndef_ cplusplus</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">error</span> This file should be processed with C+ + compiler.</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>如果#error执行，编译器就会报错，报的错即程序员自定义的这个错，编译过程中的任意错误信息意味着无法生成最终的可执行程序。</p><p>例1：#error在条件编译中的应用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 使用宏PRODUCT来决定编译哪些程序，从而区分出高中低端产品 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> ( PRODUCT == 1 )</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is a low level product!\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> ( PRODUCT == 2 )</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is a middle level product!\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> ( PRODUCT == 3 )</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is a high level product!\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">f</span>();<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1. Query Information.\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2. Record Information.\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;3. Delete Information.\n&quot;</span>);<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> ( PRODUCT == 1 )</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;4. Exit.\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> ( PRODUCT == 2 )</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;4. High Level Query.\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;5. Exit.\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> ( PRODUCT == 3 )</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;4. High Level Query.\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;5. Mannul Service.\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;6. Exit.\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">gcc -DPRODUCT=<span class="hljs-number">2</span> test.c    <br><span class="hljs-regexp">/* 我们通过编译PRODUCT这个宏来决定属于哪个产品，但若我们忘记编译该宏，程序依旧会编译通过，并不能给我们警示信息，这样会导致我们的程序达不到我们的要求 */</span><br></code></pre></td></tr></table></figure><p>我们可以通过#error或#warning来指出错误信息，可以这么修改</p><p>①使用#error</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> ( PRODUCT == 1 )</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is a low level product!\n&quot;</span>);<br>    ...<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">error</span> The <span class="hljs-string">&quot;PRODUCT&quot;</span> is NOT defined!</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> ( PRODUCT == 1 )</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;4. Exit.\n&quot;</span>);<br>    ...<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">error</span> The <span class="hljs-string">&quot;PRODUCT&quot;</span> is NOT defined!</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>不在命令中定义宏PRODUCT，#error语句执行，程序报错，无法生成可执行程序。</p><p>②使用#warning</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> ( PRODUCT == 1 )</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is a low level product!\n&quot;</span>);<br>    ...<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">warning</span> The <span class="hljs-string">&quot;PRODUCT&quot;</span> is NOT defined!</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> ( PRODUCT == 1 )</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;4. Exit.\n&quot;</span>);<br>    ...<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">warning</span> The <span class="hljs-string">&quot;PRODUCT&quot;</span> is NOT defined!</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>不在命令中定义宏PRODUCT，#warning语句执行，程序发出警告，可执行程序依旧生成。</p><p>二、#line的用法</p><p>#line用于强制指定新的行号和编译文件名,并对源程序的代码重新编号。</p><p>2.1用法</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-meta">#line number fil ename</span><br>filename可省略<br></code></pre></td></tr></table></figure><p>#line编译指示字的本质是重定义_ LINE_（行号） 和_ FILE_（文件名）</p><p>2.2 来源</p><p>最初的C语言程序员都比较小，程序员都习惯所有代码写在一个文件中，后来逐渐开始合作。一个程序员a写a.c，另一个写b.c，写完后再放到一个程序中，但程序要出错后需要改错，谁写的谁解决，于是出现以下类似的代码。</p><p>例3：#line的使用</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs d">#include &lt;stdio.h&gt;<br><br><span class="hljs-comment">// The code section is written by A.</span><br><span class="hljs-comment">// Begin</span><br><span class="hljs-meta">#line 1 &quot;a.c&quot;</span><br><br><span class="hljs-comment">// End</span><br><br><span class="hljs-comment">// The code section is written by B.</span><br><span class="hljs-comment">// Begin</span><br><span class="hljs-meta">#line 1 &quot;b.c&quot;</span><br><br><span class="hljs-comment">// End</span><br><br><span class="hljs-comment">// The code section is written by Delphi.</span><br><span class="hljs-comment">// Begin</span><br><span class="hljs-meta">#line 1 &quot;delphi_tang.c&quot;</span><br><br><span class="hljs-keyword">int</span> main()<br>&#123;<br>    printf(<span class="hljs-string">&quot;%s : %d\n&quot;</span>, <span class="hljs-keyword">__FILE__</span>, <span class="hljs-keyword">__LINE__</span>);<br>    <br>    printf(<span class="hljs-string">&quot;%s : %d\n&quot;</span>, <span class="hljs-keyword">__FILE__</span>, <span class="hljs-keyword">__LINE__</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// End</span><br></code></pre></td></tr></table></figure><p>小结：</p><p>#error用于自定义一-条编译错误信息</p><p>#warning用于自定义一条编译警告信息</p><p>#error和#warning常应用于条件编译的情形</p><p>#line用于强制指定新的行号和编译文件名</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo遇到的问题</title>
    <link href="/2023/01/15/Hexo/Hexo%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2023/01/15/Hexo/Hexo%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>本文记录了使用Hexo时遇到的各种问题与解决方法</p><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><p>笔记的标题中若包含’#’会在categories发现找不到该文章<br>例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-comment">#define</span><br><span class="hljs-attr">categories:</span> <span class="hljs-string">C语言</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">C</span>]<br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>现象：<br><img src="data:image/png;base64,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" alt="categories页显示异常"></p><p>解决方法：<br>title中不要以’#’开头，categories同理</p><h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><p>笔记文件的名字中若包含’#’，页面打开就会直接报错<br>例：文件命名为#define.md<br>现象：<br><img src="data:image/png;base64,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" alt="文件打开报错"></p><p>解决方法：<br>笔记文件名中不要以’#’开头</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>奇怪的问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>宏定义:#define</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/%E5%AE%8F%E5%AE%9A%E4%B9%89#define/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/%E5%AE%8F%E5%AE%9A%E4%B9%89#define/</url>
    
    <content type="html"><![CDATA[<p>本文为C语言#define语法的记录</p><h1 id="define"><a href="#define" class="headerlink" title="define"></a>define</h1><p>一、#define的特点：</p><p>1.#define定义的宏可以出现在程序的任意位置，且定义之后的代码都可以使用这个宏。</p><p>#define定义的宏常量可以直接使用，且宏常量本质为字面量（字面量不占用内存）</p><p>3.对于宏而言，不能说其有作用域，作用域的概念是针对变量和函数的，不针对宏，因为宏是被预处理所处理，编译器根本不知道宏定义的存在，所以也无法把作用域的概念用在宏定义上。但宏的生效范围是自定义开始直到整个文件结尾。</p><p>例1：以下宏定义是正确的吗</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* test.c */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR -1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PATH1 <span class="hljs-string">&quot;D:\test\test.c&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PATH2 D:\test\test.c    <span class="hljs-comment">//宏用来替代路径很好用</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PATH3 D:\test\    <span class="hljs-comment">/* 由于&#x27;\&#x27;出现在宏定义的最后一个字符，因此&#x27;\&#x27;变为了接续符 */</span></span><br>test.<span class="hljs-function">c</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> err = ERROR;<br>    <span class="hljs-type">char</span>* p1 = PATH1;<br>    <span class="hljs-type">char</span>* p2 = PATH2;<br>    <span class="hljs-type">char</span>* p3 = PATH3;<br>&#125;<br><br><span class="hljs-comment">/* test.i */</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;test.c&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;&lt;built-in&gt;&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;&lt;command-line&gt;&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;test.c&quot;</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> err = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">char</span>* p1 = <span class="hljs-string">&quot;D:\test\test.c&quot;</span>;<br>    <span class="hljs-type">char</span>* p2 = D:\test\test.c;<br>    <span class="hljs-type">char</span>* p3 = D:\testtest.c;<br>&#125;<br></code></pre></td></tr></table></figure><p>答：宏定义是正确的，但只能通过预编译，不能通过编译。因为预处理器只进行文本替换而不进行语法检查的，语法检查由编译器执行。替换后编译器发现不符合语法规则后才报错。</p><p>二、宏定义表达式</p><p>#define表达式的使用类似函数调用，但更容易出错且可读性极差（因为预处理器直接进行文本替换，结果就可能和我们预想的不一样），一般都不会用define定义函数。但#define表达式也可以比函数更强大，比如实现求数组大小。</p><p>例2：下面的宏定义表达式正确吗？</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/* test.c */</span><br>#define <span class="hljs-constructor">_SUM_(<span class="hljs-params">a</span>, <span class="hljs-params">b</span>)</span> (a) + (b)<br>#define <span class="hljs-constructor">_MIN_(<span class="hljs-params">a</span>, <span class="hljs-params">b</span>)</span> ((a) &lt; (b) ? (a) : (b))<br>#define <span class="hljs-constructor">_DIM_(<span class="hljs-params">a</span>)</span> sizeof(a)/sizeof(*a)    <span class="hljs-comment">//求一个数组的大小</span><br><br><span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span><br>&#123;<br>    <span class="hljs-built_in">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">int</span> b = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">int</span> c<span class="hljs-literal">[<span class="hljs-number">4</span>]</span> = &#123;<span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-built_in">int</span> s1 = <span class="hljs-constructor">_SUM_(<span class="hljs-params">a</span>, <span class="hljs-params">b</span>)</span>;<br>    <span class="hljs-built_in">int</span> s2 = <span class="hljs-constructor">_SUM_(<span class="hljs-params">a</span>, <span class="hljs-params">b</span>)</span><span class="hljs-operator"> * </span><span class="hljs-constructor">_SUM_(<span class="hljs-params">a</span>, <span class="hljs-params">b</span>)</span>;<br>    <span class="hljs-built_in">int</span> m = <span class="hljs-constructor">_MIN_(<span class="hljs-params">a</span><span class="hljs-operator">++</span>, <span class="hljs-params">b</span>)</span>;<br>    <span class="hljs-built_in">int</span> d = <span class="hljs-constructor">_DIM_(<span class="hljs-params">c</span>)</span>;<br><br>     printf(<span class="hljs-string">&quot;s1 = %d\n&quot;</span>, s1);    <span class="hljs-comment">//3</span><br>     printf(<span class="hljs-string">&quot;s2 = %d\n&quot;</span>, s2);    <span class="hljs-comment">//5</span><br>     printf(<span class="hljs-string">&quot;m = %d\n&quot;</span>, m);      <span class="hljs-comment">//2</span><br>     printf(<span class="hljs-string">&quot;d = %d\n&quot;</span>, d);      <span class="hljs-comment">//4</span><br><br>    return <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* test.i */</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;test.c&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;&lt;built-in&gt;&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;&lt;command-line&gt;&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;test.c&quot;</span><br><br><span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span><br>&#123;<br>    <span class="hljs-built_in">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">int</span> b = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">int</span> c<span class="hljs-literal">[<span class="hljs-number">4</span>]</span> = &#123;<span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-built_in">int</span> s1 = (a) + (b);<br>    <span class="hljs-built_in">int</span> s2 = (a) + (b)<span class="hljs-operator"> * </span>(a) + (b);        <span class="hljs-comment">//所以说比函数更容易出错</span><br>    <span class="hljs-built_in">int</span> m = ((a++) &lt; (b) ? (a++) : (b));   <span class="hljs-comment">//所以说比函数更容易出错</span><br>    <span class="hljs-built_in">int</span> d = sizeof(c)/sizeof(*c);<br><br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>三、宏表达式和函数的对比</p><p>宏表达式被预处理器处理，编译器不知道宏表达式的存在。</p><p>宏表达式用“实参”完全替代形参（文本替换），不进行任何运算。</p><p>优势：宏表达式没有任何的“调用”开销，函数则需要参数布栈布置返回地址等开销。</p><p>因为宏只是简单的替换，所以宏不需要考虑类型的因素，甚至可以用类型名做参数。</p><p>宏表达式中不能出现递归定义，函数可以有递归函数。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#define <span class="hljs-constructor">_SUM_(<span class="hljs-params">n</span>)</span> ((n&gt;<span class="hljs-number">0</span>)?(<span class="hljs-constructor">_SUM_(<span class="hljs-params">n</span>-1)</span>+n):<span class="hljs-number">0</span>)    <span class="hljs-comment">//error</span><br><span class="hljs-built_in">int</span> s = <span class="hljs-constructor">_SUM_(10)</span>;<br></code></pre></td></tr></table></figure><p>例3：宏定义的常量或表达式是否有作用域限制</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">/* test.c */</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">def</span>()</span><br>&#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> PI 3.1415926</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> AREA(r) r * r * PI</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">double</span> <span class="hljs-title">area</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> r</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> AREA(r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    <span class="hljs-built_in">double</span> r = area(<span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// printf(&quot;PI = %f\n&quot;, PI);</span><br>    <span class="hljs-comment">// printf(&quot;d = 5; a = %f\n&quot;, r);</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>答：对于宏而言，不能说其有作用域，作用域的概念是针对变量和函数的，不针对宏，因为宏是被预处理所处理，编译器根本不知道宏定义的存在，所以也无法把作用域的概念用在宏定义上。但宏的生效范围是自定义开始直到整个文件结尾。</p><p>四、强大的内置宏</p><p><img src="/image/Slide10.PNG" alt="Slide10.PNG"></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;stdio.h&gt;<br>#<span class="hljs-keyword">include</span> &lt;malloc.h&gt;<br><br>#define <span class="hljs-constructor">MALLOC(<span class="hljs-params">type</span>, <span class="hljs-params">x</span>)</span> (<span class="hljs-keyword">type</span>*)malloc(sizeof(<span class="hljs-keyword">type</span>)*x)    <span class="hljs-comment">//用来向堆空间申请一个数组</span><br><br>#define <span class="hljs-constructor">FREE(<span class="hljs-params">p</span>)</span> (free(p), p=NULL)    <span class="hljs-comment">//释放堆空间，指针指向空</span><br><br><span class="hljs-comment">/* 打印当前时间，当前文件名，当前行号，字符串s */</span><br>#define <span class="hljs-constructor">LOG(<span class="hljs-params">s</span>)</span> printf(<span class="hljs-string">&quot;[%s] &#123;%s:%d&#125; %s \n&quot;</span>, __DATE__, __FILE__, __LINE__, s)<br><br><span class="hljs-comment">/* 一个for循环 */</span><br>#define <span class="hljs-constructor">FOREACH(<span class="hljs-params">i</span>, <span class="hljs-params">m</span>)</span> <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>#define BEGIN &#123;<br>#define END   &#125;<br><br><span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span><br>&#123;<br>    <span class="hljs-built_in">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span>* p = <span class="hljs-constructor">MALLOC(<span class="hljs-params">int</span>, 5)</span>;    <span class="hljs-comment">//C语言是不能将一个类型作为参数调用的</span><br>    <br>    <span class="hljs-constructor">LOG(<span class="hljs-string">&quot;Begin to run main code...&quot;</span>)</span>;    <span class="hljs-comment">//日志宏</span><br>    <br>    <span class="hljs-constructor">FOREACH(<span class="hljs-params">x</span>, 5)</span><br>    BEGIN<br>        p<span class="hljs-literal">[<span class="hljs-identifier">x</span>]</span> = x;<br>    END<br>    <br>    <span class="hljs-constructor">FOREACH(<span class="hljs-params">x</span>, 5)</span><br>    BEGIN<br>        printf(<span class="hljs-string">&quot;%d\n&quot;</span>, p<span class="hljs-literal">[<span class="hljs-identifier">x</span>]</span>);<br>    END<br>    <br>    <span class="hljs-constructor">FREE(<span class="hljs-params">p</span>)</span>;<br>    <br>    <span class="hljs-constructor">LOG(<span class="hljs-string">&quot;End&quot;</span>)</span>;    <span class="hljs-comment">//日志宏</span><br>    <br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>小结：</p><p>预处理器直接对宏进行文本替换</p><p>宏使用的参数不会进行求值和运算</p><p>预处理器不会对宏定义进行语法检查，所有define出来的宏都是正确的</p><p>宏定义时出现的语法错误只能被编译器检测</p><p>宏定义的效率高于函数调用</p><p>宏的使用会带来一定的副作用</p><p>五、在工程中的发现</p><p>5.1 一个宏用于多个宏</p><p>使用宏描述一位引脚</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-attr">#define Bit0</span>            <span class="hljs-comment">((u8)</span><span class="hljs-number">0</span>x<span class="hljs-number">01</span>)<br><span class="hljs-attr">#define Bit1</span>            <span class="hljs-comment">((u8)</span><span class="hljs-number">0</span>x<span class="hljs-number">02</span>)<br><span class="hljs-attr">#define Bit2</span>            <span class="hljs-comment">((u8)</span><span class="hljs-number">0</span>x<span class="hljs-number">04</span>)<br><span class="hljs-attr">#define Bit3</span>            <span class="hljs-comment">((u8)</span><span class="hljs-number">0</span>x<span class="hljs-number">08</span>)<br><span class="hljs-attr">#define Bit4</span>            <span class="hljs-comment">((u8)</span><span class="hljs-number">0</span>x<span class="hljs-number">10</span>)<br><span class="hljs-attr">#define Bit5</span>            <span class="hljs-comment">((u8)</span><span class="hljs-number">0</span>x<span class="hljs-number">20</span>)<br><span class="hljs-attr">#define Bit6</span>            <span class="hljs-comment">((u8)</span><span class="hljs-number">0</span>x<span class="hljs-number">40</span>)<br><span class="hljs-attr">#define Bit7</span>            <span class="hljs-comment">((u8)</span><span class="hljs-number">0</span>x<span class="hljs-number">80</span>)<br></code></pre></td></tr></table></figure><p>然后分别再用宏描述GPIOABCD实际连接上的设备</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//GPIOA</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WaterIn       Bit1            <span class="hljs-comment">//水位输入，1为水满</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PA2           Bit2            <span class="hljs-comment">//引脚悬空，配置为悬浮输出低电平</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CompEn        Bit3            <span class="hljs-comment">//压机使能位,推挽输出</span></span><br><br><span class="hljs-comment">//GPIOB</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FanEn         Bit7        <span class="hljs-comment">//风扇使能位</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PumpEn        Bit6        <span class="hljs-comment">//水泵使能位</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SDA           Bit5        <span class="hljs-comment">//I2C数据线</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SCL           Bit4        <span class="hljs-comment">//I2C时钟线</span></span><br></code></pre></td></tr></table></figure><p><img src="/./image/7a423e1363130fffc12ff536a9e7e961.png" alt="7a423e1363130fffc12ff536a9e7e961.png"></p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>enex转换为md格式</title>
    <link href="/2023/01/15/%E6%9D%82/enex%E8%BD%AC%E6%8D%A2%E4%B8%BAmd%E6%A0%BC%E5%BC%8F/"/>
    <url>/2023/01/15/%E6%9D%82/enex%E8%BD%AC%E6%8D%A2%E4%B8%BAmd%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>本文记录了将印象笔记导出格式.enex转换为.md格式的方法</p><h2 id="下载大哥的转换工具"><a href="#下载大哥的转换工具" class="headerlink" title="下载大哥的转换工具"></a>下载大哥的转换工具</h2><p><a href="%5B%E7%BD%91%E7%AB%99%E7%BD%91%E5%9D%80%5D(https://github.com/wormi4ok/evernote2md/tags)">evernote2md</a></p><h2 id="格式转化"><a href="#格式转化" class="headerlink" title="格式转化"></a>格式转化</h2><ol><li>将下载下来的文件解压后会得到一个evernote2md.exe</li><li>在evernote2md.exe目录下进入windows cmd</li><li>输入指令<font color=orange><code>evernote2md [inputFile] [outputDir]</code></font> 来转换格式<blockquote><p>不指定<font color=orange><code>[outputDir]</code></font>就会建立一个默认的文件夹notes来存放输出文件<br>evernote2md *.enex 转换目录下的所有enex文件</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>杂</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂</tag>
      
      <tag>操作流程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 超时解决</title>
    <link href="/2023/01/15/Git/%E5%A5%87%E6%80%AA%E7%9A%84%E9%97%AE%E9%A2%98/Git%E8%B6%85%E6%97%B6%E8%A7%A3%E5%86%B3/"/>
    <url>/2023/01/15/Git/%E5%A5%87%E6%80%AA%E7%9A%84%E9%97%AE%E9%A2%98/Git%E8%B6%85%E6%97%B6%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<p>本文记录了两种解决Git超时的方法</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><blockquote><p>有时能用，有时会报Fail to connect to ….,，这时候去换另一种方法吧</p></blockquote><h3 id="Step1-取消代理"><a href="#Step1-取消代理" class="headerlink" title="Step1:取消代理"></a>Step1:取消代理</h3><p><font color=orange><code>git config --global --unset http.proxy</code></font><br><font color=orange><code>git config --global --unset https.proxy</code></font></p><h3 id="Step2-更新DNS"><a href="#Step2-更新DNS" class="headerlink" title="Step2:更新DNS"></a>Step2:更新DNS</h3><p><font color=orange><code>ipconfig /flushdns</code></font> </p><h3 id="Step3-设置代理"><a href="#Step3-设置代理" class="headerlink" title="Step3:设置代理"></a>Step3:设置代理</h3><p><font color=orange><code>git config --global http.proxy  http://127.0.0.1:7890</code></font><br><font color=orange><code>git config --global https.proxy https://127.0.0.1:7890</code></font></p><blockquote><p>127地址与端口号自行查看本地</p></blockquote><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>打开魔法</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
      <category>奇怪的问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>奇怪的问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>标日初上01_单词</title>
    <link href="/2023/01/08/%E6%97%A5%E8%AF%AD/%E6%97%A5%E8%AF%AD%E8%AF%BE%E7%A8%8B/%E6%A0%87%E5%87%86%E6%97%A5%E8%AF%AD%E5%88%9D%E7%BA%A7_%E4%B8%8A%E5%86%8C/%E6%A0%87%E6%97%A5%E5%88%9D%E4%B8%8A01_%E5%8D%95%E8%AF%8D/"/>
    <url>/2023/01/08/%E6%97%A5%E8%AF%AD/%E6%97%A5%E8%AF%AD%E8%AF%BE%E7%A8%8B/%E6%A0%87%E5%87%86%E6%97%A5%E8%AF%AD%E5%88%9D%E7%BA%A7_%E4%B8%8A%E5%86%8C/%E6%A0%87%E6%97%A5%E5%88%9D%E4%B8%8A01_%E5%8D%95%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="生词表1：国家相关"><a href="#生词表1：国家相关" class="headerlink" title="生词表1：国家相关"></a>生词表1：国家相关</h2><table><thead><tr><th align="center">假名</th><th align="center">声调</th><th align="center">日语书写形式</th><th align="center">释义</th></tr></thead><tbody><tr><td align="center">ちゅう　ごく</td><td align="center">1</td><td align="center">中国</td><td align="center">中国</td></tr><tr><td align="center">に　ほん</td><td align="center">2</td><td align="center">日本</td><td align="center">日本</td></tr><tr><td align="center">かん　こく</td><td align="center">1</td><td align="center">韓国</td><td align="center">韩国</td></tr><tr><td align="center">アメリカ</td><td align="center">0</td><td align="center">アメリカ</td><td align="center">美国america</td></tr><tr><td align="center">フランス</td><td align="center">0</td><td align="center">フランス</td><td align="center">法国France</td></tr></tbody></table><h2 id="生词表2：职业相关"><a href="#生词表2：职业相关" class="headerlink" title="生词表2：职业相关"></a>生词表2：职业相关</h2><table><thead><tr><th align="center">假名</th><th align="center">声调</th><th align="center">日语书写形式</th><th align="center">释义</th></tr></thead><tbody><tr><td align="center">がく　せい</td><td align="center">0</td><td align="center">学生</td><td align="center">学生</td></tr><tr><td align="center">せん　せい</td><td align="center">3</td><td align="center">先生</td><td align="center">先生</td></tr><tr><td align="center">りゅう　がく　せい</td><td align="center">3</td><td align="center">留学生</td><td align="center">留学生</td></tr><tr><td align="center">きょう　じゅ</td><td align="center">0</td><td align="center">教授</td><td align="center">教授</td></tr><tr><td align="center">しゃ　いん</td><td align="center">1</td><td align="center">社員</td><td align="center">普通职员</td></tr><tr><td align="center">かい　しゃ　いん</td><td align="center">3</td><td align="center">会社員</td><td align="center">上班族</td></tr></tbody></table><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul><li><p>学生がくせい</p><ul><li>广义：指学生这种身份</li><li>狭义：专指大学生</li></ul></li><li><p>先生せんせい<br>可以前加名字，称呼老师，医生作家，画家，律师等</p></li><li><p>社員しゃいん<br>日语的社員类似于员工的意思，一般前接公司名，仅仅表示属于某公司的人</p></li><li><p>会社員かいしゃいん<br>日语的会社員表示一种职业，类似医生，工程师，意思是公司职员，在公司工作的人</p></li></ul><h1 id="生词表3：职业相关"><a href="#生词表3：职业相关" class="headerlink" title="生词表3：职业相关"></a>生词表3：职业相关</h1><table><thead><tr><th align="center">假名</th><th align="center">声调</th><th align="center">日语书写形式</th><th align="center">释义</th></tr></thead><tbody><tr><td align="center">てん　いん</td><td align="center">0</td><td align="center">店員</td><td align="center">店员</td></tr><tr><td align="center">けん　しゅう　せい</td><td align="center">3</td><td align="center">研修生</td><td align="center">进修生</td></tr><tr><td align="center">か　ちょう</td><td align="center">0</td><td align="center">課長</td><td align="center">科长</td></tr><tr><td align="center">しゃ　ちょう</td><td align="center">0</td><td align="center">社長</td><td align="center">总经理 社长</td></tr><tr><td align="center">き　ぎょう</td><td align="center">1</td><td align="center">企業</td><td align="center">企业</td></tr></tbody></table><h3 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h3><ul><li>研修生けんしゅうせい<br>外国人在留资格的一种。一边在企业等地方工作，一边学习技能和知识</li></ul><h2 id="生词表4：人称指代"><a href="#生词表4：人称指代" class="headerlink" title="生词表4：人称指代"></a>生词表4：人称指代</h2><table><thead><tr><th align="center">假名</th><th align="center">声调</th><th align="center">日语书写形式</th><th align="center">释义</th></tr></thead><tbody><tr><td align="center">わたし</td><td align="center">0</td><td align="center">私わたし</td><td align="center">我</td></tr><tr><td align="center">あなた</td><td align="center">2</td><td align="center">あなた</td><td align="center">你</td></tr><tr><td align="center">ちち</td><td align="center">0</td><td align="center">父</td><td align="center">(我)父亲</td></tr><tr><td align="center">おう</td><td align="center">1</td><td align="center">王</td><td align="center">中国人姓氏</td></tr><tr><td align="center">ちょう</td><td align="center">1</td><td align="center">張</td><td align="center">中国人姓氏</td></tr><tr><td align="center">もり</td><td align="center">0</td><td align="center">森</td><td align="center">日本人姓氏</td></tr><tr><td align="center">はやし</td><td align="center">0</td><td align="center">林</td><td align="center">日本人姓氏</td></tr><tr><td align="center">おの</td><td align="center">0</td><td align="center">小野</td><td align="center">日本人姓氏</td></tr></tbody></table><h3 id="补充-2"><a href="#补充-2" class="headerlink" title="补充"></a>补充</h3><ul><li><p>私わたし</p><ul><li>わたし：第一人称我，男女都可以用，比较正式，对话中经常忽略</li><li>僕　ぼく：男性的自称，用于熟人间</li><li>俺　おれ：男性的自称，用于和平辈，或比自己级别低的人说话时</li></ul></li><li><p>あなた</p><ul><li>あなた：多用于妻子对自己丈夫的称呼。或用于不知道对方的姓名又必须打招呼的时候</li><li>君　きみ：你，对男女都可以用，用于上对下，比自己年龄小的人之间</li><li>俺 おれ：男性的自称，用于和平辈，或比自己级别低的人说话时</li><li>お前　おまえ：一种不礼貌的说法，上对下才用</li></ul></li><li><p>父ちち</p><ul><li>ちち：用作和别人谈到自己父亲的时候，是自谦的说法</li><li>お父さん：称呼别人父亲的时候，或家里叫自己父亲的时候，表示尊敬的说法</li></ul></li></ul><h2 id="生词表5：人称指代"><a href="#生词表5：人称指代" class="headerlink" title="生词表5：人称指代"></a>生词表5：人称指代</h2><table><thead><tr><th align="center">假名</th><th align="center">声调</th><th align="center">日语书写形式</th><th align="center">释义</th></tr></thead><tbody><tr><td align="center">よし　だ</td><td align="center">0</td><td align="center">吉田</td><td align="center">吉田</td></tr><tr><td align="center">た　なか</td><td align="center">0</td><td align="center">田中</td><td align="center">田中</td></tr><tr><td align="center">なか　むら</td><td align="center">0</td><td align="center">中村</td><td align="center">中村</td></tr><tr><td align="center">た　ろう</td><td align="center">1</td><td align="center">太郎</td><td align="center">太郎</td></tr><tr><td align="center">キム</td><td align="center">1</td><td align="center">金　キム</td><td align="center">金</td></tr><tr><td align="center">デョポン</td><td align="center">1</td><td align="center">デョポン</td><td align="center">迪蓬</td></tr><tr><td align="center">スミス</td><td align="center">1</td><td align="center">スミス</td><td align="center">史密斯</td></tr><tr><td align="center">ジョンソン</td><td align="center">1</td><td align="center">ジョンソン</td><td align="center">约翰逊</td></tr></tbody></table><h2 id="生词表6：专有名词"><a href="#生词表6：专有名词" class="headerlink" title="生词表6：专有名词"></a>生词表6：专有名词</h2><table><thead><tr><th align="center">假名</th><th align="center">声调</th><th align="center">日语书写形式</th><th align="center">释义</th></tr></thead><tbody><tr><td align="center">とう　きょう　だい　がく</td><td align="center">5</td><td align="center">東京大学</td><td align="center">东京大学</td></tr><tr><td align="center">ぺきんだいがく</td><td align="center">5</td><td align="center">北京大学</td><td align="center">北京大学</td></tr><tr><td align="center">ジェー　シー　きがく</td><td align="center">5</td><td align="center">JC企画</td><td align="center">假名未分开：能否与汉字对应存疑</td></tr><tr><td align="center">ぺ　きん　りょ　こう　しゃ</td><td align="center">5</td><td align="center">北京旅行社</td><td align="center">北京旅行社</td></tr><tr><td align="center">につ　ちゅう　しょう　じ</td><td align="center">5</td><td align="center">日中商事</td><td align="center"></td></tr></tbody></table><h2 id="生词表7：其他"><a href="#生词表7：其他" class="headerlink" title="生词表7：其他"></a>生词表7：其他</h2><table><thead><tr><th align="center">假名</th><th align="center">声调</th><th align="center">日语书写形式</th><th align="center">释义</th></tr></thead><tbody><tr><td align="center">だい　がく</td><td align="center">0</td><td align="center">大学</td><td align="center">大学</td></tr><tr><td align="center">で　むがえ</td><td align="center">0</td><td align="center">出　迎え</td><td align="center">迎接</td></tr><tr><td align="center">あのひと</td><td align="center">2</td><td align="center">あの人</td><td align="center">那个人</td></tr><tr><td align="center">どうも</td><td align="center">1</td><td align="center">どうも</td><td align="center">非常，很</td></tr><tr><td align="center">はい</td><td align="center">1</td><td align="center">はい</td><td align="center">是的，哎</td></tr><tr><td align="center">いいえ</td><td align="center">3</td><td align="center">いいえ</td><td align="center">不是，不对</td></tr><tr><td align="center">あつ</td><td align="center">～</td><td align="center">あつ</td><td align="center">哎，哎呀</td></tr></tbody></table><h2 id="惯用语1"><a href="#惯用语1" class="headerlink" title="惯用语1"></a>惯用语1</h2><table><thead><tr><th align="center">假名</th><th align="center">声调</th><th align="center">释义</th></tr></thead><tbody><tr><td align="center">こんにちは</td><td align="center">5</td><td align="center">你好</td></tr><tr><td align="center">すみません</td><td align="center">4</td><td align="center">对不起，不好意思</td></tr><tr><td align="center">どうぞ</td><td align="center">1</td><td align="center">请</td></tr><tr><td align="center">よろしく　おねがいいたします</td><td align="center">0&#x2F;6</td><td align="center">请多关照</td></tr><tr><td align="center">はじめまして</td><td align="center">4</td><td align="center">初次见面</td></tr><tr><td align="center">こちらこそ</td><td align="center">4</td><td align="center">我才要…</td></tr><tr><td align="center">そうです</td><td align="center">1</td><td align="center">是的，没错</td></tr><tr><td align="center">ちがいます</td><td align="center">4</td><td align="center">不对，不是这样</td></tr><tr><td align="center">わかりません</td><td align="center">5</td><td align="center">不知道</td></tr><tr><td align="center">どうも　すみません</td><td align="center">～</td><td align="center">太对不起了</td></tr></tbody></table><h2 id="国家-x2F-人-x2F-语言"><a href="#国家-x2F-人-x2F-语言" class="headerlink" title="国家&#x2F;人&#x2F;语言"></a>国家&#x2F;人&#x2F;语言</h2><p>“人” 读音 “じん”<br>“語” 读音 “ご”</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
      <category>日语课程</category>
      
      <category>标准日本语初级_上册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日语</tag>
      
      <tag>上课笔记</tag>
      
      <tag>日语单词</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>标日初上01_语法</title>
    <link href="/2023/01/08/%E6%97%A5%E8%AF%AD/%E6%97%A5%E8%AF%AD%E8%AF%BE%E7%A8%8B/%E6%A0%87%E5%87%86%E6%97%A5%E8%AF%AD%E5%88%9D%E7%BA%A7_%E4%B8%8A%E5%86%8C/%E6%A0%87%E6%97%A5%E5%88%9D%E4%B8%8A01_%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/01/08/%E6%97%A5%E8%AF%AD/%E6%97%A5%E8%AF%AD%E8%AF%BE%E7%A8%8B/%E6%A0%87%E5%87%86%E6%97%A5%E8%AF%AD%E5%88%9D%E7%BA%A7_%E4%B8%8A%E5%86%8C/%E6%A0%87%E6%97%A5%E5%88%9D%E4%B8%8A01_%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h2><h3 id="は"><a href="#は" class="headerlink" title="は"></a>は</h3><p>は是日语中常见的助词，没有实际意思，主要接在名词后面起语法作用，用来凸显提示一句话的主题和话题<br>は做助词时，应读作”わ(wa)”</p><blockquote><p>わたしは森です。</p></blockquote><h3 id="です"><a href="#です" class="headerlink" title="です"></a>です</h3><p>助动词，表示肯定的判断，是句子的谓语部分。在这里相当于文中的”是”</p><blockquote><p>わたしは森です。</p></blockquote><h3 id="か"><a href="#か" class="headerlink" title="か"></a>か</h3><p>助词，疑问句的标志。<br>日语中，在非疑问句末尾加上”か”，就可以表达疑问的意思。且日语的问句不以“？”结束，而以”。”结束。</p><blockquote><p>森さんはジエーシー企画の社員ですか。</p></blockquote><h3 id="の"><a href="#の" class="headerlink" title="の"></a>の</h3><p>名1 <code>の</code> 名2<br>助词，助词连接名词和名词，表示前面名词是后面名词从属的机构、国家、属性等。又是相当于中文的”的”</p><blockquote><p>森さんはジエーシー企画の社員です。</p></blockquote><h2 id="词组"><a href="#词组" class="headerlink" title="词组"></a>词组</h2><h3 id="称谓：-さん"><a href="#称谓：-さん" class="headerlink" title="称谓：~さん"></a>称谓：~さん</h3><p>接在姓氏后面，不分男女，表示礼貌尊敬<br>还可以接在职业的词后，同样表示礼貌尊敬，比如:学生さん<br>日本人对话时，一般不用”あなた”，而是习惯称呼对方的姓氏，在其后加さん</p><h3 id="称谓：-ちゃん-君"><a href="#称谓：-ちゃん-君" class="headerlink" title="称谓：~ちゃん(君)"></a>称谓：~ちゃん(君)</h3><p>称呼小朋友可以使用ちゃん<br>朋友或熟人之间，称呼和自己年龄相仿的男性还可以使用”君”(くん)</p><h2 id="句型"><a href="#句型" class="headerlink" title="句型"></a>句型</h2><h3 id="判断句-名1-は-名2-です-名1是名2"><a href="#判断句-名1-は-名2-です-名1是名2" class="headerlink" title="判断句: 名1 は 名2 です　(名1是名2)"></a>判断句: 名1 <code>は</code> 名2 <code>です</code>　(名1是名2)</h3><blockquote><p>日语的语序</p><blockquote><p>日语的谓语和宾语位置与中文不同，日语的谓语永远在句末<br>吉田さんは学生です<br>主语(主题)宾语谓语</p></blockquote></blockquote><h3 id="判断句-名1-は-名2-ではありません-名1不是名2"><a href="#判断句-名1-は-名2-ではありません-名1不是名2" class="headerlink" title="判断句: 名1 は 名2 ではありません　(名1不是名2)"></a>判断句: 名1 <code>は</code> 名2 <code>ではありません</code>　(名1不是名2)</h3><p>ではありません是です的否定形式，相当于”不是”。<br>口语中，”では”可以用”じゃ”代替 </p><h3 id="一般疑问句：名1-は-名2-ですか-名1是名2吗？"><a href="#一般疑问句：名1-は-名2-ですか-名1是名2吗？" class="headerlink" title="一般疑问句：名1 は 名2 ですか　(名1是名2吗？)"></a>一般疑问句：名1 <code>は</code> 名2 <code>ですか</code>　(名1是名2吗？)</h3><h3 id="一般疑问句的应答-あの人は田中さんですか。"><a href="#一般疑问句的应答-あの人は田中さんですか。" class="headerlink" title="一般疑问句的应答:あの人は田中さんですか。"></a>一般疑问句的应答:あの人は田中さんですか。</h3><p>对一般疑问句的应答必须先回答”はい”或”いいえ”</p><h4 id="肯定回答"><a href="#肯定回答" class="headerlink" title="肯定回答"></a>肯定回答</h4><p>肯定回答后，把谓语重复一遍</p><ul><li>はい、田中さんです。</li></ul><p>或者直接使用”そう”，”そう”的意思是”那样”，即对方提到的情况</p><ul><li>はい、そうです。</li></ul><h4 id="否定回答"><a href="#否定回答" class="headerlink" title="否定回答"></a>否定回答</h4><p>否定回答后，把谓语重复一遍</p><ul><li>いいえ、田中さんではありません。</li></ul><p>或者直接使用”ちがいます”</p><ul><li>いいえ、ちがいます。</li></ul><h4 id="我不清楚"><a href="#我不清楚" class="headerlink" title="我不清楚"></a>我不清楚</h4><ul><li>すっみません、わかりません。</li></ul>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
      <category>日语课程</category>
      
      <category>标准日本语初级_上册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日语</tag>
      
      <tag>日语语法</tag>
      
      <tag>上课笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日语发音</title>
    <link href="/2023/01/08/%E6%97%A5%E8%AF%AD/%E6%9D%82/%E6%97%A5%E8%AF%AD%E5%8F%91%E9%9F%B3/"/>
    <url>/2023/01/08/%E6%97%A5%E8%AF%AD/%E6%9D%82/%E6%97%A5%E8%AF%AD%E5%8F%91%E9%9F%B3/</url>
    
    <content type="html"><![CDATA[<p>本文指出了日语中的一些需要特别注意的发音方式</p><h2 id="辅音的发音"><a href="#辅音的发音" class="headerlink" title="辅音的发音"></a>辅音的发音</h2><h3 id="长音"><a href="#长音" class="headerlink" title="长音"></a>长音</h3><p>a段假名加元音a读作长音<br>i段假名加元音i读作长音<br>u段假名加元音u读作长音<br>e段假名加元音e&#x2F;i读作长音<br>o段假名加元音u&#x2F;o读作长音<br>外来语的长音:加一</p><h3 id="促音"><a href="#促音" class="headerlink" title="促音"></a>促音</h3><p>前面的音发完后，做好发下一个音的嘴型，即空占一拍不发音<br>但是在位于さ行假名之前，需要漏发出s的音</p><h2 id="日语的声调"><a href="#日语的声调" class="headerlink" title="日语的声调"></a>日语的声调</h2><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ul><li>平板型：第一拍低，之后全高    桥はし</li><li>头高型：第一拍高，之后全低箸はし</li><li>中高型：第一拍低，第二个以后的某个音节降下来</li><li>尾高型：第一拍低，之后全高，知道后续助词的地方才降下来</li></ul><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>第一个音节必定和第二个音节发音相反</li><li>一个单词的声调中，或没有下降，或只有一处下降</li></ul><blockquote><p>复合名词的音调</p><blockquote><p>复合名词的音调遵循一定的规律<br>一般是在第二个词的第一个假名后开始降调<br>ぺきん|だいがく|ぺきんだ<sub>下降</sub>いがく<br>东京|大学|东京大学</p></blockquote></blockquote><blockquote><p>发拗音时认为拗音是一个音节</p></blockquote><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>せんせい：音调为3,即<br>1<sub>下降</sub>2<sup>上升</sup>3<sup>上升</sup>4<sub>下降</sub><br>せ<sub>下降</sub>ん<sup>上升</sup>せ<sup>上升</sup>い<sub>下降</sub></p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
      <category>杂</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日语</tag>
      
      <tag>发音</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用中文键盘打日语</title>
    <link href="/2023/01/08/%E6%97%A5%E8%AF%AD/%E6%9D%82/%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87%E9%94%AE%E7%9B%98%E6%89%93%E6%97%A5%E8%AF%AD/"/>
    <url>/2023/01/08/%E6%97%A5%E8%AF%AD/%E6%9D%82/%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87%E9%94%AE%E7%9B%98%E6%89%93%E6%97%A5%E8%AF%AD/</url>
    
    <content type="html"><![CDATA[<p>本文指出了使用中文键盘拼写日语时的一些拼写方法</p><h2 id="五十音的拼写"><a href="#五十音的拼写" class="headerlink" title="五十音的拼写"></a>五十音的拼写</h2><p>んnn<br>をwo </p><h2 id="小写五十音的拼写"><a href="#小写五十音的拼写" class="headerlink" title="小写五十音的拼写"></a>小写五十音的拼写</h2><p>l+任意一个可小写的五十音&#x3D;小写的五十音<br>比如：ltu &#x3D;　っ</p><blockquote><p>拼写不出来，就是没有这个写法</p></blockquote><h2 id="促音"><a href="#促音" class="headerlink" title="促音"></a>促音</h2><p>只要促音后的五十音连敲两个，就可以拼出促音<br>学校　がっこう　gakkou</p><h2 id="浊音，半浊音"><a href="#浊音，半浊音" class="headerlink" title="浊音，半浊音"></a>浊音，半浊音</h2><p>虽然じぢ、ずづ发音相同，但是输入时还是需要这样输入<br>ざza じzi ずzu ぜze ぞzo<br>だda ぢdi づdu でde どdo</p><h2 id="长音"><a href="#长音" class="headerlink" title="长音"></a>长音</h2><p>‘ー’即输入’-‘<br>比如：ノート no-to</p><h2 id="拗音"><a href="#拗音" class="headerlink" title="拗音"></a>拗音</h2><p>きゃkya きゅkyu きょkyo</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
      <category>杂</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作流程</tag>
      
      <tag>日语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MakeDown语法</title>
    <link href="/2023/01/08/%E8%A7%84%E8%8C%83/MakeDown%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/01/08/%E8%A7%84%E8%8C%83/MakeDown%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>本文为使用Hexo时，笔记中使用的MakeDown语法的记录。</p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><h3 id="一号标题"><a href="#一号标题" class="headerlink" title="一号标题"></a>一号标题</h3><pre><code class="hljs"># 内容</code></pre><h3 id="二号标题"><a href="#二号标题" class="headerlink" title="二号标题"></a>二号标题</h3><pre><code class="hljs">## 内容</code></pre><h3 id="三号标题"><a href="#三号标题" class="headerlink" title="三号标题"></a>三号标题</h3><pre><code class="hljs">### 内容</code></pre><h3 id="四号标题"><a href="#四号标题" class="headerlink" title="四号标题"></a>四号标题</h3><pre><code class="hljs">#### 内容</code></pre><h3 id="五号标题"><a href="#五号标题" class="headerlink" title="五号标题"></a>五号标题</h3><pre><code class="hljs">##### 内容</code></pre><h3 id="六号标题"><a href="#六号标题" class="headerlink" title="六号标题"></a>六号标题</h3><pre><code class="hljs">###### 内容</code></pre><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><pre><code class="hljs">---- 或 **** (大于三个)</code></pre><h2 id="文字设置"><a href="#文字设置" class="headerlink" title="文字设置"></a>文字设置</h2><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><pre><code class="hljs">*内容*</code></pre><p>样式：<font size=6 face="黑体"><em>内容</em></font></p><h3 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a>粗体</h3><pre><code class="hljs">**内容**</code></pre><p>样式：<font size=6 face="黑体"><strong>内容</strong></font></p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><pre><code class="hljs">~~内容~~</code></pre><p>样式：<font size=6 face="黑体"><del>内容</del></font></p><h3 id="颜色字号字体"><a href="#颜色字号字体" class="headerlink" title="颜色字号字体"></a>颜色字号字体</h3><pre><code class="hljs">&lt;font color=red size=6 face=&quot;黑体&quot;&gt;红色6号黑体&lt;/font&gt;</code></pre><p>样式：<font color=red size=6 face="黑体">红色6号黑体</font></p><h3 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h3><pre><code class="hljs">2&lt;sup&gt;2&lt;/sup&gt;</code></pre><p>样式：2<sup>2</sup></p><h3 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h3><pre><code class="hljs">H&lt;sub&gt;2&lt;/sub&gt;O</code></pre><p>样式：H<sub>2</sub>O</p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><pre><code class="hljs">[超链接显示名](网站网址)</code></pre><p>样式：<a href="http://localhost:4000/">超链接显示名</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><pre><code class="hljs">![图片显示名](图片Base64字符串或图片网址)</code></pre><blockquote><p>使用Base64工具将图片转为Base64字符串:<a href="https://base64.us/">Base64 在线编码解码</a><br>样式：<img src="data:image/png;base64,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" alt="Git Error 10054"></p></blockquote><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>单个-、+或*符号(加空格)代表无序列表，可嵌套</p><pre><code class="hljs">+ 一层    - 二层        * 三层            + 四层</code></pre><p>样式：</p><ul><li>一层<ul><li>二层<ul><li>三层<ul><li>四层</li></ul></li></ul></li></ul></li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>使用1.(加空格)表示有序列表，可嵌套。</p><pre><code class="hljs">1. 一层    1.  二层        1. 三层            1. 四层    2. 一层</code></pre><p>样式：</p><ol><li>一层<ol><li>二层<ol><li>三层<ol><li>四层</li></ol></li></ol></li><li>一层</li></ol></li></ol><h2 id="文字引用"><a href="#文字引用" class="headerlink" title="文字引用"></a>文字引用</h2><p>使用多个&gt;(加空格)表示，多个&gt;代表多层</p><blockquote><p>一般写注释内容</p><blockquote><p>注释的注释<br>直接在&gt;&gt;后一行用&gt;没办法分离出来</p></blockquote></blockquote><blockquote><p>必须空一行再加&gt;就可以分离出来了</p></blockquote><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><h3 id="行内代码块"><a href="#行内代码块" class="headerlink" title="行内代码块"></a>行内代码块</h3><pre><code class="hljs">`ctrl + c`</code></pre><p>样式：<code>ctrl + c</code></p><h3 id="任意代码块"><a href="#任意代码块" class="headerlink" title="任意代码块"></a>任意代码块</h3><p>四个空格或一个制表符</p><h4 id="代码高亮以及行数表示"><a href="#代码高亮以及行数表示" class="headerlink" title="代码高亮以及行数表示"></a>代码高亮以及行数表示</h4><p>使用&#96;&#96;&#96;来标记，可以在它后面加上源代码语言的标记，比如C、C++、java、javascript、Markdown等</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino">三个`<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span></span><br><span class="hljs-function"></span>&#123;<br>System.out.<span class="hljs-built_in">println</span>( <span class="hljs-string">&quot;Hello,world&quot;</span> );<br>&#125;<br>&#125;<br>三个`<br></code></pre></td></tr></table></figure><blockquote></blockquote><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><pre><code class="hljs">|售卖商品|数量|单价||:-|:-:|-:||苹果|10|\$1||电脑|1|\$1000|</code></pre><table><thead><tr><th align="left">售卖商品</th><th align="center">数量</th><th align="right">单价</th></tr></thead><tbody><tr><td align="left">苹果</td><td align="center">10</td><td align="right">$1</td></tr><tr><td align="left">电脑</td><td align="center">1</td><td align="right">$1000</td></tr></tbody></table><blockquote><p>:-左对齐、:-:居中、-:右对齐<br>更多内容参考:<em><a href="https://www.cnblogs.com/lxd-koi/p/16996368.html">https://www.cnblogs.com/lxd-koi/p/16996368.html</a></em></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>规范</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MakeDown语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MakeDown笔记标准</title>
    <link href="/2023/01/08/%E8%A7%84%E8%8C%83/MakeDown%E7%AC%94%E8%AE%B0%E6%A0%87%E5%87%86/"/>
    <url>/2023/01/08/%E8%A7%84%E8%8C%83/MakeDown%E7%AC%94%E8%AE%B0%E6%A0%87%E5%87%86/</url>
    
    <content type="html"><![CDATA[<p>本文为使用写作MakeDown笔记时，个人的标准手册。</p><h2 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h2><p>笔记开始加上hexo固定内容与笔记简单概括</p><blockquote><p>MakeDown真不错，调查发现它已经固定了很多排版。<br>虽然可选择性少了，但是它给的排版即省事又美观。</p></blockquote><h2 id="语法使用"><a href="#语法使用" class="headerlink" title="语法使用"></a>语法使用</h2><h3 id="表达键盘操作或键入内容"><a href="#表达键盘操作或键入内容" class="headerlink" title="表达键盘操作或键入内容"></a>表达键盘操作或键入内容</h3><pre><code class="hljs">&lt;font color=orange&gt;`Ctrl + C`&lt;/font&gt; </code></pre><p>样式： <font color=orange><code>Ctrl + C</code></font></p><h3 id="表达对某段内容的解释"><a href="#表达对某段内容的解释" class="headerlink" title="表达对某段内容的解释"></a>表达对某段内容的解释</h3><pre><code class="hljs">&gt; 大概就是&quot;PS:&quot;的感觉</code></pre><p>样式：</p><blockquote><p>大概就是”PS:”的感觉</p></blockquote><h3 id="直接表示链接"><a href="#直接表示链接" class="headerlink" title="直接表示链接"></a>直接表示链接</h3><pre><code class="hljs">*https://blog.csdn.net/weixin_41978699/article/details/126261808*</code></pre><p>样式：<em><a href="https://blog.csdn.net/weixin_41978699/article/details/126261808">https://blog.csdn.net/weixin_41978699/article/details/126261808</a></em></p>]]></content>
    
    
    <categories>
      
      <category>规范</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>MakeDown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo使用笔记</title>
    <link href="/2023/01/08/Hexo/Hexo%20%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/01/08/Hexo/Hexo%20%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>本文为Hexo Fluid风格博客的个人使用方法笔记<br>具体官方引导请参照：<a href="https://hexo.fluid-dev.com/docs/">Hexo Fluid 用户手册</a></p><h2 id="上传更新笔记"><a href="#上传更新笔记" class="headerlink" title="上传更新笔记"></a>上传更新笔记</h2><h3 id="新建笔记"><a href="#新建笔记" class="headerlink" title="新建笔记"></a>新建笔记</h3><p>本地博客目录下\source_posts 中新建MakeDown笔记</p><h3 id="Git-Bash"><a href="#Git-Bash" class="headerlink" title="Git Bash"></a>Git Bash</h3><p>本地博客目录下右键打开 Git Bash Here 命令窗口</p><h3 id="静态部署"><a href="#静态部署" class="headerlink" title="静态部署"></a>静态部署</h3><ol><li><p>输入 <font color=orange><code>hexo clean</code></font> 清除缓存文件和静态文件</p></li><li><p>再输入 <font color=orange><code>hexo g</code></font> 生成网站静态文件到默认设置的 public 文件夹</p></li></ol><h3 id="启用Hexo服务"><a href="#启用Hexo服务" class="headerlink" title="启用Hexo服务"></a>启用Hexo服务</h3><ol><li><p>输入 <font color=orange><code>hexo clean</code></font> 清除缓存文件和静态文件</p></li><li><p>再输入 <font color=orange><code>hexo s</code></font> 启动本地服务器</p></li><li><p>预览主题: <em><a href="http://localhost:4000/">http://localhost:4000/</a></em></p></li></ol><blockquote><p>预览的同时可以修改文章内容或主题代码，保存后刷新页面即可；</p></blockquote><blockquote><p>对 Hexo 根目录 _config.yml 的修改，需要重启本地服务器后才能预览效果。</p></blockquote><h3 id="部署仓库"><a href="#部署仓库" class="headerlink" title="部署仓库"></a>部署仓库</h3><ol><li>使用 <font color=orange><code>ctrl + c</code></font> 结束服务器预览</li><li>输入 <font color=orange><code>hexo d</code></font> 自动生成网站静态文件，并部署到设定的仓库。<blockquote><p>有时会报如下错误<br><img src="data:image/png;base64,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" alt="Git Error 10054"><br>解决办法：等会重试一遍(蛮随机的)，或者用魔法</p></blockquote></li></ol><h4 id="查看效果"><a href="#查看效果" class="headerlink" title="查看效果"></a>查看效果</h4><p>访问<a href="https://godxqi.github.io/">GODXQI Hexo 主页</a></p><blockquote><p>结果可能会延迟</p></blockquote><blockquote><p>命令简化:使用’|’串联多个命令<br>如：<font color=orange><code>hexo clean|hexo g|hexo clean|hexo s</code></font><br>虽然报错了，但看起来能用</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作流程</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
