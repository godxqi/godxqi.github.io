<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>国富论</title>
    <link href="/2023/01/15/%E9%98%85%E8%AF%BB/%E5%9B%BD%E5%AF%8C%E8%AE%BA/"/>
    <url>/2023/01/15/%E9%98%85%E8%AF%BB/%E5%9B%BD%E5%AF%8C%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>第一编<br>论劳动生产力改进的原因，兼论劳动产品在不同阶级的人民间自然分配的顺序</p><p>劳动分工提高效率，提高同一批人完成工作量增加<br>-工人熟练度增加<br>-节约转换工作所需要的时间<br>-发明机器简化了劳动</p><p>劳动分工起源于人的特性:交换<br>当一个人发现自己做某件事比做其他事很容易获得利益后，他就会专职做这件事来获得更多利益，再用自己劳动的剩余部分与他人交换自己所需的物品，这就促进了职业的诞生<br>分工与交换使个体的才能成为共同财富<br>市场很小时，对物品需求小，物品种类小，无法用自己劳动的剩余部分与他人交换到自己所需的物品，所以抑制了职业的诞生，影响了分工的范围</p><p>货币的起源<br>由于物物交换的困难，导致选用某种商品作为货币<br>最终采用金属，因其耐久和可分</p><p>铸币制度和造币厂的诞生<br>防止造假，使用公章</p><p>使用价值与交换价值<br>具有最大的使用价值的东西，常常很少或根本没有交换价值；反之亦然</p><p>(而且，他似乎一再把某种商品可以交换到的劳动量同生产该商品所花费的劳动量混淆在一起，因为可以交换的劳动量必定是商品的交换价值，而不是商品的使用价值)</p><p>商品的价值</p>]]></content>
    
    
    <categories>
      
      <category>阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>struct cdev</title>
    <link href="/2023/01/15/%E5%BC%95%E7%94%A8/struct_cdev/"/>
    <url>/2023/01/15/%E5%BC%95%E7%94%A8/struct_cdev/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/ecbtnrt/article/details/6686138?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">https://blog.csdn.net/ecbtnrt/article/details/6686138?utm_medium&#x3D;distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source&#x3D;distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param</a></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">cdev</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">kobject</span> kobj;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">module</span> *owner;<br>    const <span class="hljs-keyword">struct</span> <span class="hljs-type">file_operations</span> *ops;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">list_head</span> list;<br>    dev_t dev;<br>    unsigned int count;<br>&#125;;<br></code></pre></td></tr></table></figure><p>问题：注册的这个字符设备到底注册到哪里去了？</p><p>参数1：struct kobject</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">kobject</span> &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>        *name;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_head</span>    entry;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">kobject</span>        *parent;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">kset</span>        *kset;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">kobj_type</span>    *ktype;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sysfs_dirent</span>    *sd;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">kref</span>        kref;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> state_initialized:<span class="hljs-number">1</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> state_in_sysfs:<span class="hljs-number">1</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> state_add_uevent_sent:<span class="hljs-number">1</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> state_remove_uevent_sent:<span class="hljs-number">1</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> uevent_suppress:<span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>主要的操作有</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">extern void kobject<span class="hljs-constructor">_init(<span class="hljs-params">struct</span> <span class="hljs-params">kobject</span> <span class="hljs-operator">*</span><span class="hljs-params">kobj</span>, <span class="hljs-params">struct</span> <span class="hljs-params">kobj_type</span> <span class="hljs-operator">*</span><span class="hljs-params">ktype</span>)</span>;<br>extern void kobject<span class="hljs-constructor">_del(<span class="hljs-params">struct</span> <span class="hljs-params">kobject</span> <span class="hljs-operator">*</span><span class="hljs-params">kobj</span>)</span>;<br>extern <span class="hljs-keyword">struct</span> kobject *kobject<span class="hljs-constructor">_get(<span class="hljs-params">struct</span> <span class="hljs-params">kobject</span> <span class="hljs-operator">*</span><span class="hljs-params">kobj</span>)</span>;<br>extern void kobject<span class="hljs-constructor">_put(<span class="hljs-params">struct</span> <span class="hljs-params">kobject</span> <span class="hljs-operator">*</span><span class="hljs-params">kobj</span>)</span>;extern void kobject<span class="hljs-constructor">_put(<span class="hljs-params">struct</span> <span class="hljs-params">kobject</span> <span class="hljs-operator">*</span><span class="hljs-params">kobj</span>)</span>;<br></code></pre></td></tr></table></figure><p>cdev_add里面只调用了一个函数：kobj_map(cdev_map, dev, count, NULL, exact_match, exact_lock, p)</p><p>cdev_map是fs&#x2F;char_dev.h里定义的一个结构体变量，而kobj_map的作用就是初始化它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">kobj_map</span> *cdev_map;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">kobj_map</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">probe</span> &#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">probe</span> *next;<br>        <span class="hljs-type">dev_t</span> dev;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> range;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">module</span> *owner;<br>        <span class="hljs-type">kobj_probe_t</span> *get;<br>        <span class="hljs-built_in">int</span> (*lock)(<span class="hljs-type">dev_t</span>, <span class="hljs-type">void</span> *);<br>        <span class="hljs-type">void</span> *data;<br>    &#125; *probes[<span class="hljs-number">255</span>];<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">mutex</span> *lock;<br>&#125;;<br></code></pre></td></tr></table></figure><p>kobj_map:</p><p>内核中所有的字符设备都会记录在一个 kobj_map 结构的 cdev_map 变量中。这个结构的变量中包含一个散列表用来快速存取所有的对象。kobj_map() 函数就是用来把字符设备编号和 cdev 结构变量一起保存到 cdev_map 这个散列表里。当后续要打开一个字符设备文件时，通过调用 kobj_lookup() 函数，根据设备编号就可以找到 cdev 结构变量，从而取出其中的 ops 字段。</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>.owner与THIS_MODULE</title>
    <link href="/2023/01/15/%E5%BC%95%E7%94%A8/-owner%E4%B8%8ETHIS_MODULE/"/>
    <url>/2023/01/15/%E5%BC%95%E7%94%A8/-owner%E4%B8%8ETHIS_MODULE/</url>
    
    <content type="html"><![CDATA[<p>.owner &#x3D; THIS_MODULE：</p><p><a href="https://blog.csdn.net/heybeaman/article/details/79583649">https://blog.csdn.net/heybeaman/article/details/79583649</a></p><p><a href="https://blog.csdn.net/lqxandroid2012/article/details/46122311">https://blog.csdn.net/lqxandroid2012/article/details/46122311</a></p><p>（一）struct module结构体</p><p>我们使用工具insmod插入一个内核模块时，该工具实际上调用了系统调用init_module，在该系统调用函数中会调用 load_module，把用户空间传入的整个内核模块文件创建成一个内核模块，返回一个struct module结构体。内核中便以这个结构体代表这个内核模块。（使用rmmod工具卸载模块时，也会调用系统调用delete_module），即：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">module</span><br>&#123;<br>    <span class="hljs-keyword">enum</span> module_state state;<br>    <span class="hljs-keyword">struct</span> list_head list;<br>    <span class="hljs-built_in">char</span> name[MODULE_NAME_LEN];<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>参数：</p><p>（1）state是模块当前的状态。它是一个枚举型变量，可取的值为：</p><ul><li>MODULE_STATE_LIVE：模块当前正常使用中</li><li>MODULE_STATE_COMING：模块当前正在被加载</li><li>MODULE_STATE_GOING：模块当前正在被卸载</li></ul><p>load_module函数中完成模块的部分创建工作后，把状态置为MODULE_STATE_COMING；</p><p>sys_init_module函数中完成模块的全部初始化工作后（包括把模块加入全局的模块列表，调用模块本身的初始化函数)，把模块状态置为MODULE_STATE_LIVE；</p><p>使用rmmod工具卸载模块时，会调用系统调用delete_module，会把模块的状态置为MODULE_STATE_GOING。</p><p>（2）list是作为一个列表的成员，所有的内核模块都被维护在一个全局链表中，链表头是一个全局变量struct module *modules。任何一个新创建的模块，都会被加入到这个链表的头部，通过modules-&gt;next即可引用到。</p><p>（3）name是模块的名字，一般会拿模块文件的文件名作为模块名。它是这个模块的一个标识。</p><p>（二）THIS_MODULE和owner</p><p>关于宏THIS_MODULE，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> THIS_MODULE (&amp;__this_module)</span><br></code></pre></td></tr></table></figure><p>__this_module就是一个struct module变量，代表着当前模块，跟current有几分相似。可以通过THIS_MODULE宏来引用当前模块的struct module结构，比如使用THIS_MODULE-&gt;state可以获得当前模块的状态。</p><p>owner正是一个struct module *类型的结构体指针，它是file_operation结构体里的一个成员，这个成员用来防止设备的方法正在被使用时模块被卸载. 几乎所有时间中, 它被简单初始化为THIS_MODULE。</p><p>（三）额外话题</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-title">.owner  =   THIS_MODULE,</span><br></code></pre></td></tr></table></figure><p>为什么要加点？</p><p>这是一种特殊的结构初始化方式。这种方式称为指定初始化，采用这种方式的优势就在于由此初始化不必严格按照定义时的顺序。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">book</span> &#123;<br>char <span class="hljs-built_in">title</span>[MAXTITL];<br>char author[MAXAUTL];<br>float value; <br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-type">book</span> surprise = &#123; .value = <span class="hljs-number">10.99</span> &#125;;     <span class="hljs-comment">//只初始化value</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-type">book</span> gift = &#123;    <span class="hljs-comment">//按照任意的顺序使用指定初始化项目</span><br>.value = <span class="hljs-number">25.99</span>,<br>.author = \<span class="hljs-string">&quot;James Broadfool\&quot;,</span><br><span class="hljs-string">.title = \&quot;Rue for the Toad\&quot;</span><br><span class="hljs-string">&#125;;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自己写c语言应用程序的时候，经常会使用printf来打印。</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E8%87%AA%E5%B7%B1%E5%86%99c%E8%AF%AD%E8%A8%80%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E7%BB%8F%E5%B8%B8%E4%BC%9A%E4%BD%BF%E7%94%A8printf%E6%9D%A5%E6%89%93%E5%8D%B0%E3%80%82/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E8%87%AA%E5%B7%B1%E5%86%99c%E8%AF%AD%E8%A8%80%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E7%BB%8F%E5%B8%B8%E4%BC%9A%E4%BD%BF%E7%94%A8printf%E6%9D%A5%E6%89%93%E5%8D%B0%E3%80%82/</url>
    
    <content type="html"><![CDATA[<p>自己写c语言应用程序的时候，经常会使用printf来打印。</p><p>printf在是一个标准库函数，功能是：打印(变量、字符串)等等。</p><p>问题：能不能依据printf的原理，写一个简易的用于裸机程序调试的my_printf函数呢？</p><p>好处：1)my_printf函数在单片机、嵌入式芯片裸机调试过程中非常方便。</p><p>      2)my_printf函数可以帮你打印寄存器的值、变量的值、打印字符串等。</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>printf的声明</p><p>int printf(const char *format, …);   </p><p>format:固定参数</p><p>…   :可变参数(变参)</p><p>…可放入多个参数，放入的参数依次存储在堆栈中</p><p>printf中的格式字符</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>可变参数</p><p>1）c语言指针的复习</p><p>2）代码：手工确定可变参数</p><p>        堆栈：X86平台，函数调用时参数传递时使用堆栈来实现的</p><p>        </p><p>        结构体字节对齐：由于在x86(32位机器)平台下，GCC编译器默认按4字节对齐，(如：结构体4字节对齐,即结构体成员变量所在的内存地址是4的整数倍。),可以通过使用gcc中__attribute__选项来设置指定的对齐大小。</p><p>        1）：__attribute__ ((packed))，让所作用的结构体取消在编译过程中的优化对齐，</p><p>按照实际占用字节数进行对齐。</p><p>        2）：__attribute((aligned (n)))，让所作用的结构体成员对齐在n字节边界上。</p><p>如果结构体中有成员变量的字节长度大于n，则按照最大成员变量的字节长度来对齐。</p><p>        在变参(可变参数)传递过程中，浮点数默认按照double类型存储</p><p>3）代码：自动确定可变参数</p><p>#include &lt;stdarg.h&gt;</p><p>va_list    p;            </p><p>va_start(p,fmt );         </p><p>va_arg( p, int);          </p><p>va_end( p );             </p><p>vc6.0中的stdarg.h</p><p>typedef char *  <span style="background-color: #ffaaaa">va_list</span>;</p><p>&#x2F;&#x2F;当sizeof(n)&#x3D;1&#x2F;2&#x2F;4时,_INTSIZEOF(n)等于4</p><p>#defin e _INTSIZEOF(n)   ( (sizeof(n) + sizeof(int) - 1) &amp; ~(sizeof(int) - 1) )</p><p>#define <span style="background-color: #ffaaaa">va_start(ap,v)</span>  ( ap &#x3D; (va_list)&amp;v + _INTSIZEOF(v) )</p><p>&#x2F;*</p><p>    va_start(p, format )  ( p &#x3D; (char *)&amp;format + _INTSIZEOF(format) )</p><p>                          ( p &#x3D; (char *)&amp;format + _INTSIZEOF(char *) )</p><p>                          ( p &#x3D; (char *)&amp;format + 4 )</p><p>*&#x2F;</p><p>#define <span style="background-color: #ffaaaa">va_arg(ap,t</span>)    ( *(t *)((ap +&#x3D; _INTSIZEOF(t)) - _INTSIZEOF(t)) )</p><p>#define va_arg(ap,t)    (ap &#x3D; ap + _INTSIZEOF(t), *(t *)(ap - _INTSIZEOF(t)))</p><p>#define va_arg(ap,t)    (*(t *)(ap &#x3D; ap + _INTSIZEOF(t), ap - _INTSIZEOF(t)))</p><p>#define <span style="background-color: #ffaaaa">va_end(ap)</span>      ( ap &#x3D; (va_list)0 )    </p><p> &#x2F;*</p><p>#define va_end(ap)      ( ap &#x3D; (char *)0 )    </p><p>*&#x2F;   </p><p>    </p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>硬件知识</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%A1%AC%E4%BB%B6%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%A1%AC%E4%BB%B6%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>点亮led</p><hr><p>来源：008_001</p><p><img src="/image/4f11108b552794cdf8763bebe27bbc9b.png" alt="4f11108b552794cdf8763bebe27bbc9b.png"></p><p><img src="/image/14ebab160f3c33634edd2bdb9356bd10.png" alt="14ebab160f3c33634edd2bdb9356bd10.png"></p><p><img src="/image/33efb8fb730c93e24d08be9f80dd6236.png" alt="33efb8fb730c93e24d08be9f80dd6236.png"></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>疑问与解答</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%96%91%E9%97%AE%E4%B8%8E%E8%A7%A3%E7%AD%94/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%96%91%E9%97%AE%E4%B8%8E%E8%A7%A3%E7%AD%94/</url>
    
    <content type="html"><![CDATA[<p>1.<img src="/image/8bac40b2c79ec86de990278267f0d483.png" alt="8bac40b2c79ec86de990278267f0d483.png"></p><p>但在第8课第9节的反汇编文件中可以看到是利用r3来保存局部变量的，这是为什么</p><p>答：在<a href="https://blog.csdn.net/chengdong1314/article/details/80423600">https://blog.csdn.net/chengdong1314/article/details/80423600</a></p><p><a href="https://blog.csdn.net/chengdong1314/article/details/80423600">https://blog.csdn.net/chengdong1314/article/details/80423600</a></p><p>了解到编译器对局部变量的处理方法不同，是否所用寄存器也是可以不同的？[ ] </p><p>还说要保存这些寄存器，为何没看到保存的处理代码？</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>裸机开发工具</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E8%A3%B8%E6%9C%BA%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<p><strong>目录</strong></p><hr><ol><li>001节_简介</li><li>002节_编辑器</li><li>003节_</li></ol><p>简介</p><hr><p>名词解释：gcc</p><p>    gcc是linux系统下主要的编译软件，</p><p>    gcc的全称是GNU编译器套件（GNU Compiler Collection），</p><p>    除了可以编译c语言开发的程序外，还可以开发C++、Java等多个语言的程序。</p><p>    GCC的初衷是为GNU操作系统专门编写的一款编译器。</p><p>使用gcc的原因：功能强大、稳定、开源免费。</p><p>1）gcc  -v  查看gcc的版本，从而验证了gcc编译器正常。</p><p>不论你使用哪一个版本的gcc，只有后面能够正常编译就可以了。</p><p>2）gcc   -o   输出文件名    源文件</p><p>o:output</p><p>交叉编译模式：</p><p>    通常编译嵌入式程序的平台称为宿主机（如：PC的ubuntu系统，CPU架构为X86架构），</p><p>    运行嵌入式程序的平台成为目标机（如：某款ARM开发板，CPU架构为ARM架构）。</p><p>    在X86平台编辑和和编译器arm-linux-gcc编译ARM架构的程序，</p><p>    两者属于不同的架构平台，从而属于交叉编译模式。</p><p>    然后将程序烧写到ARM开发板中（下载方式有：JTAG、USB、SD卡、网络等多种方式），</p><p>    然后在开发板上运行该程序。</p><p>编辑器</p><p>推荐使用windows平台的source insight和notepad。</p><p>source insight在查看代码、编辑代码等功能时非常好用。</p><p>编译器</p><p>推荐使用arm-linux-gcc</p><p>arm-linux-gcc是基于linux平台的arm编译器。给arm芯片编译程序的，它是开源免费的编译器。</p><p>arm-linux-gcc功能强大、稳定、支持的arm芯片众多、更新速度快。</p><p>入门误区：使用ads、MDK</p><p>ads（停止更新）、MDK，是windows平台的编译器，功能较弱。</p><p>1）只适合个人或者小团队的开发，不适合于中型、大型团队的协作开发。</p><p>2）是收费软件。</p><p>    </p><p>编辑器</p><hr><p>source insight:c文件、h文件、ARM汇编文件</p><p>notepad：其他文件，如Makefile(简单理解为：指明了要编译哪些源文件、指定编译后的输出文件名)    </p><p>source insight是收费软件，但是这个软件可以免费35天。</p><p>推荐版本：3.5</p><ol><li>增加文件类型</li></ol><p>options--&gt;documents options中，将c source file的文件过滤设置为*.c;*.h;*.S</p><ol><li>新建项目(新建工程)</li></ol><p>project--&gt;new project，然后将相应的文件添加到该项目中。</p><ol><li>字体的设置(解决中文乱码)</li></ol><p>options--&gt;documents options中，将screen fonts设置为：宋体、常规、12、GB2312.</p><p>使用alt+F12来调整字体的等宽。</p><ol><li>说明一下source insight的窗口</li></ol><p>项目窗口：指明该项目中有哪些文件。</p><p>主窗口：显示当前打开文件的文件内容。</p><p>符号窗口：显示了当前打开文件的函数名、结构体名、宏定义等等。</p><p>上下文窗口：光标放在某个函数上(变量上、宏定义上)，在下面的上下文窗口就可以看到相应的定义。</p><ol><li>显示行号</li></ol><p>view--&gt;line number</p><ol><li>快速跳转到某一行</li></ol><p>工具栏中有一个go to line。</p><ol><li>高亮关键词</li></ol><p>光标放在关键词上，然后右键菜单---&gt;highlight word</p><ol><li>查看函数定义位置</li></ol><p>光标放在函数上，然后右键菜单---&gt;jump  to defintion，或者ctrl + 鼠标左键。</p><p>go back   (alt + ,)回到上一次光标所在位置，或者使用工具栏中的向左箭头。</p><p>go forward(alt + .)回到下一次光标所在位置，或者使用工具栏中的向右箭头。</p><ol><li>查找</li></ol><p>右键菜单--&gt;lookup reference，或者ctrl + &#x2F; 。</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链接地址，存储地址的理解</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%AD%98%E5%82%A8%E5%9C%B0%E5%9D%80%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%AD%98%E5%82%A8%E5%9C%B0%E5%9D%80%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>链接地址：</p><p>arm-linux-ld -Ttest 0x3000000 来指定了代码段的起始地址，也就是说代码的链接地址，就是在链接的是时候确立的。</p><p>存储地址：</p><p>我们编写的C代码，会被编译成汇编指令，在汇编阶段进一步变成机器码，最后加载到arm的内存中。即我们的汇编指令被存储在内存之中，而指令对应的地址，就是他的“存储地址”。其实“存储地址”的值，一直由pc这个寄存器所记载着。想改变“存储地址”的值直接改变pc好了（汇编指令和机器码是一一对应的，汇编其实就是机器码的助记符）</p><p>他们之间的关系是什么？</p><p>链接地址是指令应该运行的地方，也就是说，正常情况下指令的存储地址和链接地址应该是相同的，不然程序会出错。链接地址是在程序一开始链接时就已经确定了，目的就是规划整个程序，比如确定这个全局变量放在哪？那个静态又搁在哪？事前就确定好，那么到时程序访问的时候，就可以按照原先说好的位置去找他，那么这个“链接地址”就是我所说的“原先说好的位置”。而“存储地址”，就是“实际存在的位置”，如果说“原先说好的位置”和“实际存在的位置”不一样，那么出问题是必然的。</p><p>但是为什么说是可能出问题呢？那就是说存在：即使“链接地址”和“存储地址”不一样，也不会出错的代码——位置无关码。例如一些相对跳转指令b，bl（首先他们得不会去访问一些全局变量或者是静态变量）他们只需要在当前位置加上偏移量即可，不需要一个确切的地址。也就是说他们根本用不到链接地址，那么自然也就不会出错了。</p><p>为什么会存在两种地址？</p><p>引出代码重定位：当我们打开电脑的时候，硬盘上的程序会加载到内存中运行，这就是代码重定位！“实际存在的位置”是硬盘，“原先说好的位置”是内存。</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发板基本操作</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E5%BC%80%E5%8F%91%E6%9D%BF%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E5%BC%80%E5%8F%91%E6%9D%BF%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/%E5%BC%80%E5%8F%91%E6%9D%BF%E6%8E%A5%E5%8F%A3%E5%8F%8A%E8%BF%9E%E7%BA%BF.jpg" alt="开发板接口及连线.jpg"></p><p>eop常见问题</p><ol><li>未连接op&#x2F;eop到电脑</li><li>有其他程序在使用op&#x2F;eop (同一时间只能有一个程序使用它)</li><li>jtag线未接</li><li>开发板未上电</li><li>oflash xxx.bin 时当前目录下没有xxx.bin</li><li>烧写完后没有正确设置启动开关</li><li>烧写完后，op&#x2F;eop-----开发板之间的排线未断开, 导致程序无法运行</li></ol><p>使用uboot烧写裸板程序(大程序)</p><ol><li>使用op&#x2F;eop把u-boot.bin烧到nor flash</li><li>开发板设置为nor启动, 上电后马上在串口输入空格键，使板子进入UBOOT而不是启动板子上的内核</li><li>连接PC-----------开发板的usb device口; 安装驱动</li><li>在UBOOT的串口菜单中输入n (表示接收USB文件并烧写到NAND)</li><li>使用dnw_100ask.exe发送bin文件</li><li>uboot即会自动接收、烧写bin文件</li><li>断电、设为NAND启动、上电：运行nand上烧好的程序</li></ol><p>恢复出厂系统</p><ol><li>使用op&#x2F;eop烧写u-boot到nor&#x2F;nand, 设置为nor&#x2F;nand启动</li><li>上电后马上在串口输入空格键，使板子进入UBOOT而不是启动板子上的内核</li><li>连接PC-----------开发板的usb device口; 安装驱动</li><li>下载内核: 在UBOOT的串口菜单中输入k</li><li>使用dnw_100ask.exe发送uImage文件</li><li>uboot即会自动接收、烧写uImage文件</li><li>下载文件系统: 在UBOOT的串口菜单中输入y</li><li>使用dnw_100ask.exe发送 fs_qtopia.yaffs2 文件</li><li>uboot即会自动接收、烧写根文件系统</li><li>输入q退出UBOOT串口菜单, 执行命令删除参数分区: nand erase params</li><li>重启(对于QT文件系统，第一次重启时会要求你较准触摸屏)</li></ol><p>(如果触摸不准，可以等系统启动后在串口执行：rm &#x2F;etc&#x2F;pointercal 然后重启再次较准)</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单的汇编指令</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AE%80%E5%8D%95%E7%9A%84%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AE%80%E5%8D%95%E7%9A%84%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p><strong>简单的汇编指令</strong></p><hr><p>（一）LDR：读内存。</p><p>-LDR R0,[R1]假设R1的值为X，读取地址X上的数据(4字节)，保存到R0中。即把R1数据读出来到R0中</p><p>-LDR R0，Label ；Label为程序标号，Label必须是当前指令的-4~4KB范围内；该指令是将Label地址中的值给r0(一般为机器码，若用了.word x给出的就是x的地址值)<a href="https://blog.csdn.net/qq1113231395/article/details/83650069">https://blog.csdn.net/qq1113231395/article/details/83650069</a></p><p>LDR r, label 和 LDR r, &#x3D;label的区别：</p><p>LDR r, &#x3D;label 会把label表示的值(label的地址)加载到寄存器中，而LDR r, label会把label当做地址，把label指向的地址中的值加载到寄存器中。（LDR r, &#x3D;label用作大范围的地址读取伪指令）</p><p>譬如 label的值是 0x8000， LDR r, &#x3D;label会将 0x8000加载到寄存器中，而LDR r, label则会将内存0x8000处的值加载到寄存器中。</p><p>（二）STR：写内存命令。</p><p>STR R0，[R1]，＃8；将R0中的字数据写入以R1为地址的存储器中，并将新地址R1＋8写入R1。</p><p>STR R0，[R1，＃8]；将R0中的字数据写入以R1＋8为地址的存储器中。</p><p>（三）B：跳转</p><p>（四）MOV： MOV R0,R1            &#x2F;&#x2F;把R1的值赋给R0</p><p>MOV R0,#0x100    &#x2F;&#x2F;R0&#x3D;0X100</p><p>MOV R0,#0x12345678 &#x2F;&#x2F;error，因为一条ARM指令中仅有32位，而MOV和R0占了一定字节，剩下的空间不足以表示任意值(0x12345678)，只能表示简单值(比如0x100，这种数被称为立即数)</p><p>（五）LDR R0,&#x3D;0X12345678    &#x2F;&#x2F;R0&#x3D;0X12345678</p><p>此为伪指令，它会被拆分为几条真正的RAM指令</p><p>LDR r0, label  和 LDR r0, &#x3D;label的区别：</p><p>LDR r0, label  会把label当做地址，把label指向的地址中的值加载到r0中，相当于指针操作.</p><p>LDR r0, &#x3D;label 会把label表示的值加载到r0中，相当于直接赋值。</p><p>譬如 label的值是 0x8000， LDR r0, &#x3D;label会将 0x8000加载到r0中，而LDR r0, label则会将内存0x8000处的值加载到r0中。</p><p>（六）add R0,R1,#4：R0&#x3D;R1+4</p><p>sub R0,R1,#4：R0&#x3D;R1-4</p><p>sub R0,R1,R2：R0&#x3D;R1-R2</p><p>（七）BL：brarch and link</p><p>bl xxx：</p><ul><li>跳到XXX</li><li>把返回地址(下一条指令的地址)保存到lr寄存器</li></ul><p>（八）ldm：读内存，写入多个寄存器，高编号的寄存器存放在高地址 </p><p>stm：把多个寄存器的值写入内存，高编号的寄存器存放在高地址 </p><p>-ia：过后增加        -ib预先增加        -da过后减少        -db预先减少</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">/* sp!表示sp会等于指向的最终值sp&#x27; */</span><br><span class="hljs-keyword">stmdb</span>   <span class="hljs-built_in">sp</span>!, &#123;<span class="hljs-built_in">fp</span>, <span class="hljs-built_in">ip</span>, <span class="hljs-built_in">lr</span>, <span class="hljs-built_in">pc</span>&#125; <span class="hljs-comment">//sp&#x27;=sp-4=4092,4092到4095的内存中放pc;先压pc再增地址</span><br>                              <span class="hljs-comment">//sp&#x27;=sp&#x27;-4=4088,4088到4091的内存中放lr;再压lr</span><br>                              <span class="hljs-comment">//sp&#x27;=sp&#x27;-4=4084,4084到4087的内存中放ip;再压ip</span><br>                              <span class="hljs-comment">//sp&#x27;=sp&#x27;-4=4080,4080到4083的内存中放fp;再压fp</span><br><span class="hljs-comment">/* sp无感叹号表示sp修改后的地址值sp&#x27;不存入sp中 */</span><br><span class="hljs-keyword">ldmia</span>   <span class="hljs-built_in">sp</span>, &#123;<span class="hljs-built_in">fp</span>, <span class="hljs-built_in">sp</span>, <span class="hljs-built_in">pc</span>&#125;   <span class="hljs-comment">//和stmdb成对使用，达成入栈出栈操作</span><br>                           <span class="hljs-comment">//fp=4080到4083的内存中=原来保存的fp,sp&#x27;=sp+4=4084;先弹fp</span><br>                           <span class="hljs-comment">//sp=4084到4087的内存中=原来保存的ip,sp&#x27;=sp&#x27;+4=4088;先弹sp，</span><br>                             <span class="hljs-comment">//在之前的程序中将sp的初始值保存到了ip中，此处会将sp重新指向4096</span><br>                             <span class="hljs-comment">//此处的sp值的修改不会影响sp，因为ldmia是一个机器周期执行完的。</span><br>                           <span class="hljs-comment">//pc=4088到4091的内存中=原来保存的lr,sp&#x27;=sp&#x27;+4=4092;</span><br>                             <span class="hljs-comment">//而lr即为返回地址的值，把lr保存到pc就会跳到返回地址执行</span><br></code></pre></td></tr></table></figure><p>（九）BIC―――――位清除指令</p><p>指令格式：BIC{cond}{S} Rd,Rn,operand2</p><p>BIC指令将Rn 的值与操作数operand2 的反码按位逻辑”与”，结果存放到目的寄存器Rd 中。</p><p>指令示例：</p><p>-BIC R0,R0,#0x0F ；将R0最低4位清零，其余位不变结果存放在R0中。</p><p>-bic r0, r0, #(1&lt;&lt;7)  &#x2F;* 清除7位 *&#x2F;</p><p>（十）MRS：MRS{条件}     通用寄存器，程序状态寄存器（CPSR或SPSR）</p><p>MRS指令用于将程序状态寄存器的内容传送到通用寄存器中。</p><p>（十一）MSR：MSR{条件}     程序状态寄存器（CPSR戒SPSR）_&lt;域&gt;，操作数</p><p>MSR指令用亍将操作数的内容传送到程序状态寄存器的特定域中。</p><hr><p>typedef  void (*pfun)(void);         &#x2F;&#x2F; pfun 类型是 void(*)(void)</p><p>pfun main;                                       &#x2F;&#x2F; 定义一个函数：void (*main)(void);</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第022课_传感器</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AC%AC022%E8%AF%BE_%E4%BC%A0%E6%84%9F%E5%99%A8/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AC%AC022%E8%AF%BE_%E4%BC%A0%E6%84%9F%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>目录</strong></p><hr><ol><li>第001节_光敏电阻的使用</li><li>第002节_高精度延时函数</li><li>第003节_DHT11温湿度传感器的使用</li><li>第004节_DS18B20温度传感器介绍</li><li>第005节_DS18B20温度传感器编程</li><li>第006节_红外线遥控协议简介及编程思路</li><li>第007节_前期编程_系统时间与环型缓冲区</li><li>第008节_HS0038红外线接收器的编程_打印原始脉冲</li><li>第009节_HS0038红外线接收器的编程_解析数据</li></ol><p><strong>第001节_光敏电阻的使用</strong></p><hr><p>这节课我们开始讲的传感器，有光敏电阻、DH11温湿度传感器、DS18B20温度传感器、HS0038红外接收器。</p><p>首先介绍光敏电阻传感器。</p><p>光敏电阻有一个特点，就是它的阻值随光照强度变化而变化，</p><p>看一下它的原理图，R5是一个普通电阻，LAS1是光敏电阻，它们串联组成一个分压电路，</p><p>LAS1阻值变化，将会导致中间RES_AO测得的电压发生变化。</p><p><img src="/image/800px-Chapter22_lesson1_001.png" alt="800px-Chapter22_lesson1_001.png"></p><p>这个电路图有点绕，画一个示意图如下：</p><p><img src="/image/800px-Chapter22_lesson1_002.png" alt="800px-Chapter22_lesson1_002.png"></p><p>使用ADC测量A点的电压，可以得知LAS1的变化情况，这里的测量是一个模拟信号。</p><p>现在假如需要这个光敏系统在光照大于&#x2F;小于某个值时，发出中断，怎么办呢？</p><p>这里就需要再加一个比较的电路，B处的电压是可调电阻得到的电压，可以通过调节电阻进行变化。A、B两个电压最后接在一个比较器的“正负端”，当A&gt;B时，输出1，反之输出0。</p><p>通过调节可调电阻，可以实现对比较阈值的控制。</p><p>现在这个电路就即可得到模拟信号和数字信号。</p><p>现在就可以开始写程序了，复制前面024的代码为025_sensors，这是这一章的第一个项目，再创建个001_photoresistor文件夹，将代码都放进去。</p><p>再创建一个sensors文件夹用来放本课的所有传感器代码，然后再创建photoresistor文件夹放本节课代码，再在里面创建photoresistor.c。</p><p>在代码里面，我们要做两件事：</p><ol><li>启动ADC，读出AIN1电压值；</li><li>注册中断，当光线强度超过或小于某个阈值时，产生中断；</li></ol><p>打开工程里的adc代码，原来的adc_init，只初始化了adc0，现在我们要用AIN1，修改下代码，传入个参数就能初始化对应的AIN:</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ada">void adc_init(int channel)<br>&#123;<br>        /* [<span class="hljs-number">15</span>] : <span class="hljs-type">ECFLG</span>,  <span class="hljs-number">1</span> = <span class="hljs-keyword">End</span> <span class="hljs-keyword">of</span> A/D conversion  <br>         * [<span class="hljs-number">14</span>] : <span class="hljs-type">PRSCEN</span>, <span class="hljs-number">1</span> = A/D converter prescaler enable  <br>         * [<span class="hljs-number">13</span>:<span class="hljs-number">6</span>]: PRSCVL, adc clk = PCLK / (PRSCVL + <span class="hljs-number">1</span>)  <br>         * [<span class="hljs-number">5</span>:<span class="hljs-number">3</span>] : <span class="hljs-type">SEL_MUX</span>, <span class="hljs-number">000</span> = AIN <span class="hljs-number">0</span>  <br>         * [<span class="hljs-number">2</span>]   : <span class="hljs-type">STDBM</span>  <br>         * [<span class="hljs-number">0</span>]   : 1 = <span class="hljs-type">A</span>/D conversion starts <span class="hljs-keyword">and</span> this bit <span class="hljs-keyword">is</span> cleared after the startup.  <br>         */<br>        ADCCON = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">14</span>) | (<span class="hljs-number">49</span>&lt;&lt;<span class="hljs-number">6</span>) | (channel&lt;&lt;<span class="hljs-number">3</span>);<br><br>        ADCDLY = <span class="hljs-number">0</span>xff;       <br>&#125;<br></code></pre></td></tr></table></figure><p>后面的adc_read_ain0只能读取AIN0的数据，现在修改一下，传入个通道参数，就能读取对应通道的ADC值：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> adc<span class="hljs-constructor">_read(<span class="hljs-params">int</span> <span class="hljs-params">channel</span>)</span><br>&#123;<br>        adc<span class="hljs-constructor">_init(<span class="hljs-params">channel</span>)</span>;<br>        <br>        <span class="hljs-comment">/* 启动ADC */</span><br>        ADCCON <span class="hljs-pattern-match">|= (1&lt;&lt;0);</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">        <span class="hljs-keyword">while</span> (!(<span class="hljs-constructor">ADCCON</span> &amp; (1&lt;&lt;15)));  <span class="hljs-operator">/</span><span class="hljs-operator">*</span> 等待<span class="hljs-constructor">ADC</span>结束 <span class="hljs-operator">*</span><span class="hljs-operator">/</span></span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">        return <span class="hljs-constructor">ADCDAT0</span> &amp; 0x3ff;</span><br><span class="hljs-pattern-match">&#125;</span><br></code></pre></td></tr></table></figure><p>修改了这两个函数，原来的adc_test函数里调用的adc读取函数也要对应进行修改。</p><p>参考这个adc_test，编写photoresistor_test函数。</p><p>需要修改的内容并不多，首先是修改adc_read参数，将通道0改为通道1。</p><p>然后我们想同时再把AIN0上的滑动电阻对应的电压也读出来，因此再做一次ADC0读取的操作。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs awk">void photoresistor_test(void)<br>&#123;<br>        int val, val0;<br>        double vol, vol0;<br>        int m, m0; <span class="hljs-regexp">/* 整数部分 */</span><br>        int n, n0; <span class="hljs-regexp">/* 小数部分 */</span><br>        <br>        <span class="hljs-regexp">//</span>adc_init();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        &#123;<br>                val = adc_read(<span class="hljs-number">1</span>);<br>                vol = (double)val<span class="hljs-regexp">/1023*3.3;   /</span>* <span class="hljs-number">1023</span>----<span class="hljs-number">3.3</span>v */<br>                m = (int)vol;      <span class="hljs-regexp">/* 3.01, m = 3 */</span><br>                vol = vol - m;  <span class="hljs-regexp">/* 小数部分: 0.01 */</span><br>                n = vol * <span class="hljs-number">1000</span>;  <span class="hljs-regexp">/* 10 */</span><br><br>                val0 = adc_read(<span class="hljs-number">0</span>);<br>                vol0 = (double)val0<span class="hljs-regexp">/1023*3.3;   /</span>* <span class="hljs-number">1023</span>----<span class="hljs-number">3.3</span>v */<br>                m0 = (int)vol0;    <span class="hljs-regexp">/* 3.01, m = 3 */</span><br>                vol0 = vol0 - m0;       <span class="hljs-regexp">/* 小数部分: 0.01 */</span><br>                n0 = vol0 * <span class="hljs-number">1000</span>;  <span class="hljs-regexp">/* 10 */</span><br><br>                <span class="hljs-regexp">/* 在串口上打印 */</span><br>                printf(<span class="hljs-string">&quot;photoresistor vol: %d.%03dv, compare to threshold %d.%03dv\r&quot;</span>, m, n, m0, n0);  <span class="hljs-regexp">/* 3.010v */</span><br><br>                <span class="hljs-regexp">/* 在LCD上打印 */</span><br>                <span class="hljs-regexp">//</span>fb_print_string();<br>        &#125;<br></code></pre></td></tr></table></figure><p>以上就完成了我们的第一个目标。</p><p>现在开始做第二个目标，注册中断放在interrupt.c里实现。</p><p>硬件上RES_DO是EINT15。我们可以仿照之前的按键中断来编写本次的中断。</p><p>先分析一下中断，如图：</p><p><img src="/image/800px-Chapter22_lesson1_003.png" alt="800px-Chapter22_lesson1_003.png"></p><p>GPG7作为中断引脚，它会先经过外部中断EINTMASK寄存器，才能进入到中断控制器。</p><p>所以，需要做以下操作：</p><ol><li>首先初始化：</li></ol><p>a.GPG7配置为中断引脚；</p><p>b.设置中端触发方式：双边沿触发；</p><p>c.设置EINTMASK使能中断；</p><ol><li>中断处理：</li></ol><p>a.分辨：读EINTPEND;</p><p>b.读GPG7；</p><p>在原来的key_eint_init函数里配置GPG7为中断引脚:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">    /* 配置GPG7为中断引脚, 用于光敏电阻 */<br>    GPGCON &amp;= ~((3&lt;&lt;<span class="hljs-string">14));</span><br><span class="hljs-string">    GPGCON |= ((2&lt;&lt;14</span>));<br></code></pre></td></tr></table></figure><p>然后设置中端触发方式：双边沿触发</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">    <span class="hljs-comment">/* 设置中断触发方式: 双边沿触发 */</span><br>    EXTI<span class="hljs-symbol">NT0</span> |= <span class="hljs-comment">(7&lt;&lt;0)</span> | <span class="hljs-comment">(7&lt;&lt;8)</span>;     <span class="hljs-comment">/* S2,S3 */</span><br>    EXTI<span class="hljs-symbol">NT1</span> |= <span class="hljs-comment">(7&lt;&lt;12)</span>;             <span class="hljs-comment">/* S4 */</span><br>    EXTI<span class="hljs-symbol">NT2</span> |= <span class="hljs-comment">(7&lt;&lt;12)</span>;             <span class="hljs-comment">/* S5 */</span><br></code></pre></td></tr></table></figure><p>最后再使能中断：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">    <span class="hljs-regexp">/* 使能中断GPG7/</span>EINT15, 用于光敏电阻 */<br>    EINTMASK &amp;= ~((<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>));<br></code></pre></td></tr></table></figure><p>修改key_eint_irq中断处理函数，先判断是哪个中断产生，再读取电平，打印。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val <span class="hljs-operator">&amp;</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">15</span>)) <span class="hljs-comment">/* eint15, 用于光敏电阻 */</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (val2 <span class="hljs-operator">&amp;</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">7</span>))<br>            &#123;<br>                printf(<span class="hljs-string">&quot;<span class="hljs-subst">\n</span><span class="hljs-subst">\r</span>photoresistor dark!<span class="hljs-subst">\n</span><span class="hljs-subst">\r</span>&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                printf(<span class="hljs-string">&quot;<span class="hljs-subst">\n</span><span class="hljs-subst">\r</span>photoresistor light!<span class="hljs-subst">\n</span><span class="hljs-subst">\r</span>&quot;</span>);<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>至此，代码就写完了，最后还要修改对应的Makefile和主函数。</p><p><strong>第002节_高精度延时函数</strong></p><hr><p>在后续我们对讲解多个传感器，这几个传感器对时序的要求都比较高，比如温湿度传感器DH11，查看芯片手册时序，至少就需要微秒级的延时函数。</p><p>延时函数的方式一般有两种:</p><ol><li>使用for循环，利用示波器等工具测得精确值；</li><li>使用定时器，通过不断检测定时器的计数值获得精确时间；</li></ol><p>使用for循环的方式，可能会因为硬件的差异，导致延时函数不准，因此这里我们使用定时器的方式。</p><p>打开之前的timers.c文件，修改timer_init函数的配置。</p><p>PCLK仍然等于50000000，将prescaler value改为4，divider value设置为2，</p><p>这样，每减1, 对应0.2us；每减5, 对应1us；从50000减到0，对应10ms。</p><p>修改对应的寄存器：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">    TCFG0 = <span class="hljs-number">4</span>;  <span class="hljs-regexp">/* Prescaler 0 = 4, 用于timer0,1 */</span><br>    TCFG1 &amp;= ~<span class="hljs-number">0</span>xf; <span class="hljs-regexp">/* MUX0 : 1/</span><span class="hljs-number">2</span> */<br><br>    <span class="hljs-regexp">/* 设置TIMER0的初值 */</span><br>    TCNTB0 = <span class="hljs-number">50000</span>;  <span class="hljs-regexp">/* 10Ms中断一次 */</span><br></code></pre></td></tr></table></figure><p>我们先写一个us延时的函数，然后ms延时就调用us即可。</p><p>因此，us延时函数里，尽量少调用函数。</p><p>假如现在要延时nus，我们先将n*5，得到nus对应的“计数时钟数”。</p><p>然后如果传入“计数时钟周期”如果大于0，则一直计算过去了多少个“计数时钟数”，与传入的“计数时钟数”相减，直到为零，退出循环，也就实现了延时nus。</p><p>怎样计算过去了多少个“计算周期”呢？</p><p>自然是当前的值，减去一开始进入函数的值。</p><p>但还有一种情况是定时器里的计数记到0时，会自动变成5000，计数计数，这时候，计算方式就变成了pre+(5000-cur)：</p><p><img src="/image/700px-Chapter22_lesson2_001.png" alt="700px-Chapter22_lesson2_001.png"></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs excel">/* 尽量少调用函数 */<br>void udelay(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>)<br>&#123;<br>        <span class="hljs-built_in">int</span> cnt = <span class="hljs-built_in">n</span> * <span class="hljs-number">5</span>;  /* u us 对应<span class="hljs-built_in">n</span>*<span class="hljs-number">5</span>个计数值 */<br>        <span class="hljs-built_in">int</span> pre = TCNTO0;<br>        <span class="hljs-built_in">int</span> cur;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">delta</span>;<br><br>        while (cnt &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>                cur = TCNTO0;<br>                <span class="hljs-built_in">if</span> (cur &lt;= pre)<br>                        <span class="hljs-built_in">delta</span> = pre - cur;<br>                else<br>                        <span class="hljs-built_in">delta</span> = pre + (<span class="hljs-number">50000</span> - cur);<br><br>                cnt = cnt - <span class="hljs-built_in">delta</span>;<br>                pre = cur;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后时ms延时函数：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-built_in">mdelay</span>(int m)<br>&#123;<br>        <span class="hljs-built_in">udelay</span>(m*<span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以写一个测试函数，简单的测试下是否可用，测试函数隔1分钟进行打印一下。</p><p>如果us不准的话，放大至s，会有比较大的偏差，这样可以进行粗略的检测，精确检测可以使用示波器等工具。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hrtimer_test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;delay one min: &quot;</span>);<br>                <span class="hljs-built_in">mdelay</span>(<span class="hljs-number">60000</span>); <span class="hljs-comment">/* 延时1分钟 */</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n\r&quot;</span>, ++cnt);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>前面延时里的计算还是比较耗费时间的，因此，我们尽量提高CPU的运行时钟，并且 将尽可能的启动icache、dcache和mmu。</p><p>此外，如果延时过程中，发生了中断，如果中断比较耗时的话，就会导致延时可能出现不准确，所以，我们可以延时之前关中断, 延时之后开中断；</p><p>课后作业:</p><ul><li>a. 禁止icache, 禁止mmu, 修改lds, 测试延时函数是否还准确；</li><li>b. 测试延时之前关中断, 延时之后开中断；</li></ul><p><strong>第003节_DHT11温湿度传感器的使用</strong></p><hr><p>这节课开始讲解DH11温湿度传感器的使用，首先查看芯片手册，里面的典型应用电路如下：</p><p><img src="/image/700px-Chapter22_lesson3_001.png" alt="700px-Chapter22_lesson3_001.png"></p><p>MCU通过一条数据线与DH11连接，MCU通过这条线发命令给DH11，DH11再通过这条线把数据发送给MCU。</p><p>因此，温湿度模块的核心就是 MCU发给DH11的命令格式和DH11返回的数据格式。</p><p>再来先简单看一下通讯的时序：</p><p><img src="/image/700px-Chapter22_lesson3_002.png" alt="700px-Chapter22_lesson3_002.png"></p><p>灰色这条线是由MCU驱动控制的，浅色的部分是由DH11驱动控制的。</p><p>首先MCU发送一个开始信号，这个开始信号是一个低脉冲，然后再拉高。</p><p>然后，DH11拉低，做出一个响应信号，再拉高。</p><p>接着就是DH11返回的数据。</p><p>这些数据一共有40bit,高位先出。</p><p>数据格式:8bit湿度整数数据+8bit湿度小数数据+8bi温度整数数据+8bit温度小数数据+8bit校验和</p><p>且当前小数部分用于以后扩展,现读出为零.</p><p>数据传送正确时校验和数据等于“8bit湿度整数数据+8bit湿度小数数据+8bi温度整数数据+8bit温度小数数据”所得结果的末8位。</p><p>DH11的难点是前面所说的时序脉冲,需要满足一定的时长.比如开始信号:</p><p><img src="/image/700px-Chapter22_lesson3_003.png" alt="700px-Chapter22_lesson3_003.png"></p><p>MCU必须先拉低至少18ms,然后再拉高20-40us,DH11再拉低80us以响应,最后再拉高80us.</p><p>接下来就是传输数据,我们的目的就是读到温湿度的数据,这些数据由DH11提供,那它怎么传回这些数据,怎么表示0和1呢?</p><p><img src="/image/Chapter22_lesson3_004.png" alt="Chapter22_lesson3_004.png"></p><p><img src="/image/Chapter22_lesson3_005.png" alt="Chapter22_lesson3_005.png"></p><p>可以看到，不管是0还是1，都开始是50us的低电平，</p><p>对于0数据，之后是26~28us的高电平；</p><p>对于1数据，之后是70us的高电平;</p><p>有了上面的知识，加上之前的高精度延时，现在就可以开始写程序了。</p><p>复制前面的第二个程序，文件名改为003_dht11_022_003，然后在sensors目录里新建dht11目录，再创建一个dht11.c文件。</p><p>我们的目的是，控制GPIO读取DHT11的数据，流程如下：</p><ol><li>主机发出至少18MS的低脉冲: start信号</li><li>start信号变为高, 20-40us之后, dht11会拉低总线维持80us，然后拉高80us: 回应信号</li><li>之后就是数据, 逐位发送</li></ol><ul><li>bit0 : 50us低脉冲, 26-28us高脉冲</li><li>bit1 : 50us低脉冲, 70us高脉冲</li></ul><ol><li>数据有40bit: 8bit湿度整数数据+8bit湿度小数数据+8bit温度整数数据+8bit温度小数数据+8bit校验和</li></ol><p>DH11的DATA引脚连接到了GPG5。</p><p>先实现GPIO的基本操作，配置GPIO模式，实现输出、输入引脚的功能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dht11_data_cfg_as_output</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>        <span class="hljs-variable constant_">GPGCON</span> &amp;= ~(<span class="hljs-number">3</span>&lt;&lt;<span class="hljs-number">10</span>);<br>        <span class="hljs-variable constant_">GPGCON</span> |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">10</span>);<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dht11_data_cfg_as_input</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>        <span class="hljs-variable constant_">GPGCON</span> &amp;= ~(<span class="hljs-number">3</span>&lt;&lt;<span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>再设置输出电平或读取引脚数据：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">dht11_data_set</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">if</span> (val)<br>                GPGDAT |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">else</span><br>                GPGDAT &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">dht11_data_get</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">if</span> (GPGDAT &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>再来实现DHT11的读操作。</p><p>在芯片手册里介绍说，DH11传感器上电后，要等待1s，以越过不稳定状态，在此期间无需发送任何指令。</p><p>因此首先写一个初始化函数，跳过这个不稳定状态：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-built_in">dht11_init</span>(void)<br>&#123;<br>        <span class="hljs-built_in">dht11_data_cfg_as_output</span>();<br>        <span class="hljs-built_in">dht11_data_set</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">mdelay</span>(<span class="hljs-number">2000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>根据start时序要求，编写程序，维持一个大于18ms的低电平，然后释放引脚，及设置为输入引脚即可。</p><p>因为该引脚接有上拉电阻，一旦MCU设置为输入，引脚电平将有上拉电阻决定。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">static void <span class="hljs-built_in">dht11_start</span>(void)<br>&#123;<br>        <span class="hljs-built_in">dht11_data_set</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">mdelay</span>(<span class="hljs-number">20</span>);<br>        <span class="hljs-built_in">dht11_data_cfg_as_input</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>然后等待40us以上，再去读取引脚电平，判断是否被拉低，以确定DH11给了响应。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">static int <span class="hljs-built_in">dht11_wait_ack</span>(void)<br>&#123;<br>        <span class="hljs-built_in">udelay</span>(<span class="hljs-number">60</span>);<br>        return <span class="hljs-built_in">dht11_data_get</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>再写个延时函数，用于时序中的，等待响应信号结束：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static <span class="hljs-built_in">int</span> dht11<span class="hljs-constructor">_wait_for_val(<span class="hljs-params">int</span> <span class="hljs-params">val</span>, <span class="hljs-params">int</span> <span class="hljs-params">timeout_us</span>)</span><br>&#123;<br>        <span class="hljs-keyword">while</span> (timeout_us--)<br>        &#123;<br>                <span class="hljs-keyword">if</span> (dht11<span class="hljs-constructor">_data_get()</span><span class="hljs-operator"> == </span><span class="hljs-keyword">val</span>)<br>                        return <span class="hljs-number">0</span>; <span class="hljs-comment">/* ok */</span><br>                udelay(<span class="hljs-number">1</span>);<br>        &#125;<br>        return -<span class="hljs-number">1</span>; <span class="hljs-comment">/* err */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>后面的数据会有五个字节组成，这里先写出读取一个字节，每个字节要读取8位。</p><p>先等待直到高电平，过滤到共同的50us延时，然后延时28us以上，再读取引脚电平，</p><p>如果引脚电平是1，则数据是1，反之是0。</p><p>然后再直到低电平的到来，循环8次，完成一个字节数据的读取。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">dht11_recv_byte</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-type">int</span> data = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>        &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dht11_wait_for_val</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>))<br>                &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;dht11 wait for high data err!\n\r&quot;</span>);<br>                        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>                &#125;<br>                <span class="hljs-built_in">udelay</span>(<span class="hljs-number">40</span>);<br>                data &lt;&lt;= <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dht11_data_get</span>() == <span class="hljs-number">1</span>)<br>                        data |= <span class="hljs-number">1</span>;<br>                <br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dht11_wait_for_val</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1000</span>))<br>                &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;dht11 wait for low data err!\n\r&quot;</span>);<br>                        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> data;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第004节_DS18B20温度传感器介绍</strong></p><hr><p>比DHT11温湿度传感器精度高很多</p><p><img src="/image/Chapter22_lesson4_001.png" alt="Chapter22_lesson4_001.png"></p><p>DS18B20只通过一条数据线传输数据，既要控制器发送数据给芯片，又要通过芯片发送数据给控制器，所以这个是双向传输数据的</p><p>怎么在一个引脚上实现数据的双向传输 : 参考这视频的第19分钟之后的内容: 第19课_第001节_I2C协议与EEPROM</p><p>检测温度，我们需要一个主控芯片</p><p>如果有多个温度传感器，则需要一个主控制器去管理它们，通过发送命令传输数据，每个设备都会有固化在芯片内部的64bit ID的ROM来用于区分不同的设备</p><p>如果主控制器想访问设备，必须发送命令，这个命令中带有ID返回值</p><p>怎么访问指定的DS18B20</p><ol><li><p>发出低脉冲，提醒准备工作: initialization</p></li><li><p>发出ID命令:ROM Command</p></li><li><p>发出功能命令: Function Command</p><ul><li>a.转换温度</li><li>b.读温度，读数据</li></ul></li></ol><p>每次操作，都要重重上述过程</p><p>内部框图</p><p><img src="/image/700px-Chapter22_lesson4_002.png" alt="700px-Chapter22_lesson4_002.png"></p><p>TEMPERATURE SENSOR温度ADC</p><p>SCRATCHPAD实际上是一个9 byte的内存 9byte的说明如下图所示</p><p><img src="/image/700px-Chapter22_lesson4_003.png" alt="700px-Chapter22_lesson4_003.png"></p><p>温度值会保存在9byte内存中的 BYTE0 和 BYTE1 也就是当我们发出一个温度值的命令之后，还需要发送一个读内存的命令才能把温度值读取出来</p><p>最后一位是CRC校验码，通过前8位的数据和最后一位的校验码比较 64位数据中有8位是校验码，</p><p><strong>问题1：怎么采样温度？</strong></p><ol><li>初始化</li><li>ROM命令</li><li>FunctionCommand 设置某些值，比如转换温度</li><li>等待完成</li><li>init</li><li>R om cmd</li><li>Function Command 读RAM中的值</li></ol><p><img src="/image/Chapter22_lesson4_004.png" alt="Chapter22_lesson4_004.png"></p><p>关于EEPROM寄存器 前面两个字节可以用来设置用户自己的目的，也可以用来设置Th Tl 寄存器 Th Tl 寄存器就是用来设置警报，温度的上限或者下限，当温度超过某个值时它会发出警报 所谓警报只不过是在DS18B20中设置状态而已，并不能主动通知主芯片 主芯片可以发出某些命令来确定那些芯片发出了警报 配置寄存器，用于设置精度，精度越高转换时间越长</p><p>EEPROM使用</p><ol><li><p>上电</p><ul><li>EEPROM自动放入RAM用于控制精度这些</li></ul></li><li><p>写EEPROM</p><ul><li>发出命令先写RAM</li><li>从RAM传到EEPROM</li></ul></li><li><p>读出EEPROM的值</p><ul><li>EEPROM值保存到RAM</li><li>发出命令读RAM</li></ul></li></ol><p>关于ROM命令和功能命令整理成一个表格</p><p><img src="/image/00dad52bd88f2d5682c5812bcd27073c.png" alt="00dad52bd88f2d5682c5812bcd27073c.png"></p><p>信号传输</p><ol><li><p>怎么initialization(初始化)</p></li><li><p>怎么发数据，怎么发出1bit</p><ul><li>怎么发出bit0</li><li>怎么发出bit1</li></ul></li><li><p>怎么读数据&#x3D;&#x3D;&gt;怎么读1bit</p><ul><li>怎么判读读到0</li><li>怎么判断读到1</li></ul></li></ol><p>初始化时序</p><p><img src="/image/700px-Chapter22_lesson4_005.png" alt="700px-Chapter22_lesson4_005.png"></p><p>一开始是高电平，想要开始传输信号，必须要拉低至少480us释放总线 经过15<del>60us之后 DS18B20会把这条线拉低60</del>240us</p><p><strong>问题2：怎么发数据，怎么发出1bit</strong></p><ul><li>怎么发出bit0</li><li>怎么发出bit1</li></ul><p>写数据时序</p><p><img src="/image/700px-Chapter22_lesson4_006.png" alt="700px-Chapter22_lesson4_006.png"></p><p>不论是写0还是写1时序都是大于60us 写0拉低总线维持60us以上 写1时，信号线拉低1us时间，提醒要写数据了，让后回高，写1位之间的时间间隔1us</p><p><img src="/image/700px-Chapter22_lesson4_007.png" alt="700px-Chapter22_lesson4_007.png"></p><p>读数据时序 也是由主机发起 提醒脉冲大于1us,主机马上释放总线 在15us之内读信号，一个读周期至少是60us，每位的间隔也是1us</p><p>DS18B20提供了编程图</p><p><img src="/image/700px-Chapter22_lesson4_008.png" alt="700px-Chapter22_lesson4_008.png"></p><p>供电方式</p><p><img src="/image/700px-Chapter22_lesson4_009.png" alt="700px-Chapter22_lesson4_009.png"></p><p>参考资料: DS18B20 驱动编写 </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/zqixiao_09/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">50973969</span><br></code></pre></td></tr></table></figure><p>CRC8校验分析和DS18B20的CRC8编程实现方法 </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>www.<span class="hljs-number">360</span>doc.com<span class="hljs-regexp">/content/</span><span class="hljs-number">15</span><span class="hljs-regexp">/1230/</span><span class="hljs-number">17</span>/<span class="hljs-number">27708084</span>_524223594.shtml<br></code></pre></td></tr></table></figure><p><strong>第005节_DS18B20温度传感器编程</strong></p><hr><p>​设置精度相关的位</p><p><img src="/image/700px-Chapter22_lesson4_010.png" alt="700px-Chapter22_lesson4_010.png"></p><p>创建ds18b20目录 查看使用那个引脚</p><p><img src="/image/Chapter22_lesson4_011.png" alt="Chapter22_lesson4_011.png"></p><p>使用GPG6引脚</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-comment">#include &quot;../../s3c2440_soc.h&quot;</span><br><br><span class="hljs-comment">/* 使用GPG6作用ds18b20的DATA引脚 */</span><br><br><span class="hljs-comment">/*定义命令和函数的宏*/</span><br><span class="hljs-comment">/* rom commands */</span><br><span class="hljs-comment">#define SEARCH_ROM    0xF0</span><br><span class="hljs-comment">#define READ_ROM      0x33</span><br><span class="hljs-comment">#define MATCH_ROM     0x55</span><br><span class="hljs-comment">#define SKIP_ROM      0xCC</span><br><span class="hljs-comment">#define ALARM_ROM     0xEC</span><br><br><span class="hljs-comment">/* functions commands */</span><br><span class="hljs-comment">#define CONVERT_TEAMPERATURE 0x44</span><br><span class="hljs-comment">#define WRITE_SCRATCHPAD     0x4E</span><br><span class="hljs-comment">#define READ_SCRATCHPAD      0xBE</span><br><span class="hljs-comment">#define COPY_SCRATCHPAD      0x48</span><br><span class="hljs-comment">#define RECALL_EEPROM        0xB8</span><br><span class="hljs-comment">#define READ_POWER_SUPPLY    0xB4</span><br><br><span class="hljs-comment">/* 先实现GPIO的基本操作 */</span><br><span class="hljs-keyword">static</span> <span class="hljs-variable">void</span> <span class="hljs-title function_">ds18b20_data_cfg_as_output</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-variable">GPGCON</span> <span class="hljs-operator">&amp;</span><span class="hljs-operator">=</span> <span class="hljs-operator">~</span>(<span class="hljs-number">3</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">12</span>);<br>        <span class="hljs-variable">GPGCON</span> <span class="hljs-operator">|</span><span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">12</span>);<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-variable">void</span> <span class="hljs-title function_">ds18b20_data_cfg_as_input</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-variable">GPGCON</span> <span class="hljs-operator">&amp;</span><span class="hljs-operator">=</span> <span class="hljs-operator">~</span>(<span class="hljs-number">3</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">12</span>);<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-variable">void</span> <span class="hljs-title function_">ds18b20_data_set</span>(<span class="hljs-params">int</span> <span class="hljs-params">val</span>)<br>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">val</span>)<br>                <span class="hljs-variable">GPGDAT</span> <span class="hljs-operator">|</span><span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">6</span>);<br>        <span class="hljs-keyword">else</span><br>                <span class="hljs-variable">GPGDAT</span> <span class="hljs-operator">&amp;</span><span class="hljs-operator">=</span> <span class="hljs-operator">~</span>(<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">6</span>);<br>&#125;<br><br><span class="hljs-keyword">static</span> int <span class="hljs-title function_">ds18b20_data_get</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">GPGDAT</span> <span class="hljs-operator">&amp;</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">6</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*通过函数设置时间*/</span><br><span class="hljs-keyword">static</span> <span class="hljs-variable">void</span> <span class="hljs-title function_">ds18b20_data_set_val_for_time</span>(<span class="hljs-params">int</span> <span class="hljs-params">val</span>, <span class="hljs-params">int</span> <span class="hljs-params">us</span>)<br>&#123;<br>        <span class="hljs-title function_">ds18b20_data_cfg_as_output</span>();<br>        <span class="hljs-title function_">ds18b20_data_set</span>(<span class="hljs-variable">val</span>);<br>        <span class="hljs-title function_">udelay</span>(<span class="hljs-variable">us</span>);<br>&#125;<br><br><span class="hljs-comment">/*ds18b20释放总线*/</span><br><span class="hljs-keyword">static</span> <span class="hljs-variable">void</span> <span class="hljs-title function_">ds18b20_data_release</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-title function_">ds18b20_data_cfg_as_input</span>();<br>&#125;<br><br><span class="hljs-comment">/* ds18b20的代码</span><br><span class="hljs-comment"> *先实现ds18b20初始化操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> int <span class="hljs-title function_">ds18b20_initialization</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        int <span class="hljs-variable">val</span>;<br>        <br>        <span class="hljs-title function_">ds18b20_data_set_val_for_time</span>(<span class="hljs-number">0</span>, <span class="hljs-number">500</span>);<br>        <span class="hljs-title function_">ds18b20_data_release</span>();<br>        <span class="hljs-title function_">udelay</span>(<span class="hljs-number">80</span>);<br>        <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">ds18b20_data_get</span>();<br>        <span class="hljs-title function_">udelay</span>(<span class="hljs-number">250</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">val</span>;<br>&#125;<br><br><span class="hljs-comment">/*实现写入一位数据*/</span><br><span class="hljs-keyword">static</span> <span class="hljs-variable">void</span> <span class="hljs-title function_">ds18b20_write_bit</span>(<span class="hljs-params">int</span> <span class="hljs-params">val</span>)<br>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> <span class="hljs-operator">==</span> <span class="hljs-variable">val</span>)<br>        &#123;<br>                <span class="hljs-title function_">ds18b20_data_set_val_for_time</span>(<span class="hljs-number">0</span>, <span class="hljs-number">60</span>);         <br>                <span class="hljs-title function_">ds18b20_data_release</span>();<br>                <span class="hljs-title function_">udelay</span>(<span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>                <span class="hljs-title function_">ds18b20_data_set_val_for_time</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);          <br>                <span class="hljs-title function_">ds18b20_data_release</span>();<br>                <span class="hljs-title function_">udelay</span>(<span class="hljs-number">60</span>);<br>        &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">实现一位数据的读操作</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">static</span> int <span class="hljs-title function_">ds18b20_read_bit</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        int <span class="hljs-variable">val</span>;<br>        <br>        <span class="hljs-title function_">ds18b20_data_set_val_for_time</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);          <br>        <span class="hljs-title function_">ds18b20_data_release</span>();<br>        <span class="hljs-title function_">udelay</span>(<span class="hljs-number">10</span>);<br>        <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">ds18b20_data_get</span>();<br>        <span class="hljs-title function_">udelay</span>(<span class="hljs-number">50</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">val</span>;<br>&#125;<br><br><span class="hljs-comment">/*实现写一字节数据函数*/</span><br><span class="hljs-keyword">static</span> <span class="hljs-variable">void</span> <span class="hljs-title function_">ds18b20_write_byte</span>(<span class="hljs-params">unsigned</span> <span class="hljs-params">char</span> <span class="hljs-params">data</span>)<br>&#123;<br>        <span class="hljs-comment">/* 优先传输最低位 */</span><br>        int <span class="hljs-variable">i</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-variable">i</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">8</span>; <span class="hljs-variable">i</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span>)<br>        &#123;<br>                <span class="hljs-title function_">ds18b20_write_bit</span>(<span class="hljs-variable">data</span> <span class="hljs-operator">&amp;</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-variable">i</span>));<br>        &#125;<br>&#125;<br><span class="hljs-comment">/*实现读一字节数据函数*/</span><br><span class="hljs-keyword">static</span> <span class="hljs-variable">unsigned</span> <span class="hljs-variable">char</span> <span class="hljs-title function_">ds18b20_read_byte</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        int <span class="hljs-variable">i</span>;<br>        <span class="hljs-variable">unsigned</span> <span class="hljs-variable">char</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-variable">i</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">8</span>; <span class="hljs-variable">i</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span>)<br>        &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-title function_">ds18b20_read_bit</span>() <span class="hljs-operator">==</span> <span class="hljs-number">1</span>)<br>                        <span class="hljs-variable">data</span> <span class="hljs-operator">|</span><span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-variable">i</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">data</span>;<br>&#125;<br><br><span class="hljs-comment">/*写入一字节的命令数据*/</span><br><span class="hljs-keyword">static</span> <span class="hljs-variable">void</span> <span class="hljs-title function_">ds18b20_write_rom_cmd</span>(<span class="hljs-params">unsigned</span> <span class="hljs-params">char</span> <span class="hljs-params">cmd</span>)<br>&#123;<br>        <span class="hljs-title function_">ds18b20_write_byte</span>(<span class="hljs-variable">cmd</span>);<br>&#125;<br><br><span class="hljs-comment">/*写入一字节的功能命令数据*/</span><br><span class="hljs-keyword">static</span> <span class="hljs-variable">void</span> <span class="hljs-title function_">ds18b20_write_function_cmd</span>(<span class="hljs-params">unsigned</span> <span class="hljs-params">char</span> <span class="hljs-params">cmd</span>)<br>&#123;<br>        <span class="hljs-title function_">ds18b20_write_byte</span>(<span class="hljs-variable">cmd</span>);<br>&#125;<br><br><span class="hljs-comment">/*实际操作函数 读rom*/</span><br>int <span class="hljs-title function_">ds18b20_read_rom</span>(<span class="hljs-params">unsigned</span> <span class="hljs-params">char</span> <span class="hljs-params">rom</span>[])<br>&#123;<br>        int <span class="hljs-variable">i</span>;<br>        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">ds18b20_initialization</span>() <span class="hljs-operator">!=</span> <span class="hljs-number">0</span>)<br>        &#123;<br>                <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;ds18b20_initialization err!<span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span>&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-title function_">ds18b20_write_rom_cmd</span>(<span class="hljs-variable">READ_ROM</span>);<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-variable">i</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">8</span>; <span class="hljs-variable">i</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span>)<br>        &#123;<br>                <span class="hljs-variable">rom</span>[<span class="hljs-variable">i</span>] <span class="hljs-operator">=</span> <span class="hljs-title function_">ds18b20_read_byte</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>int <span class="hljs-title function_">ds18b20_wait_when_processing</span>(<span class="hljs-params">int</span> <span class="hljs-params">timeout_us</span>)<br>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-variable">timeout_us</span><span class="hljs-operator">-</span><span class="hljs-operator">-</span>)<br>        &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-title function_">ds18b20_read_bit</span>() <span class="hljs-operator">==</span> <span class="hljs-number">1</span>)<br>                        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">/* ok */</span><br>                <span class="hljs-title function_">udelay</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">/*启动温度传输*/</span><br>int <span class="hljs-title function_">ds18b20_start_convert</span>(<span class="hljs-params">void</span>)<br>&#123;        <span class="hljs-comment">/*         </span><br><span class="hljs-comment">            所有操作到要先发出初始化操作，再发出rom命令 </span><br><span class="hljs-comment">          */</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">ds18b20_initialization</span>() <span class="hljs-operator">!=</span> <span class="hljs-number">0</span>)<br>        &#123;<br>                <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;ds18b20_initialization err!<span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span>&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-title function_">ds18b20_write_rom_cmd</span>(<span class="hljs-variable">SKIP_ROM</span>);<br>        <span class="hljs-title function_">ds18b20_write_function_cmd</span>(<span class="hljs-variable">CONVERT_TEAMPERATURE</span>);<br><br>        <span class="hljs-comment">/* 等待/判断转换成功 */</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> <span class="hljs-operator">!=</span> <span class="hljs-title function_">ds18b20_wait_when_processing</span>(<span class="hljs-number">1000000</span>))<br>        &#123;<br>                <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;ds18b20_wait_when_processing err!<span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span>&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>&#125;<br><br><span class="hljs-comment">/*读ram中的数据*/</span><br>int <span class="hljs-title function_">ds18b20_read_ram</span>(<span class="hljs-params">unsigned</span> <span class="hljs-params">char</span> <span class="hljs-params">ram</span>[])<br>&#123;<br>        int <span class="hljs-variable">i</span>;<br>        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">ds18b20_initialization</span>() <span class="hljs-operator">!=</span> <span class="hljs-number">0</span>)<br>        &#123;<br>                <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;ds18b20_initialization err!<span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span>&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-title function_">ds18b20_write_rom_cmd</span>(<span class="hljs-variable">SKIP_ROM</span>);<br>        <span class="hljs-title function_">ds18b20_write_function_cmd</span>(<span class="hljs-variable">READ_SCRATCHPAD</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-variable">i</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">9</span>; <span class="hljs-variable">i</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span>)<br>        &#123;<br>                <span class="hljs-variable">ram</span>[<span class="hljs-variable">i</span>] <span class="hljs-operator">=</span> <span class="hljs-title function_">ds18b20_read_byte</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*读温度*/</span><br>int <span class="hljs-title function_">ds18b20_read_temperature</span>(<span class="hljs-params">double</span> *<span class="hljs-params">temp</span>)<br>&#123;<br>        int <span class="hljs-variable">err</span>;<br>        <span class="hljs-variable">unsigned</span> <span class="hljs-variable">char</span> <span class="hljs-variable">ram</span>[<span class="hljs-number">9</span>];<br><br>        <span class="hljs-comment">/*每一位都是前面一位的两倍*/</span><br>        <span class="hljs-variable">double</span> <span class="hljs-variable">val</span>[] <span class="hljs-operator">=</span> &#123;<span class="hljs-number">0.0625</span>, <span class="hljs-number">0.125</span>, <span class="hljs-number">0.25</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">32</span>, <span class="hljs-number">64</span>&#125;;<br>        <span class="hljs-variable">double</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        int <span class="hljs-variable">i</span>;<br>        <br>        <span class="hljs-variable">err</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">ds18b20_start_convert</span>();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">err</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-variable">err</span>;<br>        <span class="hljs-variable">err</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">ds18b20_read_ram</span>(<span class="hljs-variable">ram</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">err</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-variable">err</span>;<br><br>        <span class="hljs-comment">/* 计算温度 */</span><br><br>        <span class="hljs-comment">/* 先判断精度  byte4 的4位和6位*/</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">ram</span>[<span class="hljs-number">4</span>] <span class="hljs-operator">&amp;</span> (<span class="hljs-number">3</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">5</span>) <span class="hljs-operator">==</span> <span class="hljs-number">0</span>) <span class="hljs-comment">/* 精度: 9bit */</span><br>                <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable">ram</span>[<span class="hljs-number">4</span>] <span class="hljs-operator">&amp;</span> (<span class="hljs-number">3</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">5</span>) <span class="hljs-operator">==</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">5</span>)) <span class="hljs-comment">/* 精度: 10bit */</span><br>                <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable">ram</span>[<span class="hljs-number">4</span>] <span class="hljs-operator">&amp;</span> (<span class="hljs-number">3</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">5</span>) <span class="hljs-operator">==</span> (<span class="hljs-number">2</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">5</span>)) <span class="hljs-comment">/* 精度: 11bit */</span><br>                <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">/* 精度是 12 bit */</span><br>                <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span> (; <span class="hljs-variable">i</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">8</span>; <span class="hljs-variable">i</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span>)<br>        &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-variable">ram</span>[<span class="hljs-number">0</span>] <span class="hljs-operator">&amp;</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-variable">i</span>))<br>                        <span class="hljs-variable">sum</span> <span class="hljs-operator">+</span><span class="hljs-operator">=</span> <span class="hljs-variable">val</span>[<span class="hljs-variable">i</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-variable">i</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">3</span>; <span class="hljs-variable">i</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span>)<br>        &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-variable">ram</span>[<span class="hljs-number">1</span>] <span class="hljs-operator">&amp;</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-variable">i</span>))<br>                        <span class="hljs-variable">sum</span> <span class="hljs-operator">+</span><span class="hljs-operator">=</span> <span class="hljs-variable">val</span>[<span class="hljs-number">8</span><span class="hljs-operator">+</span><span class="hljs-variable">i</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">ram</span>[<span class="hljs-number">1</span>] <span class="hljs-operator">&amp;</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">3</span>))<br>                <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-operator">-</span> <span class="hljs-variable">sum</span>;<br><br>        <span class="hljs-operator">*</span><span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-variable">sum</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-variable">void</span> <span class="hljs-title function_">ds18b20_init_state</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-title function_">ds18b20_data_release</span>();<br>&#125;<br><span class="hljs-variable">void</span> <span class="hljs-title function_">ds18b20_test</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-variable">unsigned</span> <span class="hljs-variable">char</span> <span class="hljs-variable">rom</span>[<span class="hljs-number">8</span>];<br>        int <span class="hljs-variable">i</span>;<br>        <span class="hljs-variable">double</span> <span class="hljs-variable">temp</span>;<br>        int <span class="hljs-variable">m</span>,<span class="hljs-variable">n</span>;<br>        <span class="hljs-comment">/*一开始我们应该保证为高电平*/</span><br>        <span class="hljs-title function_">ds18b20_init_state</span>();<br>        <br>        <span class="hljs-comment">//while (1)</span><br>        &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-title function_">ds18b20_read_rom</span>(<span class="hljs-variable">rom</span>) <span class="hljs-operator">==</span> <span class="hljs-number">0</span>)<br>                &#123;<br>                        <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;ds18b20 rom: &quot;</span>);<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-variable">i</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">8</span>; <span class="hljs-variable">i</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span>)<br>                        &#123;<br>                                <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;%02x &quot;</span>, <span class="hljs-variable">rom</span>[<span class="hljs-variable">i</span>]);<br>                        &#125;<br>                        <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;<span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span>&quot;</span>);<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        &#123;<br>        <span class="hljs-comment">/*循环打印温度*/</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> <span class="hljs-operator">==</span> <span class="hljs-title function_">ds18b20_read_temperature</span>(<span class="hljs-operator">&amp;</span><span class="hljs-variable">temp</span>))<br>                &#123;        <span class="hljs-comment">/*实现浮点数的打印*/</span><br>                        <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (int)<span class="hljs-variable">temp</span>;     <span class="hljs-comment">/* 3.01, m = 3 */</span><br>                        <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">-</span> <span class="hljs-variable">m</span>;        <span class="hljs-comment">/* 小数部分: 0.01 */</span><br>                        <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">*</span> <span class="hljs-number">10000</span>;  <span class="hljs-comment">/* 10 */</span><br>                        <br>                        <span class="hljs-comment">/* 在串口上打印 */</span><br>                        <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;ds18b20 temperature: %d.%04d<span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span>&quot;</span>, <span class="hljs-variable">m</span>, <span class="hljs-variable">n</span>);  <span class="hljs-comment">/* 3.010v */</span><br>                &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改main.c 添加</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">ds18b20_test</span>();<br></code></pre></td></tr></table></figure><p>修改Makefile 添加</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">objs += sensors<span class="hljs-regexp">/ds18b20/</span>ds18b20.o<br></code></pre></td></tr></table></figure><p>由于使用数组涉及到了memcpy 所以编译出错，现在需要实现在string_utils.c实现memcpy函数</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">void</span> *memcpy(<span class="hljs-keyword">void</span> *dest, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *src, <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span>)<br>&#123;<br>        <span class="hljs-built_in">char</span> *tmp = dest;<br>        <span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> *s = src;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">count</span>--)<br>                *tmp++ = *s++;<br>        <span class="hljs-keyword">return</span> dest;<br>&#125;<br></code></pre></td></tr></table></figure><p>烧写</p><p>课后作业:</p><ul><li>a. 使用CRC较验 64bit rom数据</li><li>b. 使用CRC较验 9byte的 ram数据</li><li>c. 增加写ram, 写eeprom的功能, 设置转换精度</li></ul><p><strong>第006节_红外线遥控协议简介及编程思路</strong></p><hr><p>​本节开始讲解红外遥控器信号的接收和解码，视频分为三部分，每一部分都专注做一件事情，让每节视频更短一点。</p><p>红外遥控器的操作比前面的温度、温湿度传感器都要简单。</p><p>首先看一下原理图上的红外遥控接收器：</p><p><img src="/image/Chapter22_lesson6_001.png" alt="Chapter22_lesson6_001.png"></p><p>我们用遥控器对它按动的时候，它就可以接收到红外信号，然后把红外信号转换成电平信号，通过IRD这根线，传给SOC。</p><p>整个传输，只涉及单向传输，由HS0038向主芯片传送。</p><p>因此，我们只需要编写程序，从IRD上获取数据即可，在这之前，我们需要先了解下数据是怎么表示的，也就是传输的红外数据的格式。</p><p>红外协议有：NEC、SONY、RC5、RC6等，常用的就是NEC格式，因此我们主要对NEC进行讲解。</p><p>可以参考这个文章，直观的了解下NEC格式波形的样子： <a href="https://www.cnblogs.com/openusb/archive/2010/01/07/1641357.html">https://www.cnblogs.com/openusb/archive/2010/01/07/1641357.html</a></p><p>在分析文章中的波形之前，我们先想象一下怎么在一条数据线上传输信号。</p><p>开始传输数据之前，一般都会发出一个start起始信号，通知对方我开始传输数据了，后面就是每一位每一位的数据。</p><p>NEC协议的开始是一段引导码：</p><p><img src="/image/Chapter22_lesson6_002.png" alt="Chapter22_lesson6_002.png"></p><p>这个引导码由一个9ms的低脉冲加上一个4.5ms的高脉冲组成，它用来通知接收方我要开始传输数据了。</p><p><img src="/image/Chapter22_lesson6_003.png" alt="Chapter22_lesson6_003.png"></p><p>然后接着的是数据，数据由4字节组成：地址、地址(取反)、数据、数据(取反)，这些取反是用来校验用的。</p><p>地址是指遥控器的ID，每一类遥控器的ID都不一样，数据就是遥控器上的不同按键。</p><p>从前面的图可以知道，NEC每次要发32位的数据，每一位用什么来表示0和1呢？</p><p><img src="/image/Chapter22_lesson6_004.png" alt="Chapter22_lesson6_004.png"></p><p>数据1和01，开始都是0.56ms的低脉冲，对于数据1，后面的高脉冲比较长，对于数据0，后面的高脉冲比较短。 可以看出，红外遥控器的数据表示方法是比较简单的。</p><p>我们长按一个按键，第一次按的时候，他会发出引导码，地址，地址取反，数据，数据取反。</p><p>接着由于长按，遥控器会发送一个不一样的引导码，这个引导码由9ms的低脉冲，2.25ms的高脉冲组成，表示现在按的还是上次一样的按键，然后再一直是引导码(重复)，直到松开。</p><p><img src="/image/Chapter22_lesson6_005.png" alt="Chapter22_lesson6_005.png"></p><p>在后面的调试中，发现以上并不是NEC协议的全部，打开bing国际版搜索“ir nec protocal”，得到一篇官方文章：<a href="http://techdocs.altium.com/display/FPGA/NEC/+Infrared/+Transmission/+Protocol">http://techdocs.altium.com/display/FPGA/NEC\+Infrared\+Transmission\+Protocol</a></p><p>里面的内容和前面文章基本一致，但这个更详细，发现每次数据传输完还有一个0.5625ms的低脉冲表示数据传输结束。</p><p>对于引导码(重复)也一样，也有一个0.5625ms的低脉冲表示传输结束。</p><p>大部分文章都漏掉了结束的低脉冲。</p><p>NEC协议里有很多时间，这些时间有一个有趣的现象，把所有时间里面最小的0.53ms看作基本脉冲宽度，假设用t表示，那么其它所有时间都是t的倍数：</p><p><img src="/image/Chapter22_lesson6_006.png" alt="Chapter22_lesson6_006.png"></p><p>我们可以看到对于所有的时间，最小的单位都是0.56ms，这个时间对人来说是非常短的，但对嵌入式系统它是非常非常长的了，足够我们做很多事情了，那么我们可以使用中断来处理这些数据。</p><p>并且对于红外遥控器来说，我们根本不知道用户什么时候按下遥控器，使用轮询的方式特别耗资源，因此直接使用中断来处理。</p><p><img src="/image/Chapter22_lesson6_007.png" alt="Chapter22_lesson6_007.png"></p><p>图中的脉冲方向正好相反，绿色表示低脉冲，白色表示高脉冲。</p><p>涉及内容：</p><ul><li>中断引脚设置为双边缘触发，在每一个脉冲变化的地方都会产生中断；</li><li>发生中断时，计算当前中断与上次中断之间的时间差，就得到脉冲宽度，放入buffer，同时还要记录引脚极性；</li><li>主循环从buffer取出数据，并解析时序；</li></ul><p>我们可以估算下，每按下一次遥控器，会产生多少中断，2+32*2+1&#x3D;67次。</p><p>中断发生时，将数据放入buffer，主函数从buffer取出数据，用什么数据结构来实现数据的存取？</p><p>最好的方式就是环形缓冲区，所谓环形缓冲区就是一边存储数据一边读取数据，下节课再详细讲解。</p><p>编程要点：</p><ul><li>中断</li><li>系统时间</li><li>环形缓冲区</li><li>NEC解析</li></ul><p><strong>第007节_前期编程_系统时间与环型缓冲区</strong></p><hr><p>​这节课实现两个小功能：系统时间和环形缓冲区。</p><p>在上一课的基础上添加代码，打开timer.c，前面的设置的定时器，每10ms产生一次中断，这里定义一个全局变量，来记录产生次数，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> g_system_time_10ms_cnt = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>这里的类型选择使用unsigned int类型，2^32*10&#x2F;1000&#x2F;3600&#x2F;24&#x3D;497天，也就是说如果运行497天后，计数溢出，将会导致一些问题。</p><p>改为unsigned long long类型的话，2^64*10&#x2F;1000&#x2F;3600&#x2F;24&#x2F;365&#x3D;5849424173年，这个时间就不怕溢出了，因此这里计数变量的类型为unsigned long long：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> g_system_time_10ms_cnt = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>在定时器中断timer_irq()函数里面让这个计数值每次加1：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">g_system_time_10ms_cnt</span><span class="hljs-literal">++</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>以后我们就可以读取这个计数值，知道系统时间。</p><p>现在开始编写获取系统时间的函数，精度要求是us级别的，读取TCNTO0的值，再加上g_system_time_10ms_cnt的计数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">get_system_time_us</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> us = (<span class="hljs-number">50000</span> - TCNTO0)/<span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">return</span> g_system_time_10ms_cnt * <span class="hljs-number">10</span> * <span class="hljs-number">1000</span> + us;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过这个函数就知道上电到之后任何一个时刻，过去了多久。</p><p>再写一个函数计算两段时间之间的差值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">delta_time_us</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> pre, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> now)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">return</span> (now - pre);<br>&#125;<br></code></pre></td></tr></table></figure><p>到此，系统时间相关函数就完成了。</p><p>首先介绍一下环形缓冲区，假设有一个数组char Buf[6]，它的结构如下：</p><p><img src="/image/700px-Chapter22_lesson7_001.jpg" alt="700px-Chapter22_lesson7_001.jpg"></p><p>定义一个读指针r&#x3D;0，一个写指针w&#x3D;0。</p><ul><li>写数据：</li></ul><p>buf[w] &#x3D; val;</p><p>w &#x3D; (w+1)%LEN &#x3D; (w+1)%6;</p><ul><li>读数据：</li></ul><p>val &#x3D; buf(r);</p><p>r &#x3D; (r+1)%LEN;</p><p>如何判断buf是空： r &#x3D;&#x3D; w； &#x2F;&#x2F;为空</p><p>如何判断buf是满： (w+1)%LEN &#x3D;&#x3D; r； &#x2F;&#x2F;为满</p><p>读写指针，每到达最后面，就从0开始，就像一个圆环一样，因此得名环形缓冲区。</p><p>对于我们红外数据，保存的数据并不是char，而是一个结构体，里面含有脉冲宽度，引脚极性等。</p><p>在sensors文件下创建一个irda文件夹，里面创建irda_raw.h和circle_buffer.c，在irda_raw.h里定义一个数据结构体，包含极性和脉冲宽度：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _IRDA_RAW_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IRDA_RAW_H</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">irda_raw_event</span> &#123;<br>        <span class="hljs-type">int</span> pol; <span class="hljs-comment">/* 极性 */</span><br>        <span class="hljs-type">int</span> duration;  <span class="hljs-comment">/* 脉冲宽度, us */</span><br>&#125;irda_raw_event, *p_irda_raw_event;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* _IRDA_RAW_H */</span></span><br></code></pre></td></tr></table></figure><p>然后在circle_buffer.c实现环形缓冲区。</p><p>先定义个irda_raw_event类型的g_events[]数组，这里大小设置为1024，</p><p>之前介绍过，每传一次irda，至少会传67次数据，因此这个buf要至少大于67行，再定义两个读写指针位置。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">static irda_raw_event g_events[<span class="hljs-number">1024</span>]<span class="hljs-comment">;</span><br>static int g_r <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>static int g_w <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>判断buf是否是空的函数：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">is_ir_event_buf_empty</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">return</span> g_r = g_w;<br>&#125;<br></code></pre></td></tr></table></figure><p>判断buf是否是满的函数：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">is_ir_event_buf_full</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">NEXT_PLACE</span>(g_w) == g_r;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，(w+1)%LEN使用宏NEXT_PLACE(i)代替，宏的定义如下：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">#define NEXT_PLACE(<span class="hljs-name">i</span>) ((<span class="hljs-name">i+1</span>)&amp;0x3FF)<br></code></pre></td></tr></table></figure><p>%的操作使用位&amp;操作实现一样的效果。</p><p>然后是把数据放入缓冲区：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> ir<span class="hljs-constructor">_event_put(<span class="hljs-params">p_irda_raw_event</span> <span class="hljs-params">pd</span>)</span><br>&#123;<br>        <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">_ir_event_buf_full()</span>)<br>                return -<span class="hljs-number">1</span>;<br>        g_events<span class="hljs-literal">[<span class="hljs-identifier">g_w</span>]</span> = *pd;<br>        g_w = <span class="hljs-constructor">NEXT_PLACE(<span class="hljs-params">g_w</span>)</span>;<br>        return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>先判断的缓冲区是否已满，没满的话就在写的位置放入数据，然后写位置再移动到下一个。</p><p>最后是读数据：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> ir<span class="hljs-constructor">_event_get(<span class="hljs-params">p_irda_raw_event</span> <span class="hljs-params">pd</span>)</span><br>&#123;<br>        <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">_ir_event_buf_empty()</span>)<br>                return -<span class="hljs-number">1</span>;<br>        *pd = g_events<span class="hljs-literal">[<span class="hljs-identifier">g_r</span>]</span>;<br>        g_r = <span class="hljs-constructor">NEXT_PLACE(<span class="hljs-params">g_r</span>)</span>;<br>        return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>先判断的缓冲区是否是空，没空的话就在读的位置读出数据，然后读位置移到到下一个。</p><p>修改Makefile，添加本次写的新文件。</p><p><strong>第008节_HS0038红外线接收器的编程_打印原始脉冲</strong></p><hr><p>先打印出原始数据</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">ird<span class="hljs-built_in">a_raw</span>.c<br>ird<span class="hljs-built_in">a_raw</span>.h<br></code></pre></td></tr></table></figure><p>获取电平极性方式，当前引脚极性电平取反</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;../../s3c2440_soc.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;irda_raw.h&quot;</span></span><br><br><span class="hljs-comment">/* IRDA引脚 : EINT1/GPF1 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> g_last_time = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/*  </span><br><span class="hljs-comment"> * 配置GPIO, 注册中断 </span><br><span class="hljs-comment"> * 在中断处理函数里:      </span><br><span class="hljs-comment">    记录中断发生的时间,      </span><br><span class="hljs-comment">    跟上次中断的时间比较, 计算出脉冲宽度      </span><br><span class="hljs-comment">    读取引脚极性      </span><br><span class="hljs-comment">    把数据放入环型缓冲区 </span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/* 先实现GPIO的基本操作 */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">irda_data_cfg_as_eint</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-comment">/* 配置为中断引脚 */</span><br>        GPFCON &amp;= ~(<span class="hljs-number">3</span>&lt;&lt;<span class="hljs-number">2</span>);<br>        GPFCON |= (<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">/* 设置中断触发方式: 双边沿触发 */</span><br>        EXTINT0 |= (<span class="hljs-number">7</span>&lt;&lt;<span class="hljs-number">4</span>);  <span class="hljs-comment">/* eint1 */</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">irda_data_get</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;        <span class="hljs-comment">/*如果bit1 等于1就表明高电平，返回1 */</span><br>        <span class="hljs-keyword">if</span> (GPFDAT &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*irda中断处理函数*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">irda_irq</span><span class="hljs-params">(<span class="hljs-type">int</span> irq)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-comment">/* 在中断处理函数里:          </span><br><span class="hljs-comment">            记录中断发生的时间,          </span><br><span class="hljs-comment">            跟上次中断的时间比较, 计算出脉冲宽度          </span><br><span class="hljs-comment">            读取引脚极性          </span><br><span class="hljs-comment">            把数据放入环型缓冲区 </span><br><span class="hljs-comment">         */</span><br>        irda_raw_event event;<br>        <span class="hljs-comment">/*获得当前时间并赋值给cur*/</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> cur = <span class="hljs-built_in">get_system_time_us</span>();<br>        <span class="hljs-comment">/*上次时间和这次时间的差值，也就是周期*/</span><br>        event.duration = <span class="hljs-built_in">delta_time_us</span>(g_last_time, cur);<br>        <span class="hljs-comment">/*获取引脚极性*/</span><br>        event.pol      = !<span class="hljs-built_in">irda_data_get</span>();<br>        <span class="hljs-comment">/*我们需要环形缓冲区的函数放入环形缓冲区 */</span><br>        <span class="hljs-built_in">ir_event_put</span>(&amp;event);<br>        <span class="hljs-comment">/*更新时间*/</span><br>        g_last_time = cur;<br>&#125;<br><br><span class="hljs-comment">/* 注册中断 仿照之前的按键中断程序 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">irda_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;        <span class="hljs-comment">/*1. 配置为中断引脚 </span><br><span class="hljs-comment">          *2. 配置为双边沿触发  </span><br><span class="hljs-comment">          */</span><br>        <span class="hljs-built_in">irda_data_cfg_as_eint</span>();<br>        <span class="hljs-comment">/*注册中断*/</span><br>        <span class="hljs-built_in">register_irq</span>(<span class="hljs-number">1</span>, irda_irq);<br>&#125;<br><span class="hljs-comment">/*测试原始数据*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">irda_raw_test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        irda_raw_event event;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> pre = <span class="hljs-number">0</span>, cur;<br>        <br>        <span class="hljs-built_in">irda_init</span>();<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        &#123;<br>                <span class="hljs-comment">/*如果从唤醒缓冲区读到数据，就把它打印出来*/</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == <span class="hljs-built_in">ir_event_get</span>(&amp;event))<br>                &#123;<br>                        cur = <span class="hljs-built_in">get_system_time_us</span>();<br>                        <span class="hljs-comment">/*如果这次时间和上次时间相差远的话，就打印回车换行*/</span><br>                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">delta_time_us</span>(pre, cur) &gt; <span class="hljs-number">1000000</span>)<br>                                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n\r&quot;</span>);<br>                        pre = cur;<br>                        <span class="hljs-comment">/*使用三目运算符来判断pol是高电平还是低电平*/</span><br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %d us | &quot;</span>, event.pol? <span class="hljs-string">&quot;hight&quot;</span> : <span class="hljs-string">&quot;low&quot;</span>, event.duration);<br>                &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>irda_raw.h定义极性和脉冲宽度结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _IRDA_RAW_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IRDA_RAW_H</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">irda_raw_event</span> &#123;<br>        <span class="hljs-type">int</span> pol; <span class="hljs-comment">/* 极性 */</span><br>        <span class="hljs-type">int</span> duration;  <span class="hljs-comment">/* 脉冲宽度, us */</span><br>&#125;irda_raw_event, *p_irda_raw_event;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* _IRDA_RAW_H */</span></span><br></code></pre></td></tr></table></figure><p>测试代码 修改main.c 在main主函数中增加</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">irda_rae_test</span>();<br></code></pre></td></tr></table></figure><p>修改Makefile 增加</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">objs += sensors<span class="hljs-regexp">/irda/i</span>rda_raw.o<br></code></pre></td></tr></table></figure><p>编译执行</p><p><img src="/image/700px-Chapter22_lesson8_001.png" alt="700px-Chapter22_lesson8_001.png"></p><p>一开始时间很长是因为一上电的时候高电平，值打印的特别大，说明有问题</p><p>irda中断函数中没有更新上一次的时间</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">/*更新时间*/<br>g_last_time <span class="hljs-operator">=</span> cur<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>再次更新</p><p><img src="/image/700px-Chapter22_lesson8_002.png" alt="700px-Chapter22_lesson8_002.png"></p><p>时间和数据格式符合时序要求</p><p><strong>第009节_HS0038红外线接收器的编程_解析数据</strong></p><hr><p>​解析NEC格式的数据</p><p>创建irda_nec.c</p><p><img src="/image/700px-Chapter22_lesson8_003.png" alt="700px-Chapter22_lesson8_003.png"></p><p><img src="/image/Chapter22_lesson8_004.png" alt="Chapter22_lesson8_004.png"></p><p>对于NEC格式的脉冲，基本脉冲宽度是0.56ms &#x3D; 562.5us &#x3D; t</p><p>其它的脉冲都是这个的整数倍，需要控制脉冲在9ms范围,那么我们可以把这个作为其他脉冲的最大偏差值</p><p>9ms – 2&#x2F;t &lt; DURATION &lt; 9ms + 2&#x2F;t 得到判断最大偏差值公式</p><p><img src="/image/7871f3581421a7aee9f6f7c13488006f.png" alt="7871f3581421a7aee9f6f7c13488006f.png"></p><p><img src="/image/da1f5da3fc9b9b3c197d63bc3a5b8e65.png" alt="da1f5da3fc9b9b3c197d63bc3a5b8e65.png"></p><p><img src="/image/04daa15cd569b9bfc6522e00aa199e98.png" alt="04daa15cd569b9bfc6522e00aa199e98.png"></p><p><img src="/image/3d86f212ea209185073a878b66223ce2.png" alt="3d86f212ea209185073a878b66223ce2.png"></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第021课 MMU和Cache</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AC%AC021%E8%AF%BE_MMU%E5%92%8CCache/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AC%AC021%E8%AF%BE_MMU%E5%92%8CCache/</url>
    
    <content type="html"><![CDATA[<p><strong>目录</strong></p><hr><ol><li>第001节_Cache简述及协处理器指令</li><li>第002节_协处理器指令_开启ICache代码示例</li><li>第003节_MMU及地址映射</li><li>第004节_MMU代码示例</li></ol><p><strong>第001节_Cache简述及协处理器指令</strong></p><hr><p>如果对MMU ICache有所了解或者知道其概念作用，那么这节课可以跳过，我们很少会使用MMU或ICache</p><p><img src="/image/800px-Chapter21_lesson1_001.png" alt="800px-Chapter21_lesson1_001.png"></p><p>在2440芯片里面除了CPU之外， Instruction MMU 指令MMU；</p><p>Data MMU 数据MMU；</p><p>InstructionC ACHE(16KB) 指令cache；</p><p>Data CACHE (16KB) 数据cache</p><p>全都通过CP15协处理器来进行操作这些</p><p>协处理器的含义作用 coprocessor协助主处理器做某些事情， 比如在ARM系统中有cp0 – cp15一共16个协处理器，其中cp15负责管理mmu icache</p><p>写一个程序，0到100求和</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span>()<br>&#123;<br>        <span class="hljs-built_in">int</span> I;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; I &lt;= <span class="hljs-number">100</span>; i++)<br>                <span class="hljs-keyword">sum</span> += I;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">sum</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看反汇编代码</p><p><img src="/image/Chapter21_lesson1_002.png" alt="Chapter21_lesson1_002.png"></p><p>局部变量保存在栈中，也就是内存</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-number">70</span>:      e50b3014                 <span class="hljs-keyword">str</span>      <span class="hljs-built_in">r3</span>, [<span class="hljs-built_in">fp</span>,#-<span class="hljs-number">20</span>]  <span class="hljs-comment">//这个应该就是sum 假设地址是A</span><br><span class="hljs-number">78</span>：    e50b3010         <span class="hljs-keyword">str</span>   <span class="hljs-built_in">r3</span>,  [<span class="hljs-built_in">fp</span>, #-<span class="hljs-number">16</span>] <span class="hljs-comment">//这个应该就是I 假设地址是B</span><br>                                        <span class="hljs-keyword">ldr</span>   <span class="hljs-built_in">r3</span>,   [<span class="hljs-built_in">fp</span>, #-<span class="hljs-number">16</span>] <span class="hljs-comment">//也就是地址B中取出值</span><br>                                        <span class="hljs-keyword">cmp</span>  <span class="hljs-built_in">r3</span>, <span class="hljs-number">#100</span> <span class="hljs-comment">//跟100比较</span><br>                                <span class="hljs-comment">//如果大于100程序跳到  a8 如果小于100则执行下面的for循环</span><br>从<span class="hljs-number">7</span>c:到 <span class="hljs-built_in">a4</span>指令保存在内存中，CPU根据这些执行进行操作<br></code></pre></td></tr></table></figure><p>1 不断的读写地址A和B</p><p>2 不断的执行for循环里面代码</p><p>2.1 取指令</p><p>2.2 执行指令</p><p>问SDRAM非常慢，那么怎么提高程序执行效率？ 先引入一个感念，程序局部性原理</p><ul><li>时间局部性:在同一段时间里，有极大的概率访问同一地址的指令或数据</li></ul><p>(在这个for循环中同一个地址指令经常被访问到)</p><ul><li>空间局部性: 有极大概率访问到相邻空间的指令&#x2F;数据</li></ul><p>我们在一个比较慢的SDRAM上能不能在CPU上开一个高速缓存，把这些指令放进高速缓存icache</p><p><img src="/image/800px-Chapter21_lesson1_001.png" alt="800px-Chapter21_lesson1_001.png"></p><p>指令cache只有16KB 数据cache也只有16KB 而我们的SDRAM有64MB空间，显然擦车不可能存储SDRAM中所有的内容，它只能存储一部分</p><p><img src="/image/800px-Chapter21_lesson1_003.png" alt="800px-Chapter21_lesson1_003.png"></p><p>cache的示意图</p><p>以数据开始为例</p><ul><li>1 程序要读地址A的数据</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, [A的数据]<br></code></pre></td></tr></table></figure><p>a. cpu以地址A查找cache，一开始cache无数据，导致cache miss</p><p>返回一系列的数据，叫做cache line: 8word 32byte</p><p>b. cpu把地址A发到SDRAM,读入cache line,成为cache file 把地址A上的数据返回给CPU </p><ul><li>2 程序再次读取地址A的数据 a cpu以地址A查找cache,cache hit有数据直接从cache返回数据给CPU</li><li>3 程序要读地址B的数据，CPU也是以地址B查找数据，cache hint直接返回</li><li>4 cache满了，CPU访问C a cache替换，置换老的数据 b 填充新数据</li></ul><p>数据写</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">write buffer<br></code></pre></td></tr></table></figure><p>查看2410芯片手册 附录 appendix4-caches, write buffer 585页</p><p><img src="/image/800px-Chapter21_lesson1_004.png" alt="800px-Chapter21_lesson1_004.png"></p><p>设置为NCNB (no cache no buffer)数据直接到达硬件不经过缓冲器</p><p>比如GPFDAT寄存器CPU读寄存器的时候想读到引脚状态，不应该从cache读取老的数据，而是不断直接访问硬件返回最新的数据 对于这些寄存器应该设置为NCNB</p><p><img src="/image/800px-Chapter21_lesson1_005.png" alt="800px-Chapter21_lesson1_005.png"></p><p>不使用cache但数据写到buffer中，CPU就不管了 由write buffer直接进行写操作 CPU直接操作下一条指令</p><p><img src="/image/800px-Chapter21_lesson1_006.png" alt="800px-Chapter21_lesson1_006.png"></p><ul><li>第一种不使用cache buffer 适用于直接硬件操作 gpio 得到最新数据</li><li>第二种 不使用cache使用write buffer， cpu把写发给buffer，cpu就可以直接下一条指令</li><li>第三种 WT 写通方式 使用cache不使用buffer，马上写硬件</li></ul><p>CPU直接写给write buffer 由write执行缓慢写操作</p><ul><li>第四种 写回方式</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">miss: cpu数据直接到达write buffer<br>hit: cpu数据写入cache标记为dirty，让后会在合适的时机由write buffer写给硬件<br></code></pre></td></tr></table></figure><ul><li>合适的时机</li></ul><p>cache替换时dirty会写给write buffer写给硬件</p><p>或者强制Flash cache 写给write buffer 写给硬件</p><p>下节讲协处理指令</p><p><strong>第002节_协处理器指令_开启ICache代码示例</strong></p><hr><p><img src="/image/800px-Chapter21_lesson1_001.png" alt="800px-Chapter21_lesson1_001.png"></p><p>CPU中还有许多协处理器来协助主处理功能 比如2440有CP0 ~ CP15一共16个协处理器</p><p>CP15管理cache mmu 我们启动cache需要操作CP15 协处理器指令 先看硬件结构</p><p><img src="/image/800px-Chapter21_lesson1_007.png" alt="800px-Chapter21_lesson1_007.png"></p><p>CP15中也有许多寄存器 C0 ~ C15 启动C7’ 是备份寄存器</p><p>现在主CPU中某一个值R0传给CP15中的某一个寄存器</p><p>我们需要引入协处理器指令</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">mrc</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r1</span>, <span class="hljs-built_in">r0</span><br></code></pre></td></tr></table></figure><p>结果是r0 &#x3D;传给&#x3D;&gt; r1</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">mrc<br>c coprocessor <span class="hljs-operator">=</span>传给<span class="hljs-operator">=</span>&gt; register<br></code></pre></td></tr></table></figure><p>mcr 是把主处理器的值发给协处理器 register &#x3D;传给&#x3D;&gt; coprocessor 查看一下语法格式 在2440中搜索mrc</p><p>得到语法格式</p><p><img src="/image/800px-Chapter21_lesson1_008.png" alt="800px-Chapter21_lesson1_008.png"></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">&lt;MCR|MRC&gt;&#123;cond&#125; p#,<span class="hljs-symbol">&lt;expression1&gt;</span>,Rd,<span class="hljs-keyword">cn</span>,<span class="hljs-keyword">cm</span>&#123;,<span class="hljs-symbol">&lt;expression2&gt;</span>&#125;<br></code></pre></td></tr></table></figure><p>举个例子</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">mcr</span> <span class="hljs-built_in">P15</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">r1</span>,<span class="hljs-built_in">c1</span><br></code></pre></td></tr></table></figure><p>把主处理器的值发给协处理器</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs llvm">expression<span class="hljs-number">1</span> 值设置为<span class="hljs-number">0</span>，表示用不到<br>r<span class="hljs-number">1</span> 是主cpu寄存器里面的值<br><span class="hljs-keyword">c</span><span class="hljs-number">1</span> 是cp<span class="hljs-number">15</span>寄存器里的值<br>cm<span class="hljs-punctuation">,</span> 用不到，写为<span class="hljs-keyword">c</span><span class="hljs-number">0</span><br>expression<span class="hljs-number">2</span> 值设置为<span class="hljs-number">0</span>，表示用不到<br>cm和expression<span class="hljs-number">2</span>用来区分哪一个<span class="hljs-keyword">c</span><span class="hljs-number">1</span>，一般写为<span class="hljs-keyword">c</span><span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>这条命令表示主cpu中r1 值写入 协处理器cp15 中的c1寄存器</p><p>反过来要从cp15寄存器读到主cpu寄存器</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">mrc</span> <span class="hljs-built_in">p15</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">r1</span>, <span class="hljs-built_in">c1</span>, <span class="hljs-built_in">c0</span>, <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>这条命令表示协处理器cp15 c1寄存器的值读出来写入主cpu的r1寄存器</p><p>2410手册中有讲cp15寄存器的作用</p><p><img src="/image/800px-Chapter21_lesson1_009.png" alt="800px-Chapter21_lesson1_009.png"></p><p>其中寄存器1控制寄存器 下图为介绍控制寄存器1的功能</p><p><img src="/image/800px-Chapter21_lesson1_0010.png" alt="800px-Chapter21_lesson1_0010.png"></p><p>bit12位是控制cache指令的开启或者关闭，我们等下把bit 12设置为1</p><p>c7里面有许多不同的寄存器，对应不同的功能</p><p><img src="/image/800px-Chapter21_lesson1_0011.png" alt="800px-Chapter21_lesson1_0011.png"></p><p>寄存器7表示用来操作cache，根据语法规则cm{,&lt;expression2&gt;} 来区分选择那个c7</p><p>接下来写程序使能cache 注意2440里有data cache和指令cache 其中data cache要启用地址映射才可以使用，只能使用指令cache</p><p>打开start.s</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">reset:</span><br>        <span class="hljs-comment">/* 关闭看门狗 */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-number">=0x53000000</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r1</span>, <span class="hljs-number">=0</span><br>        <span class="hljs-keyword">str</span> <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r0</span>]<br><br>        <span class="hljs-comment">/* 设置MPLL, FCLK : HCLK : PCLK = 400m : 100m : 50m */</span><br>        <span class="hljs-comment">/* LOCKTIME(0x4C000000) = 0xFFFFFFFF */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-number">=0x4C000000</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r1</span>, <span class="hljs-number">=0xFFFFFFFF</span><br>        <span class="hljs-keyword">str</span> <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r0</span>]<br><br>        <span class="hljs-comment">/* CLKDIVN(0x4C000014) = 0X5, tFCLK:tHCLK:tPCLK = 1:4:8  */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-number">=0x4C000014</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r1</span>, <span class="hljs-number">=0x5</span><br>        <span class="hljs-keyword">str</span> <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r0</span>]<br><br>        <span class="hljs-comment">/* 设置CPU工作于异步模式 */</span><br>        <span class="hljs-keyword">mrc</span> <span class="hljs-built_in">p15</span>,<span class="hljs-number">0</span>,<span class="hljs-built_in">r0</span>,<span class="hljs-built_in">c1</span>,<span class="hljs-built_in">c0</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">orr</span> <span class="hljs-built_in">r0</span>,<span class="hljs-built_in">r0</span>,<span class="hljs-number">#0xc0000000</span>   <span class="hljs-comment">//R1_nF:OR:R1_iA</span><br>        mcr <span class="hljs-built_in">p15</span>,<span class="hljs-number">0</span>,<span class="hljs-built_in">r0</span>,<span class="hljs-built_in">c1</span>,<span class="hljs-built_in">c0</span>,<span class="hljs-number">0</span><br><br>        <span class="hljs-comment">/* 设置MPLLCON(0x4C000004) = (92&lt;&lt;12)|(1&lt;&lt;4)|(1&lt;&lt;0)   </span><br><span class="hljs-comment">         *  m = MDIV+8 = 92+8=100  </span><br><span class="hljs-comment">         *  p = PDIV+2 = 1+2 = 3  </span><br><span class="hljs-comment">         *  s = SDIV = 1  </span><br><span class="hljs-comment">         *  FCLK = 2*m*Fin/(p*2^s) = 2*100*12/(3*2^1)=400M  </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-number">=0x4C000004</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r1</span>, =(<span class="hljs-number">92</span>&lt;&lt;<span class="hljs-number">12</span>)<span class="hljs-title">|(1&lt;&lt;4)|</span>(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">str</span> <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r0</span>]<br>        <br>        <span class="hljs-comment">/* 一旦设置PLL, 就会锁定lock time直到PLL输出稳定  </span><br><span class="hljs-comment">         * 然后CPU工作于新的频率FCLK  </span><br><span class="hljs-comment">         */</span><br>                <span class="hljs-comment">/*         </span><br><span class="hljs-comment">                使能icache </span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">bl</span> enable_icache<br><br>        <span class="hljs-comment">/* 设置内存: sp 栈 */</span><br>        <span class="hljs-comment">/* 分辨是nor/nand启动  </span><br><span class="hljs-comment">         * 写0到0地址, 再读出来  </span><br><span class="hljs-comment">         * 如果得到0, 表示0地址上的内容被修改了, 它对应ram, 这就是nand启动  </span><br><span class="hljs-comment">         * 否则就是nor启动  </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">r1</span>, <span class="hljs-number">#0</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, [<span class="hljs-built_in">r1</span>] <span class="hljs-comment">/* 读出原来的值备份 */</span><br>        <span class="hljs-keyword">str</span> <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r1</span>] <span class="hljs-comment">/* 0-&gt;[0] */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r2</span>, [<span class="hljs-built_in">r1</span>] <span class="hljs-comment">/* r2=[0] */</span><br>        <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">r1</span>, <span class="hljs-built_in">r2</span>   <span class="hljs-comment">/* r1==r2? 如果相等表示是NAND启动 */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">=0x40000000</span>+<span class="hljs-number">4096</span> <span class="hljs-comment">/* 先假设是nor启动 */</span><br>        <span class="hljs-keyword">moveq</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">#4096</span>  <span class="hljs-comment">/* nand启动 */</span><br>        <span class="hljs-keyword">streq</span> <span class="hljs-built_in">r0</span>, [<span class="hljs-built_in">r1</span>]   <span class="hljs-comment">/* 恢复原来的值 */</span><br><br>        <span class="hljs-keyword">bl</span> sdram_init<br>        <span class="hljs-comment">//bl sdram_init2  /* 用到有初始值的数组, 不是位置无关码 */</span><br><br>        <span class="hljs-comment">/* 重定位text, rodata, data段整个程序 */</span><br>        <span class="hljs-keyword">bl</span> copy2sdram<br><br>        <span class="hljs-comment">/* 清除BSS段 */</span><br>        <span class="hljs-keyword">bl</span> clean_bss<br><br>        <span class="hljs-comment">/* 复位之后, cpu处于svc模式  </span><br><span class="hljs-comment">         * 现在, 切换到usr模式  </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">mrs</span> <span class="hljs-built_in">r0</span>, <span class="hljs-keyword">cpsr</span>         <span class="hljs-comment">/* 读出cpsr */</span><br>        <span class="hljs-keyword">bic</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">r0</span>, <span class="hljs-number">#0xf</span>     <span class="hljs-comment">/* 修改M4-M0为0b10000, 进入usr模式 */</span><br>        <span class="hljs-keyword">bic</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">r0</span>, #(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">7</span>)  <span class="hljs-comment">/* 清除I位, 使能中断 */</span><br>        <span class="hljs-keyword">msr</span> cpsr, <span class="hljs-built_in">r0</span><br><br>        <span class="hljs-comment">/* 设置 sp_usr */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">=0x33f00000</span><br><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, <span class="hljs-symbol">=sdram</span><br><span class="hljs-symbol">sdram:</span><br>        <span class="hljs-keyword">bl</span> uart0_init<br><br>        <span class="hljs-keyword">bl</span> print1<br>        <span class="hljs-comment">/* 故意加入一条未定义指令 */</span><br><span class="hljs-symbol">und_code:</span><br>        <span class="hljs-meta">.word</span> <span class="hljs-number">0xdeadc0de</span>  <span class="hljs-comment">/* 未定义指令 */</span><br>        <span class="hljs-keyword">bl</span> print2<br><br>        <span class="hljs-keyword">swi</span> <span class="hljs-number">0x123</span>  <span class="hljs-comment">/* 执行此命令, 触发SWI异常, 进入0x8执行 */</span><br><br>        <span class="hljs-comment">//bl main  /* 使用BL命令相对跳转, 程序仍然在NOR/sram执行 */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">lr</span>, <span class="hljs-symbol">=halt</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, <span class="hljs-symbol">=main</span>  <span class="hljs-comment">/* 绝对跳转, 跳到SDRAM */</span><br><span class="hljs-symbol">halt:</span><br>        <span class="hljs-keyword">b</span> halt如何使能icache 打开<span class="hljs-number">2410</span>芯片手册<br><span class="hljs-symbol">enable_icache:</span><br>        <span class="hljs-comment">/* 设置协处理器使能icache */</span><br>        <span class="hljs-keyword">mrc</span> <span class="hljs-built_in">p15</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">c1</span>, <span class="hljs-built_in">c0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">orr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">r0</span>, #(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">12</span>)  <span class="hljs-comment">/* r0 = r0 or (1&lt;&lt;12) */</span><br>        mcr <span class="hljs-built_in">p15</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">c1</span>, <span class="hljs-built_in">c0</span>, <span class="hljs-number">0</span>   <span class="hljs-comment">//把修改好的r0写给cp15的c1寄存器</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">pc</span>, <span class="hljs-built_in">lr</span><br></code></pre></td></tr></table></figure><p>刷屏效率变快</p><p><strong>第003节_MMU及地址映射</strong></p><hr><p>​对于JZ2440它有64M内存(SDRAM)，假设现在有N个APP同时运行，则：</p><p>1). 它们同时保存在SDRAM里；</p><p>2). 它们的地址各不相同；</p><p>之前我们讲过链接地址，链接地址就是程序运行时所处地址。</p><p>假设APP1所处的地址是Addr1，APP2所处的地址是Addr2，APPn所处的地址是Addrn，</p><p>则编译某个App时，需要单独指定它的的链接地址，这是一个不可能完成的任务。</p><p>因为，假如只有几个程序，为每个程序单独的指定地址还能够实现，但对于一个开放式的嵌入式系统，应用程序可能有成百上千个，你不可能重新编译这成百上千的应用程序，并且这些应用程序运行时保存的地址，也是不可预料的。</p><p>为了解决上述问题，于是就引入了虚拟地址。</p><p>也就是说虽然这些应用程序它们保存在内存中的位置各不一样，但对于CPU，它们运行时，都在同一个虚拟地址上。</p><p>举个例子，如视频中的两个hello应用程序，编译后查看反汇编代码，可以看到这两个程序的起始地址都是0x80A4。于是CPU运行两个APP时，都会去0x80A4读指令，然后经过MMU转换成Addr1、Addr2。这样，不同的APP可以在任意地址，经过MMU地址转换后，在内存上是不同的地址，互不干扰。</p><p><img src="/image/700px-Chapter21_lesson3_001.jpg" alt="700px-Chapter21_lesson3_001.jpg"></p><p>这里说的同时运行，并不是真正的同时运行，CPU是分时操作，APP1先工作很短一段时间，再APP2工作很短的一段时间，宏观的来看就是两个在同时工作。</p><p><strong>因此，引入虚拟机地址的原因之一：让APP可以以同样的链接地址来编译；</strong></p><p>在电子系统里面，内存都是有限的，无论是嵌入式系统还是电脑，比如我们的JZ2440内存就只有64M，这时假如有一个APP，需要1G的内存。应用程序执行时，不是一次性将所有代码都放入内存，而是将要运行的部分依次放入，当放入的代码指令大于64M后，会先将SDRAM里暂时用不到代码指令先置换出来，再放入需要运行的代码指令。这样尽管SDRAM很小，也可以运行内存需要很大的应用程序，而这个置换管理的工作，就是由MMU完成的。</p><p><img src="/image/Chapter21_lesson3_002.jpg" alt="Chapter21_lesson3_002.jpg"></p><p><strong>因此，引入虚拟机地址的原因之二：让大容量APP可以在资源少的系统上运行；</strong></p><p>此外，不同的APP之间应该相互独立，避免APP1能直接访问到APP2，以防止APP1影响APP2。</p><p><strong>因此，引入虚拟机地址的原因之三：权限管理，禁止访问其它空间；</strong></p><p>CPU发出虚拟地址(VA)到达MMU，MMU转换成物理地址(PA)发给硬件，那么MMU怎么根据什么将一个虚拟地址转换成物理地址？</p><p>a.表格</p><p>最简单的方法就是弄一个表格，将VA和PA对应起来，根据VA就能找到PA。这种方法优点是简单，缺点是有点浪费空间，需要同时记录VA和PA的地址。</p><p>b.改进</p><p>在表格里面，我们只保存PA，PA1对应的VA是0<del>1M-1，PA2对应的VA是1M</del>2M-1，以此类推。这样改进后，只需要原来表格容量的一半即可。最后还需要把基地址告诉MMU，启动MMU。</p><p><img src="/image/700px-Chapter21_lesson3_003.jpg" alt="700px-Chapter21_lesson3_003.jpg"></p><p>怎么使用MMU?</p><ol><li>在内存中创建这些表格(页表)；</li><li>把页表基地址告诉MMU；</li><li>设置CP15，启动MMU；</li></ol><p>前面图中的是一级页表，对于一级页表，条目&#x2F;描述符对应的大小是1M，条目&#x2F;描述符的格式可以参考S3C2410的芯片手册，MMU章节。</p><p><img src="/image/700px-Chapter21_lesson3_004.jpg" alt="700px-Chapter21_lesson3_004.jpg"></p><p>对于一级页表，我们只需要关系“Section”这一行，里面的PA是物理地址，剩下的AP、Domain、C、B用来进行权限管理。</p><p>简单插讲一下概念。</p><ul><li>权限管理：</li></ul><p>权限管理就是是否允许程序访问某块内存，有以下几种情况：</p><p>1). 完全不允许访问；</p><p>2). 允许系统模式访问，不允许用户模式访问；</p><p>3). 用户模式下，根据描述符中的AP决定怎么访问；</p><ul><li>域:</li></ul><p>在CP15寄存器有个C3，用来进行域控制。</p><p>ARM9中，有16个域，每个域用2位来表示4种权限。</p><p><img src="/image/700px-Chapter21_lesson3_005.jpg" alt="700px-Chapter21_lesson3_005.jpg"></p><ul><li>条目&#x2F;描述符(AP)：</li></ul><p>1). 设置domain；查看CP15 C3，确定域权限；</p><p>2). 如果域权限是01，使用AP来决定；</p><p>AP来自页表中的描述符，S、R来自CP15中的C1；</p><p><img src="/image/700px-Chapter21_lesson3_006.jpg" alt="700px-Chapter21_lesson3_006.jpg"></p><p>最后再来补充一个概念，前面我们运行多个APP，切换进程时，需要重新把0x80B4地址对应到不同的物理地址上，也就是说，每切换一个进程，你都需要重新修改下页表，这个开销非常的大，那有什么办法优化呢？</p><p>引入<strong>MVA</strong>，也就是修改后的虚拟地址。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">if</span> (VA&lt;32M)<br>    <span class="hljs-attribute">MVA</span>=VA|(pid&lt;&lt;25);<br><span class="hljs-keyword">else</span><br>    <span class="hljs-attribute">MVA</span>=VA;<br></code></pre></td></tr></table></figure><p>当虚拟地址小于32M时，MVA和进程的PID有关，否则等于VA，这就可以解决切换进程，频繁构造页表的问题。 假设现在有两个APP，分别是APP1和APP2，链接地址都是0x80b4，PID分别是1和2。</p><p>1). 当CPU运行APP1时，发出VA，MVA&#x3D;VA(1&lt;&lt;25)，对应的页表是PA&#x3D;APP1所在的内存；</p><p>2). 当CPU运行APP2时，发出VA，MVA&#x3D;VA(2&lt;&lt;25)，对应的页表是PA&#x3D;APP2所在的内存；</p><p>虽然我们发出的都是同一个VA，但因为PID不一样，所对应的页表项也就不一样，也就不需要重新去构造页表，这样进程从APP1切换到APP2时，只需要修改PID即可，不需要去重新创建页表，这样就可以提高切换效率。</p><p><strong>第004节_MMU代码示例</strong></p><hr><p>​这节课开始编写MMU代码，从上一个程序的基础上修改。</p><p>首先打开Start.S，我们需要创建页表，启动MMU，页表是保存在SDRAM里面的，也就在内存初始化之后，创建页表。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm">    <span class="hljs-comment">/* 创建页表 */</span><br>    <span class="hljs-keyword">bl</span> create_page_table<br><br>    <span class="hljs-comment">/* 启动MMU */</span><br>    <span class="hljs-keyword">bl</span> mmu_enable<br></code></pre></td></tr></table></figure><p>新建一个mmu.c文件。</p><p>在创建一个一级页表前，我们要先确定要映射哪些虚拟地址(VA)，映射到哪个物理地址(VB)，类型是否使用Cache和Buffer(CB)。</p><p>我们程序一开始运行是从0地址开始运行，为了保证使能MMU后，前后的地址保持一致，0地址这段我们需要映射。</p><p>在做了一些初始化后，会用到栈，如果是nor启动，栈是0x40000000开始。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache">    <span class="hljs-attribute">VA</span>                   PA                   CB<br>    <span class="hljs-attribute">0</span>                      <span class="hljs-number">0</span>                     <span class="hljs-number">00</span><br>    <span class="hljs-attribute">0x40000000</span>    <span class="hljs-number">0</span>x40000000    <span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><p>然后映射64M的SDRAM：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">    <span class="hljs-number">64</span>M sdram:<br>    VA                   PA                   CB<br>    <span class="hljs-number">0x30000000</span>    <span class="hljs-number">0x30000000</span>    <span class="hljs-number">11</span><br>    ......<br>    <span class="hljs-number">0x33f00000</span>     <span class="hljs-number">0x33f00000</span>    <span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><p>接着是映射寄存器，且不应该使用Cache和Buffer：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">    register: <span class="hljs-number">0x48000000</span>~<span class="hljs-number">0</span>x5B00001C<br>    VA                   PA                   CB<br>    <span class="hljs-number">0x48000000</span>    <span class="hljs-number">0x48000000</span>    <span class="hljs-number">00</span><br>    .......<br>    <span class="hljs-number">0</span>x<span class="hljs-number">5B000000</span>    <span class="hljs-number">0</span>x<span class="hljs-number">5B000000</span>    <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p>涉及LCD的话，还有Framebuffer:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache">    <span class="hljs-attribute">Framebuffer</span> : <span class="hljs-number">0</span>x33c00000<br>    <span class="hljs-attribute">VA</span>                   PA                   CB<br>    <span class="hljs-attribute">0x33c00000</span>    <span class="hljs-number">0</span>x33c00000     <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p>同时，为了验证映射成功，先修改链接脚本中的链接地址为0xB00000000，再对应的映射</p><p>0xB00000000到原来的0x300000000:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache">    <span class="hljs-attribute">link</span> address:<br>    <span class="hljs-attribute">VA</span>                   PA                   CB<br>    <span class="hljs-attribute">0xB0000000</span>    <span class="hljs-number">0</span>x30000000    <span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><p>根据上一节的“Section”格式，将每位的操作定义成宏：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MMU_SECDESC_AP      (3&lt;&lt;10)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MMU_SECDESC_DOMAIN  (0&lt;&lt;5)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MMU_SECDESC_NCNB    (0&lt;&lt;2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MMU_SECDESC_WB      (3&lt;&lt;2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MMU_SECDESC_TYPE    ((1&lt;&lt;4) | (1&lt;&lt;1))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MMU_SECDESC_FOR_IO   (MMU_SECDESC_AP | MMU_SECDESC_DOMAIN | MMU_SECDESC_NCNB | MMU_SECDESC_TYPE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MMU_SECDESC_FOR_MEM   (MMU_SECDESC_AP | MMU_SECDESC_DOMAIN | MMU_SECDESC_WB | MMU_SECDESC_TYPE)</span><br></code></pre></td></tr></table></figure><p>设置页表的第一步，就是设置页表保存的位置在哪，随便选择一个没使用过的空间即可，大小为16K：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* ttb: translation table base */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *ttb = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *)<span class="hljs-number">0x32000000</span>;<br></code></pre></td></tr></table></figure><p>第二步就是根据va,pa依次设置页表条目，这里我们写个函数来完成对应关系：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IO  1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MEM 0</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create_secdesc</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *ttb, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> va, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> pa, <span class="hljs-type">int</span> io)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">int</span> index;<br>        index = va / <span class="hljs-number">0x100000</span>;<br>        <span class="hljs-keyword">if</span> (io)<br>                ttb[index] = (pa &amp; <span class="hljs-number">0xfff00000</span>) | MMU_SECDESC_FOR_IO;<br>        <span class="hljs-keyword">else</span><br>                ttb[index] = (pa &amp; <span class="hljs-number">0xfff00000</span>) | MMU_SECDESC_FOR_MEM;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后依次映射每个页表条目：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs dns">        /* <span class="hljs-number">2</span>.<span class="hljs-number">1</span> for sram/nor flash */<br>        create_secdesc(ttb, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, IO)<span class="hljs-comment">;</span><br><br>        /* <span class="hljs-number">2</span>.<span class="hljs-number">2</span> for sram when nor boot */<br>        create_secdesc(ttb, <span class="hljs-number">0x40000000</span>, <span class="hljs-number">0x40000000</span>, MEM)<span class="hljs-comment">;</span><br><br>        /* <span class="hljs-number">2</span>.<span class="hljs-number">3</span> for <span class="hljs-number">64</span>M sdram */<br>        va = <span class="hljs-number">0x30000000</span><span class="hljs-comment">;</span><br>        pa = <span class="hljs-number">0x30000000</span><span class="hljs-comment">;</span><br>        for (<span class="hljs-comment">; va &lt; 0x34000000;)</span><br>        &#123;<br>                create_secdesc(ttb, va, pa, MEM)<span class="hljs-comment">;</span><br>                va += <span class="hljs-number">0x100000</span><span class="hljs-comment">;</span><br>                pa += <span class="hljs-number">0x100000</span><span class="hljs-comment">;</span><br>        &#125;<br><br>        /* <span class="hljs-number">2</span>.<span class="hljs-number">4</span> for register: <span class="hljs-number">0x48000000</span>~<span class="hljs-number">0</span>x5B00001C */<br>        va = <span class="hljs-number">0x48000000</span><span class="hljs-comment">;</span><br>        pa = <span class="hljs-number">0x48000000</span><span class="hljs-comment">;</span><br>        for (<span class="hljs-comment">; va &lt;= 0x5B000000;)</span><br>        &#123;<br>                create_secdesc(ttb, va, pa, IO)<span class="hljs-comment">;</span><br>                va += <span class="hljs-number">0x100000</span><span class="hljs-comment">;</span><br>                pa += <span class="hljs-number">0x100000</span><span class="hljs-comment">;</span><br>        &#125;<br><br>        /* <span class="hljs-number">2</span>.<span class="hljs-number">5</span> for Framebuffer : <span class="hljs-number">0x33c00000</span> */<br>        create_secdesc(ttb, <span class="hljs-number">0x33c00000</span>, <span class="hljs-number">0x33c00000</span>, IO)<span class="hljs-comment">;</span><br><br>        /* <span class="hljs-number">2</span>.<span class="hljs-number">6</span> for link address */<br>        create_secdesc(ttb, <span class="hljs-number">0</span>xB<span class="hljs-number">0000000</span>, <span class="hljs-number">0x30000000</span>, MEM)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>至此，我们完成了MMU的设置，还需要使能MMU。 在Start.S里面添加mmu_enable，需要做的步骤有： 1.把页表基址告诉cp15 2.设置域为0xffffffff, 不进行权限检查 3.使能icache,dcache,mmu 4.返回到之前位置</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">mmu_enable:</span><br>        <span class="hljs-comment">/* 把页表基址告诉cp15 */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-number">=0x32000000</span><br>        mcr <span class="hljs-built_in">p15</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">c2</span>, <span class="hljs-built_in">c0</span>, <span class="hljs-number">0</span><br><br>        <span class="hljs-comment">/* 设置域为0xffffffff, 不进行权限检查 */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-number">=0xffffffff</span><br>        mcr <span class="hljs-built_in">p15</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">c3</span>, <span class="hljs-built_in">c0</span>, <span class="hljs-number">0</span><br><br>        <span class="hljs-comment">/* 使能icache,dcache,mmu */</span><br>        <span class="hljs-keyword">mrc</span> <span class="hljs-built_in">p15</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">c1</span>, <span class="hljs-built_in">c0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">orr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">r0</span>, #(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">12</span>)  <span class="hljs-comment">/* enable icache */</span><br>        <span class="hljs-keyword">orr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">r0</span>, #(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">2</span>)  <span class="hljs-comment">/* enable dcache */</span><br>        <span class="hljs-keyword">orr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">r0</span>, #(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>)  <span class="hljs-comment">/* enable mmu */</span><br>        mcr <span class="hljs-built_in">p15</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">c1</span>, <span class="hljs-built_in">c0</span>, <span class="hljs-number">0</span>   <br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">pc</span>, <span class="hljs-built_in">lr</span><br></code></pre></td></tr></table></figure><p>最后修改Makefile，添加mmu.o进行测试。</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第020课 SPI裸板</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AC%AC020%E8%AF%BE_SPI%E8%A3%B8%E6%9D%BF/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AC%AC020%E8%AF%BE_SPI%E8%A3%B8%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<p><strong>目录</strong></p><hr><ol><li>第001节_SPI协议介绍</li><li>第002节_使用GPIO实现SPI协议操作OLED</li><li>第003节_SPI_FLASH编程_读ID</li><li>第004节_SPI_FLASH编程_读写</li><li>第005节_在OLED上显示ADC的值</li><li>第006节_使用SPI控制器</li><li>第007节_移植到MINI2440_TQ2440</li></ol><p><strong>第001节_SPI协议介绍</strong></p><hr><p>市面上的开发板很少接有SPI设备，但是SPI协议在工作中经常用到。我们开发了SPI模块，上面有SPI Flash和SPI OLED。OLED就是一块显示器。</p><p>我们裸板程序会涉及两部分：</p><ol><li>用GPIO模拟SPI</li><li>用S3C2440的SPI控制器</li></ol><p>我们先介绍下SPI协议，硬件框架如下：</p><p><img src="/image/700px-Chapter20_lesson1_001.jpg" alt="700px-Chapter20_lesson1_001.jpg"></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">SCK：提供时钟<br><span class="hljs-section">DO:作为数据输出</span><br><span class="hljs-section">DI:作为数据输入</span><br><span class="hljs-section">CS0/CS1:作为片选</span><br></code></pre></td></tr></table></figure><p>同一时刻只能有一个SPI设备处于工作状态。</p><p>假设现在2440传输一个0x56数据给SPI Flash，时序如下：</p><p><img src="/image/700px-Chapter20_lesson1_002.jpg" alt="700px-Chapter20_lesson1_002.jpg"></p><p>低选中SPI Flash，0x56的二进制就是0b0101 0110，因此在每个SCK时钟周期，DO输出对应的电平。 SPI Flash会在每个时钟周期的上升沿读取D0上的电平。</p><p>在SPI协议中，有两个值来确定SPI的模式，共有四个模式。 CPOL:表示SPICLK的初始电平，0为低电平，1为高电平 CPHA:表示相位，即第一个还是第二个时钟沿采样数据，0为第一个时钟沿，1为第二个时钟沿</p><p><img src="/image/445bf76e1e8fc1bca395b0217d64fe57.png" alt="445bf76e1e8fc1bca395b0217d64fe57.png"></p><p>我们常用的是模式0和模式3，因为它们都是在上升沿采样数据，不用去在乎时钟的初始电平是什么，只要在上升沿采集数据就行。</p><p>极性选什么？格式选什么？通常去参考外接的模块的芯片手册。比如对于OLED，查看它的芯片手册时序部分：</p><p><img src="/image/700px-Chapter20_lesson1_003.jpg" alt="700px-Chapter20_lesson1_003.jpg"></p><p>SCLK的初始电平我们并不需要关心，只要保证在上升沿采样数据就行。</p><p><strong>第002节_使用GPIO实现SPI协议操作OLED</strong></p><hr><p>现在开始写代码，使用GPIO实现SPI协议操作。</p><p>我们现在想要操作OLED，通过三条线(SCK、DO、CS)与OLED相连，这里没有DI是因为2440只会向OLED传数据而不用接收数据。</p><p>我们要用GPIO来实现SOC向OLED写数据，这一层用gpio_spi.c来实现，负责发送数据。</p><p>对于OLED，有专门的指令和数据格式，要传输的数据内容，在oled.c这一层来实现，负责组织数据。</p><p>因此，我们需要实现以上两个文件。</p><p><img src="/image/400px-Chapter20_lesson2_001.jpg" alt="400px-Chapter20_lesson2_001.jpg"></p><p>需要实现的函数：先SPI初始化SPIInt()，再初始化OLEDOLEDInit()，最后再显示OLEDPrint()。</p><p>新建一个gpio_spi.c文件，实现SPI初始化SPIInt()</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-built_in">SPIInit</span>(void)<br>&#123;<br>    <span class="hljs-comment">/* 初始化引脚 */</span><br>    <span class="hljs-built_in">SPI_GPIO_Init</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>再具体实现SPI_GPIO_Init()。这里使用GPIO实现SPI协议，电路图如下：</p><p><img src="/image/700px-Chapter20_lesson2_002.jpg" alt="700px-Chapter20_lesson2_002.jpg"></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">GPF<span class="hljs-number">1</span>作为OLED片选引脚，设置为输出；<br>GP<span class="hljs-name">G2</span>作为FLASH片选引脚，设置为输出；<br>GP<span class="hljs-name">G4</span>作为OLED的数据<span class="hljs-comment">(Data)</span>/命令<span class="hljs-comment">(Command)</span>选择引脚，设置为输出；<br>GP<span class="hljs-name">G5</span>作为SPI的MISO，设置为输入；<br>GP<span class="hljs-name">G6</span>作为SPI的MOSI，设置为输出；<br>GP<span class="hljs-name">G7</span>作为SPI的时钟CLK，设置为输出；<br></code></pre></td></tr></table></figure><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs coq">/* 用GPIO模拟SPI */<br>static void SPI_GPIO_Init(void)<br>&#123;<br>    /* GPF1 OLED_CSn output */<br>    GPFCON &amp;= ~(<span class="hljs-number">3</span>&lt;&lt;(<span class="hljs-number">1</span>*<span class="hljs-number">2</span>));<br>    GPFCON |<span class="hljs-type">= (1</span>&lt;&lt;(<span class="hljs-number">1</span>*<span class="hljs-number">2</span>));<br>    GPFDAT |<span class="hljs-type">= (1</span>&lt;&lt;<span class="hljs-number">1</span>);<br><br>    /* GPG2 FLASH_CSn output    <br>     * GPG4 OLED_DC   output    <br>     * GPG5 SPIMISO   input    <br>     * GPG6 SPIMOSI   output    <br>     * GPG7 SPICLK    output    <br>     */<br>    GPGCON &amp;= ~((<span class="hljs-number">3</span>&lt;&lt;(<span class="hljs-number">2</span>*<span class="hljs-number">2</span>)) | <span class="hljs-type">(3</span>&lt;&lt;(<span class="hljs-number">4</span>*<span class="hljs-number">2</span>)) | <span class="hljs-type">(3</span>&lt;&lt;(<span class="hljs-number">5</span>*<span class="hljs-number">2</span>)) | <span class="hljs-type">(3</span>&lt;&lt;(<span class="hljs-number">6</span>*<span class="hljs-number">2</span>)) | <span class="hljs-type">(3</span>&lt;&lt;(<span class="hljs-number">7</span>*<span class="hljs-number">2</span>)));<br>    GPGCON |<span class="hljs-type">= ((1</span>&lt;&lt;(<span class="hljs-number">2</span>*<span class="hljs-number">2</span>)) | <span class="hljs-type">(1</span>&lt;&lt;(<span class="hljs-number">4</span>*<span class="hljs-number">2</span>)) | <span class="hljs-type">(1</span>&lt;&lt;(<span class="hljs-number">6</span>*<span class="hljs-number">2</span>)) | <span class="hljs-type">(1</span>&lt;&lt;(<span class="hljs-number">7</span>*<span class="hljs-number">2</span>)));<br>    GPGDAT |<span class="hljs-type">= (1</span>&lt;&lt;<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>再新建一个oled.c文件，以实现初始化OLEDOLEDInit()</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-built_in">OLEDInit</span>(void)&#123;<br><span class="hljs-comment">/* 向OLED发命令以初始化 */</span><br>&#125;<br><br>查阅OLED数据手册SPEC UG-<span class="hljs-number">2864</span>TMBEG01<span class="hljs-selector-class">.pdf</span>可以得知其初始化流程和参考的初始化代码：<br><br>void <span class="hljs-built_in">OLEDInit</span>(void)<br>&#123;<br>    <span class="hljs-comment">/* 向OLED发命令以初始化 */</span><br>    <span class="hljs-built_in">OLEDWriteCmd</span>(<span class="hljs-number">0</span>xAE); <span class="hljs-comment">/*display off*/</span><br>    <span class="hljs-built_in">OLEDWriteCmd</span>(<span class="hljs-number">0</span>x00); <span class="hljs-comment">/*set lower column address*/</span><br>    <span class="hljs-built_in">OLEDWriteCmd</span>(<span class="hljs-number">0</span>x10); <span class="hljs-comment">/*set higher column address*/</span><br>    <span class="hljs-built_in">OLEDWriteCmd</span>(<span class="hljs-number">0</span>x40); <span class="hljs-comment">/*set display start line*/</span><br>    <span class="hljs-built_in">OLEDWriteCmd</span>(<span class="hljs-number">0</span>xB0); <span class="hljs-comment">/*set page address*/</span><br>    <span class="hljs-built_in">OLEDWriteCmd</span>(<span class="hljs-number">0</span>x81); <span class="hljs-comment">/*contract control*/</span><br>    <span class="hljs-built_in">OLEDWriteCmd</span>(<span class="hljs-number">0</span>x66); <span class="hljs-comment">/*128*/</span><br>    <span class="hljs-built_in">OLEDWriteCmd</span>(<span class="hljs-number">0</span>xA1); <span class="hljs-comment">/*set segment remap*/</span><br>    <span class="hljs-built_in">OLEDWriteCmd</span>(<span class="hljs-number">0</span>xA6); <span class="hljs-comment">/*normal / reverse*/</span><br>    <span class="hljs-built_in">OLEDWriteCmd</span>(<span class="hljs-number">0</span>xA8); <span class="hljs-comment">/*multiplex ratio*/</span><br>    <span class="hljs-built_in">OLEDWriteCmd</span>(<span class="hljs-number">0</span>x3F); <span class="hljs-comment">/*duty = 1/64*/</span><br>    <span class="hljs-built_in">OLEDWriteCmd</span>(<span class="hljs-number">0</span>xC8); <span class="hljs-comment">/*Com scan direction*/</span><br>    <span class="hljs-built_in">OLEDWriteCmd</span>(<span class="hljs-number">0</span>xD3); <span class="hljs-comment">/*set display offset*/</span><br>    <span class="hljs-built_in">OLEDWriteCmd</span>(<span class="hljs-number">0</span>x00);<br>    <span class="hljs-built_in">OLEDWriteCmd</span>(<span class="hljs-number">0</span>xD5); <span class="hljs-comment">/*set osc division*/</span><br>    <span class="hljs-built_in">OLEDWriteCmd</span>(<span class="hljs-number">0</span>x80);<br>    <span class="hljs-built_in">OLEDWriteCmd</span>(<span class="hljs-number">0</span>xD9); <span class="hljs-comment">/*set pre-charge period*/</span><br>    <span class="hljs-built_in">OLEDWriteCmd</span>(<span class="hljs-number">0</span>x1f);<br>    <span class="hljs-built_in">OLEDWriteCmd</span>(<span class="hljs-number">0</span>xDA); <span class="hljs-comment">/*set COM pins*/</span><br>    <span class="hljs-built_in">OLEDWriteCmd</span>(<span class="hljs-number">0</span>x12);<br>    <span class="hljs-built_in">OLEDWriteCmd</span>(<span class="hljs-number">0</span>xdb); <span class="hljs-comment">/*set vcomh*/</span><br>    <span class="hljs-built_in">OLEDWriteCmd</span>(<span class="hljs-number">0</span>x30);<br>    <span class="hljs-built_in">OLEDWriteCmd</span>(<span class="hljs-number">0</span>x8d); <span class="hljs-comment">/*set charge pump enable*/</span><br>    <span class="hljs-built_in">OLEDWriteCmd</span>(<span class="hljs-number">0</span>x14);<br>&#125;<br></code></pre></td></tr></table></figure><p>因此我们还要先实现OLEDWriteCmd()函数，对于OLED，除了SPI的片选、时钟、数据引脚，还有一个数据&#x2F;命令切换引脚。</p><p><img src="/image/Chapter20_lesson2_003.jpg" alt="Chapter20_lesson2_003.jpg"></p><p>这里的D&#x2F;C即数据(Data)&#x2F;命令(Command)选择引脚，它为高电平时，OLED即认为收到的是数据；它为低电平时，OLED即认为收到的是命令。</p><p>对于OLED，命令由开启&#x2F;关闭显示、背光亮度等，具体有什么命令，可以查阅OLED的主控芯片手册SSD1306-Revision 1.1 (Charge Pump).pdf，在9 COMMAND TABLE 有相关命令的介绍。</p><p>因此，在编写OLEDWriteCmd()时，需要先设置为命令模式：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">static void <span class="hljs-built_in">OLEDWriteCmd</span>(unsigned char cmd)<br>&#123;<br>    <span class="hljs-built_in">OLED_Set_DC</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">/* command */</span><br>    <span class="hljs-built_in">OLED_Set_CS</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">/* select OLED */</span><br>    <span class="hljs-built_in">SPISendByte</span>(cmd);<br>    <span class="hljs-built_in">OLED_Set_CS</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">/* de-select OLED */</span><br>    <span class="hljs-built_in">OLED_Set_DC</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">/*  */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>即：先设置为命令模式，再片选OLED，再传输命令，再恢复成原来的模式和取消片选。</p><p>片选函数和模式切换函数都比较简单，设置为对应的高低电平即可：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">OLED_Set_DC</span><span class="hljs-params">(<span class="hljs-type">char</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (val)<br>        GPGDAT |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">else</span><br>        GPGDAT &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">OLED_Set_CS</span><span class="hljs-params">(<span class="hljs-type">char</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (val)<br>        GPFDAT |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">else</span><br>        GPFDAT &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>还剩下SPISendByte()函数，它属于SPI协议，放在gpio_spi.c里面：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void <span class="hljs-constructor">SPISendByte(<span class="hljs-params">unsigned</span> <span class="hljs-params">char</span> <span class="hljs-params">val</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>    &#123;<br>        <span class="hljs-constructor">SPI_Set_CLK(0)</span>;<br>        <span class="hljs-constructor">SPI_Set_DO(<span class="hljs-params">val</span> &amp; 0x80)</span>;<br>        <span class="hljs-constructor">SPI_Set_CLK(1)</span>;<br>        <span class="hljs-keyword">val</span> &lt;&lt;= <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>发送数据要满足SPI的时序要求，参考前面的介绍：</p><p><img src="/image/700px-Chapter20_lesson1_002.jpg" alt="700px-Chapter20_lesson1_002.jpg"></p><p>先设置CLK为低，然后数据引脚输出数据的最高位，然后CLK为高，在CLK这个上升沿中,OLED就读取了一位数据。接着左移一位，将原来的第7位移动到了第8位，重复8次，传输完成。</p><p>再完成SPI_Set_CLK()和SPI_Set_DO()：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">SPI_Set_CLK</span><span class="hljs-params">(<span class="hljs-type">char</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (val)<br>        GPGDAT |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">7</span>);<br>    <span class="hljs-keyword">else</span><br>        GPGDAT &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">7</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">SPI_Set_DO</span><span class="hljs-params">(<span class="hljs-type">char</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (val)<br>        GPGDAT |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">6</span>);<br>    <span class="hljs-keyword">else</span><br>        GPGDAT &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">6</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，SPI初始化和OLED初始化就基本完成了，接下来就是OLED显示部分。</p><p>先了解一下OLED显示的原理：</p><p><img src="/image/700px-Chapter20_lesson2_004.jpg" alt="700px-Chapter20_lesson2_004.jpg"></p><p>OLED长有128个像素，宽有64个像素，每个像素用一位来表示，为1则亮，为0则灭。</p><p>每一个字节数据Datax控制每列8个像素，在显存里面存放Data数据。</p><p>之后所需的操作就是把数据写到显存里面去，如何写到显存可以拆分成两个问题：</p><p>1). 怎么发地址</p><p>2). 怎么发数据</p><p>OLED主控的手册里介绍了三种地址模式，我们常用的是页地址模式(Page addressing mode (A[1:0]&#x3D;10xb))，它把显存的64行分为8页，每页对应8行；选中某页后，再选择某列，然后就可以往里面写数据了，每写一个数据，地址就会加1，一直写到最右端的位置，他会自动跳到最左端。</p><p>通过命令来实现发送页地址和列地址，其中列地址分为两次发送，先发送低字节，再发送高字节。</p><p>假设每个字符数据大小为8x16，假如第一个字符位置为(page,col)，相邻的右边就是(page,col+8)，写满一行跳至下一行的坐标就是(page+2,col)。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">/* page: 0-7 </span><br><span class="hljs-comment"> * col : 0-127 </span><br><span class="hljs-comment"> * 字符: 8x16象素 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> OLEDPrint(<span class="hljs-built_in">int</span> page, <span class="hljs-built_in">int</span> col, <span class="hljs-built_in">char</span> *<span class="hljs-built_in">str</span>)<br>&#123;<br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">str</span>[i])<br>    &#123;<br>        OLEDPutChar(page, col, <span class="hljs-built_in">str</span>[i]);<br>        col += <span class="hljs-number">8</span>;<br>        <span class="hljs-keyword">if</span> (col &gt; <span class="hljs-number">127</span>)<br>        &#123;<br>            col = <span class="hljs-number">0</span>;<br>            page += <span class="hljs-number">2</span>;<br>        &#125;<br>        i++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只要字符数组str[i]有数据，就调用OLEDPutChar(page, col, str[i])在指定位置显示第一个字符，然后位置向右移动一个字符的大小，如果遇到行尾，再进行换行，就这样依次显示完所有字符。</p><p>现在开始实现最重要的OLEDPutChar()函数。把一个字符在OLED上显示出来需要以下几个步骤：</p><p>1). 得到字模</p><p>2). 发给OLED</p><p>字模我们可以从网上搜索相关资料获取到，将字模的数组oled_asc2_8x16[95][16]放在oledfont.c里面，字符从空格开始，因此每次减去一个空格才是我们想要的字符。</p><p>如图所示一个字符，先以(page, col)为起点，显示8位数据，再换行，以(page+1, col)为起点显示8位数据。</p><p><img src="/image/Chapter20_lesson2_005.jpg" alt="Chapter20_lesson2_005.jpg"></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/* page: 0-7 </span><br><span class="hljs-comment"> * col : 0-127 </span><br><span class="hljs-comment"> * 字符: 8x16象素 </span><br><span class="hljs-comment"> */</span><br>void <span class="hljs-constructor">OLEDPutChar(<span class="hljs-params">int</span> <span class="hljs-params">page</span>, <span class="hljs-params">int</span> <span class="hljs-params">col</span>, <span class="hljs-params">char</span> <span class="hljs-params">c</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/* 得到字模 */</span><br>    const unsigned <span class="hljs-built_in">char</span> *dots = oled_asc2_8x16<span class="hljs-literal">[<span class="hljs-identifier">c</span> - &#x27; &#x27;]</span>;<br><br>    <span class="hljs-comment">/* 发给OLED */</span><br>    <span class="hljs-constructor">OLEDSetPos(<span class="hljs-params">page</span>, <span class="hljs-params">col</span>)</span>;<br>    <span class="hljs-comment">/* 发出8字节数据 */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>        <span class="hljs-constructor">OLEDWriteDat(<span class="hljs-params">dots</span>[<span class="hljs-params">i</span>])</span>;<br><br>    <span class="hljs-constructor">OLEDSetPos(<span class="hljs-params">page</span>+1, <span class="hljs-params">col</span>)</span>;<br>    <span class="hljs-comment">/* 发出8字节数据 */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>        <span class="hljs-constructor">OLEDWriteDat(<span class="hljs-params">dots</span>[<span class="hljs-params">i</span>+8])</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>显示一个字符，就先获取字模数据，接着发出8字节数据，再换行发出8字节数。</p><p>再来实现OLED设置坐标位置函数，先设置page：</p><p><img src="/image/700px-Chapter20_lesson2_006.jpg" alt="700px-Chapter20_lesson2_006.jpg"></p><p>D0~D2表示page数据，D3-D7是固定的值，因此每次写的命令内容为0xB0+page;</p><p>再设置列：</p><p><img src="/image/700px-Chapter20_lesson2_007.jpg" alt="700px-Chapter20_lesson2_007.jpg"></p><p>分两次发送，显示发送低字节4位，再发送高字节四位；</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static void <span class="hljs-constructor">OLEDSetPos(<span class="hljs-params">int</span> <span class="hljs-params">page</span>, <span class="hljs-params">int</span> <span class="hljs-params">col</span>)</span><br>&#123;<br>    <span class="hljs-constructor">OLEDWriteCmd(0xB0 + <span class="hljs-params">page</span>)</span>; <span class="hljs-comment">/* page address */</span><br>    <span class="hljs-constructor">OLEDWriteCmd(<span class="hljs-params">col</span> &amp; 0xf)</span>;   <span class="hljs-comment">/* Lower Column Start Address */</span><br>    <span class="hljs-constructor">OLEDWriteCmd(0x10 + (<span class="hljs-params">col</span> &gt;&gt; 4)</span>);   <span class="hljs-comment">/* Lower Higher Start Address */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>前面提到了OLED主控有三种地址模式，我们常用的是页地址模式(Page addressing mode (A[1:0]&#x3D;10xb))，虽然这是默认的摸索，但还是设置一下比较好：</p><p><img src="/image/700px-Chapter20_lesson2_008.jpg" alt="700px-Chapter20_lesson2_008.jpg"></p><p>即先发送0x20，再设置A[1:0]&#x3D;10：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">static void <span class="hljs-built_in">OLEDSetPageAddrMode</span>(void)<br>&#123;<br>    <span class="hljs-built_in">OLEDWriteCmd</span>(<span class="hljs-number">0</span>x20);<br>    <span class="hljs-built_in">OLEDWriteCmd</span>(<span class="hljs-number">0</span>x02);<br>&#125;<br></code></pre></td></tr></table></figure><p>在显示中，一般都需一个清屏函数来清空当前可能显示的数据。清屏函数比较简单，往所有位置里面写0即可：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss">static void <span class="hljs-built_in">OLEDClear</span>(void)<br>&#123;<br>    int page, <span class="hljs-selector-tag">i</span>;<br>    for (page = <span class="hljs-number">0</span>; page &lt; <span class="hljs-number">8</span>; page ++)<br>    &#123;<br>        <span class="hljs-built_in">OLEDSetPos</span>(page, <span class="hljs-number">0</span>);<br>        for (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">128</span>; i++)<br>            <span class="hljs-built_in">OLEDWriteDat</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再把地址模式OLEDSetPageAddrMode()和清屏函数OLEDClear()放在SPI_GPIO_Init()里，在Makefile加上gpio_spi.o和oled.o。</p><p>最后在主函数里加上初始化和显示函数：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">SPIInit</span>();<br><span class="hljs-built_in">OLEDInit</span>();<br><span class="hljs-built_in">OLEDPrint</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,&quot;www.<span class="hljs-number">100</span>ask.net, <span class="hljs-number">100</span>ask.taobao.com&quot;);<br></code></pre></td></tr></table></figure><p><strong>第003节_SPI_FLASH编程_读ID</strong></p><hr><p>这节讲解如何使用SPI操作Flash，我们在上节课的代码上进行修改，添加一个文件 spi_flash.c 和其头文件 spi_flash.h 。</p><p>我们先做一个最简单的spi操作，读取Flash的ID， SPIFlashID() 。</p><p>Flash的ID有厂家ID和设备ID，分别用pMID和pDID来保存。</p><p>根据Flash的芯片手册 W25Q16DV.pdf 可以知道需要先发出一个指令0x90，再发送24位的地址0，再读取数据前8位是设备ID，然后是8位设备ID。进行操作前必须要片选SPI Flash，片选完还是释放SPI Flash:</p><p><img src="/image/800px-Chapter20_lesson3_001.jpg" alt="800px-Chapter20_lesson3_001.jpg"></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void <span class="hljs-constructor">SPIFlashReadID(<span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">pMID</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">pDID</span>)</span><br>&#123;<br>    <span class="hljs-constructor">SPIFlash_Set_CS(0)</span>; <span class="hljs-comment">/* 选中SPI FLASH */</span><br><br>    <span class="hljs-constructor">SPISendByte(0x90)</span>;<br><br>    <span class="hljs-constructor">SPIFlashSendAddr(0)</span>;<br><br>    *pMID = <span class="hljs-constructor">SPIRecvByte()</span>;<br>    *pDID = <span class="hljs-constructor">SPIRecvByte()</span>;<br><br>    <span class="hljs-constructor">SPIFlash_Set_CS(1)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>把其中的发送24地址封装成了一个函数 SPIFlashSendAddr() :</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static void <span class="hljs-constructor">SPIFlashSendAddr(<span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">addr</span>)</span><br>&#123;<br>    <span class="hljs-constructor">SPISendByte(<span class="hljs-params">addr</span> &gt;&gt; 16)</span>;<br>    <span class="hljs-constructor">SPISendByte(<span class="hljs-params">addr</span> &gt;&gt; 8)</span>;<br>    <span class="hljs-constructor">SPISendByte(<span class="hljs-params">addr</span> &amp; 0xff)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>依次完成上面的子函数，先是SPI片选，上一节的原理图可以看到SPI Flash的片选是GPG2:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">SPIFlash_Set_CS</span><span class="hljs-params">(<span class="hljs-type">char</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (val)<br>        GPGDAT |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">else</span><br>        GPGDAT &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">SPISendByte</span><span class="hljs-params">()</span></span> 和前面OLED的是一样的，就不用写了，因此就只剩下 <span class="hljs-built_in">SPIRecvByte</span>() ，放在 gpio_spi<span class="hljs-selector-class">.c</span> 里面实现：<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">unsigned <span class="hljs-built_in">char</span> <span class="hljs-constructor">SPIRecvByte(<span class="hljs-params">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> i;<br>    unsigned <span class="hljs-built_in">char</span> <span class="hljs-keyword">val</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">val</span> &lt;&lt;= <span class="hljs-number">1</span>;<br>        <span class="hljs-constructor">SPI_Set_CLK(0)</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-constructor">SPI_Get_DI()</span>)<br>            <span class="hljs-keyword">val</span> <span class="hljs-pattern-match">|= 1;</span><br><span class="hljs-pattern-match">        <span class="hljs-constructor">SPI_Set_CLK(1)</span>;</span><br><span class="hljs-pattern-match">    &#125;</span><br><span class="hljs-pattern-match">    return <span class="hljs-keyword">val</span>;    </span><br><span class="hljs-pattern-match">&#125;</span><br></code></pre></td></tr></table></figure><p>在每个时钟周期读取DI引脚上的值，对于SOC就是MISO引脚：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">char</span> <span class="hljs-title">SPI_Get_DI</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (GPGDAT &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，读取Flash的ID基本实现，最后在主函数里调用打印，分别在串口和OLED上显示：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">    SPIFlashReadID(&amp;mid, &amp;pid);<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;SPI Flash : MID = 0x%02x, PID = 0x%02x\n\r&quot;</span>, mid, pid);<br>    <span class="hljs-keyword">sprintf</span>(str, <span class="hljs-string">&quot;SPI : %02x, %02x&quot;</span>, mid, pid);<br>    OLEDPrint(<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,str);<br></code></pre></td></tr></table></figure><p>Makefile记得加上新生成的 spi_flash.o 。</p><p><strong>第004节_SPI_FLASH编程_读写</strong></p><hr><p>Flash作为一个存储芯片，最重要的就是存储和读取存储的数据，这节我们就实现Flash里数据的读写。 对于Flash，每次写操作需要的步骤如下:</p><ol><li>去保护（写使能、写状态寄存器）；</li><li>擦除（写使能）</li><li>编写入数据（写使能）</li></ol><p>可以看出对于写操作，每次都要写使能，查阅芯片手册，可以看出写使能比较简单，只需要发送0x06命令即可：</p><p><img src="/image/800px-Chapter20_lesson4_001.jpg" alt="800px-Chapter20_lesson4_001.jpg"></p><p>反之，写保护则是写入0x04:</p><p><img src="/image/800px-Chapter20_lesson4_002.jpg" alt="800px-Chapter20_lesson4_002.jpg"></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss">static void <span class="hljs-built_in">SPIFlashWriteEnable</span>(int enable)<br>&#123;<br>    if (enable)<br>    &#123;<br>        <span class="hljs-built_in">SPIFlash_Set_CS</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">SPISendByte</span>(<span class="hljs-number">0</span>x06);<br>        <span class="hljs-built_in">SPIFlash_Set_CS</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    else<br>    &#123;<br>        <span class="hljs-built_in">SPIFlash_Set_CS</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">SPISendByte</span>(<span class="hljs-number">0</span>x04);<br>        <span class="hljs-built_in">SPIFlash_Set_CS</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是读写状态寄存器，状态寄存器有两个，通过0x05读取状态寄存器1，通过0x35读取状态寄存器2：</p><p><img src="/image/800px-Chapter20_lesson4_001.jpg" alt="800px-Chapter20_lesson4_001.jpg"></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static unsigned <span class="hljs-built_in">char</span> <span class="hljs-constructor">SPIFlashReadStatusReg1(<span class="hljs-params">void</span>)</span><br>&#123;<br>    unsigned <span class="hljs-built_in">char</span> <span class="hljs-keyword">val</span>;<br>    <span class="hljs-constructor">SPIFlash_Set_CS(0)</span>;<br>    <span class="hljs-constructor">SPISendByte(0x05)</span>;<br>    <span class="hljs-keyword">val</span> = <span class="hljs-constructor">SPIRecvByte()</span>;<br>    <span class="hljs-constructor">SPIFlash_Set_CS(1)</span>;<br>    return <span class="hljs-keyword">val</span>;<br>&#125;<br><br>static unsigned <span class="hljs-built_in">char</span> <span class="hljs-constructor">SPIFlashReadStatusReg2(<span class="hljs-params">void</span>)</span><br>&#123;<br>    unsigned <span class="hljs-built_in">char</span> <span class="hljs-keyword">val</span>;<br>    <span class="hljs-constructor">SPIFlash_Set_CS(0)</span>;<br>    <span class="hljs-constructor">SPISendByte(0x35)</span>;<br>    <span class="hljs-keyword">val</span> = <span class="hljs-constructor">SPIRecvByte()</span>;<br>    <span class="hljs-constructor">SPIFlash_Set_CS(1)</span>;<br>    return <span class="hljs-keyword">val</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>写状态寄存器则是先发出0x01命令，再依次发送状态寄存器1、状态寄存器2：</p><p><img src="/image/800px-Chapter20_lesson4_004.jpg" alt="800px-Chapter20_lesson4_004.jpg"></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scss">static void <span class="hljs-built_in">SPIFlashWriteStatusReg</span>(unsigned char reg1, unsigned char reg2)<br>&#123;    <br>    <span class="hljs-built_in">SPIFlashWriteEnable</span>(<span class="hljs-number">1</span>);  <br>    <br>    <span class="hljs-built_in">SPIFlash_Set_CS</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">SPISendByte</span>(<span class="hljs-number">0</span>x01);<br>    <span class="hljs-built_in">SPISendByte</span>(reg1);<br>    <span class="hljs-built_in">SPISendByte</span>(reg2);<br>    <span class="hljs-built_in">SPIFlash_Set_CS</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">SPIFlashWaitWhenBusy</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>写状态寄存器还需要去保护，默认的是发出`SPIFlashWriteEnable()`后，即可写状态寄存器，但为了确保万无一失，还是手动在将SRP1和SRP2设置为0，即将状态寄存器1的最高位清零和状态寄存器最低位清零：</p><p><img src="/image/800px-Chapter20_lesson4_005.jpg" alt="800px-Chapter20_lesson4_005.jpg"></p><p><img src="/image/800px-Chapter20_lesson4_006.jpg" alt="800px-Chapter20_lesson4_006.jpg"></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static void <span class="hljs-constructor">SPIFlashClearProtectForStatusReg(<span class="hljs-params">void</span>)</span><br>&#123;<br>    unsigned <span class="hljs-built_in">char</span> reg1, reg2;<br>    reg1 = <span class="hljs-constructor">SPIFlashReadStatusReg1()</span>;<br>    reg2 = <span class="hljs-constructor">SPIFlashReadStatusReg2()</span>;<br>    reg1 &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">7</span>);<br>    reg2 &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>);<br>    <span class="hljs-constructor">SPIFlashWriteStatusReg(<span class="hljs-params">reg1</span>, <span class="hljs-params">reg2</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Flash有两种保护机制，一个是保护状态寄存器，一种是保护存储数据，现在再来清除数据保护。 需要将CMP设置为0的同时，将BP0、BP1、BP2都设置为0：</p><p><img src="/image/800px-Chapter20_lesson4_007.jpg" alt="800px-Chapter20_lesson4_007.jpg"></p><p><img src="/image/800px-Chapter20_lesson4_006.jpg" alt="800px-Chapter20_lesson4_006.jpg"></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static void <span class="hljs-constructor">SPIFlashClearProtectForData(<span class="hljs-params">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">/* cmp=0,bp2,1,0=0b000 */</span><br>    unsigned <span class="hljs-built_in">char</span> reg1, reg2;<br><br>    reg1 = <span class="hljs-constructor">SPIFlashReadStatusReg1()</span>;<br>    reg2 = <span class="hljs-constructor">SPIFlashReadStatusReg2()</span>;<br><br>    reg1 &amp;= ~(<span class="hljs-number">7</span>&lt;&lt;<span class="hljs-number">2</span>);<br>    reg2 &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">6</span>);<br><br>    <span class="hljs-constructor">SPIFlashWriteStatusReg(<span class="hljs-params">reg1</span>, <span class="hljs-params">reg2</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>将两个清除写保护都放在一起，作为一个SPI Flash初始化函数：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-built_in">SPIFlashInit</span>(void)<br>&#123;<br>    <span class="hljs-built_in">SPIFlashClearProtectForStatusReg</span>();<br>    <span class="hljs-built_in">SPIFlashClearProtectForData</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>再来实现擦除，擦除命令需要先发一个0x20的命令，再发出24位的想擦除位置的地址：</p><p><img src="/image/800px-Chapter20_lesson4_008.jpg" alt="800px-Chapter20_lesson4_008.jpg"></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">/* erase 4K */</span><br>void <span class="hljs-built_in">SPIFlashEraseSector</span>(unsigned int addr)<br>&#123;<br>    <span class="hljs-built_in">SPIFlashWriteEnable</span>(<span class="hljs-number">1</span>);  <br><br>    <span class="hljs-built_in">SPIFlash_Set_CS</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">SPISendByte</span>(<span class="hljs-number">0</span>x20);<br>    <span class="hljs-built_in">SPIFlashSendAddr</span>(addr);<br>    <span class="hljs-built_in">SPIFlash_Set_CS</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-built_in">SPIFlashWaitWhenBusy</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>为了保证擦除成功，需要读取状态寄存器1的的第1位：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">SPIFlashWaitWhenBusy</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">SPIFlashReadStatusReg1</span>() &amp; <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是烧写函数，先发命令0x02，再发出24位地址，最后再逐个发送数据：</p><p><img src="/image/800px-Chapter20_lesson4_009.jpg" alt="800px-Chapter20_lesson4_009.jpg"></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/* program */</span><br>void <span class="hljs-constructor">SPIFlashProgram(<span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">addr</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">buf</span>, <span class="hljs-params">int</span> <span class="hljs-params">len</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> i;<br>    <br>    <span class="hljs-constructor">SPIFlashWriteEnable(1)</span>; <br><br>    <span class="hljs-constructor">SPIFlash_Set_CS(0)</span>;<br>    <span class="hljs-constructor">SPISendByte(0x02)</span>;<br>    <span class="hljs-constructor">SPIFlashSendAddr(<span class="hljs-params">addr</span>)</span>;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>        <span class="hljs-constructor">SPISendByte(<span class="hljs-params">buf</span>[<span class="hljs-params">i</span>])</span>;<br>    <br>    <span class="hljs-constructor">SPIFlash_Set_CS(1)</span>;<br><br>    <span class="hljs-constructor">SPIFlashWaitWhenBusy()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同前面的擦除操作一样，烧写操作也不是一定是实时的，需要读取状态标志位来判断是否完成。</p><p>读函数也是类似的操作，先发命令0x03，再发出24位地址，再逐个读取数据：</p><p><img src="/image/800px-Chapter20_lesson4_0010.jpg" alt="800px-Chapter20_lesson4_0010.jpg"></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void <span class="hljs-constructor">SPIFlashRead(<span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">addr</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">buf</span>, <span class="hljs-params">int</span> <span class="hljs-params">len</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> i;<br>    <br>    <span class="hljs-constructor">SPIFlash_Set_CS(0)</span>;<br>    <span class="hljs-constructor">SPISendByte(0x03)</span>;<br>    <span class="hljs-constructor">SPIFlashSendAddr(<span class="hljs-params">addr</span>)</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>        buf<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = <span class="hljs-constructor">SPIRecvByte()</span>;<br><br>    <span class="hljs-constructor">SPIFlash_Set_CS(1)</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><p>至此，基本的Flash读写功能已经完成，在主函数调用擦除函数擦除4096这个扇区的数据，再往4096这个地方写入字符串，再从该地址读取出来，在串口和OLED打印出来：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">SPIFlashEraseSector</span>(<span class="hljs-number">4096</span>);<br><span class="hljs-built_in">SPIFlashProgram</span>(<span class="hljs-number">4096</span>, &quot;<span class="hljs-number">100</span>ask&quot;, <span class="hljs-number">7</span>);<br><span class="hljs-built_in">SPIFlashRead</span>(<span class="hljs-number">4096</span>, str, <span class="hljs-number">7</span>);<br><span class="hljs-built_in">printf</span>(&quot;SPI Flash read from <span class="hljs-number">4096</span>: %s\n\r&quot;, str);<br><span class="hljs-built_in">OLEDPrint</span>(<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,str);<br></code></pre></td></tr></table></figure><p><strong>第005节_在OLED上显示ADC的值</strong></p><hr><p>这节我们在OLED显示ADC电压值，通过调节可调电阻，让ADC的值在屏幕上不断变化。</p><p>在JZ2440的主光盘的hardware里面有一个adc_ts触摸屏的程序，把里面的adc_ts.c和adc_ts.h提取出来放在本节视频待写的代码里面。</p><p>主函数调用的是Test_Adc.c进行测试adc，因此在里面加上打印和OLED显示函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*  </span><br><span class="hljs-comment"> * 测试ADC </span><br><span class="hljs-comment"> * 通过A/D转换，测量可变电阻器的电压值 </span><br><span class="hljs-comment"> */</span>       <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Test_Adc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> vol0, vol1;<br>    <span class="hljs-type">int</span> t0, t1;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Measuring the voltage of AIN0 and AIN1, press any key to exit\n\r&quot;</span>);<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">awaitkey</span>(<span class="hljs-number">0</span>))    <span class="hljs-comment">// 串口无输入，则不断测试</span><br>    &#123;<br>        vol0 = ((<span class="hljs-type">float</span>)<span class="hljs-built_in">ReadAdc</span>(<span class="hljs-number">0</span>)*<span class="hljs-number">3.3</span>)/<span class="hljs-number">1024.0</span>;  <span class="hljs-comment">// 计算电压值</span><br>        vol1 = ((<span class="hljs-type">float</span>)<span class="hljs-built_in">ReadAdc</span>(<span class="hljs-number">1</span>)*<span class="hljs-number">3.3</span>)/<span class="hljs-number">1024.0</span>;  <span class="hljs-comment">// 计算电压值</span><br>        t0   = (vol0 - (<span class="hljs-type">int</span>)vol0) * <span class="hljs-number">1000</span>;   <span class="hljs-comment">// 计算小数部分, 本代码中的printf无法打印浮点数</span><br>        t1   = (vol1 - (<span class="hljs-type">int</span>)vol1) * <span class="hljs-number">1000</span>;   <span class="hljs-comment">// 计算小数部分,  本代码中的printf无法打印浮点数</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;AIN0 = %d.%-3dV    AIN1 = %d.%-3dV\r&quot;</span>, (<span class="hljs-type">int</span>)vol0, t0, (<span class="hljs-type">int</span>)vol1, t1);<br>        <span class="hljs-built_in">sprintf</span>(buf,<span class="hljs-string">&quot;ADC: %d.%-3d, %d.%-3d&quot;</span>, (<span class="hljs-type">int</span>)vol0, t0, (<span class="hljs-type">int</span>)vol1, t1);<br>        <br>        <span class="hljs-built_in">OLEDPrint</span>(<span class="hljs-number">6</span>, <span class="hljs-number">0</span>, buf);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里调用了一个awaitkey()函数，需要再复制adc_ts触摸屏的程序里serial.c的该函数到本工程里面。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * 接收字符，若有数据直接返回，否则等待规定的时间 </span><br><span class="hljs-comment"> * 输入参数： </span><br><span class="hljs-comment"> *     timeout: 等待的最大循环次数，0表示不等待 </span><br><span class="hljs-comment"> * 返回值:  </span><br><span class="hljs-comment"> *    0     : 无数据，超时退出 </span><br><span class="hljs-comment"> *    其他值：串口接收到的数据 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-title">awaitkey</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> timeout)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">while</span> (!(UTRSTAT0 &amp; RXD0READY))<br>    &#123;<br>        <span class="hljs-keyword">if</span> (timeout &gt; <span class="hljs-number">0</span>)<br>            timeout--;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">// 超时，返回0</span><br>        &#125;<br>    <span class="hljs-keyword">return</span> URXH0;       <span class="hljs-comment">// 返回接收到的串口数据</span><br>&#125;<br></code></pre></td></tr></table></figure><p>修改Makefile，加入adc_ts.o，编译，报错，涉及除法操作，需要加入数学库：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">LDFLASG := -L <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> dirname <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> -print-libgcc-<span class="hljs-built_in">file</span>-name)</span> -lgcc<br></code></pre></td></tr></table></figure><p>现在重新编译即可通过。</p><p>现在将IIC的的结果也在OLED上显示出来，在主函数添加如下代码：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache">    <span class="hljs-attribute">i2c_init</span>();<br><br>    <span class="hljs-attribute">at24cxx_write</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>x55);<br>    <span class="hljs-attribute">data</span> = at24cxx_read(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-attribute">OLEDClearPage</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-attribute">OLEDClearPage</span>(<span class="hljs-number">3</span>);<br>    <br>    <span class="hljs-attribute">if</span> (data == <span class="hljs-number">0</span>x55)    <br>        <span class="hljs-attribute">OLEDPrint</span>(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&quot;I2C OK!&quot;</span>);<br>    <span class="hljs-attribute">else</span><br>        <span class="hljs-attribute">OLEDPrint</span>(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&quot;I2C Err!&quot;</span>);<br></code></pre></td></tr></table></figure><p>先初始化iic，在0地址写入0x55，然后再读取出来，判断是否与写入的一样，一样则打印OK，否则打印Err。</p><p>为了防止OLED出现之前显示的数据残留，需要再写一个清除Page的函数：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void <span class="hljs-constructor">OLEDClearPage(<span class="hljs-params">int</span> <span class="hljs-params">page</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> i;<br>    <span class="hljs-constructor">OLEDSetPos(<span class="hljs-params">page</span>, 0)</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">128</span>; i++)<br>        <span class="hljs-constructor">OLEDWriteDat(0)</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第006节_使用SPI控制器</strong></p><hr><p>前面我们都是通过GPIO管脚来实现的SPI通信，这节我们使用2440里面的GPIO控制器来实现SPI通信。</p><p>前面使用GPIO发送数据时，是手工的控制时钟线、数据线，我们使用SPI控制器的话，只需要 把数据写入寄存器，它就可以帮我自动那些时钟线和数据线，我们继续在上一节的基础上修改，添加一个文件s3c2440_spi.c和s3c2440_spi.h，同时修改Makefile，替换gpio_spi.c为s3c2440_spi.o。</p><p>从初始化函数开始，需要管脚初始化和SPI控制器初始化：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-built_in">SPIInit</span>(void)<br>&#123;<br>    <span class="hljs-comment">/* 初始化引脚 */</span><br>    <span class="hljs-built_in">SPI_GPIO_Init</span>();<br><br>    <span class="hljs-built_in">SPIControllerInit</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>管脚初始化即需要把SPI相关的CLK、MOSI、MISO配置为对应的功能引脚：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs coq">static void SPI_GPIO_Init(void)<br>&#123;<br>    /* GPF1 OLED_CSn output */<br>    GPFCON &amp;= ~(<span class="hljs-number">3</span>&lt;&lt;(<span class="hljs-number">1</span>*<span class="hljs-number">2</span>));<br>    GPFCON |<span class="hljs-type">= (1</span>&lt;&lt;(<span class="hljs-number">1</span>*<span class="hljs-number">2</span>));<br>    GPFDAT |<span class="hljs-type">= (1</span>&lt;&lt;<span class="hljs-number">1</span>);<br><br>    /* GPG2 FLASH_CSn output    <br>     * GPG4 OLED_DC   output    <br>     * GPG5 SPIMISO       <br>     * GPG6 SPIMOSI       <br>     * GPG7 SPICLK         <br>     */<br>    GPGCON &amp;= ~((<span class="hljs-number">3</span>&lt;&lt;(<span class="hljs-number">2</span>*<span class="hljs-number">2</span>)) | <span class="hljs-type">(3</span>&lt;&lt;(<span class="hljs-number">4</span>*<span class="hljs-number">2</span>)) | <span class="hljs-type">(3</span>&lt;&lt;(<span class="hljs-number">5</span>*<span class="hljs-number">2</span>)) | <span class="hljs-type">(3</span>&lt;&lt;(<span class="hljs-number">6</span>*<span class="hljs-number">2</span>)) | <span class="hljs-type">(3</span>&lt;&lt;(<span class="hljs-number">7</span>*<span class="hljs-number">2</span>)));<br>    GPGCON |<span class="hljs-type">= ((1</span>&lt;&lt;(<span class="hljs-number">2</span>*<span class="hljs-number">2</span>)) | <span class="hljs-type">(1</span>&lt;&lt;(<span class="hljs-number">4</span>*<span class="hljs-number">2</span>)) | <span class="hljs-type">(3</span>&lt;&lt;(<span class="hljs-number">5</span>*<span class="hljs-number">2</span>)) | <span class="hljs-type">(3</span>&lt;&lt;(<span class="hljs-number">6</span>*<span class="hljs-number">2</span>)) | <span class="hljs-type">(3</span>&lt;&lt;(<span class="hljs-number">7</span>*<span class="hljs-number">2</span>)));<br>    GPGDAT |<span class="hljs-type">= (1</span>&lt;&lt;<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是SPI控制器的初始化，控制器的初始化可以参考芯片手册介绍的编程步骤：</p><p><img src="/image/700px-Chapter20_lesson6_001.jpg" alt="700px-Chapter20_lesson6_001.jpg"></p><p>首先是设置波特率，要根据外设所能接受的范围来设置，比如查阅OLED的芯片手册得知其时钟最小值为100ns，即最小为10MHz；Flash时钟支持最大104MHz，为了代码简单，就直接取10MHz，根据等式推出寄存器值：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Baud</span> rate = PCLK / <span class="hljs-number">2</span> / (Prescaler value + <span class="hljs-number">1</span>)<br><span class="hljs-attribute">10</span> = <span class="hljs-number">50</span> / <span class="hljs-number">2</span> / (Prescaler value + <span class="hljs-number">1</span>)<br><span class="hljs-attribute">Prescaler</span> value = <span class="hljs-number">1</span>.<span class="hljs-number">5</span> = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>实际的波特率为：50&#x2F;2&#x2F;3&#x3D;8.3MHz</p><p>根据参考流程，接下来设置SPI控制寄存器：</p><p><img src="/image/700px-Chapter20_lesson6_001.jpg" alt="700px-Chapter20_lesson6_001.jpg"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-attr">[6:5]</span>设置为查询模式: <span class="hljs-number">00</span> polling mode<br><span class="hljs-selector-attr">[4]</span>设置时钟使能: <span class="hljs-number">1</span> = enable<br><span class="hljs-selector-attr">[3]</span>设置为主机模式: <span class="hljs-number">1</span> = master<br><span class="hljs-selector-attr">[2]</span>设置无数据时时钟为低电平: <span class="hljs-number">0</span><br><span class="hljs-selector-attr">[1]</span>设置工作模式为模式A: <span class="hljs-number">0</span> = format A<br><span class="hljs-selector-attr">[0]</span>设置发送数据时无需读取数据: <span class="hljs-number">0</span> = <span class="hljs-attribute">normal</span> mode<br></code></pre></td></tr></table></figure><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ada">static void SPIControllerInit(void)<br>&#123;<br>    /* OLED  : 100<span class="hljs-type">ns</span>, <span class="hljs-number">10</span>MHz    <br>     * FLASH : 104<span class="hljs-type">MHz</span>    <br>     * 取<span class="hljs-number">10</span>MHz    <br>     * <span class="hljs-number">10</span> = <span class="hljs-number">50</span> / <span class="hljs-number">2</span> / (Prescaler value + <span class="hljs-number">1</span>)    <br>     * Prescaler value = <span class="hljs-number">1.5</span> = <span class="hljs-number">2</span>    <br>     * Baud rate = <span class="hljs-number">50</span>/<span class="hljs-number">2</span>/<span class="hljs-number">3</span>=<span class="hljs-number">8.3</span>MHz    <br>     */<br>    SPPRE0 = <span class="hljs-number">2</span>;<br>    SPPRE1 = <span class="hljs-number">2</span>;<br><br>    /* [<span class="hljs-number">6</span>:<span class="hljs-number">5</span>] : 00, <span class="hljs-type">polling</span> mode    <br>     * [<span class="hljs-number">4</span>]   : 1 = <span class="hljs-type">enable</span>     <br>     * [<span class="hljs-number">3</span>]   : 1 = <span class="hljs-type">master</span>    <br>     * [<span class="hljs-number">2</span>]   : 0    <br>     * [<span class="hljs-number">1</span>]   : 0 = <span class="hljs-type">format</span> A    <br>     * [<span class="hljs-number">0</span>]   : 0 = <span class="hljs-type">normal</span> mode    <br>     */<br>    SPCON0 = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">3</span>);<br>    SPCON1 = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>发送数据时，先检查状态寄存器，判断发送&#x2F;接收数据是否准备好了，准备好后就把数据放在寄存器SPTDAT1里，SPI控制器就自己控制时序把数据自动发送出去了。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void <span class="hljs-constructor">SPISendByte(<span class="hljs-params">unsigned</span> <span class="hljs-params">char</span> <span class="hljs-params">val</span>)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (!(SPSTA1 &amp; <span class="hljs-number">1</span>));<br>    SPTDAT1 = <span class="hljs-keyword">val</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><p>接收数据时，先写0xFF到寄存器SPTDAT1，再检查状态寄存器，判断发送&#x2F;接收数据是否准备好了，准备好后就读取寄存器SPTDAT1，读取出来的就是接收到的数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-title">SPIRecvByte</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    SPTDAT1 = <span class="hljs-number">0xff</span>;    <br>    <span class="hljs-keyword">while</span> (!(SPSTA1 &amp; <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">return</span> SPRDAT1;    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第007节_移植到MINI2440_TQ2440</strong></p><hr><p>前面在JZ2440上操作了SPI Flash和OLED，这节视频是件前面的代码移植到MINI2440和TQ2440上，如果你使用的是JZ2440，本节视频就不用看了。</p><p>MINI2440和TQ2440上的SPI管脚是完全一样的，因此只需移植一个，两者就通用了，先移植GPIO模式版本的，复制前面 04th_spi_i2c_adc_jz2440_ok_020_005 里的代码，复制后的新的命名为 06th_spi_i2c_adc_mini2440_tq2440_gpio_020_007 。</p><p>修改 gpio_spi.c ，里面的管脚几乎都变化了，因此需要改 SPI_GPIO_Init() ：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs coq">static void SPI_GPIO_Init(void)<br>&#123;<br>    /* GPG1 OLED_CSn output     <br>     * GPG10 FLASH_CSn output    <br>     */<br>    GPGCON &amp;= ~((<span class="hljs-number">3</span>&lt;&lt;(<span class="hljs-number">1</span>*<span class="hljs-number">2</span>)) | <span class="hljs-type">(3</span>&lt;&lt;(<span class="hljs-number">10</span>*<span class="hljs-number">2</span>)));<br>    GPGCON |<span class="hljs-type">= (1</span>&lt;&lt;(<span class="hljs-number">1</span>*<span class="hljs-number">2</span>)) | <span class="hljs-type">(1</span>&lt;&lt;(<span class="hljs-number">10</span>*<span class="hljs-number">2</span>));<br>    GPGDAT |<span class="hljs-type">= (1</span>&lt;&lt;<span class="hljs-number">1</span>) | <span class="hljs-type">(1</span>&lt;&lt;<span class="hljs-number">10</span>);<br><br>    /*     <br>     * GPF3  OLED_DC   output    <br>     * GPE11 SPIMISO   input    <br>     * GPE12 SPIMOSI   output    <br>     * GPE13 SPICLK    output    <br>     */<br>    GPFCON &amp;= ~(<span class="hljs-number">3</span>&lt;&lt;(<span class="hljs-number">3</span>*<span class="hljs-number">2</span>));    <br>    GPFCON |<span class="hljs-type">= (1</span>&lt;&lt;(<span class="hljs-number">3</span>*<span class="hljs-number">2</span>));    <br>    GPECON &amp;= ~((<span class="hljs-number">3</span>&lt;&lt;(<span class="hljs-number">11</span>*<span class="hljs-number">2</span>)) | <span class="hljs-type">(3</span>&lt;&lt;(<span class="hljs-number">12</span>*<span class="hljs-number">2</span>)) | <span class="hljs-type">(3</span>&lt;&lt;(<span class="hljs-number">13</span>*<span class="hljs-number">2</span>)));<br>    GPECON |<span class="hljs-type">= ((1</span>&lt;&lt;(<span class="hljs-number">12</span>*<span class="hljs-number">2</span>)) | <span class="hljs-type">(1</span>&lt;&lt;(<span class="hljs-number">13</span>*<span class="hljs-number">2</span>)));<br>&#125;<br></code></pre></td></tr></table></figure><p>CLK引脚也变了，修改如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">SPI_Set_CLK</span><span class="hljs-params">(<span class="hljs-type">char</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (val)<br>        GPEDAT |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">13</span>);<br>    <span class="hljs-keyword">else</span><br>        GPEDAT &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">13</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>SPI的MOSI和MISO也要变化如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">SPI_Set_DO</span><span class="hljs-params">(<span class="hljs-type">char</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (val)<br>        GPEDAT |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">12</span>);<br>    <span class="hljs-keyword">else</span><br>        GPEDAT &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">12</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">char</span> <span class="hljs-title">SPI_Get_DI</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (GPEDAT &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">11</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于SPI Flash需要修改其片选引脚，修改 spi_flash.c 里面的片选函数如下:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">SPIFlash_Set_CS</span><span class="hljs-params">(<span class="hljs-type">char</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (val)<br>        GPGDAT |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">else</span><br>        GPGDAT &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>重新编译烧写，测试正常。 再移植SPI控制器版本的，复制前面 05th_spi_i2c_adc_jz2440_spi_controller_020_006 里的代码，复制后的新的命名为 07th_spi_i2c_adc_mini2440_tq2440_spi_controller_020_007 。 同样的首先修改GPIO初始化，修改为配套引脚：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs coq">static void SPI_GPIO_Init(void)<br>&#123;<br>    /* GPG1 OLED_CSn output     <br>     * GPG10 FLASH_CSn output    <br>     */<br>    GPGCON &amp;= ~((<span class="hljs-number">3</span>&lt;&lt;(<span class="hljs-number">1</span>*<span class="hljs-number">2</span>)) | <span class="hljs-type">(3</span>&lt;&lt;(<span class="hljs-number">10</span>*<span class="hljs-number">2</span>)));<br>    GPGCON |<span class="hljs-type">= (1</span>&lt;&lt;(<span class="hljs-number">1</span>*<span class="hljs-number">2</span>)) | <span class="hljs-type">(1</span>&lt;&lt;(<span class="hljs-number">10</span>*<span class="hljs-number">2</span>));<br>    GPGDAT |<span class="hljs-type">= (1</span>&lt;&lt;<span class="hljs-number">1</span>) | <span class="hljs-type">(1</span>&lt;&lt;<span class="hljs-number">10</span>);<br><br>    /*     <br>     * GPF3  OLED_DC   output    <br>     * GPE11 SPIMISO       <br>     * GPE12 SPIMOSI       <br>     * GPE13 SPICLK        <br>     */<br>    GPFCON &amp;= ~(<span class="hljs-number">3</span>&lt;&lt;(<span class="hljs-number">3</span>*<span class="hljs-number">2</span>));    <br>    GPFCON |<span class="hljs-type">= (1</span>&lt;&lt;(<span class="hljs-number">3</span>*<span class="hljs-number">2</span>));  <br>  <br>    GPECON &amp;= ~((<span class="hljs-number">3</span>&lt;&lt;(<span class="hljs-number">11</span>*<span class="hljs-number">2</span>)) | <span class="hljs-type">(3</span>&lt;&lt;(<span class="hljs-number">12</span>*<span class="hljs-number">2</span>)) | <span class="hljs-type">(3</span>&lt;&lt;(<span class="hljs-number">13</span>*<span class="hljs-number">2</span>)));<br>    GPECON |<span class="hljs-type">= ((2</span>&lt;&lt;(<span class="hljs-number">11</span>*<span class="hljs-number">2</span>)) | <span class="hljs-type">(2</span>&lt;&lt;(<span class="hljs-number">12</span>*<span class="hljs-number">2</span>)) | <span class="hljs-type">(2</span>&lt;&lt;(<span class="hljs-number">13</span>*<span class="hljs-number">2</span>)));<br>&#125;<br></code></pre></td></tr></table></figure><p>SPI Flash使用的是SPI0，因此将 SPTDAT1 改为 *SPTDAT1* :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SPISendByte</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (!(SPSTA0 &amp; <span class="hljs-number">1</span>));<br>    SPTDAT0 = val;    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-title">SPIRecvByte</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    SPTDAT0 = <span class="hljs-number">0xff</span>;    <br>    <span class="hljs-keyword">while</span> (!(SPSTA0 &amp; <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">return</span> SPRDAT0;    <br>&#125;<br></code></pre></td></tr></table></figure><p>修改SPI Flash的片选引脚：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">SPIFlash_Set_CS</span><span class="hljs-params">(<span class="hljs-type">char</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (val)<br>        GPGDAT |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">else</span><br>        GPGDAT &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后是OLED的片选和数据&#x2F;命令控制引脚：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">OLED_Set_DC</span><span class="hljs-params">(<span class="hljs-type">char</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (val)<br>        GPFDAT |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">else</span><br>        GPFDAT &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">3</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">OLED_Set_CS</span><span class="hljs-params">(<span class="hljs-type">char</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (val)<br>        GPGDAT |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">else</span><br>        GPGDAT &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>重新编译、烧写，测试。</p><p>SPI 是英语 Serial Peripheral interface 的缩写，顾名思义就是串行外围设备接口。SPI总线是Motorola公司推出的三线同步接口，同步串行3线方式进行通信:一条时钟线SCK，一条数据输入线MOSI，一条数据输出线MISO; </p><p> SPI，是一种高速的，全双工，同步的通信总线，并且在芯片的管脚上只占用四根线，节约了芯片的管脚</p><p><img src="/image/20161223220423489.png" alt="20161223220423489.png"></p><p>SPI全双工的特点：一边发送一边接收，硬件上只有一个SPI_DR寄存器和两个缓冲器（发送缓冲器和接收缓冲器），主模式：SPI_DR会先从发送缓冲器读出数据，然后通过MOSI引脚一位一位地将数据发出去，在发送的过程中，SPI_DR的数据会左移（如果是高位先发送），并且会从MISO引脚读入数据填补SPI_DR左移后的空缺。传输8比特数据后，SPI_DR再把数据并行写入接收缓冲寄存器。</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第019课 I2C</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AC%AC019%E8%AF%BE_I2C/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AC%AC019%E8%AF%BE_I2C/</url>
    
    <content type="html"><![CDATA[<p> </p><p><strong>目录</strong></p><hr><ol><li>第001节_I2C协议与EEPROM</li><li>第002节_S3C2440的I2C控制器</li><li>第003节_程序框架</li><li>第004节_I2C控制器编程_框架</li><li>第005节_I2C控制器编程_中断</li><li>第006节_EEPROM编程和测试代码</li><li>第007节_测试</li></ol><p><strong>第001节_I2C协议与EEPROM</strong></p><hr><p>I2C协议</p><hr><p>I2C在硬件上的接法如下(图19-1)所示，主控芯片引出两条线SCL,SDA线，在一条I2C总线上可以接很多I2C设备，我们还会放一个上拉电阻（放一个上拉电阻的原因以后我们再说）。</p><p><img src="/image/700px-Chapter19_lesson1_001.jpg" alt="700px-Chapter19_lesson1_001.jpg"></p><p>我们怎么传输数据，我们需要发数据从主设备发送到从设备上去，也需要把数据从从设备传送到主设备上去，数据涉及到双向传输。</p><p>举个例子：</p><p><img src="/image/700px-Chapter19_lesson1_002.jpg" alt="700px-Chapter19_lesson1_002.jpg"></p><p>体育老师：可以把球发给学生，也可以把球从学生中接过来。</p><ol><li>发球：</li></ol><p>a.老师说：注意了(start) </p><p>b.老师对A学生说我要球发给你(地址)。</p><p>c.老师就把球发出去了（传输）。</p><p>d.A收到球之后，应该告诉老师一声（回应）。</p><p>e.老师说下课（停止）</p><ol><li>接球：</li></ol><p>a.老师说注意了(start)，</p><p>b.老师说：B把球发给我(地址)</p><p>c.B就把球发给老师（传输）</p><p>d.老师收到球之后，给B说一声，表示收到球了（回应）。</p><p>e.老师说下课（停止）</p><p>我们就使用这个简单的例子，来解释一下IIC的传输协议。</p><ul><li>老师说注意了，表示开始信号(start)</li><li>老师告诉某个学生，表示发送地址(address)</li><li>老师发球&#x2F;接球，表示数据的传输</li><li>老师&#x2F;学生收到球，回应表示：回应信号(ACK)</li><li>老师说下课，表示IIC传输接受(P)</li></ul><p>IIC传输数据的格式</p><hr><p><strong>1.写操作：</strong></p><p>刚开始主芯片要发出一个start信号，然后发出一个设备地址(用来确定是往哪一个芯片写数据)，方向(读&#x2F;写，0表示写，1表示读)。</p><p>回应(用来确定这个设备是否存在)，然后就可以传输数据，传输数据之后，要有一个回应信号（确定数据是否接受完成)，然后再传输下一个数据。</p><p>每传输一个数据，接受方都会有一个回应信号，数据发送完之后，主芯片就会发送一个停止信号。</p><p>白色背景：主→从</p><p>灰色背景：从→主</p><p><img src="/image/700px-Chapter19_lesson1_003.jpg" alt="700px-Chapter19_lesson1_003.jpg"></p><p><strong>2.读操作：</strong></p><p>刚开始主芯片要发出一个start信号，然后发出一个设备地址(用来确定是从哪一个芯片读取数据)，方向(读&#x2F;写，0表示写，1表示读)。</p><p>回应(用来确定这个设备是否存在)，然后就可以传输数据，传输数据之后，要有一个回应信号（确定数据是否接受完成)，然后在传输下一个数据。</p><p>每传输一个数据，接受方都会有一个回应信号，数据发送完之后，主芯片就会发送一个停止信号。</p><p>白色背景：主→从</p><p>灰色背景：从→主</p><p><img src="/image/700px-Chapter19_lesson1_004.jpg" alt="700px-Chapter19_lesson1_004.jpg"></p><p>传输是以8位为单元数据传输的，先传输最高位(MSB)，主芯片发出start信号之后，然后发出9个时钟传输数据。</p><p>1). 开始信号（S）：SCL为高电平时，SDA由高电平向低电平跳变，开始传送数据。</p><p>2). 结束信号（P）：SCL为高电平时，SDA由低电平向高电平跳变，结束传送数据。</p><p>3). 响应信号(ACK)：接收器在接收到8位数据后，在第9个时钟周期，拉低SDA</p><p>SDA上传输的数据必须在SCL为高电平期间保持稳定，SDA上的数据只能在SCL为低电平期间变化。如图</p><p><img src="/image/700px-Chapter19_lesson1_005.jpg" alt="700px-Chapter19_lesson1_005.jpg"></p><p><strong>问题1：如何在SDA上实现双向传输？</strong></p><p>答：主芯片通过一根SDA线既可以把数据发给从设备，也可以从SDA上读取数据，连接SDA线的引脚里面必然有两个引脚（发送引脚&#x2F;接受引脚）。</p><p><strong>问题2：主设备(从设备)发送数据时，从设备(主设备)的发送引脚，不影响数据的发送，怎么做到呢？</strong></p><p>答：里面放一个三极管，使用开极(极电集开发出去作为输出)电路，如下图</p><p><img src="/image/700px-Chapter19_lesson1_006.jpg" alt="700px-Chapter19_lesson1_006.jpg"></p><p><img src="/image/Chapter19_lesson1_007.jpg" alt="Chapter19_lesson1_007.jpg"></p><ul><li>从真值表和电路图我们可以知道，当某一个芯片不行影响SDA线时，那就不驱动这个三极管。</li><li>想输出高电平时；都不驱动(高电平就由上拉电阻决定)。</li><li>想输出低电平，就驱动三极管。</li></ul><p>从下面的例子可以看看数据是怎么传的（实现双向传输），比如：主设备发送（8bit）给从设备 1.前8个clk</p><ul><li>从设备不要影响，从设备不驱动三极管；</li><li>主设备决定数据；</li></ul><p>2.第9个clk，由从设备决定数据</p><ul><li>主设备不驱动三极管；</li><li>从设备决定数据；</li></ul><p>从上面的例子，就可以知道，怎样在一条线上实现，双向传输的办法。这就是为什么在SDA,SCL上放上拉电阻的原因。</p><p>在第9个时钟之后，如果有某一方处于繁忙状态，它可以一直把SCL拉低当SCL为低电平时候，大家都不应该使用IIC总线，只有当SCL从低电平变为高电平的时候，IIC总线才能被使用。</p><p>从前图我们也可以知道ACK信号应该是低电平。主设备不驱动三极管，如果从设备不驱动三极端的化SDA应该是高电平，当从设备接收数据之后，发出回应信号的时候，就会驱动三极管，让SDA变为低电平。所以说：ACK信号是低电平。</p><p>对于IIC协议它只能规定怎么传输数据，数据什么含义它完全不能够控制，数据的含义有从设备决定。</p><p><strong>第002节_S3C2440的I2C控制器</strong></p><hr><p>在嵌入式系统里面的主控芯片一般都会有I2C控制器，要是没有可以根据I2C协议用GPIO管脚模拟，但是非常麻烦，我们要发送数据时，可以把数据放到某个寄存器，它就会自动的发出时钟，并且把数据发送给从设备，同时会等待从设备会返回回应信号。</p><p>当我们想发送一个数据的时候，要设置某个寄存器启动传输，它也一样会产生时钟，然后从设备就会把数据通过SDA传到I2C控制器里面，组装进某个寄存器里面，最终寄存器会把接收到的8位数据返回给我们的程序，从这里可以看到I2C控制器简化了I2C的操作。简短电路连接图，如图:</p><p><img src="/image/700px-Chapter19_lesson2_001.jpg" alt="700px-Chapter19_lesson2_001.jpg"></p><p><img src="/image/700px-Chapter19_lesson2_002.jpg" alt="700px-Chapter19_lesson2_002.jpg"></p><p>根据上图，我们首先设置IICCON(来设置时钟)，时钟源是PCLK(是50MHZ)太快了我们需要设置这个分频系数，把时钟降低，降低到我们想要的SCL,然后我们要发出start信号，我们需要设置寄存器发出start信号，之后我们需要发出数据啊，我们的程序可以把数据写入到IICDS寄存器，一写入就会自动的发出时钟，并且把这8位数据从SDA发送给从设备，数据发送之后，在第九个时钟会收到回应信号，可以查询IICSTAT是否有ACK(有ACK表示数据发送成功了)，可以继续发送数据，等发完数据之后，再来设置IICSTAT让它发出P信号。</p><p>在第九个CLK，就会产生一个中断,在中断处理过程中SCL被拉为低电平，谁都不能再使用IIC总线，等待中断处理完成.</p><p><strong>怎样处理中断？</strong></p><ul><li>写操作：<ul><li>若无ACK,出错，然后发出P信号结束，</li><li>若有ACK信号表示上一个字节成功发送出去</li><li>若仍有数据，写入IICDS寄存器，然后清中断，一清中断就会释放SCL信号，继续发出时钟，把数据再次发送出去。</li><li>若没有数据了，发出P信号结束。</li></ul></li><li>读操作：<ul><li>读到8位数时，应该回应一个ACK信号。</li></ul></li></ul><p>还想读数据，清中断，启动传输。等它再次发生中断时，再来读取IICDS寄存器,得到数据。不想读取数据，发出P信号结束。</p><p><strong>重点</strong>： 发生中断时，我们的IIC控制器会把SCL拉低，阻止任何设备再使用IIC总线，清中断之后才能继续使用，这种机制就给我们中断服务程序的执行提供了时间。</p><p><strong>读-写操作</strong></p><ul><li>在发送模式：</li></ul><p>1). 往寄存器IICDS寄存器放入一个val值。</p><p>2). 发完，产生中断，并且会把 SCL拉低。</p><p>3). 在中断程序里，判断状态，然后往IICDS里面写入下一个数据，一旦写入下一个数据IIC继续操作，若再次发完，就会再次产生中断。</p><ul><li>在接受模式：</li></ul><p>1). 我的程序发起传输，接受数据。</p><p>2). 接收到数据之后，产生中断，SCL被拉低。</p><p>3). 中断程序里，判断数据是否要继续接受等，如果还有继续接受的话，再次设置，设置好之后读IICDS寄存器，一但读出来IIC。</p><p>继续接受下一个数据，收到新数据之后，又会产生一个中断（就是这样循环操作）。</p><p><strong>（1）IICCON寄存器（Multi-msterIIC-buscontrol)</strong></p><p>IICCON寄存器用于控制是否发出ACK信号、设置发送器的时钟、开启，i2c中断，并标识中断是否发生。它的各位含义如表:</p><p><img src="/image/700px-Chapter19_lesson2_003.jpg" alt="700px-Chapter19_lesson2_003.jpg"></p><p>使用IICCON寄存器时，有如下注意事项。</p><p>1). 发送模式的时钟频率由位[6]、位[3:0]联合决定,另外，llCCON[6]&#x3D;0,IICCON[3:0] 不能取0或10</p><p>2). 12c中断在以下3种情况下发生：当发出地址信息或接收到一个从机地址并且吻合时,当总线仲裁失败时，当发送&#x2F;接收完一个字节的数据（包括响应位）时。</p><p>3). 基于SDA、SCL线上时间特性的考虑，要发送数据时，先将数据写入IICDS寄存器，然后再清除中断。</p><p>4). 如果IICCON[5]&#x3D;0，IICCON14]将不能正常工作。所以，即使不使用12c中断，也要将IICCON[5]设为1。</p><p><strong>（2）IICSTAT寄存器(Multi-masterIIC-buscontrol&#x2F;status)</strong></p><p>IICSTAT寄存器用于选择12c接口的工作模式，发出S信号、P信号，使能接收／发送功能，并标识各种状态，比如总线仲裁是否成功、作为从机时是否被寻址、是否接收到0地址、是否接收到ACK信号等。IICSTAT寄存器的各位如表:</p><p><img src="/image/700px-Chapter19_lesson2_004.jpg" alt="700px-Chapter19_lesson2_004.jpg"></p><p><strong>（3）IICADD寄存器(Multi-masterIlC-busaddress)</strong></p><p>用到IICADD寄存器的位[7:11]，表示从机地址。IICADD寄存器在串行输出使能位 IICSTAT[4]为0时，才可以写入：在任何时间都可以读出。IICADD寄存器的各位如表:</p><p><img src="/image/700px-Chapter19_lesson2_005.jpg" alt="700px-Chapter19_lesson2_005.jpg"></p><p><strong>（4）IICDS寄存器(Multi-masterIIC-busTx&#x2F;Rxdatashift)</strong></p><p>用到IICDS寄存器的位丨7：0]，其中保存的是要发送或己经接收的数据。IICDS寄存器在串行输出使能位IICSTAT()1为1时，叼可以写入；在任何时间都可以读出。IICDS寄存器的各位如表:</p><p><img src="/image/700px-Chapter19_lesson2_006.jpg" alt="700px-Chapter19_lesson2_006.jpg"></p><p><strong>读写操作流程图</strong></p><p>主机发送器模式操作:</p><p><img src="/image/700px-Chapter19_lesson2_007.jpg" alt="700px-Chapter19_lesson2_007.jpg"></p><p>主机接收器模式操作:</p><p><img src="/image/700px-Chapter19_lesson2_008.jpg" alt="700px-Chapter19_lesson2_008.jpg"></p><p><strong>第003节_程序框架</strong></p><hr><p>写程序之前 考虑好程序的框架，我们想写出一个结构比较好，比较容易扩展的程序</p><p>我们先要考虑清楚框架的设计。</p><p>IIC控制器的功能</p><hr><p>IIC会做什么事情呢？</p><p>对于IIC控制器，它负责传输数据，不知道数据的含义，但是它要实现写&#x2F;读操作</p><p><strong>读操作</strong></p><p><img src="/image/800px-Chapter19_lesson3_001.jpg" alt="800px-Chapter19_lesson3_001.jpg"></p><p><strong>写操作</strong></p><p><img src="/image/800px-Chapter19_lesson3_002.jpg" alt="800px-Chapter19_lesson3_002.jpg"></p><p>IIC设备的功能</p><hr><p>很显然，IIC控制器提供了传输数据的能力，至于数据有什么含义，IIC控制器并不知道，数据的含义有外接的IIC芯片决定，我们需要阅读芯片手册，才知道IIC控制器应该发出怎样的数据，</p><p>AT24cxx的操作方法</p><p><img src="/image/800px-Chapter19_lesson3_003.jpg" alt="800px-Chapter19_lesson3_003.jpg"></p><p><img src="/image/800px-Chapter19_lesson3_004.jpg" alt="800px-Chapter19_lesson3_004.jpg"></p><p>显然我们的程序应该分为两层（IIC设备层，IIC控制器层），框架如下图所示：</p><p><img src="/image/800px-Chapter19_lesson3_005.jpg" alt="800px-Chapter19_lesson3_005.jpg"></p><p>我们提供一个统一的接口i2c_transfer，不关使用哪个芯片，他最终都会调用i2c_transfer，来选择某一款I2C控制器，把数据发送出去，或者从I2c设备读到数据，对于每一次传输的数据都可以用一个i2c_msg结构体来表示。但是，读某个地址的数据时，就要用两个i2c_msg结构体来描述它，因为一个i2c_msg结构体只能描述一个传输方向(读&#x2F;写)，我们读取ac24ccxx某个地址上的数据时，要先写出要读取的地址，然后来读取设备地址上的数据。</p><p>我们想设计出以一个结构体比较容易扩展的框架，对于I2C控制器我们要抽象出一个结构体i2c_controller，我们构造这个结构体之后，把这个这个结构体，告诉上层(I2C控制器那一层)，上层有个管理者i2c_contreller.c文件。</p><p>我们在s3c2440_i2c_controller.c这个文件中我们构造出一个i2c_controller结构体，把它放入上层文件中的数组里，以后就根据结构体的名字，把这个结构体取出来使用。</p><p>假设我们有一个TI的开发板，在ti_i2c_controller.c文件中，也要构造出一个i2c_controller结构体，同样们也会把这个结构体放入上层的结构体数组(i2c_contreller.c文件中)中，以后根据名字先出来使用。</p><p>对于设备层中的at24cxx芯片我们写出at24cxx.c文件在这个文件实现读写函数：</p><p>1). at24cxx_write函数</p><p>2). at24cxx_read。</p><p>函数读写函数都会调用i2c_transfer发起IIC传输，所以我们写程序的时候主要的暂时会涉及到三个文件：</p><p>at24cxx.c， s3c2440_i2c_controller.c，i2c_contreller.c。在最上层会写出一个i2c_test.c文件，它会提供菜单供我们选择来测试。</p><p>下面我们写一个程序框架，涉及到的文件有：i2c_test.c、at24cxx.c、i2c_controller.c、s3c2440_i2c_controller.c。</p><p><strong>i2c_test.c文件</strong></p><p>该文件的内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">i2c_test</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>        <span class="hljs-comment">/* 初始化: 选择I2C控制器 */</span><br>        <span class="hljs-comment">/* 提供菜单供测试 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个菜单最终会调用到at24cxx.c里面的函数。</p><p><strong>at24cxx.c文件</strong></p><p>在里面会使用标准的接口i2c_transfer来启动I2C传输。该文件的内容如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> at24cxx<span class="hljs-constructor">_write(<span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">addr</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">data</span>, <span class="hljs-params">int</span> <span class="hljs-params">len</span>)</span><br>&#123;<br>        <span class="hljs-comment">/* 构造i2c_msg */</span><br>        <span class="hljs-comment">/* 调用i2c_transfer */</span><br>&#125;<br><br><span class="hljs-built_in">int</span> at24cxx<span class="hljs-constructor">_read(<span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">addr</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">data</span>, <span class="hljs-params">int</span> <span class="hljs-params">len</span>)</span><br>&#123;<br>        <span class="hljs-comment">/* 构造i2c_msg */</span><br>        <span class="hljs-comment">/* 调用i2c_transfer */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>i2c_controller.c文件</strong></p><p>该文件的内容如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/* 有一个i2c_controller数组用来存放各种不同芯片的操作结构体 */</span><br>void register<span class="hljs-constructor">_i2c_controller()</span><br>&#123;<br>&#125;<br><br><span class="hljs-comment">/* 根据名字来选择某款I2C控制器 */</span><br>void select<span class="hljs-constructor">_i2c_controller(<span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">name</span>)</span><br>&#123;<br>&#125;<br><br><span class="hljs-comment">/* 实现 i2c_transfer 接口函数 */</span><br><span class="hljs-built_in">int</span> i2c<span class="hljs-constructor">_transfer(<span class="hljs-params">i2c_msg</span> <span class="hljs-params">msgs</span>, <span class="hljs-params">int</span> <span class="hljs-params">num</span>)</span><br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>select_i2c_controller函数根据名字来选择某款I2C控制器后，以后就会使用被选择的I2C控制器来启动传输。</p><p>有数组一定有注册函数register_i2c_controller会把下面实现的I2C控制器结构体i2c_controller放到i2c_controller数组里面。</p><p><strong>s3c2440_i2c_controller.c文件</strong></p><p>对于具体的芯片，要实现自己的i2c_controller。该文件的内容如下：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">/* 实现i2c_controller          <br>        <span class="hljs-string">.init</span>          <br>        <span class="hljs-string">.master_xfer</span>          <br>        <span class="hljs-string">.name</span> <br>*/<br></code></pre></td></tr></table></figure><p><strong>第004节_I2C控制器编程_框架</strong></p><hr><p>我们现在来讲I2C控制器怎么写，它是I2C程序中最核心的地方，我们要先构造几个结构体，这几个结构体放在i2c_controller.h里面。</p><p>我们要发出I2c传输时，要构造出i2c_msg，把构造出的i2c_msg扔给下面的i2c_controller.c，i2c_controller.c会选择某一个i2c控制器，使用里面的master_xfer来传输数据， 所以我们需要构造出一个i2c_controller结构体。</p><p><strong>i2c_controller.h文件</strong></p><p>文件的内容如下所示：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _I2C_CONTROLLER_H</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> i2c_msg &#123;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> addr;  <span class="hljs-comment">/* 7bits */</span><br>        <span class="hljs-type">int</span> flags;  <span class="hljs-comment">/* 0 - write, 1 - read */</span><br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-type">int</span> cnt_transferred;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *buf;<br>&#125;i2c_msg, *p_i2c_msg;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> i2c_controller &#123;<br>        <span class="hljs-type">int</span> (*<span class="hljs-type">int</span>)(<span class="hljs-type">void</span>);<br>        <span class="hljs-type">int</span> (*master_xfer)(i2c_msg msgs, <span class="hljs-type">int</span> num);<br>        <span class="hljs-type">char</span> *name;&#125;i2c_controller, *p_i2c_controller;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* _I2C_CONTROLLER_H */</span></span><br></code></pre></td></tr></table></figure><p>解析：我们构造这两个结构体，我们要把它放在i2c_controller.c把它用起来</p><p><strong>i2c_controller.c文件</strong></p><p>文件的内容如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> I2C_CONTROLLER_NUM 10</span><br><span class="hljs-comment">/* 有一个i2c_controller数组用来存放各种不同芯片的操作结构体 */</span><br><span class="hljs-type">static</span> p_i2c_controller p_i2c_controllers[I2C_CONTROLLER_NUM];<span class="hljs-type">static</span> p_i2c_controller p_i2c_con_selected;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">register_i2c_controller</span><span class="hljs-params">(p_i2c_controller *p)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; I2C_CONTROLLER_NUM; i++)<br>        &#123;<br>                <span class="hljs-keyword">if</span> (!p_i2c_controllers[i])<br>                &#123;<br>                        p_i2c_controllers[i] = p;<br>                        <span class="hljs-keyword">return</span>;<br>                &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解析：register_i2c_controller函数用于把参数中的结构体指针，注册到p_i2c_controllers指针数组中</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> select_i2c_controller(<span class="hljs-type">char</span> *<span class="hljs-type">name</span>)<br>&#123;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; I2C_CONTROLLER_NUM; i++)<br>        &#123;<br>                <span class="hljs-keyword">if</span> (p_i2c_controllers[i] &amp;&amp; !strcmp(<span class="hljs-type">name</span>, p_i2c_controllers[i]-&gt;<span class="hljs-type">name</span>))<br>                &#123;<br>                        p_i2c_con_selected = p_i2c_controllers[i];<br>                        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>解析：select_i2c_controller函数根据参数中的名字(name) 从p_i2c_controllers指针数组中取出对应的结构体指针复制给p_i2c_con_selected结构体指针(静态全局变量)。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/* 实现 i2c_transfer 接口函数 */</span><br><span class="hljs-built_in">int</span> i2c<span class="hljs-constructor">_transfer(<span class="hljs-params">i2c_msg</span> <span class="hljs-params">msgs</span>, <span class="hljs-params">int</span> <span class="hljs-params">num</span>)</span><br>&#123;<br>        return p_i2c_con_selected-&gt;master<span class="hljs-constructor">_xfer(<span class="hljs-params">msgs</span>, <span class="hljs-params">num</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>解析：i2c_transfer接口函数，调用选择的p_i2c_con_selected成员中master_xfer函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">i2c_init</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>        <span class="hljs-comment">/* 注册下面的I2C控制器 */</span><br>        <span class="hljs-title function_">s3c2440_i2c_con_add</span>();<br>        <span class="hljs-comment">/* 选择某款I2C控制器 */</span><br>        <span class="hljs-comment">/* 调用它的init函数 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>解析：s3c2440_i2c_con_add()函数，把定义的s3c2440_i2c_con结构体注册给p_i2c_controllers数组中。</p><p><strong>s3c2440_i2c_controller.c文件</strong></p><p>中断服务函数，当发成中断是，就会调用中断服务函数，代码如下</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">i2c_interrupt_func</span><span class="hljs-params">(<span class="hljs-type">int</span> irq)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-comment">/* 每传输完一个数据将产生一个中断 */</span><br>        <span class="hljs-comment">/* 对于每次传输, 第1个中断是&quot;已经发出了设备地址&quot; */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>s3c2440_i2c_con_init函数，用来初始化I2C,控制器代码如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk">void s3c2440_i2c_con_init(void)<br>&#123;<br>        <span class="hljs-regexp">/* 设置时钟 */</span><br>        /* [<span class="hljs-number">7</span>] : IIC-bus acknowledge enable bit, <span class="hljs-number">1</span>-enable <span class="hljs-keyword">in</span> rx mode  <br>         * [<span class="hljs-number">6</span>] : 时钟源, <span class="hljs-number">0</span>: IICCLK = fPCLK <span class="hljs-regexp">/16; 1: IICCLK = fPCLK /</span><span class="hljs-number">512</span>  <br>         * [<span class="hljs-number">5</span>] : <span class="hljs-number">1</span>-enable interrupt  <br>         * [<span class="hljs-number">4</span>] : 读出为<span class="hljs-number">1</span>时表示中断发生了, 写入<span class="hljs-number">0</span>来清除并恢复I2C操作  <br>         * [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] : Tx clock = IICCLK/(IICCON[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>).  <br>         * Tx Clock = <span class="hljs-number">100</span>khz = <span class="hljs-number">50</span>Mhz<span class="hljs-regexp">/16/</span>(IICCON[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>)  <br>         */<br>        IICCON = (<span class="hljs-number">0</span>&lt;&lt;<span class="hljs-number">6</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>) | (<span class="hljs-number">30</span>&lt;&lt;<span class="hljs-number">0</span>);<br>        <span class="hljs-regexp">/* 注册中断处理函数 */</span><br>        register_irq(<span class="hljs-number">27</span>, i2c_interrupt_func);<br>&#125;<br></code></pre></td></tr></table></figure><p>解析：</p><p>1). IICCON &#x3D; (0&lt;&lt;6) | (1&lt;&lt;5) | (30&lt;&lt;0); 设置IICCON控制寄存器。选择发送时钟，使能中断。</p><p>2). register_irq(27, i2c_interrupt_func)：注册中断处理函数，当发生I2C中断的时候就会调用i2c_interrupt_func中断处理函数。</p><p>初始化完成后，就可以调用do_master_tx写I2C从机了，这个函数仅仅启动I2C传输，然后等待，直到数据在中断服务程序中传输完毕后再返回。函数代码如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk">void do_master_tx(p_i2c_msg msg)<br>&#123;<br>        msg-&gt;cnt_transferred = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-regexp">/* 设置寄存器启动传输 */</span><br>        <span class="hljs-regexp">/* 1. 配置为 master tx mode */</span><br>                <br>        <span class="hljs-regexp">/* 2. 把从设备地址写入IICDS */</span><br>        IICDS = msg-&gt;addr&lt;&lt;<span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-regexp">/* 3. IICSTAT = 0xf0 , 数据即被发送出去, 将导致中断产生 */</span><br>        IICSTAT = <span class="hljs-number">0</span>xf0;<br>        <br>        <span class="hljs-regexp">/* 后续的传输由中断驱动 */</span><br>        <span class="hljs-regexp">/* 循环等待中断处理完毕 */</span><br>        <span class="hljs-keyword">while</span> (msg-&gt;cnt_transferred != msg-&gt;len);<br>&#125;<br></code></pre></td></tr></table></figure><p>解析：</p><p>1). IICDS &#x3D; msg-&gt;addr&lt;&lt;1: 把从机地址（高7位，所以需要向右移一位）写入到IICDS寄存器中。</p><p>2). IICSTAT &#x3D; 0xf0:设置IICSTAT寄存器，将s3c2440设为主机发送器，并发出S信号后，紧接着就发出从机地址。后续的传输工作将在中断服务程序中完成。</p><p>do_master_rx函数的实现和do_master_tx函数类似，代码如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk">void do_master_rx(p_i2c_msg msg)<br>&#123;<br>        msg-&gt;cnt_transferred = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-regexp">/* 设置寄存器启动传输 */</span><br>        <span class="hljs-regexp">/* 1. 配置为 Master Rx mode */</span><br>                <br>        <span class="hljs-regexp">/* 2. 把从设备地址写入IICDS */</span><br>        IICDS = (msg-&gt;addr&lt;&lt;<span class="hljs-number">1</span>)|(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>);<br>        <br>        <span class="hljs-regexp">/* 3. IICSTAT = 0xb0 , 从设备地址即被发送出去, 将导致中断产生 */</span><br>        IICSTAT = <span class="hljs-number">0</span>xb0;<br>        <br>        <span class="hljs-regexp">/* 后续的传输由中断驱动 */</span><br>        <span class="hljs-regexp">/* 循环等待中断处理完毕 */</span><br>        <span class="hljs-keyword">while</span> (msg-&gt;cnt_transferred != msg-&gt;len);<br>&#125;<br></code></pre></td></tr></table></figure><p>解析： 1).IICDS &#x3D; (msg-&gt;addr&lt;&lt;1)|(1&lt;&lt;0)：把从设备地址写入IICDS，前7位是从机地址，第8位表示传输方向(0表示写操作，1表示读操作)。</p><p>s3c2440传输函数，根据标志位flags，来指明是读&#x2F;写(1：读 0：写)。代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> s3c2440<span class="hljs-constructor">_master_xfer(<span class="hljs-params">p_i2c_msg</span> <span class="hljs-params">msgs</span>, <span class="hljs-params">int</span> <span class="hljs-params">num</span>)</span><br>&#123;<br>        <span class="hljs-built_in">int</span> i;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num; i++)  <br>        &#123;<br>                <span class="hljs-keyword">if</span> (msgs<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>-&gt;flags<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)<span class="hljs-comment">/* write */</span><br>                        <span class="hljs-keyword">do</span><span class="hljs-constructor">_master_tx(<span class="hljs-params">msgs</span>[<span class="hljs-params">i</span>])</span>;<br>                <span class="hljs-keyword">else</span><br>                        <span class="hljs-keyword">do</span><span class="hljs-constructor">_master_rx(<span class="hljs-params">msgs</span>[<span class="hljs-params">i</span>])</span>;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们定义一个i2c_controller结构体s3c2440_i2c_con。下面的代码对他进行初始化。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">static i2c_controller s3c2440_i2c_con = &#123;<br>        <span class="hljs-string">.name</span> = <span class="hljs-string">&quot;s3c2440&quot;</span>,<br>        <span class="hljs-string">.init</span> = s3c2440_i2c_con_init,<br>        <span class="hljs-string">.master_xfer</span> = s3c2440_master_xfer,<br>&#125;;<br></code></pre></td></tr></table></figure><p>s3c2440_i2c_con_add函数把上面定义的s3c2440_i2c_con结构体注册到上层的i2c_controller数组中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">s3c2440_i2c_con_add</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>        <span class="hljs-title function_">register_i2c_controller</span>(&amp;s3c2440_i2c_con);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第005节_I2C控制器编程_中断</strong></p><hr><p>中断控制器是IIC程序中的核心中的核心。</p><p>Start信号之后，发出设备地址，在第9个时钟就会产生一个中断，我们根据i2c的流程图来编写中断程序。</p><p>每传输完一个数据将产生一个中断，I2C操作的主体在中断服务程序，它可以分为两部分：写操作，读操作。</p><p>先分析写操作，代码如下：</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs zephir">void i2c_interrupt_func(<span class="hljs-keyword">int</span> irq)<br>&#123;<br>        <span class="hljs-keyword">int</span> index;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> iicstat = IICSTAT;<br><br>        p_cur_msg-&gt;cnt_transferred++;<br>        <br>        <span class="hljs-comment">/* 每传输完一个数据将产生一个中断 */</span><br><br>        <span class="hljs-comment">/* 对于每次传输, 第1个中断是&quot;已经发出了设备地址&quot; */</span><br><br>        <span class="hljs-keyword">if</span> (p_cur_msg-&gt;flags == <span class="hljs-number">0</span>)       <span class="hljs-comment">/* write */</span><br>        &#123;<br>                <span class="hljs-comment">/* 对于第1个中断, 它是发送出设备地址后产生的         </span><br><span class="hljs-comment">                 * 需要判断是否有ACK          </span><br><span class="hljs-comment">                 * 有ACK : 设备存在          </span><br><span class="hljs-comment">                 * 无ACK : 无设备, 出错, 直接结束传输          </span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">if</span> (p_cur_msg-&gt;cnt_transferred == <span class="hljs-number">0</span>)  <span class="hljs-comment">/* 第1次中断 */</span><br>                &#123;<br>                        <span class="hljs-keyword">if</span> (iicstat &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>))<br>                        &#123; <span class="hljs-comment">/* no ack */</span><br>                                <span class="hljs-comment">/* 停止传输 */</span><br>                                IICSTAT = <span class="hljs-number">0xd0</span>;<br>                                IICCON &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>);<br>                                p_cur_msg-&gt;err = <span class="hljs-number">-1</span>;<br>                                delay(<span class="hljs-number">1000</span>);<br>                                <span class="hljs-keyword">return</span>;<br>                        &#125;<br>                &#125;<br></code></pre></td></tr></table></figure><p>1). p_cur_msg-&gt;cnt_transferred初始值为-1(我们后面设置)。</p><p>2). p_cur_msg-&gt;cnt_transferred &#x3D;&#x3D; 0表示是第一次传输数据产生的中断，即发送从设备地址产生的中断。</p><p>3). iicstat &amp; (1&lt;&lt;0)表示主机没有接受到ACK信号(即发出的设备地址不存在)，需要停止传输。</p><p>4). IICSTAT &#x3D; 0xd0置IICSTAT寄存器的[5]写为0，以便发出P信号，但是由于这时IICCON[4]仍为1，P信号没有实际发出，当执行IICCON &amp;&#x3D; ~(1&lt;&lt;4);清除IICCON[4]后，P信号才真正发出。</p><p>5). 等待一段时间，确保P信号已经发送完毕。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xl">              <span class="hljs-function"><span class="hljs-title">if</span> (p_cur_msg-&gt;</span><span class="hljs-function"><span class="hljs-title">cnt_transferred</span> &lt; p_cur_msg-&gt;</span>len)<br>                &#123;<br>                        <span class="hljs-comment">/* 对于其他中断, 要继续发送下一个数据                  */</span><br>                        IICDS = <span class="hljs-function"><span class="hljs-title">p_cur_msg</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">buf</span>[p_cur_msg-&gt;</span>cnt_transferred];<br>                        IICCON &amp;= ~(<span class="hljs-number">1</span><span class="hljs-string">&lt;&lt;4);</span><br><span class="hljs-string">                &#125;</span><br><span class="hljs-string">                else</span><br><span class="hljs-string">                &#123;</span><br><span class="hljs-string">                        /* 停止传输 */</span><br><span class="hljs-string">                        IICSTAT = 0xd0;</span><br><span class="hljs-string">                        IICCON &amp;= ~(1&lt;&lt;4);</span><br><span class="hljs-string">                        p_cur_msg-&gt;err = -1;</span><br><span class="hljs-string">                        delay(1000);</span><br><span class="hljs-string">                &#125;</span><br><span class="hljs-string">        &#125;</span><br></code></pre></td></tr></table></figure><p>1). 假如if (p_cur_msg-&gt;cnt_transferred &lt; p_cur_msg-&gt;len)条件成立，表示数据还没有发送完毕，需要继续发送数据。</p><p>2). 执行IICDS &#x3D; p_cur_msg-&gt;buf[p_cur_msg-&gt;cnt_transferred把要发送的数据写入到IICDS寄存器中，经过执行IICCON &amp;&#x3D; ~(1&lt;&lt;4);清除中断标志后后，紧接着就自动把数据发送出去了，这将触发下一个中断。</p><p>3). 如果条件不成立表示数据传输完毕，发出P信号，停止数据的传输。</p><p>写操作：I2C读操作的处理与写操作类似，我们就不进行分析了，代码如下：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">else</span> <span class="hljs-comment">/* read */</span><br>        &#123;<br>                <span class="hljs-comment">/* 对于第1个中断, 它是发送出设备地址后产生的          </span><br><span class="hljs-comment">                 * 需要判断是否有ACK          </span><br><span class="hljs-comment">                 * 有ACK : 设备存在, 恢复I2C传输, 这样在下一个中断才可以得到第1个数据          </span><br><span class="hljs-comment">                 * 无ACK : 无设备, 出错, 直接结束传输          </span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">if</span> (p_cur_msg-&gt;cnt_transferred == <span class="hljs-number">0</span>)  <span class="hljs-comment">/* 第1次中断 */</span><br>                &#123;<br>                        <span class="hljs-keyword">if</span> (iicstat &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>))<br>                        &#123; <span class="hljs-comment">/* no ack */</span><br>                                <span class="hljs-comment">/* 停止传输 */</span><br>                                IICSTAT = <span class="hljs-number">0x90</span>;<br>                                IICCON &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>);<br>                                p_cur_msg-&gt;err = -<span class="hljs-number">1</span>;<br>                                delay(<span class="hljs-number">1000</span>);<br>                                <span class="hljs-keyword">return</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* ack */</span><br>                        &#123;<br>                                <span class="hljs-comment">/* 恢复I2C传输 */</span><br>                                IICCON &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>);<br>                                <span class="hljs-keyword">return</span>;<br>                        &#125;<br>                &#125;<br>                <span class="hljs-comment">/* 非第1个中断, 表示得到了一个新数据          </span><br><span class="hljs-comment">                 * 从IICDS读出、保存          </span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">if</span> (p_cur_msg-&gt;cnt_transferred &lt; p_cur_msg-&gt;len)<br>                &#123;<br>                        index = p_cur_msg-&gt;cnt_transferred - <span class="hljs-number">1</span>;<br>                        p_cur_msg-&gt;buf[index] = IICDS;<br>                        <span class="hljs-comment">/* 恢复I2C传输 */</span><br>                        IICCON &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>);<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                        <span class="hljs-comment">/* 发出停止信号 */</span><br>                        IICSTAT = <span class="hljs-number">0x90</span>;<br>                        IICCON &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>);<br>                        delay(<span class="hljs-number">1000</span>);<br>                &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们还要在s3c2440_i2c_con_init函数中设置IICCON寄存器，设置ACK应答使能。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">IICCON</span> = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">7</span>) | (<span class="hljs-number">0</span>&lt;&lt;<span class="hljs-number">6</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>) | (<span class="hljs-number">30</span>&lt;&lt;<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p><strong>第006节_EEPROM编程和测试代码</strong></p><hr><p>从设备程序，只涉及到两个函数分别是：从设备的写函数，从设备的读函数。下面下分析从设备的写函数，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24CXX_ADDR 0x50</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">at24cxx_write</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *data, <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>        i2c_msg msg;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-type">int</span> err;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> buf[<span class="hljs-number">2</span>];<br>        <br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>        &#123;<br>                buf[<span class="hljs-number">0</span>] = addr++;<br>                buf[<span class="hljs-number">1</span>] = data[i];<br>                <br>                <span class="hljs-comment">/* 构造i2c_msg */</span><br>                msg.addr  = AT24CXX_ADDR;<br>                msg.lags = <span class="hljs-number">0</span>; <span class="hljs-comment">/* write */</span><br>                msg.len   = <span class="hljs-number">2</span>;<br>                msg.buf   = buf;<br>                msg.err   = <span class="hljs-number">0</span>;<br>                msg.cnt_transferred = <span class="hljs-number">-1</span>;<br>                <span class="hljs-comment">/* 调用i2c_transfer */</span><br>                err = <span class="hljs-built_in">i2c_transfer</span>(&amp;msg, <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (err)<br>                        <span class="hljs-keyword">return</span> err;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>1). #define AT24CXX_ADDR 0x50宏定义设备地址。</p><p>2). 我们每次只写一个字节，所以我们需要构造出len个msg。</p><p>3). 调用i2c接口函数，传输构造i2C_msg结构体，我们传输指针只需要传输四个字节，我们需要把以前的参数都改成传输指针的格式。</p><p>从设备读函数和写函数类似，读函数需要构造两个i2c_msg(每个i2c_msg只能表示一个传输方向) ，因为在读操作之前，需要把要读的地址告诉从设备。</p><p>代码如下：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs prolog">int at24cxx_read(unsigned int addr, unsigned char *data, int len)<br>&#123;<br>        i2c_msg msg[<span class="hljs-number">2</span>];<br>        int err;<br>        <br>        <span class="hljs-comment">/* 构造i2c_msg */</span><br>        msg[<span class="hljs-number">0</span>].addr  = <span class="hljs-symbol">AT24CXX_ADDR</span>;<br>        msg[<span class="hljs-number">0</span>].lags  = <span class="hljs-number">0</span>; <span class="hljs-comment">/* write */</span><br>        msg[<span class="hljs-number">0</span>].len   = <span class="hljs-number">1</span>;<br>        msg[<span class="hljs-number">0</span>].buf   = &amp;addr;<br>        msg[<span class="hljs-number">0</span>].err   = <span class="hljs-number">0</span>;<br>        msg[<span class="hljs-number">0</span>].cnt_transferred = <span class="hljs-number">-1</span>;<br>        msg[<span class="hljs-number">1</span>].addr  = <span class="hljs-symbol">AT24CXX_ADDR</span>;<br>        msg[<span class="hljs-number">1</span>].lags  = <span class="hljs-number">1</span>; <span class="hljs-comment">/* read */</span><br>        msg[<span class="hljs-number">1</span>].len   = len;<br>        msg[<span class="hljs-number">1</span>].buf   = data;<br>        msg[<span class="hljs-number">1</span>].err   = <span class="hljs-number">0</span>;<br>        msg[<span class="hljs-number">1</span>].cnt_transferred = <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">/* 调用i2c_transfer */</span><br>        err = i2c_transfer(&amp;msg, <span class="hljs-number">2</span>);<br>        if (err)<br>                return err;<br>        return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>I2c_test测试程序如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">i2c_test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">char</span> c;<br>        <span class="hljs-comment">/* 初始化 */</span><br>        <span class="hljs-built_in">i2c_init</span>();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        &#123;<br>                <span class="hljs-comment">/* 打印菜单, 供我们选择测试内容 */</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[w] Write at24cxx\n\r&quot;</span>);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[r] Read at24cxx\n\r&quot;</span>);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[q] quit\n\r&quot;</span>);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter selection: &quot;</span>);<br>                c = <span class="hljs-built_in">getchar</span>();<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n\r&quot;</span>, c);<br>                <span class="hljs-comment">/* 测试内容:          </span><br><span class="hljs-comment">                 * 3. 编写某个地址          </span><br><span class="hljs-comment">                 * 4. 读某个地址          </span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">switch</span> (c)                 <br>                &#123;<br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;q&#x27;</span>:<br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Q&#x27;</span>:<br>                                <span class="hljs-keyword">return</span>;<br>                                <span class="hljs-keyword">break</span>;<br>                                <br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;w&#x27;</span>:<br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;W&#x27;</span>:<br>                                <span class="hljs-built_in">do_write_at24cxx</span>();<br>                                <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;r&#x27;</span>:<br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;R&#x27;</span>:<br>                                <span class="hljs-built_in">do_read_at24cxx</span>();<br>                                <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-keyword">default</span>:<br>                                <span class="hljs-keyword">break</span>;<br>                &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1). 调用i2c_controller.c里面的 i2c_init()初始化函数，在这个函数中需要添加一些功能，i2c_init()代码如下所示：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-built_in">i2c_init</span>(void)<br>&#123;<br>        <span class="hljs-comment">/* 注册下面的I2C控制器 */</span><br>        <span class="hljs-built_in">s3c2440_i2c_con_add</span>();<br>        <span class="hljs-comment">/* 选择某款I2C控制器 */</span><br>        <span class="hljs-built_in">select_i2c_controller</span>(&quot;s3c2440&quot;);<br>        <span class="hljs-comment">/* 调用它的init函数 */</span><br>        p_i2c_con_selected-&gt;<span class="hljs-built_in">init</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>select_i2c_controller(“s3c2440”)用于选择s3c2440的i2c控制器。</li><li>p_i2c_con_selected-&gt;init()调用s3c2440的i2c控制器结构体中init初始化函数，初始化s3c2440的i2c控制器。</li></ul><p>2). 执行do_write_at24cxx()函数用于往at24cxx设备中写入数据，do_write_at24cxx()函数的代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&#123;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> addr;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br>        <span class="hljs-type">int</span> err;<br>        <br>        <span class="hljs-comment">/* 获得地址 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the address of sector to write: &quot;</span>);<br>        addr = <span class="hljs-built_in">get_uint</span>();<br>        <span class="hljs-keyword">if</span> (addr &gt; <span class="hljs-number">256</span>)<br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;address &gt; 256, error!\n\r&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the string to write: &quot;</span>);<br>        <span class="hljs-built_in">gets</span>(str);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;writing ...\n\r&quot;</span>);<br>        err = <span class="hljs-built_in">at24cxx_write</span>(addr, str, <span class="hljs-built_in">strlen</span>(str)+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;at24cxx_write ret = %d\n\r&quot;</span>, err);&#125;<br></code></pre></td></tr></table></figure><ul><li>addr &#x3D; get_uint()用于把输入的地址赋值给addr。</li><li>gets(str)用于把输入的字符串存在str字符数组中。</li><li>at24cxx_write(addr, str, strlen(str)+1)调用at24cxx_write函数把输入的数据str,，放在输入的地址addr中。</li></ul><p>3). 执行do_read_at24cxx()函数从at24cxx中读取数据，do_read_at24cxx()函数的代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_read_at24cxx</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> addr;<br>        <span class="hljs-type">int</span> i, j;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> data[<span class="hljs-number">100</span>];<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str[<span class="hljs-number">16</span>];<br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-type">int</span> err;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">/* 获得地址 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the address to read: &quot;</span>);<br>        addr = <span class="hljs-built_in">get_uint</span>();<br>        <span class="hljs-keyword">if</span> (addr &gt; <span class="hljs-number">256</span>)<br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;address &gt; 256, error!\n\r&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">/* 获得长度 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the length to read: &quot;</span>);<br>        len = <span class="hljs-built_in">get_int</span>();<br>        err = <span class="hljs-built_in">at24cxx_read</span>(addr, data, len);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;at24cxx_read ret = %d\n\r&quot;</span>, err);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Data : \n\r&quot;</span>);<br>        <span class="hljs-comment">/* 长度固定为64 */</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        &#123;<br>                <span class="hljs-comment">/* 每行打印16个数据 */</span><br>                <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">16</span>; j++)<br>                &#123;<br>                        <span class="hljs-comment">/* 先打印数值 */</span><br>                        c = data[cnt++];<br>                        str[j] = c;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02x &quot;</span>, c);<br>                &#125;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   ; &quot;</span>);<br>                <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">16</span>; j++)<br>                &#123;<br>                        <span class="hljs-comment">/* 后打印字符 */</span><br>                        <span class="hljs-keyword">if</span> (str[j] &lt; <span class="hljs-number">0x20</span> || str[j] &gt; <span class="hljs-number">0x7e</span>)  <span class="hljs-comment">/* 不可视字符 */</span><br>                                <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;.&#x27;</span>);<br>                        <span class="hljs-keyword">else</span><br>                                <span class="hljs-built_in">putchar</span>(str[j]);<br>                &#125;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n\r&quot;</span>);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>调用at24cxx_read(addr, data, len)函数，从addr地址中读取len长度的字节数据，放在data字符数组中，后面的代码就是把读取得到的数据，打印出来。</li></ul><p><strong>第007节_测试</strong></p><hr><p>在测试中，出现问题和解决办法：</p><ul><li>中断没产生 : 未配置GPIO用于IIC功能</li></ul><p>解决方法: 配置引脚用于I2C</p><ul><li>只产生了一次中断, 并且出错 : tx err, no ack</li></ul><p>解决方法: 启动传输之前 IICSTAT&#x3D;(1&lt;&lt;4)</p><ul><li>第1次读OK，再次写卡死，复位再写仍卡死，重新上电再写OK:</li></ul><p>解决方法: 读最后一个数据时，不要回应ACK给AT24CXX</p><p>程序框架如下图所示：</p><p><img src="/image/1180px-Chapter19_lesson7_001.jpg" alt="1180px-Chapter19_lesson7_001.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第018课 ADC和触摸屏</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F-1/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F-1/</url>
    
    <content type="html"><![CDATA[<p><strong>目录</strong></p><hr><ol><li>第001节_ADC硬件原理</li><li>第002节_ADC编程</li><li>第003节_电阻触摸屏硬件原</li><li>第004节_S3C2440触摸屏接口</li><li>第005节_触摸屏编程_按下松开检测</li><li>第006节_触摸屏编程_ADC中断</li><li>第007节_触摸屏编程_定时器程序优化</li><li>第008节_触摸屏编程_使用定时器支持长按</li><li>第009节_触摸屏编程_较准原理</li><li>第010节_触摸屏编程_较准与画线编</li><li>第011节_触摸屏编程_测试</li><li>第012节_触摸屏编程_完善</li></ol><p><strong>第001节_ADC硬件原理</strong></p><hr><p>模数转换器即A&#x2F;D转换器，或简称ADC，通常是指一个将模拟信号转变为数字信号的电子元件。</p><p>通常的模数转换器是把经过与标准量比较处理后的模拟量转换成以二进制数值表示的离散信号的转换器。</p><p>故任何一个模数转换器都需要一个参考模拟量作为转换的标准，比较常见的参考标准为最大的可转换信号大小。而输出的数字量则表示输入信号相对于参考信号的大小。</p><p>如图，是把可变电阻上的电压值变换的模拟信号通过ADC转换，输出数字信号。</p><p><img src="/image/700px-Chapter18_lesson1_001.jpg" alt="700px-Chapter18_lesson1_001.jpg"></p><p>对于数字信号我们需要得到它的几个属性</p><ul><li>用多少位来存储这个数据（假设10bit）。</li><li>最大值0b111111111</li><li>它对应的电压是多少伏（模拟信号输入的最大值是多少）我们就可以根据模拟信号(电压)的最大值，来计算出对应的数值。</li><li>采样&#x2F;转换速度。</li></ul><p>对于程序员，我们不关心ADC的内部机制，我们只关心：</p><ul><li>怎么启动ADC</li><li>启动之后怎么得到数据，</li></ul><p>总之：我们都是通过寄存器操作的。</p><p><img src="/image/700px-Chapter18_lesson1_002.png" alt="700px-Chapter18_lesson1_002.png"></p><p>从图1-1-1可以看出ADC有8个多路选择器，显然，以后我们写程序的时候，我们可以8个多路选择之一， 下面是编写程序要做的步骤：</p><ol><li>确定是哪一路信号：设置8：1MUX，选择要测量哪一个引脚，（看原理图选择要测量的引脚）</li><li>设置工作时钟（从工作室中，可以算出转换一次，需要多长时间）</li><li>启动</li><li>读状态，判断ADC转换是否成功。</li><li>读数据</li></ol><p>ADC寄存器介绍</p><hr><p><strong>1.ADC 控制寄存器（ADCCON）</strong></p><p>ADCCON控制寄存器，用于标志转换是否完成，控制是否使能预分频器，输入通道选择，工作模式，ADC是否启动。它的各位含义如下图所示。</p><p><img src="/image/700px-Chapter18_lesson1_003.png" alt="700px-Chapter18_lesson1_003.png"></p><p><strong>2.ADC 启动延时寄存器（ADCDLY）</strong></p><p>ADCDLY 启动延时寄存器用于启动或初始化延时寄存器。它的各位含义如下图所示</p><p><img src="/image/700px-Chapter18_lesson1_004.png" alt="700px-Chapter18_lesson1_004.png"></p><p><strong>3.ADC 转换数据寄存器（ADCDAT0）</strong></p><p>ADCDAT0转换数据寄存器，本节中只用到该寄存器的前10位(用于保存转换后的结果)。</p><p><img src="/image/700px-Chapter18_lesson1_005.png" alt="700px-Chapter18_lesson1_005.png"></p><p><strong>第002节_ADC编程</strong></p><hr><p>编程步骤：</p><ol><li>初始化ADC</li><li>读数据，</li><li>在串口上显示出来。</li></ol><p><img src="/image/Chapter18_lesson2_001.png" alt="Chapter18_lesson2_001.png"></p><p>1). 初始化ADC</p><p>下面的函数实现对ADC的初始化。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">03 </span>void adc_init(void)<br><span class="hljs-number">04</span>   &#123;<br><span class="hljs-number">05</span>   /* [<span class="hljs-number">15</span>] : ECFLG,  <span class="hljs-number">1</span> = <span class="hljs-keyword">End</span> of A/D conversion<br><span class="hljs-number">06</span>               * [<span class="hljs-number">14</span>] : PRSCEN, <span class="hljs-number">1</span> = A/D converter prescaler enable<br><span class="hljs-number">07</span>               * [<span class="hljs-number">13</span>:<span class="hljs-number">6</span>]: PRSCVL, adc clk = PCLK / (PRSCVL + <span class="hljs-number">1</span>)<br><span class="hljs-number">08</span>               * [<span class="hljs-number">5</span>:<span class="hljs-number">3</span>] : SEL_MUX, <span class="hljs-number">000</span> = AIN <span class="hljs-number">0</span><br><span class="hljs-number">09</span>                * [<span class="hljs-number">2</span>]   : STDBM<br><span class="hljs-number">10</span>               * [<span class="hljs-number">0</span>]   : <span class="hljs-number">1</span> = A/D conversion starts <span class="hljs-keyword">and</span> this bit is cleared after the startup.<br><span class="hljs-number">11</span>               */<br><span class="hljs-number">12</span>           ADCCON = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">14</span>) | (<span class="hljs-number">49</span>&lt;&lt;<span class="hljs-number">6</span>) | (<span class="hljs-number">0</span>&lt;&lt;<span class="hljs-number">3</span>);<br><span class="hljs-number">13</span><br><span class="hljs-number">14</span>           ADCDLY = <span class="hljs-number">0</span>xff;       <br><span class="hljs-number">15</span>   &#125;<br></code></pre></td></tr></table></figure><ul><li>第12行：配置ADCCON寄存器，使能A&#x2F;D 转换器预分频器，设置A&#x2F;D 转换器预分频值，上拉使能。</li><li>第14行：设置ADC 转换启动延时值。</li></ul><p>2). 读数据</p><p>在这个读函数中启动ADC，并且等待ADC转换成功。然后返回数据，</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">17 </span><span class="hljs-keyword">int</span> adc_read_ain0(void)<br><span class="hljs-number">18</span>   &#123;<br><span class="hljs-number">19</span>                   /* 启动ADC */<br><span class="hljs-number">20</span>           ADCCON |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>);<br><span class="hljs-number">21</span><br><span class="hljs-number">22</span>           <span class="hljs-keyword">while</span> (!(ADCCON &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>)));  /* 等待ADC结束 */<br><span class="hljs-number">23</span><br><span class="hljs-number">24</span>           <span class="hljs-keyword">return</span> ADCDAT0 &amp; <span class="hljs-number">0</span>x3ff;    //只关心其中的十位<br><span class="hljs-number">25</span>   &#125;<br></code></pre></td></tr></table></figure><ul><li>第20行：启动ADC。</li><li>第22行：等待A&#x2F;D转换结束(ADCCON第15位置1)，</li><li>第24行：返回转换的值。(ADCDAT0寄存器的前10位，是保存转换后的值)。</li></ul><p>3). ADC测试</p><p>函数代码如下: 函数功能：在串口&#x2F;LCD上打印ADC转换后的结果。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-number">04</span> void adc<span class="hljs-constructor">_test(<span class="hljs-params">void</span>)</span><br><span class="hljs-number">05</span>   &#123;<br><span class="hljs-number">06</span>           <span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>;<br><span class="hljs-number">07</span>           double vol;<br><span class="hljs-number">08</span>           <span class="hljs-built_in">int</span> m; <span class="hljs-comment">/* 整数部分 */</span><br><span class="hljs-number">09</span>           <span class="hljs-built_in">int</span> n; <span class="hljs-comment">/* 小数部分 */</span><br><span class="hljs-number">10</span>   <br><span class="hljs-number">11</span>           adc<span class="hljs-constructor">_init()</span>;<br><span class="hljs-number">12</span><br><span class="hljs-number">13</span>           <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br><span class="hljs-number">14</span>           &#123;<br><span class="hljs-number">15</span>                   <span class="hljs-keyword">val</span> = adc<span class="hljs-constructor">_read_ain0()</span>;<br><span class="hljs-number">16</span>                   vol = (double)<span class="hljs-keyword">val</span>/<span class="hljs-number">1023</span>*<span class="hljs-number">3.3</span>;   <span class="hljs-comment">/* 1023----3.3v */</span><br><span class="hljs-number">17</span>                   m = (<span class="hljs-built_in">int</span>)vol;   <span class="hljs-comment">/* 3.01, m = 3 */</span><br><span class="hljs-number">18</span>                   vol = vol - m;  <span class="hljs-comment">/* 小数部分: 0.01 */</span><br><span class="hljs-number">19</span>                   n = vol<span class="hljs-operator"> * </span><span class="hljs-number">1000</span>;  <span class="hljs-comment">/* 10 */</span><br><span class="hljs-number">20</span><br><span class="hljs-number">21</span>                   <span class="hljs-comment">/* 在串口上打印 */</span><br><span class="hljs-number">22</span>                   printf(<span class="hljs-string">&quot;vol: %d.%03dv&quot;</span>, m, n);  <span class="hljs-comment">/* 3.010v */</span><br><span class="hljs-number">23</span><br><span class="hljs-number">24</span>                   <span class="hljs-comment">/* 在LCD上打印 */</span><br><span class="hljs-number">25</span>                   <span class="hljs-comment">//fb_print_string();</span><br><span class="hljs-number">26</span>                   &#125;<br><span class="hljs-number">27</span>   &#125;<br></code></pre></td></tr></table></figure><ul><li>第11行：初始化ADC.</li><li>第15行：把ADC转换得到的值赋值给变量val.</li><li>第16行：把变量val的值转化为电压值。</li><li>第17行：取vol整数部分赋值给变量m。</li><li>第18行：取vol的小数部分赋值给vol。</li></ul><p>测试</p><p>把生成的二进制文件烧录到开发板上，接上SPI模块，旋转可变电阻就可以在串口上看到电压值发生变化。</p><p><strong>第003节_电阻触摸屏硬件原</strong></p><hr><p>这节课我们来讲电阻触摸屏的硬件原理</p><p>假设有一个比较长的电阻,电阻是R 上面接3.3V电压，下面接地</p><p><img src="/image/Chapter18_lesson3_001.png" alt="Chapter18_lesson3_001.png"></p><p>假设整个电阻的阻值是R某一个触电它的阻值是R1 根据欧姆定律</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tp"><span class="hljs-number">3</span><span class="hljs-number">.3</span>v/<span class="hljs-keyword">R</span> = V/<span class="hljs-keyword">R</span><span class="hljs-number">1</span><br>V=<span class="hljs-number">3</span><span class="hljs-number">.3</span> *(<span class="hljs-keyword">R</span><span class="hljs-number">1</span>/<span class="hljs-keyword">R</span>)<br></code></pre></td></tr></table></figure><p>假设R1是x坐标 R的长度是L 这个电阻非常的均匀，那么这个电压就等于 3.3V * (x &#x2F; l) 这个电压和这个触电的x坐标有一个线性关系 我使用ADC把这个电压算出来，就可以间接得到这个触电的x坐标 电阻触摸屏就是使用欧姆定律使用电阻原理作出来的</p><p>可以上百度图片搜索触摸屏，就知道了触摸屏的样子,它是一个透明的薄膜,注意 LCD是LCD 触摸屏是触摸屏它是两个设备, 我们只不过是把触摸屏做的和LCD大小一样，粘在LCD上面, 实际上触摸屏是由两层膜组成，他们靠的非常近</p><p>上面这层右边引出来，代表xp ，p代表正极</p><p>上面这层左边引出来，代表xm, m代表负极</p><p><img src="/image/Chapter18_lesson3_002.png" alt="Chapter18_lesson3_002.png"></p><p>下面这层膜 前面这条边引出来为yp，后面这层边为ym</p><p>假设我们手指要点击触摸屏，那么上下就会粘贴在一起，我怎么算出这个 x y点的坐标呢？ 测量触电x坐标: xp接3.3v,xm接GND</p><p><img src="/image/Chapter18_lesson3_003.png" alt="Chapter18_lesson3_003.png"></p><p>yp,ym不接电源</p><p>2 测yp电压 上下膜连接在一起，我就可以通过yp测量这个触电的电压 这个yp就像探测一样，从前面的原理我们可以知道，当这个触电越靠近左边这个电压越小，越靠近右边电压越大 这个yp的电压就可以认为是这个触电的坐标(x坐标)</p><p>类似的我们怎么测量触电y坐标 类似的xp xm不接电源，同样yp接3.3v， ym接GND，这时候电流就从 yp这里流向ym,让后我们就可以测量xp电压 当按下屏幕时，上下两层膜链接在一起，这个xp就像探针一样，这个触电越靠近yp电压值越大，越靠近ym电压值越小</p><p><img src="/image/Chapter18_lesson3_004.png" alt="Chapter18_lesson3_004.png"></p><p>yp接3.3V ym接GND，xp xm不接电源 测量xp电压,就是y坐标</p><p>注意 x y坐标都是电压值，不是屏幕上480 * 272 这些值，我们需要把电压值转换为坐标值，这需要经过一些转换</p><p>我们测量xp yp可以得到触点的两个方向的电压值，这些电压值和坐标是线性关系 我们现在总结下使用触摸屏的流程</p><ol><li><p>按下触摸屏 按下触摸屏时，对于一个高效的系统，产生中断，这是触摸屏中断</p></li><li><p>在触摸中断程序中启动ADC，(获得数据，xy坐标)启动ADC就开始模数转换，不可能瞬间完成。</p></li><li><p>ADC完成， 产生中断</p></li><li><p>在ADC中断中读取x y坐标，我们来想想，在这个流程里，启动触摸屏的源头是按下触摸屏，那如果长按触摸屏，我按下之后一直不松开滑动手指呢</p><ul><li>那么谁来触发后续的多次ADC转换呢 不可能只启动一次吧, 为了支持长按滑动操作，我们需要启用定时器.</li></ul></li><li><p>松开启动定时器(为了支持长按滑动等)</p></li></ol><p>       6. 定时器中断发生，判断触摸屏是否仍被按下，如果按下就循环上述过程(由2开始)</p><p>a. 在触摸中断程序中启动ADC，(获得数据，xy坐标)启动ADC就开始模数转换，不可能瞬间完成</p><p>b. ADC完成，产生中断</p><p>c. ADC中断中读取x y坐标，)</p><ol><li>松开结束一个流程</li></ol><p>平时的时候上下两层膜并不连接，我们按下触摸屏的时候就会产生中断，那么你怎么知道产生中断，肯定是由某个引脚的电平发生变化,平时 Y_ADC&#x2F;xp是高电平,按下之后Y_ADC就接地了，就是被拉低了，就产生了低电平</p><p><img src="/image/Chapter18_lesson3_005.png" alt="Chapter18_lesson3_005.png"></p><p>产生低电平后就知道触摸屏被按下了，这个时候就需要测量电压值读取x坐标,XP XM通电我就测量YP的电压，这不就是 x 点的坐标</p><p><img src="/image/Chapter18_lesson3_006.png" alt="Chapter18_lesson3_006.png"></p><p>读取Y坐标</p><p>YP YM 通电，按下后XP通电，这不就是y点的坐标么</p><p><img src="/image/Chapter18_lesson3_007.png" alt="Chapter18_lesson3_007.png"></p><p><strong>第004节_S3C2440触摸屏接口</strong></p><hr><p>回顾上节触摸屏使用原理</p><p><img src="/image/Chapter18_lesson4_001.png" alt="Chapter18_lesson4_001.png"></p><p>在不使用触摸屏的时候，必须要把 S1 S2 S3断开，S4 S5闭合，只有这样当我按下触摸屏，上面的电平才能从高变低，会产生一个中断信号,而当我去读取X坐标的值时</p><p><img src="/image/Chapter18_lesson4_002.png" alt="Chapter18_lesson4_002.png"></p><p>必须让S1 S3闭合，这样电流才可以通过，同时让S2 S4 S5断开,这时候YP这层膜就相当于探针一样去测量电压</p><p>当我读取y坐标值</p><p><img src="/image/Chapter18_lesson4_003.png" alt="Chapter18_lesson4_003.png"></p><p>必须让S2 S4闭合，这样电流才可以流 下来，同时S1 S3 S5断开，这个时候XP这层膜就相当于探针一样，我可以来测量这里的电压，从而得到Y坐标的电压值</p><p>在测量x y坐标时，这个S5上拉电阻都要断开, 我们需要控制这几个开关，实际上2440的触摸屏接口就提供了这几个开关的控制方法, 打开2440的芯片手册, 从440到450， 我们看有一个8:1 MUX的多路选择器，以及XP YP</p><p><img src="/image/700px-Chapter18_lesson4_004.png" alt="700px-Chapter18_lesson4_004.png"></p><p>442页触摸屏接口模式</p><p><img src="/image/700px-Chapter18_lesson4_005.png" alt="700px-Chapter18_lesson4_005.png"></p><p><strong>正常模式，在上节视频中我们有讲解过</strong></p><p><strong>x y分离转换模式,</strong></p><p>看看我们的X Y坐标原理图，可以单独转换X坐标 单独转换Y坐标</p><p>换句话说就是逐个去测量X Y坐标,</p><p>他首先会启动X坐标的ADC转换，转换成功后数据会保存在ADCDAT0里，同时会产生一个中断，在这个中断服务程序里，就可以把X坐标读取出来，让后可以启动Y坐标的转换，转换成功后数据会保存在ADCDAT，同时会产生一个中断，进入这个中断把Y坐标读取出来 测量一次会产生２个中断，一个是X坐标中断，一个是Y坐标中断</p><p><strong>自动的或连续的X／Y坐标转换模式</strong></p><p>也就是说不需要单独控制，不需要单独去读取X坐标Y坐标，可以设置寄存器，让它一次性的测量X坐标测量Y坐标，X坐标保存在ADCDAT０　Y坐标保存在ADCDAT１，最后产生一个中断，也就是读取X／Y坐标只需要产生一次中断</p><p><strong>等待中断模式</strong></p><p>所谓等待中断模式，就是等待按下或者等待松开</p><p>对于下面这幅图，我按下的时候XP从高电平变为低电平，松开时，XP从低电平变为高电平，这就是按下松开都可以检测到</p><p>我们要等待按下或者松开时　需要设置rADCTSC &#x3D;0xd3这个值</p><p>Standby Mode静默模式&#x2F;省电模式(我们不关心这个)</p><p><img src="/image/700px-Chapter18_lesson4_006.png" alt="700px-Chapter18_lesson4_006.png"></p><p>443页编程要点</p><p><img src="/image/700px-Chapter18_lesson4_007.png" alt="700px-Chapter18_lesson4_007.png"></p><ul><li>AD转换数据时可以通过中断或者查询模式来得到数据，使用中断模式时，从AD转换开始，到得到数据可能会有些延迟，因为中断服务程序的进入和退出需要一定的时间，(也就是说，如果你对数据转换的速度要求的非常高，就可以使用查询方式)，可以查询ADCCON[15]来判断是否转换结束</li></ul><p>444页 剩下就是寄存器操作</p><p><img src="/image/700px-Chapter18_lesson4_008.png" alt="700px-Chapter18_lesson4_008.png"></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">ECFLG状态位 AD转换是否结束<br>PRSCEN 使能ADC转换<br>PRSCVL 设置A/D转换预分频值<br>SEL<span class="hljs-emphasis">_MUX选择输入通道，后面我们使用自动转换XY坐标，所以这里不需要设置</span><br><span class="hljs-emphasis">ENABLE_</span>START 启动转换<br></code></pre></td></tr></table></figure><p>445页</p><p>ADCTSC这个寄存器是重要的</p><p><img src="/image/700px-Chapter18_lesson4_009.png" alt="700px-Chapter18_lesson4_009.png"></p><ul><li>UD_SEN Bit8是用来判断触摸屏是被按下还是被松开<ul><li>0表明被按下，1表明被松开</li></ul></li><li>YM_SEN Bit7  YM开关使能控制S4</li></ul><p><img src="/image/Chapter18_lesson4_001.png" alt="Chapter18_lesson4_001.png"></p><pre><code class="hljs">- 0表示断开 1闭合</code></pre><ul><li>YP_SEN Bit6 YP开关 0表示闭合 1 表示断开<ul><li>寄存器位的含义不同</li></ul></li><li>XM_SEN Bit5 XM开关 0 断开 1 闭合<ul><li>XP_SEN Bit4 XP开关</li></ul></li></ul><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>闭合 <span class="hljs-number">1</span> 断开<br></code></pre></td></tr></table></figure><ul><li>PULL_UP Bit3 控制S5开关 0 上拉(闭合)</li></ul><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>断开<br></code></pre></td></tr></table></figure><ul><li>AUTO_PST Bit2 自动连续转换X坐标Y坐标</li></ul><p>上节视频里我们设置是 0 正常的ADC转换</p><p>如果需要连续转换ADC坐标的话，需要设置为1 ，如果需要手动转换ADC坐标的话，需要设置为0</p><ul><li>XY_PST Bit[1:0] 对于手动转换X Y坐标我们需要手动设置XY_PST 里面的位，是测量X坐标还是测量Y坐标, 也可以设置这两位等于11 让其等于等待模式, 也就是等待触摸屏被按下或者被松开.</li></ul><p>如果设置自动连续转换的话，Bit2 AUTO_PST设置为1 XY_PST设置为00</p><p>如果使用手动转换的话设置AUTO_PST为0 XY_PST设置为01 手动转换X坐标模式 或者设置为10 Y坐标转换模式</p><p>447页ADCDATA0 ADC数据寄存器</p><p><img src="/image/700px-Chapter18_lesson4_0010.png" alt="700px-Chapter18_lesson4_0010.png"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">UPDOWN</span> Bit15 可以读取这一位去判断触摸屏是按下还是松开<br><span class="hljs-attribute">AUTO_PST</span> Bit14 自动测量<br><span class="hljs-attribute">XY_PST</span> Bit[<span class="hljs-number">13</span>:<span class="hljs-number">12</span>] 和上面ADCTSC寄存器中 AUTO_PST Bit2   XY_PST Bit[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>]原理相同<br><span class="hljs-attribute">XPDATA</span> Bit[<span class="hljs-number">9</span>:<span class="hljs-number">0</span>]最低<span class="hljs-number">10</span>位用来保存ADC的值<br></code></pre></td></tr></table></figure><p>448页’ADCDAT1寄存器 和ADCDAT0功能一样的，只不过保存的数据不同</p><p><img src="/image/700px-Chapter18_lesson4_0011.png" alt="700px-Chapter18_lesson4_0011.png"></p><p>这个的低10位是用来保存 Y坐标的值</p><p>接下来是ADCUPDN触摸屏按下或者松开检查寄存器</p><p><img src="/image/700px-Chapter18_lesson4_0012.png" alt="700px-Chapter18_lesson4_0012.png"></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">TST_UP <span class="hljs-keyword">Bit1 </span>触摸屏松开中断产生<br>TST_DN <span class="hljs-keyword">Bit0 </span>触摸屏按下中断产生<br></code></pre></td></tr></table></figure><p>手册看完了，涉及到中断，我们看下这个图</p><p><img src="/image/Chapter18_lesson4_001.png" alt="Chapter18_lesson4_001.png"></p><p>它会涉及两个中断，按下或者松开，即触摸笔的状态中断，另外一个启动ADC以后，ADC结束时也会产生一个中断，但是这个手册里没有看到中断的使能寄存器</p><p>那我们猜测一下，ADC模块或者触摸屏模块一定会发出中断</p><p>首先是ADC或者触摸屏产生中断，通过中断控制器发送中断给CPU</p><p><img src="/image/700px-Chapter18_lesson4_0013.png" alt="700px-Chapter18_lesson4_0013.png"></p><p>肯定有寄存器禁止／使能ADC或者触摸屏中断</p><p>我们看看中断控制器芯片手册中都需要设置什么</p><p><img src="/image/700px-Chapter18_lesson4_0013-1.png" alt="700px-Chapter18_lesson4_0013-1.png"></p><p>ADC中断源</p><p><img src="/image/700px-Chapter18_lesson4_0014.png" alt="700px-Chapter18_lesson4_0014.png"></p><p>ADC结束中断或者触摸屏中断，看来他们合起来用一个中断 既然合并必然还会有一个寄存器来分辨到底是ADC还是触摸屏发生的中断变化</p><p>SRCPND寄存器 31位为ADC中断</p><p><img src="/image/700px-Chapter18_lesson4_0015.png" alt="700px-Chapter18_lesson4_0015.png"></p><p><img src="/image/700px-Chapter18_lesson4_0016.png" alt="700px-Chapter18_lesson4_0016.png"></p><p>设置Bit[31]</p><p>INTMOD寄存器 来决定是普通中断还是快中断模式</p><p><img src="/image/700px-Chapter18_lesson4_0017.png" alt="700px-Chapter18_lesson4_0017.png"></p><p>设置Bit[31]</p><p><img src="/image/700px-Chapter18_lesson4_0018.png" alt="700px-Chapter18_lesson4_0018.png"></p><p>INTMSK寄存器 用来表示是否屏蔽这个中断</p><p><img src="/image/700px-Chapter18_lesson4_0019.png" alt="700px-Chapter18_lesson4_0019.png"></p><p>设置Bit[31]</p><p><img src="/image/700px-Chapter18_lesson4_0020.png" alt="700px-Chapter18_lesson4_0020.png"></p><p>INTOFFSET 设置Bit[31]</p><p><img src="/image/700px-Chapter18_lesson4_0023.png" alt="700px-Chapter18_lesson4_0023.png"></p><p>到底是ADC中断还是触摸屏中断，肯定有其他寄存器可以设置</p><p>SUBSOURCE PENDING寄存器</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">INT_ADC_S</span> Bit[<span class="hljs-number">10</span>]表示ADC中断<br><span class="hljs-attribute">INT_TC</span> Bit[<span class="hljs-number">9</span>]表示触摸屏中断<br></code></pre></td></tr></table></figure><p><img src="/image/700px-Chapter18_lesson4_0024.png" alt="700px-Chapter18_lesson4_0024.png"></p><p>INTSUBMSK 也是同样的位</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">INT_ADC_S</span> Bit[<span class="hljs-number">10</span>]表示ADC中断激活/屏蔽<br><span class="hljs-attribute">INT_TC</span> Bit[<span class="hljs-number">9</span>]表示触摸屏中断激活/屏蔽<br></code></pre></td></tr></table></figure><p><img src="/image/700px-Chapter18_lesson4_0025.png" alt="700px-Chapter18_lesson4_0025.png"></p><p>我们可以通过INTSUBMSK来屏蔽ADC中断或者TouchScreen中断 当然也可以是能某个中断 可以通过SUBSRCPND来分辨到底产生那个中断，再使用INTSUBMSK屏蔽某一个，最后和SUBSOURCPND这两个寄存器都会汇集到一起 变成一个叫做INT_ADC的中断来发送给CPU</p><p>框图就是这样</p><p><img src="/image/700px-Chapter18_lesson4_0026.png" alt="700px-Chapter18_lesson4_0026.png"></p><p>我们怎么写程序？ 写出一个框架</p><ol><li><p>初始化ADC&#x2F;TouchScreen接口(ADCCON,时钟,接口等)</p></li><li><p>一开始触摸屏是没有被按下的，设置TS处于等待中断模式</p></li><li><p>设置中断</p><ul><li>INTSUBMSK使能ADC中断和触摸屏中断</li><li>设置INTMSK使能INT_ADC让他能够发给CPU</li></ul></li><li><p>按下触摸屏，进入TS中断</p><ul><li>进入自动采集模式(自动转换XY坐标)</li><li>启动ADC</li></ul></li></ol><p>       5. 转换完之后产生ADC中断</p><pre><code class="hljs">- 读数据- 再次进入 “&#39;等待中断”&#39;模式\(等待触摸屏被松开\)- 启动定时器，处理长按或者滑动</code></pre><p>       6. 定时器中断</p><pre><code class="hljs">- 判断笔是否松开，若松开结束- 若仍然按下重新执行，重新4.2启动ADC步骤</code></pre><p><strong>第005节_触摸屏编程_按下松开检测</strong></p><hr><p><img src="/image/Chapter18_lesson5_001.png" alt="Chapter18_lesson5_001.png"></p><p>看懂这张图的关键点在于 里面有个中断程序 AdcTsIntHandle 它是总的中断，这里面要分辨if, 如果是ADC中断 那么就调用Isr_adc来处理中段 else if, 如果是触摸屏中断，那么就调用Isr_tc中断</p><p>我们看看是怎么做的</p><ul><li>一开始设置中断</li><li>初始化触摸屏控制器，进入等待中断模式</li><li>这个时候如果按下触摸屏就会进入Pen Down中断</li><li>就会进入AdcTsIntHandle这个总中断函数</li><li>这里面分辨是按下触摸屏</li><li>进入自动(连续) X&#x2F;Y轴坐标转换模式，启动ADC,</li><li>ADC结束之后会产生一个ADC中断</li><li>又再次进入这个AdcTsIntHandle总中断</li><li>这里面分辨是ADC中断，这里面调用Isr_Adc</li><li>我可以读出这里面的数据，再次设置寄存器</li><li>进入等待Pen UP中断模式</li><li>松开触摸笔会再次产生一个中断 </li><li>进入总中断AdcTsIntHandle这里面分辨，原来是松开了触摸笔，再次调用Isr_tc </li><li>这里面又会设置进入等待Pen Down中断模式</li></ul><p>我们开始写代码，再上一个视频ADC代码上进行修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">002_touchscreen_018_005/adc_touchscreen<br></code></pre></td></tr></table></figure><p>我们在adc_touchscreen目录下添加几个文件</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">touchscreen_test.<span class="hljs-keyword">c</span><br>touchscreen.<span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure><p>先写touchscreen.c文件</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-built_in">touchscreen_init</span>(void)&#123;<br>        看看上面流程图<br>        <span class="hljs-comment">/*1 设置中断我们需要提供中断处理函数 */</span><br>        <span class="hljs-comment">/*2 设置触摸屏接口:也就是寄存器 */</span><br>        <span class="hljs-comment">/*3 让触摸屏控制器进入&quot;等待中断模式&quot; */</span><br>&#125;<br>我们设置中断处理函数<br>void <span class="hljs-built_in">AdcTsIntHandle</span>(void)<br>&#123;<br>&#125;<br><br>看一下之前我们是怎么写中断的,看一下interrupt<span class="hljs-selector-class">.c</span>文件<br>void <span class="hljs-built_in">key_eint_irq</span>(int irq)<br>有个中断号<br><br>那么我们也定义个int irq参数<br>void <span class="hljs-built_in">AdcTsIntHandle</span>(int irq)<br>我们在这个里面分辨一下<br>if (SUBSRCPND &amp; (<span class="hljs-number">1</span>&lt;&lt;TC_INT_BIT))  <span class="hljs-comment">/* 如果是触摸屏中断 */</span><br>        <span class="hljs-built_in">Isr_Tc</span>();    <span class="hljs-comment">/* 调用 */</span>   <br>else if <span class="hljs-comment">/* 如果是ADC中断 */</span><br>        <span class="hljs-built_in">Isr_Adc</span>();    <span class="hljs-comment">/* 调用 */</span><br>我们等会实现这两个函数<br><br>我们继续写代码<br>void <span class="hljs-built_in">touchscreen_init</span>(void)<br>&#123;<br>        看看上面流程图<br>        <span class="hljs-comment">/*1 设置中断，我们需要提供中断处理函数 */</span><br>        <span class="hljs-built_in">adc_ts_int_init</span>();<br>        <span class="hljs-comment">/*2 设置触摸屏接口:也就是寄存器 */</span><br>        <span class="hljs-built_in">adc_ts_reg_init</span>();<br>        <span class="hljs-comment">/*3 让触摸屏控制器进入&quot;等待中断模式&quot; */</span><br>        <span class="hljs-built_in">enter_wait_pen_down_mode</span>();<br>&#125;<br><br><span class="hljs-comment">//我们先来实现 adc_ts_int_init</span><br><br>void <span class="hljs-built_in">adc_ts_int_init</span>(void)<br>&#123;<br>        <span class="hljs-comment">/*注册中断处理函数*/</span><br><span class="hljs-comment">//怎么注册看之前的代码</span><br>        <span class="hljs-built_in">register_irq</span>(irq, irq_handle);<br>        <span class="hljs-comment">/* 使能中断 */</span><br></code></pre></td></tr></table></figure><p>中断号是多少？</p><p>打开芯片手册，找到中断控制器</p><p><img src="/image/700px-Chapter18_lesson4_0015.png" alt="700px-Chapter18_lesson4_0015.png"></p><p><img src="/image/700px-Chapter18_lesson4_0016.png" alt="700px-Chapter18_lesson4_0016.png"></p><p>我们是31号中断</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">register_ir<span class="hljs-string">q(31, AdcTsIntHandle)</span>;   <br></code></pre></td></tr></table></figure><p>怎么使能中断?</p><p>我们需要把&lt;code&gt; INTSUBMISK寄存器的Bit9 Bit10设置为0 宏定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADC_INT_BIT (10)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TC_INT_BIT  (9)</span><br></code></pre></td></tr></table></figure><p>使能中断，清零</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">INTSUBMSK</span> &amp;= ~((<span class="hljs-number">1</span>&lt;&lt;ADC_INT_BIT) | (<span class="hljs-number">1</span>&lt;&lt;TC_INT_BIT));<br></code></pre></td></tr></table></figure><p>还有INTMSK我们也需要把Bit31清零</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INT_ADC_TC (31)</span><br></code></pre></td></tr></table></figure><p>Bit31位清零操作</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">INTMSK    <span class="hljs-meta">&amp;= ~(1&lt;&lt;INT_ADC_TC);</span><br></code></pre></td></tr></table></figure><p>这句可以不用设置，因为register_irq已经设置</p><p>假设产生中断就会进入AdcTsIntHandle函数中 分辨是触摸屏终端还是ADC中断</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-built_in">AdcTsIntHandle</span>(int irq)<br>&#123;<br>        if   <span class="hljs-comment">/* 如果是触摸屏中断 */</span><br>                <span class="hljs-built_in">Isr_Tc</span>();<br>        if  <span class="hljs-comment">/* ADC中断 */</span><br>                <span class="hljs-built_in">Isr_Adc</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>如何进行分辨</p><p><img src="/image/700px-Chapter18_lesson4_0024.png" alt="700px-Chapter18_lesson4_0024.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs shell">if (SUBSRCPND &amp; (1&lt;&lt;TC_INT_BIT))  /* 如果是触摸屏中断 */<br>        Isr_Tc();<br>if (SUBSRCPND &amp; (1&lt;&lt;ADC_INT_BIT))  /* ADC中断 */<br>        Isr_Adc();<br><br>//我们要引用寄存器地址头文件<br><span class="hljs-meta prompt_">#</span><span class="language-bash">include <span class="hljs-string">&quot;../s3c2440_soc.h&quot;</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define ADC_INT_BIT (10)</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define TC_INT_BIT  (9)</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define INT_ADC_TC   (31)</span><br>/* ADCTSC&#x27;s bits */<br><span class="hljs-meta prompt_">#</span><span class="language-bash">define WAIT_PEN_DOWN    (0&lt;&lt;<span class="hljs-string">8)</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-string">define WAIT_PEN_UP      (1&lt;&lt;8</span>)</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define YM_ENABLE        (1&lt;&lt;<span class="hljs-string">7)</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-string">define YM_DISABLE       (0&lt;&lt;7</span>)</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define YP_ENABLE        (0&lt;&lt;<span class="hljs-string">6)</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-string">define YP_DISABLE       (1&lt;&lt;6</span>)</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define XM_ENABLE        (1&lt;&lt;<span class="hljs-string">5)</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-string">define XM_DISABLE       (0&lt;&lt;5</span>)</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define XP_ENABLE        (0&lt;&lt;<span class="hljs-string">4)</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-string">define XP_DISABLE       (1&lt;&lt;4</span>)</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define PULLUP_ENABLE    (0&lt;&lt;<span class="hljs-string">3)</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-string">define PULLUP_DISABLE   (1&lt;&lt;3</span>)</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define AUTO_PST         (1&lt;&lt;<span class="hljs-string">2)</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-string">define WAIT_INT_MODE    (3)</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-string">define NO_OPR_MODE      (0)</span></span><br>void enter_wait_pen_down_mode(void)<br>&#123;<br>        ADCTSC = WAIT_PEN_DOWN | PULLUP_ENABLE | YM_ENABLE | YP_DISABLE | XP_DISABLE | XM_DISABLE | WAIT_INT_MODE;<br>&#125;<br>void enter_wait_pen_up_mode(void)<br>&#123;<br>        ADCTSC = WAIT_PEN_UP | PULLUP_ENABLE | YM_ENABLE | YP_DISABLE | XP_DISABLE | XM_DISABLE | WAIT_INT_MODE;<br>&#125;<br></code></pre></td></tr></table></figure><p>读一下寄存器,找到触摸屏的寄存器触摸笔,按下松开状态寄存器</p><p><img src="/image/Chapter18_lesson5_001.png" alt="Chapter18_lesson5_001.png"></p><p>我们可以读它 Bit1表示up Bit0表示down</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Isr_Tc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ADCUPDN = 0x%x, ADCDAT0 = 0x%x, ADCDAT1 = 0x%x, ADCTSC = 0x%x\n\r&quot;</span>, ADCUPDN, ADCDAT0, ADCDAT1, ADCTSC);<br>        <br>        <span class="hljs-keyword">if</span> (ADCDAT0 &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>))<br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pen up\n\r&quot;</span>);<br>                <span class="hljs-built_in">enter_wait_pen_down_mode</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span>   <br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pen down\n\r&quot;</span>);<br><br>                <span class="hljs-comment">/* 进入&quot;等待触摸笔松开的模式&quot; */</span><br>                <span class="hljs-built_in">enter_wait_pen_up_mode</span>();<br>        &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AdcTsIntHandle</span><span class="hljs-params">(<span class="hljs-type">int</span> irq)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">if</span> (SUBSRCPND &amp; (<span class="hljs-number">1</span>&lt;&lt;TC_INT_BIT))  <span class="hljs-comment">/* 如果是触摸屏中断 */</span><br>                <span class="hljs-built_in">Isr_Tc</span>();<br><br><span class="hljs-comment">//       if (SUBSRCPND &amp; (1&lt;&lt;ADC_INT_BIT))  /* ADC中断*/</span><br><span class="hljs-comment">//               Isr_Adc();</span><br>        SUBSRCPND = (<span class="hljs-number">1</span>&lt;&lt;TC_INT_BIT) | (<span class="hljs-number">1</span>&lt;&lt;ADC_INT_BIT); <span class="hljs-comment">/* 清中断 */</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">adc_ts_int_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        SUBSRCPND = (<span class="hljs-number">1</span>&lt;&lt;TC_INT_BIT) | (<span class="hljs-number">1</span>&lt;&lt;ADC_INT_BIT);<br><br>        <span class="hljs-comment">/* 注册中断处理函数 */</span><br>        <span class="hljs-built_in">register_irq</span>(<span class="hljs-number">31</span>, AdcTsIntHandle);<br><br>        <span class="hljs-comment">/* 使能中断 */</span><br>        INTSUBMSK &amp;= ~((<span class="hljs-number">1</span>&lt;&lt;ADC_INT_BIT) | (<span class="hljs-number">1</span>&lt;&lt;TC_INT_BIT));<br>        <span class="hljs-comment">//INTMSK    &amp;= ~(1&lt;&lt;INT_ADC_TC);</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">adc_ts_reg_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-comment">/* [15] : ECFLG,  1 = End of A/D conversion  </span><br><span class="hljs-comment">         * [14] : PRSCEN, 1 = A/D converter prescaler enable  </span><br><span class="hljs-comment">         * [13:6]: PRSCVL, adc clk = PCLK / (PRSCVL + 1)  </span><br><span class="hljs-comment">         * [5:3] : SEL_MUX, 000 = AIN 0  * [2]   : STDBM  </span><br><span class="hljs-comment">         * [0]   : 1 = A/D conversion starts and this bit is cleared after the startup.  </span><br><span class="hljs-comment">         */</span><br>        ADCCON = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">14</span>) | (<span class="hljs-number">49</span>&lt;&lt;<span class="hljs-number">6</span>) | (<span class="hljs-number">0</span>&lt;&lt;<span class="hljs-number">3</span>);<br><br>        ADCDLY = <span class="hljs-number">0xff</span>;       <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">touchscreen_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-comment">/* 设置触摸屏接口:寄存器 */</span><br>        <span class="hljs-built_in">adc_ts_reg_init</span>();<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ADCUPDN = 0x%x, SUBSRCPND = 0x%x, SRCPND = 0x%x\n\r&quot;</span>, ADCUPDN, SUBSRCPND, SRCPND);<br><br>        <span class="hljs-comment">/* 设置中断 */</span><br>        <span class="hljs-built_in">adc_ts_int_init</span>();<br><br>        <span class="hljs-comment">/* 让触摸屏控制器进入&quot;等待中断模式&quot; */</span><br>        <span class="hljs-built_in">enter_wait_pen_down_mode</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第006节_触摸屏编程_ADC中断</strong></p><hr><p>这节课我们加上ADC中断把触点的xy坐标读出来</p><p>查看touchscreen.c</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">写出这个自动测量的函数<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">enter_auto_measure_mode</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br><span class="hljs-comment">//现在是自动测量，我们没有机会分别设置这些开关</span><br><br>设置<span class="hljs-variable constant_">AUTO_PST</span> =<span class="hljs-number">1</span><br><span class="hljs-variable constant_">XY_PST</span> = <span class="hljs-number">00</span><br><br>        <span class="hljs-variable constant_">ADCTSC</span> = <span class="hljs-variable constant_">AUTO_PST</span> | <span class="hljs-variable constant_">NO_OPR_MODE</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;现在是自动测量，我们没有机会分别设置这些开关</p><p><img src="/image/700px-Chapter18_lesson6_001.png" alt="700px-Chapter18_lesson6_001.png"></p><p>进入中断处理函数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void <span class="hljs-constructor">AdcTsIntHandle(<span class="hljs-params">int</span> <span class="hljs-params">irq</span>)</span><br>&#123;<br>        <span class="hljs-keyword">if</span> (SUBSRCPND &amp; (<span class="hljs-number">1</span>&lt;&lt;TC_INT_BIT))  <span class="hljs-comment">/* 如果是触摸屏中断 */</span><br>                <span class="hljs-constructor">Isr_Tc()</span>;<br><br>        <span class="hljs-keyword">if</span> (SUBSRCPND &amp; (<span class="hljs-number">1</span>&lt;&lt;ADC_INT_BIT))  <span class="hljs-comment">/* ADC中断，则会进入Adc中断处理函数 */</span><br>                <span class="hljs-constructor">Isr_Adc()</span>;<br><br>        SUBSRCPND = (<span class="hljs-number">1</span>&lt;&lt;TC_INT_BIT) <span class="hljs-pattern-match">| (1&lt;&lt;<span class="hljs-constructor">ADC_INT_BIT</span>);</span><br><span class="hljs-pattern-match">&#125;</span><br></code></pre></td></tr></table></figure><p>进入触摸屏中断处理函数</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk">void Isr_Tc(void)<br>&#123;<br>        <span class="hljs-regexp">//</span>printf(<span class="hljs-string">&quot;ADCUPDN = 0x%x, ADCDAT0 = 0x%x, ADCDAT1 = 0x%x, ADCTSC = 0x%x\n\r&quot;</span>, ADCUPDN, ADCDAT0, ADCDAT1, ADCTSC);<br>        <br>        <span class="hljs-keyword">if</span> (ADCDAT0 &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>))<br>        &#123;<br>                <span class="hljs-regexp">//</span>printf(<span class="hljs-string">&quot;pen up\n\r&quot;</span>);<br>                enter_wait_pen_down_mode();<br>        &#125;<br>        <span class="hljs-keyword">else</span>   <br>        &#123;<br>                <span class="hljs-regexp">/* 进入&quot;自动测量&quot;模式 */</span><br>                enter_auto_measure_mode();<br><br>                <span class="hljs-regexp">/* 启动ADC */</span><br>ENABLE_START = <span class="hljs-number">1</span>就可以了<br>                ADCCON |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;* 启动ADC *&#x2F;</p><p><img src="/image/700px-Chapter18_lesson6_002.png" alt="700px-Chapter18_lesson6_002.png"></p><p>Adc中断处理函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Isr_Adc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        进入adc中断后，等待触摸笔松开<br>        <span class="hljs-type">int</span> x = ADCDAT0 &amp; <span class="hljs-number">0x3ff</span>;<br>        <span class="hljs-type">int</span> y = ADCDAT1 &amp; <span class="hljs-number">0x3ff</span>;<br>                <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x = %08d, y = %08d\n\r&quot;</span>, x, y);<br><br><span class="hljs-comment">//等待触摸笔松开模式</span><br>        <span class="hljs-built_in">enter_wait_pen_up_mode</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>烧写 实验发现打印一堆乱码</p><p><img src="/image/700px-Chapter18_lesson6_003.png" alt="700px-Chapter18_lesson6_003.png"></p><p>应该是printf函数出了问题 打开my_printf.c文件，找到printf函数 应该是处理第二个数据的时候，没有设置初始值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*reference :   int vprintf(const char *format, va_list ap); */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">my_vprintf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt, va_list ap)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">char</span> lead=<span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-type">int</span>  maxwidth=<span class="hljs-number">0</span>;<br>        <br>         <span class="hljs-keyword">for</span>(; *fmt != <span class="hljs-string">&#x27;\0&#x27;</span>; fmt++)<br>         &#123;<br>                 <span class="hljs-keyword">if</span> (*fmt != <span class="hljs-string">&#x27;%&#x27;</span>) <br>                &#123;<br>                    <span class="hljs-built_in">outc</span>(*fmt);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>        <span class="hljs-comment">//碰到 % 就重新处理， 初始值应该重新设置初始值上去</span><br>                lead=<span class="hljs-string">&#x27; &#x27;</span>;<br>                maxwidth=<span class="hljs-number">0</span>;<br>                <br>                <span class="hljs-comment">//format : %08d, %8d,%d,%u,%x,%f,%c,%s</span><br>                    fmt++;<br>                <span class="hljs-keyword">if</span>(*fmt == <span class="hljs-string">&#x27;0&#x27;</span>)<br>                &#123;<br>                        lead = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                        fmt++;  <br>                &#125;<br>                <br>                <span class="hljs-keyword">while</span>(*fmt &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; *fmt &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)<br>                &#123;<br>                        maxwidth *=<span class="hljs-number">10</span>;<br>                        maxwidth += (*fmt - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                        fmt++;<br>                &#125;<br>                <br>                        <span class="hljs-keyword">switch</span> (*fmt) <br>            &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>: <span class="hljs-built_in">out_num</span>(<span class="hljs-built_in">va_arg</span>(ap, <span class="hljs-type">int</span>),          <span class="hljs-number">10</span>,lead,maxwidth); <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;o&#x27;</span>: <span class="hljs-built_in">out_num</span>(<span class="hljs-built_in">va_arg</span>(ap, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>),  <span class="hljs-number">8</span>,lead,maxwidth); <span class="hljs-keyword">break</span>;                                <br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;u&#x27;</span>: <span class="hljs-built_in">out_num</span>(<span class="hljs-built_in">va_arg</span>(ap, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>), <span class="hljs-number">10</span>,lead,maxwidth); <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;x&#x27;</span>: <span class="hljs-built_in">out_num</span>(<span class="hljs-built_in">va_arg</span>(ap, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>), <span class="hljs-number">16</span>,lead,maxwidth); <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-built_in">outc</span>(<span class="hljs-built_in">va_arg</span>(ap, <span class="hljs-type">int</span>   )); <br><span class="hljs-keyword">break</span>;         <br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>: <span class="hljs-built_in">outs</span>(<span class="hljs-built_in">va_arg</span>(ap, <span class="hljs-type">char</span> *)); <span class="hljs-keyword">break</span>;                               <br>                                <br>                <span class="hljs-keyword">default</span>: <span class="hljs-built_in">outc</span>(*fmt);<br><span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>重新烧写执行，发现数据变化幅度很大，但至少Adc已经有输出</p><p><img src="/image/Chapter18_lesson6_004.png" alt="Chapter18_lesson6_004.png"></p><p>我们需要解决输出值不线性的问题</p><p>到底是触摸屏质量问题，还是Adc转化精度问题， 觉得应该是触摸屏电压不稳定 之前不知道DELAY寄存器是用来干嘛的</p><p><img src="/image/700px-Chapter18_lesson6_005.png" alt="700px-Chapter18_lesson6_005.png"></p><p>等待中断模式时，当触摸笔按下时我们会产生中断，但是可以通过 DELAY来延时产生中断</p><p>在前面有一张图</p><p><img src="/image/700px-Chapter18_lesson6_006.png" alt="700px-Chapter18_lesson6_006.png"></p><p>按下触摸笔，延迟A 才可以产生中断，你才可以测量X Y坐标 A &#x3D; D（晶振的周期） D就是 DELAY就是那个寄存器的值 晶振周期时12M 我们需要设置一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">adc_ts_reg_init</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>        <span class="hljs-comment">/* [15] : ECFLG,  1 = End of A/D conversion  </span><br><span class="hljs-comment">         * [14] : PRSCEN, 1 = A/D converter prescaler enable  </span><br><span class="hljs-comment">         * [13:6]: PRSCVL, adc clk = PCLK / (PRSCVL + 1)  </span><br><span class="hljs-comment">         * [5:3] : SEL_MUX, 000 = AIN 0  * [2]   : STDBM  </span><br><span class="hljs-comment">         * [0]   : 1 = A/D conversion starts and this bit is cleared after the startup.  </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-variable constant_">ADCCON</span> = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">14</span>) | (<span class="hljs-number">49</span>&lt;&lt;<span class="hljs-number">6</span>) | (<span class="hljs-number">0</span>&lt;&lt;<span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">/*  按下触摸屏, 延时一会再发出TC中断  </span><br><span class="hljs-comment">         * 10ms为120000  </span><br><span class="hljs-comment">         *  延时时间 = ADCDLY </span><br><span class="hljs-comment">         * 晶振周期 = ADCDLY </span><br><span class="hljs-comment">         * 1 / 12000000 = 5ms  </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-variable constant_">ADCDLY</span> = <span class="hljs-number">60000</span>;      <br>&#125;<br></code></pre></td></tr></table></figure><p>再次烧写，发现数据并不规律 我们需要再次改进程序</p><p>我们按下触摸屏会产生触摸屏中断，启动自动测量，启动Adc，Adc成功后会进入Adc中断，在函数中打印数据</p><p>也许测量过程很长 我们就需要判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Isr_Adc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">int</span> x = ADCDAT0;<br>        <span class="hljs-type">int</span> y = ADCDAT1;<span class="hljs-comment">//松开的话打印也是错误的值，所以如果仍然按下才打印</span><br>        <span class="hljs-keyword">if</span> (!(x &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>))) <span class="hljs-comment">/* 如果仍然按下才打印 */</span><br>        &#123;<br>                x &amp;= <span class="hljs-number">0x3ff</span>;<br>                y &amp;= <span class="hljs-number">0x3ff</span>;<br>                <span class="hljs-comment">//打印10进制</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x = %08d, y = %08d\n\r&quot;</span>, x, y);<br>        &#125;<br>        <span class="hljs-built_in">enter_wait_pen_up_mode</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>烧写执行 发现X Y轴输出有问题</p><p><img src="/image/Chapter18_lesson6_007.png" alt="Chapter18_lesson6_007.png"></p><p>厂家把X　Y轴搞反了</p><p>电路图中</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">TSYP</span>　TSXP接反<br>TSYM　TSXM接反<br></code></pre></td></tr></table></figure><p><img src="/image/Chapter18_lesson6_008.png" alt="Chapter18_lesson6_008.png"></p><p>我们后面使用触摸屏时会使用软件处理这点，不会导致任何问题　</p><p>有一个缺点 我们按下触摸屏会输出一个数据，再按下触摸屏又输出一个数据 我长按并没有输出数据，我滑动也没有输出数据 我们需要使用定时器改进这个问题</p><p>各种方向的旋转都可以由软件转换</p><p><img src="/image/Chapter18_lesson6_009.png" alt="Chapter18_lesson6_009.png"></p><p>我们需要把触摸屏的坐标TS　XY坐标转换成LCD的XY坐标 需要用应用程序做 我们常使用Tslib库来做，这些旋转倒置都没有问题</p><p><strong>第007节_触摸屏编程_定时器程序优化</strong></p><hr><ul><li>有一个缺点</li><li>我们按下触摸屏会输出一个数据，再按下触摸屏又输出一个数据</li><li>我长按并没有输出数据，我滑动也没有输出数据</li><li>我们需要使用定时器改进这个问题</li></ul><p>这个处理流程是怎么样的？</p><ul><li>按下期间启动定时器 </li><li>定时器每过10ms &#x2F; 20ms就中断一次</li><li>在中断函数里测量触电的XY坐标</li><li>这样就可以得到连续的数据</li></ul><p>打开定时器Timer.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;s3c2440_soc.h&quot;</span></span><br><br><span class="hljs-comment">//定义一个宏 TIMER_NUM = 32</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TIMER_NUM  32</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL  ((void *)0)</span><br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*timer_func)</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-comment">//定义一个结构体 ，既存放有函数指针又存放有数据</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timer_desc</span> &#123;<br>        <span class="hljs-type">char</span> *name;<br>        timer_func fp;&#125;timer_desc, *p_timer_desc;<br><br><span class="hljs-comment">//我们需要往这个结构体数组里面添加函数，注册Timer函数</span><br>timer_desc timer_array[TIMER_NUM];<br><br><span class="hljs-comment">//注册Timer函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">register_timer</span><span class="hljs-params">(<span class="hljs-type">char</span> *name, timer_func fp)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">int</span> i;<br><span class="hljs-comment">//搜索这个数组，如果fp等于0的话，就表示没有占用这个数组项，我就把它填充进去</span><br><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; TIMER_NUM; i++)<br>        &#123;<br>                <span class="hljs-keyword">if</span> (!timer_array[i].fp)<br>                &#123;        <br>                         [i].name = name;<br>                        timer_array[i].fp   = fp;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//注册成功</span><br>                &#125;<br>        &#125;<br>        <span class="hljs-comment">//否则，表示已经满了，注册失败</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们不需要使用Timer定时器的时候unregister_timer函数, 考虑到我们需要从数组里面把这个Timer去掉，我们怎么找到这个Timer？</p><p>传入一个函数指针，以后卸载使用名字找到对应的项.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unregister_timer</span><span class="hljs-params">(<span class="hljs-type">char</span> *name)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-comment">//对于unregister_timer就反过来操作，遍历每一项</span><br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; TIMER_NUM; i++)<br>        &#123;<br>        <span class="hljs-comment">//如果这个数组项里面的名字等于我传进来我名字</span><br>                <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(timer_array[i].name, name))<br>                &#123;<br>        <span class="hljs-comment">//也就表示我找到了这两项，设置成NULL</span><br>                        timer_array[i].name = <span class="hljs-literal">NULL</span>;<br>                        timer_array[i].fp   = <span class="hljs-literal">NULL</span>;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                &#125;<br>        &#125;<br>        <span class="hljs-comment">//否则return -1;找不到选择的项</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>应该让其从某个数组里面把需要定时器处理的函数依次执行，这样做，我们以后添加定时器处理函数时就不需要修改Timer.c</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs perl">void timer_ir<span class="hljs-string">q(void)</span><br>&#123;<br>        <span class="hljs-keyword">int</span> i;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; TIMER_NUM; i++)<br>        &#123;<br>        <span class="hljs-regexp">//</span>判断指针是否为空，如果不是空的话就继续执行timer_array[i].fp();这个函数<br>                <span class="hljs-keyword">if</span> (timer_array[i].fp)<br>                &#123;<br>                        timer_array[i].fp();<br>                &#125;<br>        &#125;        <br>&#125;<br></code></pre></td></tr></table></figure><p>如果想继续点灯的话，需要单独注册led_timer_irq 在led.c文件里注册led_timer_irq 把这个函数放在led_timer_irq函数下面，防止编译错误,每10ms改函数被调用一次.</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">led_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-comment">/* 设置GPFCON让GPF4/5/6配置为输出引脚 */</span><br>        GPFCON &amp;= ~((<span class="hljs-number">3</span>&lt;&lt;<span class="hljs-number">8</span>) | (<span class="hljs-number">3</span>&lt;&lt;<span class="hljs-number">10</span>) | (<span class="hljs-number">3</span>&lt;&lt;<span class="hljs-number">12</span>));<br>        GPFCON |=  ((<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">8</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">10</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">12</span>));<br>    <span class="hljs-comment">//led是名字，led_timer_irq是函数指针</span><br>        <span class="hljs-built_in">register_timer</span>(<span class="hljs-string">&quot;led&quot;</span>, led_timer_irq);<br>&#125;<br><br><span class="hljs-comment">/* 每10ms该函数被调用一次  </span><br><span class="hljs-comment"> * 每500ms操作一下LED实现计数 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">led_timer_irq</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-comment">/* 点灯计数 */</span><br>        <span class="hljs-type">static</span> <span class="hljs-type">int</span> timer_num = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">static</span> <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> tmp;<br><br>        timer_num++;<br>        <span class="hljs-keyword">if</span> (timer_num &lt; <span class="hljs-number">50</span>)<br>                <span class="hljs-keyword">return</span>;<br>        timer_num = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//操作led</span><br>        cnt++;<br><br>        tmp = ~cnt;<br>        tmp &amp;= <span class="hljs-number">7</span>;<br>        GPFDAT &amp;= ~(<span class="hljs-number">7</span>&lt;&lt;<span class="hljs-number">4</span>);<br>        GPFDAT |= (tmp&lt;&lt;<span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>修改main.c</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs scss">int <span class="hljs-selector-tag">main</span>(void)<br>&#123;<br>        <span class="hljs-built_in">led_init</span>();<span class="hljs-comment">//初始化led</span><br>        <span class="hljs-comment">//interrupt_init();    /* 初始化中断控制器 */</span><br>        <span class="hljs-built_in">key_eint_init</span>();       <span class="hljs-comment">/* 初始化按键, 设为中断源 */</span><br>        <span class="hljs-built_in">timer_init</span>();<span class="hljs-comment">//打开定时器</span><br>        <br>        <span class="hljs-built_in">puts</span>(&quot;\n\rg_A = &quot;);<br>        <span class="hljs-built_in">printHex</span>(g_A);<br>        <span class="hljs-built_in">puts</span>(&quot;\n\r&quot;);<br><br>        <span class="hljs-comment">//nor_flash_test();</span><br>        <span class="hljs-built_in">lcd_test</span>();<br><br>        <span class="hljs-comment">//adc_test();</span><br><br>        <span class="hljs-built_in">touchscreen_test</span>();<br><br>        while (<span class="hljs-number">1</span>);<br>        <br>        return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改timer.c文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs awk">void timer_init(void)<br>&#123;<br>        <span class="hljs-regexp">/* 设置TIMER0的时钟 修改时钟频录让其10ms中断一次 */</span><br>        <span class="hljs-regexp">/* Timer clk = PCLK /</span> &#123;prescaler value+<span class="hljs-number">1</span>&#125; / &#123;divider value&#125;<br>                     = <span class="hljs-number">50000000</span><span class="hljs-regexp">/(49+1)/</span><span class="hljs-number">16</span>              <br>                     = <span class="hljs-number">62500</span>  <br>        */<br>        TCFG0 = <span class="hljs-number">49</span>;  <span class="hljs-regexp">/* Prescaler 0 = 49, 用于timer0,1 */</span><br>        TCFG1 &amp;= ~<span class="hljs-number">0</span>xf;<br>        TCFG1 |= <span class="hljs-number">3</span>;  <span class="hljs-regexp">/* MUX0 : 1/</span><span class="hljs-number">16</span> */<br><br>        <span class="hljs-regexp">/* 设置TIMER0的初值 */</span><br>        TCNTB0 = <span class="hljs-number">625</span>;  <span class="hljs-regexp">/* 10Ms中断一次 */</span><br><br>        <span class="hljs-regexp">/* 加载初值, 启动timer0 */</span><br>        TCON |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>);   <span class="hljs-regexp">/* Update from TCNTB0 &amp; TCMPB0 */</span><br><br>        <span class="hljs-regexp">/* 设置为自动加载并启动 */</span><br>        TCON &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>);<br>        TCON |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">3</span>);  <span class="hljs-regexp">/* bit0: start, bit3: auto reload */</span><br><br>        <span class="hljs-regexp">/* 设置中断 */</span><br>        register_irq(<span class="hljs-number">10</span>, timer_irq);<br>&#125;<br></code></pre></td></tr></table></figure><p>烧写到nandflash发现无输出，可能是前重定位前的代码超出了4k，所以我们使用Norflash启动,发现可以正常运行</p><p>我们修改Makefile把负责重定位代码往前移，其他无关代码往后放,接着看star.S</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">.text</span><br><span class="hljs-symbol">.global</span> _start<br><br><span class="hljs-symbol">_start:</span><br>        <span class="hljs-keyword">b</span> reset                    <span class="hljs-comment">/* vector 0 : reset */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, und_addr           <span class="hljs-comment">/* vector 4 : und */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, swi_addr           <span class="hljs-comment">/* vector 8 : swi */</span><br>        <span class="hljs-keyword">b</span> halt                     <span class="hljs-comment">/* vector 0x0c : prefetch aboot */</span><br>        <span class="hljs-keyword">b</span> halt                     <span class="hljs-comment">/* vector 0x10 : data abort */</span><br>        <span class="hljs-keyword">b</span> halt                     <span class="hljs-comment">/* vector 0x14 : reserved */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, irq_addr           <span class="hljs-comment">/* vector 0x18 : irq */</span><br>        <span class="hljs-keyword">b</span> halt                     <span class="hljs-comment">/* vector 0x1c : fiq */</span><br><br><span class="hljs-comment">//我们需要把这些异常往后放</span><br><span class="hljs-symbol">und_addr:</span><br>        <span class="hljs-meta">.word</span> do_und<br><br><span class="hljs-symbol">swi_addr:</span><br>        <span class="hljs-meta">.word</span> do_swi<br><br><span class="hljs-symbol">irq_addr:</span><br>        <span class="hljs-meta">.word</span> do_irq<br><br><span class="hljs-symbol">reset:</span><br>        <span class="hljs-comment">/* 关闭看门狗 */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-number">=0x53000000</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r1</span>, <span class="hljs-number">=0</span><br>        <span class="hljs-keyword">str</span> <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r0</span>]<br>        <br>        <span class="hljs-comment">/* 设置MPLL, FCLK : HCLK : PCLK = 400m : 100m : 50m */</span><br>        <span class="hljs-comment">/* LOCKTIME(0x4C000000) = 0xFFFFFFFF */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-number">=0x4C000000</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r1</span>, <span class="hljs-number">=0xFFFFFFFF</span><br>        <span class="hljs-keyword">str</span> <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r0</span>]<br><br>        <span class="hljs-comment">/* CLKDIVN(0x4C000014) = 0X5, tFCLK:tHCLK:tPCLK = 1:4:8  */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-number">=0x4C000014</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r1</span>, <span class="hljs-number">=0x5</span><br>        <span class="hljs-keyword">str</span> <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r0</span>]<br><br>        <span class="hljs-comment">/* 设置CPU工作于异步模式 */</span><br>        <span class="hljs-keyword">mrc</span> <span class="hljs-built_in">p15</span>,<span class="hljs-number">0</span>,<span class="hljs-built_in">r0</span>,<span class="hljs-built_in">c1</span>,<span class="hljs-built_in">c0</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">orr</span> <span class="hljs-built_in">r0</span>,<span class="hljs-built_in">r0</span>,<span class="hljs-number">#0xc0000000</span>   <span class="hljs-comment">//R1_nF:OR:R1_iA</span><br>        mcr <span class="hljs-built_in">p15</span>,<span class="hljs-number">0</span>,<span class="hljs-built_in">r0</span>,<span class="hljs-built_in">c1</span>,<span class="hljs-built_in">c0</span>,<span class="hljs-number">0</span><br><br>        <span class="hljs-comment">/* 设置MPLLCON(0x4C000004) = (92&lt;&lt;12)|(1&lt;&lt;4)|(1&lt;&lt;0)   </span><br><span class="hljs-comment">         *  m = MDIV+8 = 92+8=100  </span><br><span class="hljs-comment">         *  p = PDIV+2 = 1+2 = 3  </span><br><span class="hljs-comment">         *  s = SDIV = 1  </span><br><span class="hljs-comment">         *  FCLK = 2*m*Fin/(p*2^s) = 2*100*12/(3*2^1)=400M  </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-number">=0x4C000004</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r1</span>, =(<span class="hljs-number">92</span>&lt;&lt;<span class="hljs-number">12</span>)<span class="hljs-title">|(1&lt;&lt;4)|</span>(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">str</span> <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r0</span>]<br><br>        <span class="hljs-comment">/* 一旦设置PLL, 就会锁定lock time直到PLL输出稳定  </span><br><span class="hljs-comment">         * 然后CPU工作于新的频率FCLK  </span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-comment">/* 设置内存: sp 栈 */</span><br>        <span class="hljs-comment">/* 分辨是nor/nand启动  </span><br><span class="hljs-comment">         * 写0到0地址, 再读出来  </span><br><span class="hljs-comment">         * 如果得到0, 表示0地址上的内容被修改了, 它对应ram, 这就是nand启动  </span><br><span class="hljs-comment">         * 否则就是nor启动  </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">r1</span>, <span class="hljs-number">#0</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, [<span class="hljs-built_in">r1</span>] <span class="hljs-comment">/* 读出原来的值备份 */</span><br>        <span class="hljs-keyword">str</span> <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r1</span>] <span class="hljs-comment">/* 0-&gt;[0] */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r2</span>, [<span class="hljs-built_in">r1</span>] <span class="hljs-comment">/* r2=[0] */</span><br>        <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">r1</span>, <span class="hljs-built_in">r2</span>   <span class="hljs-comment">/* r1==r2? 如果相等表示是NAND启动 */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">=0x40000000</span>+<span class="hljs-number">4096</span> <span class="hljs-comment">/* 先假设是nor启动 */</span><br>        <span class="hljs-keyword">moveq</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">#4096</span>  <span class="hljs-comment">/* nand启动 */</span><br>         <span class="hljs-keyword">streq</span> <span class="hljs-built_in">r0</span>, [<span class="hljs-built_in">r1</span>]   <span class="hljs-comment">/* 恢复原来的值 */</span><br><br>        <span class="hljs-keyword">bl</span> sdram_init<br>        <span class="hljs-comment">//bl sdram_init2  /* 用到有初始值的数组, 不是位置无关码 */</span><br><br>        <span class="hljs-comment">/* 重定位text, rodata, data段整个程序 */</span><br>        <span class="hljs-keyword">bl</span> copy2sdram<br><br>        <span class="hljs-comment">/* 清除BSS段 */</span><br>        <span class="hljs-keyword">bl</span> clean_bss<br><br>        <span class="hljs-comment">/* 复位之后, cpu处于svc模式  </span><br><span class="hljs-comment">         * 现在, 切换到usr模式  </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">mrs</span> <span class="hljs-built_in">r0</span>, <span class="hljs-keyword">cpsr</span>         <span class="hljs-comment">/* 读出cpsr */</span><br>        <span class="hljs-keyword">bic</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">r0</span>, <span class="hljs-number">#0xf</span>     <span class="hljs-comment">/* 修改M4-M0为0b10000, 进入usr模式 */</span><br>        <span class="hljs-keyword">bic</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">r0</span>, #(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">7</span>)  <span class="hljs-comment">/* 清除I位, 使能中断 */</span><br>        <span class="hljs-keyword">msr</span> cpsr, <span class="hljs-built_in">r0</span><br><br>        <span class="hljs-comment">/* 设置 sp_usr */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">=0x33f00000</span><br><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, <span class="hljs-symbol">=sdram</span><br><span class="hljs-symbol">sdram:</span><br>        <span class="hljs-keyword">bl</span> uart0_init<br><br>        <span class="hljs-keyword">bl</span> print1<br>        <span class="hljs-comment">/* 故意加入一条未定义指令 */</span><br></code></pre></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">init.c 需要放在前面<br>nand<span class="hljs-emphasis">_init</span><br><span class="hljs-emphasis">sdram_</span>init初始化也放前面<br>sdram:<br></code></pre></td></tr></table></figure><p>bl uart0_init</p><p>这就跳到sdram了，重定位后就随便操作</p><p>修改Makefile 我们把 start.o init.o nand_flash.o放在最前面</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objs = start.o init.o nand_flash.o led.o uart.o main.o exception.o interrupt.o timer.o nor_flash.o my_printf.o string_utils.o lib1funcs.o<br><br>objs += lcd/font.o<br>objs += lcd/framebuffer.o<br>objs += lcd/geometry.o<br>objs += lcd/lcd.o<br>objs += lcd/lcd_4.3.o<br>objs += lcd/lcd_controller.o<br>objs += lcd/lcd_test.o<br>objs += lcd/s3c2440_lcd_controller.o<br>objs += lcd/font_8x16.o<br><br>objs += adc_touchscreen/adc.o<br>objs += adc_touchscreen/adc_test.o<br><br>objs += adc_touchscreen/touchscreen.o<br>objs += adc_touchscreen/touchscreen_test.o<br><br><span class="hljs-section">all: <span class="hljs-variable">$(objs)</span></span><br>        <span class="hljs-comment">#arm-linux-ld -Ttext 0 -Tdata 0x30000000  start.o led.o uart.o init.o main.o -o sdram.elf</span><br>        arm-linux-ld -T sdram.lds <span class="hljs-variable">$^</span> libgcc.a -o sdram.elf<br>        arm-linux-objcopy -O binary -S sdram.elf sdram.bin<br>        arm-linux-objdump -D sdram.elf &gt; sdram.dis<br><span class="hljs-section">clean:</span><br>        rm -f *.bin <span class="hljs-variable">$(objs)</span> *.elf *.dis<br>        <br>%.o : %.c<br>        arm-linux-gcc -march=armv4 -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><br>%.o : %.S<br>        arm-linux-gcc -march=armv4 -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br></code></pre></td></tr></table></figure><p>这节课讲定时器的优化, 下节课讲怎么使用定时器来改进触摸屏</p><p><strong>第008节_触摸屏编程_使用定时器支持长按</strong></p><hr><p>可以使用定时器把长按或者滑动触摸屏的值读出来,我们按下触摸屏就会产生触摸屏中断，这个时候可以启动ADC,ADC成功后再次产生中段,在这个中断中启动定时器,我们也可以在触摸屏中断里启动定时器.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;../s3c2440_soc.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADC_INT_BIT (10)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TC_INT_BIT  (9)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INT_ADC_TC   (31)</span><br><br><span class="hljs-comment">/* ADCTSC&#x27;s bits */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WAIT_PEN_DOWN    (0&lt;&lt;8)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WAIT_PEN_UP      (1&lt;&lt;8)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> YM_ENABLE        (1&lt;&lt;7)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> YM_DISABLE       (0&lt;&lt;7)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> YP_ENABLE        (0&lt;&lt;6)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> YP_DISABLE       (1&lt;&lt;6)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XM_ENABLE        (1&lt;&lt;5)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XM_DISABLE       (0&lt;&lt;5)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XP_ENABLE        (0&lt;&lt;4)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XP_DISABLE       (1&lt;&lt;4)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PULLUP_ENABLE    (0&lt;&lt;3)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PULLUP_DISABLE   (1&lt;&lt;3)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AUTO_PST         (1&lt;&lt;2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WAIT_INT_MODE    (3)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NO_OPR_MODE      (0)</span><br><br><span class="hljs-comment">//定义一个全局变量设置timer状态</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> g_ts_timer_enable = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">adc_ts_int_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        SUBSRCPND = (<span class="hljs-number">1</span>&lt;&lt;TC_INT_BIT) | (<span class="hljs-number">1</span>&lt;&lt;ADC_INT_BIT);<br><span class="hljs-comment">//注册中断处理函数，才可以在处理函数中启动定时器</span><br><br>        <span class="hljs-comment">/* 注册中断处理函数 */</span><br>        <span class="hljs-built_in">register_irq</span>(<span class="hljs-number">31</span>, AdcTsIntHandle);<br><br>        <span class="hljs-comment">/* 使能中断 */</span><br>        INTSUBMSK &amp;= ~((<span class="hljs-number">1</span>&lt;&lt;ADC_INT_BIT) | (<span class="hljs-number">1</span>&lt;&lt;TC_INT_BIT));<br>        <span class="hljs-comment">//INTMSK    &amp;= ~(1&lt;&lt;INT_ADC_TC);&#125;</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">touchscreen_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-comment">/* 设置触摸屏接口:寄存器 */</span><br>        <span class="hljs-built_in">adc_ts_reg_init</span>();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ADCUPDN = 0x%x, SUBSRCPND = 0x%x, SRCPND = 0x%x\n\r&quot;</span>, ADCUPDN, SUBSRCPND, SRCPND);<br><br>        <span class="hljs-comment">/* 设置中断 */</span><br>        <span class="hljs-built_in">adc_ts_int_init</span>();<br><br>        <span class="hljs-comment">/* 注册定时器处理函数 */</span><br>    <span class="hljs-comment">//首先是一个名字，其次是定时器处理函数</span><br>        <span class="hljs-built_in">register_timer</span>(<span class="hljs-string">&quot;touchscreen&quot;</span>, touchscreen_timer_irq);<br><br>        <span class="hljs-comment">/* 让触摸屏控制器进入&quot;等待中断模式&quot; */</span><br>        <span class="hljs-built_in">enter_wait_pen_down_mode</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>进入touchscreen.c adc中断处理函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Isr_Adc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">int</span> x = ADCDAT0;<br>        <span class="hljs-type">int</span> y = ADCDAT1;<br><br>        <span class="hljs-keyword">if</span> (!(x &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>))) <span class="hljs-comment">/* 如果仍然按下才打印 */</span><br>        &#123;<br>                x &amp;= <span class="hljs-number">0x3ff</span>;<br>                y &amp;= <span class="hljs-number">0x3ff</span>;<br>                <br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x = %08d, y = %08d\n\r&quot;</span>, x, y);<br>    <span class="hljs-comment">//添加定时器函数</span><br>                <span class="hljs-comment">/* 启动定时器以再次读取数据 */</span><br>                <span class="hljs-built_in">ts_timer_enable</span>();<br>        &#125;<br>    <span class="hljs-comment">//松开操作</span><br>        <span class="hljs-keyword">else</span><br>        &#123;<br>                <span class="hljs-built_in">ts_timer_disable</span>();<br>                <span class="hljs-built_in">enter_wait_pen_down_mode</span>();<br>        &#125;<br>        <span class="hljs-built_in">enter_wait_pen_up_mode</span>();<br>&#125;<br><br><span class="hljs-comment">//触摸屏定时器处理函数</span><br><span class="hljs-comment">/* 每10ms该函数被调用一次  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">touchscreen_timer_irq</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-comment">/* 如果触摸屏仍被按下, 进入&quot;自动测量模式&quot;, 启动ADC */</span><br>    <span class="hljs-comment">//如果定时器并没有被使能，则return</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">get_status_of_ts_timer</span>() == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">//如果松开，则什么事情都不做</span><br>        <span class="hljs-keyword">if</span> (ADCDAT0 &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>)) <span class="hljs-comment">/* 如果松开 */</span><br>        &#123;<br>    <span class="hljs-comment">//设置定时器状态</span><br>                <span class="hljs-built_in">ts_timer_disable</span>();<br>    <span class="hljs-comment">//触摸笔进入等待模式</span><br>                <span class="hljs-built_in">enter_wait_pen_down_mode</span>();<br>                <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>    <span class="hljs-comment">//否则启动测量</span><br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 按下状态，启动下一次测量 */</span><br>        &#123;<br>                <span class="hljs-comment">/* 进入&quot;自动测量&quot;模式 */</span><br>                <span class="hljs-built_in">enter_auto_measure_mode</span>();<br><br>                <span class="hljs-comment">/* 启动ADC */</span><br>                ADCCON |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>);<br>        &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">ts_timer_enable</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//我们使用定时器时把它的状态设置为1</span><br>        g_ts_timer_enable = <span class="hljs-number">1</span>;<br>&#125;<br><br>    <span class="hljs-comment">//有启用定时器就有关闭定时器</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">ts_timer_disable</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//我们不使用定时器把定时器状态设置为0</span><br>        g_ts_timer_enable = <span class="hljs-number">0</span>;<br>&#125;<br><br>    <span class="hljs-comment">//我们如何获取定时器状态？</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">get_status_of_ts_timer</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//返回定时器状态</span><br>        <span class="hljs-keyword">return</span> g_ts_timer_enable;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们回顾一下处理过程，根据流程图分析</p><ul><li>首先从main.c函数开始</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scss">int <span class="hljs-selector-tag">main</span>(void)<br>&#123;<br>        <span class="hljs-built_in">led_init</span>();<br>        <span class="hljs-comment">//interrupt_init();  /* 初始化中断控制器 */</span><br>        <span class="hljs-built_in">key_eint_init</span>();     <span class="hljs-comment">/* 初始化按键, 设为中断源 */</span><br>        <span class="hljs-built_in">timer_init</span>();<br>        <br>        <span class="hljs-built_in">puts</span>(&quot;\n\rg_A = &quot;);<br>        <span class="hljs-built_in">printHex</span>(g_A);<br>        <span class="hljs-built_in">puts</span>(&quot;\n\r&quot;);<br>        <span class="hljs-comment">//nor_flash_test();</span><br>        <span class="hljs-built_in">lcd_test</span>();<br>        <span class="hljs-comment">//adc_test();</span><br>           <span class="hljs-comment">//执行touchscreen_test</span><br>        <span class="hljs-built_in">touchscreen_test</span>();<br>        while (<span class="hljs-number">1</span>);<br>        <br>        return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>进入touchscreen_test.c文件执行init初始化程序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">touchscreen_test</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>        <span class="hljs-title function_">touchscreen_init</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>进入touchscreen.c文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs awk">void touchscreen_init(void)<br>&#123;<br>        <span class="hljs-regexp">/* 设置触摸屏接口:寄存器 */</span><br>        adc_ts_reg_init();<br><br>        printf(<span class="hljs-string">&quot;ADCUPDN = 0x%x, SUBSRCPND = 0x%x, SRCPND = 0x%x\n\r&quot;</span>, ADCUPDN, SUBSRCPND, SRCPND);<br><br>        <span class="hljs-regexp">/* 设置中断 */</span><br>        adc_ts_int_init();<br><br>        <span class="hljs-regexp">/* 让触摸屏控制器进入&quot;等待中断模式&quot; */</span><br>        enter_wait_pen_down_mode();<br>&#125;<br><br>void adc_ts_reg_init(void)<br>&#123;<br>        <span class="hljs-regexp">/* [15] : ECFLG,  1 = End of A/</span>D conversion  <br>         * [<span class="hljs-number">14</span>] : PRSCEN, <span class="hljs-number">1</span> = A/D converter prescaler enable  <br>         * [<span class="hljs-number">13</span>:<span class="hljs-number">6</span>]: PRSCVL, adc clk = PCLK / (PRSCVL + <span class="hljs-number">1</span>)  <br>         * [<span class="hljs-number">5</span>:<span class="hljs-number">3</span>] : SEL_MUX, <span class="hljs-number">000</span> = AIN <span class="hljs-number">0</span>  * [<span class="hljs-number">2</span>]   : STDBM  <br>         * [<span class="hljs-number">0</span>]   : <span class="hljs-number">1</span> = A/D conversion starts and this bit is cleared after the startup.  <br>         */<br>        ADCCON = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">14</span>) | (<span class="hljs-number">49</span>&lt;&lt;<span class="hljs-number">6</span>) | (<span class="hljs-number">0</span>&lt;&lt;<span class="hljs-number">3</span>);<br><br>        /*  按下触摸屏, 延时一会再发出TC中断  <br>         *  延时时间 = ADCDLY <br>         * 晶振周期 = ADCDLY <br>         * <span class="hljs-number">1</span> / <span class="hljs-number">12000000</span> = <span class="hljs-number">5</span>ms  <br>         */<br>        ADCDLY = <span class="hljs-number">60000</span>;      <br>&#125;<br><br><span class="hljs-regexp">//</span>进入adc触摸屏中断处理<br>void adc_ts_int_init(void)<br>&#123;<br>        SUBSRCPND = (<span class="hljs-number">1</span>&lt;&lt;TC_INT_BIT) | (<span class="hljs-number">1</span>&lt;&lt;ADC_INT_BIT);<br><br>        <span class="hljs-regexp">/* 注册中断处理函数 */</span><br>        register_irq(<span class="hljs-number">31</span>, AdcTsIntHandle);<br><br>        <span class="hljs-regexp">/* 使能中断 */</span><br>        INTSUBMSK &amp;= ~((<span class="hljs-number">1</span>&lt;&lt;ADC_INT_BIT) | (<span class="hljs-number">1</span>&lt;&lt;TC_INT_BIT));<br>        <span class="hljs-regexp">//</span>INTMSK    &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;INT_ADC_TC);<br>&#125;<br><br>void AdcTsIntHandle(int irq)<br>&#123;<br>        <span class="hljs-keyword">if</span> (SUBSRCPND &amp; (<span class="hljs-number">1</span>&lt;&lt;TC_INT_BIT))  <span class="hljs-regexp">/* 如果是触摸屏中断 */</span><br>                Isr_Tc();<br><br>        <span class="hljs-keyword">if</span> (SUBSRCPND &amp; (<span class="hljs-number">1</span>&lt;&lt;ADC_INT_BIT))  <span class="hljs-regexp">/* ADC中断 */</span><br>                Isr_Adc();<br>        SUBSRCPND = (<span class="hljs-number">1</span>&lt;&lt;TC_INT_BIT) | (<span class="hljs-number">1</span>&lt;&lt;ADC_INT_BIT);<br>&#125;<br><br><span class="hljs-regexp">//</span>进入触摸屏处理函数<br><span class="hljs-regexp">//</span>触摸屏定时器处理函数<br><span class="hljs-regexp">/* 每10ms该函数被调用一次  */</span><br>void touchscreen_timer_irq(void)<br>&#123;<br>        <span class="hljs-regexp">/* 如果触摸屏仍被按下, 进入&quot;自动测量模式&quot;, 启动ADC */</span><br>    <span class="hljs-regexp">//</span>如果定时器并没有被使能，则return<br>        <span class="hljs-keyword">if</span> (get_status_of_ts_timer() == <span class="hljs-number">0</span>)<br>                return;<br>    <span class="hljs-regexp">//</span>如果松开，则什么事情都不做<br>        <span class="hljs-keyword">if</span> (ADCDAT0 &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>)) <span class="hljs-regexp">/* 如果松开 */</span><br>        &#123;<br>    <span class="hljs-regexp">//</span>设置定时器状态<br>                ts_timer_disable();<br>    <span class="hljs-regexp">//</span>触摸笔进入等待模式<br>                enter_wait_pen_down_mode();<br>                return;<br>        &#125;<br><br>    <span class="hljs-regexp">//</span>否则启动测量<br>        <span class="hljs-keyword">else</span>  <span class="hljs-regexp">/* 按下状态，启动下一次测量 */</span><br>        &#123;<br>                <span class="hljs-regexp">/* 进入&quot;自动测量&quot;模式 */</span><br>                enter_auto_measure_mode();<br><br>                <span class="hljs-regexp">/* 启动ADC */</span><br>                ADCCON |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第009节_触摸屏编程_较准原理</strong></p><hr><p>我们需要校准触摸屏，所谓校准就是找到一个公式把电压值转换为坐标值</p><p>触摸屏和LCD是两个东西,触摸屏覆盖在LCD上.</p><p><img src="/image/Chapter18_lesson9_001.png" alt="Chapter18_lesson9_001.png"></p><p><strong>问：得到触电的(x1,y1)怎么换算出LCD的坐标值 (X,Y)?</strong></p><p><img src="/image/Chapter18_lesson9_002.png" alt="Chapter18_lesson9_002.png"></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">x</span><span class="hljs-operator">=</span><span class="hljs-number">479</span><span class="hljs-number">-0</span>/<span class="hljs-keyword">x</span><span class="hljs-number">2</span>-<span class="hljs-keyword">x</span><span class="hljs-number">1</span> * (<span class="hljs-keyword">x</span><span class="hljs-number">3</span>-<span class="hljs-keyword">x</span><span class="hljs-number">1</span>) + <span class="hljs-number">0</span><br><span class="hljs-keyword">x</span><span class="hljs-operator">=</span>长度的比例<br><span class="hljs-keyword">x</span><span class="hljs-number">1</span> <span class="hljs-number">0</span> 原点的触摸屏/LCD坐标<br></code></pre></td></tr></table></figure><p>我们只需要确定两个点就可以把lcd坐标确定下来，但是我们可以做的更好</p><p>假设由于制作工艺问题，导致触摸屏和LCD坐标并不相同，需要其他公式计算</p><ul><li>X轴方向</li></ul><p><img src="/image/Chapter18_lesson9_003.png" alt="Chapter18_lesson9_003.png"></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-built_in">s1</span><span class="hljs-string">&#x27;是TS上X轴两个点的距离</span><br><span class="hljs-string">s1 是LCD上X轴两个点的距离</span><br><span class="hljs-string">s2&#x27;</span> <span class="hljs-built_in">s2</span><br></code></pre></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">Kx= LCD距离/触摸屏距离<br><span class="hljs-section">= (s1 + s2) / (s1&#x27; + s2&#x27;)</span><br><span class="hljs-section">= 2s/(s1&#x27; + s2&#x27;)</span><br></code></pre></td></tr></table></figure><ul><li>Y轴方向</li></ul><p><img src="/image/Chapter18_lesson9_004.png" alt="Chapter18_lesson9_004.png"></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">TS</span>距离是<span class="hljs-built_in">d1</span><span class="hljs-string">&#x27;</span><br><span class="hljs-string">LCD距离是d1</span><br></code></pre></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">Ky=(d1 <span class="hljs-code">+ d2) / (d1&#x27; +</span> d2&#x27;)<br><span class="hljs-section">= 2d / (d1&#x27; + d2&#x27;)</span><br></code></pre></td></tr></table></figure><p>我们现在有了斜率，给定一个坐标，我们需要需要原点的触屏LCD坐标</p><p>原点我们选在最中间 可以忽略掉上下左右的偏差</p><p><img src="/image/Chapter18_lesson9_005.png" alt="Chapter18_lesson9_005.png"></p><p>原点坐标在触摸屏上是xc’ yc’,在LCD上是 xc yc ,那我们的校准公式,对于给定的x3,我们如何求出x</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">X</span>= (x3 - xc<span class="hljs-string">&#x27; ) * Kx + xc</span><br></code></pre></td></tr></table></figure><p>对于给定的y’我们如何算出Y轴坐标？</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">y</span> = (y<span class="hljs-string">&#x27; - yc&#x27;</span>) * Ky + yc<br></code></pre></td></tr></table></figure><p>我们需要点击触摸屏上这5个点，同时需要把这五个点坐标打印显示出来.</p><p>这节视频我们讲的时校准原理</p><p><strong>第010节_触摸屏编程_较准与画线编</strong></p><hr><p>这个程序我们怎么写</p><p><img src="/image/Chapter18_lesson9_005.png" alt="Chapter18_lesson9_005.png"></p><p>我们需要得到这5个点的坐标 给这5个点分别设置为ABCDE</p><p>第一步</p><ul><li>在A点显示 +</li><li>客户点击 +</li><li>记录触摸屏的坐标</li><li>在BCDE上循环操作,显示点击读取的操作</li></ul><p>第二步</p><ul><li>根据这些数据，确定公式</li></ul><p>第三步</p><ul><li>以后得到TS触点时，可转换出LCD坐标</li></ul><p>我们需要实现这几个函数</p><p>显示 + 在x y 中显示 fb_disp_cross(int x , int y)</p><p>如何记录 ts_read_raw ,读到原始数据,根据这些数据，确定公式 ts_calibrate</p><p><strong>如何转换出LCD坐标?</strong></p><p>ts_read</p><p>我们实现这几个函数</p><ul><li><p>我们先实现 +</p></li><li><p>我们既然画线就在geometry.c中实现</p></li></ul><p><img src="/image/Chapter18_lesson10_002.png" alt="Chapter18_lesson10_002.png"></p><p>画十字架, 原点x,y</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">x</span>-<span class="hljs-number">10</span> y<br><span class="hljs-attribute">x</span>+<span class="hljs-number">10</span> y<br><span class="hljs-attribute">x</span> y+<span class="hljs-number">10</span><br><span class="hljs-attribute">x</span> y+<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void fb<span class="hljs-constructor">_disp_cross(<span class="hljs-params">int</span> <span class="hljs-params">x</span>, <span class="hljs-params">int</span> <span class="hljs-params">y</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">color</span>)</span><br>&#123;<br>        draw<span class="hljs-constructor">_line(<span class="hljs-params">x</span>-10, <span class="hljs-params">y</span>, <span class="hljs-params">x</span>+10, <span class="hljs-params">y</span>, <span class="hljs-params">color</span>)</span>;<br>        draw<span class="hljs-constructor">_line(<span class="hljs-params">x</span>, <span class="hljs-params">y</span>-10, <span class="hljs-params">x</span>, <span class="hljs-params">y</span>+10, <span class="hljs-params">color</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编辑touchscreen.c</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//+ 坐标的x值</span><br>static <span class="hljs-built_in">int</span> g_ts_x;<br><span class="hljs-comment">//+ 坐标Y值</span><br>static <span class="hljs-built_in">int</span> g_ts_y;<br><br><span class="hljs-comment">//表示数据并未有效</span><br><span class="hljs-comment">//设置成volatile类型，有两个地方会用到一个是中断report_ts_xy</span><br><span class="hljs-comment">//另一个是程序ts_read_raw，我们一定确保这个值是从内存中读取出来</span><br><span class="hljs-comment">//让双方得到真实的值</span><br>static　volatile <span class="hljs-built_in">char</span> g_ts_data_valid = <span class="hljs-number">0</span>;<br><br>void <span class="hljs-constructor">Isr_Adc(<span class="hljs-params">void</span>)</span><br>&#123;<br>        <span class="hljs-built_in">int</span> x = ADCDAT0;<br>        <span class="hljs-built_in">int</span> y = ADCDAT1;<br><br>        <span class="hljs-keyword">if</span> (!(x &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>))) <span class="hljs-comment">/* 如果仍然按下才打印 */</span><br>        &#123;<br>                x &amp;= <span class="hljs-number">0x3ff</span>;<br>                y &amp;= <span class="hljs-number">0x3ff</span>;<br>            <span class="hljs-comment">//我们现在不能打印               </span><br>                <span class="hljs-comment">//printf(&quot;x = %08d, y = %08d\n\r&quot;, x, y);</span><br>            <span class="hljs-comment">//实现report_ts_xy函数来打印</span><br>                report<span class="hljs-constructor">_ts_xy(<span class="hljs-params">x</span>, <span class="hljs-params">y</span>)</span>;<br><br>                <span class="hljs-comment">/* 启动定时器以再次读取数据 */</span><br>                ts<span class="hljs-constructor">_timer_enable()</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>                ts<span class="hljs-constructor">_timer_disable()</span>;<br>                enter<span class="hljs-constructor">_wait_pen_down_mode()</span>;<br>        &#125;<br><br>        enter<span class="hljs-constructor">_wait_pen_up_mode()</span>;<br>&#125;<br><br><span class="hljs-comment">//report_ts_xy函数的实现</span><br><br>void report<span class="hljs-constructor">_ts_xy(<span class="hljs-params">int</span> <span class="hljs-params">x</span>, <span class="hljs-params">int</span> <span class="hljs-params">y</span>)</span><br>&#123;<br>        <span class="hljs-comment">//printf(&quot;x = %08d, y = %08d\n\r&quot;, x, y);</span><br>    <span class="hljs-comment">//一开始标记位=0表示没有数据</span><br>        <span class="hljs-keyword">if</span> (g_ts_data_valid<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)<br>        &#123;<br>                g_ts_x = x;<br>                g_ts_y = y;<br>                g_ts_data_valid = <span class="hljs-number">1</span>;<br>        &#125;<br>&#125;<br><br><span class="hljs-comment">//读到原始数据</span><br>void ts<span class="hljs-constructor">_read_raw(<span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">px</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">py</span>)</span><br>&#123;<br>    <span class="hljs-comment">//当按下触摸屏时会产生ADC中断</span><br>        <span class="hljs-keyword">while</span> (g_ts_data_valid<span class="hljs-operator"> == </span><span class="hljs-number">0</span>);<br>        *px = g_ts_x;<br>        *py = g_ts_y;<br>    <span class="hljs-comment">//读完数据清零</span><br>        g_ts_data_valid = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们实现ts_calibrate校准函数,在tslib.c文件中</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//设置斜率为全局变量</span><br>static double g_kx;<br>static double g_ky;<br>static <span class="hljs-built_in">int</span> g_ts_xc, g_ts_yc;<br>static <span class="hljs-built_in">int</span> g_lcd_xc, g_lcd_yc;<br><br><span class="hljs-comment">//加一个调换的全局变量</span><br>static <span class="hljs-built_in">int</span> g_ts_xy_swap = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">----------------------------</span><br><span class="hljs-comment">|                          |</span><br><span class="hljs-comment">|  +(A)              (B)+  |</span><br><span class="hljs-comment">|                          |</span><br><span class="hljs-comment">|                          |</span><br><span class="hljs-comment">|                          |</span><br><span class="hljs-comment">|            +(E)          |</span><br><span class="hljs-comment">|                          |</span><br><span class="hljs-comment">|                          |</span><br><span class="hljs-comment">|                          |</span><br><span class="hljs-comment">|  +(D)              (C)+  |</span><br><span class="hljs-comment">|                          |</span><br><span class="hljs-comment">----------------------------</span><br><span class="hljs-comment">*/</span><br>把ABCDE这<span class="hljs-number">5</span>个点都实现<br><br>void ts<span class="hljs-constructor">_calibrate(<span class="hljs-params">void</span>)</span><br>&#123;<br>        unsigned <span class="hljs-built_in">int</span> fb_base;<br>        <span class="hljs-built_in">int</span> xres, yres, bpp;<br>    <span class="hljs-comment">//定义ABCDE触摸屏坐标</span><br>        <span class="hljs-built_in">int</span> a_ts_x, a_ts_y;<br>        <span class="hljs-built_in">int</span> b_ts_x, b_ts_y;<br>        <span class="hljs-built_in">int</span> c_ts_x, c_ts_y;<br>        <span class="hljs-built_in">int</span> d_ts_x, d_ts_y;<br>        <span class="hljs-built_in">int</span> e_ts_x, e_ts_y;<br><br>        <span class="hljs-comment">/* X轴方向 */</span><br>        <span class="hljs-built_in">int</span> ts_s1, ts_s2;<br>        <span class="hljs-built_in">int</span> lcd_s;<br><br>        <span class="hljs-comment">/* Y轴方向 */</span><br>        <span class="hljs-built_in">int</span> ts_d1, ts_d2;<br>        <span class="hljs-built_in">int</span> lcd_d;<br>    <span class="hljs-comment">//通过调用framebuffer.c里面的函数，来获取LCD坐标</span><br>        <span class="hljs-comment">/* 获得LCD的参数: fb_base, xres, yres, bpp */</span><br>        get<span class="hljs-constructor">_lcd_params(&amp;<span class="hljs-params">fb_base</span>, &amp;<span class="hljs-params">xres</span>, &amp;<span class="hljs-params">yres</span>, &amp;<span class="hljs-params">bpp</span>)</span>;<br><br>        <span class="hljs-comment">/* 对于ABCDE, 循环: 显示&quot;+&quot;、点击、读ts原始值 */</span><br>    <span class="hljs-comment">//A坐标，X分辨率50， Y分辨率50</span><br>        <span class="hljs-comment">/* A(50, 50) */</span><br>        get<span class="hljs-constructor">_calibrate_point_data(50, 50, &amp;<span class="hljs-params">a_ts_x</span>, &amp;<span class="hljs-params">a_ts_y</span>)</span>;<br>    <span class="hljs-comment">//B坐标，X分辨率-50</span><br>        <span class="hljs-comment">/* B(xres-50, 50) */</span><br>        get<span class="hljs-constructor">_calibrate_point_data(<span class="hljs-params">xres</span>-50, 50, &amp;<span class="hljs-params">b_ts_x</span>, &amp;<span class="hljs-params">b_ts_y</span>)</span>;<br>    <span class="hljs-comment">//C坐标，X分辨率-50，Y分辨率-50</span><br>        <span class="hljs-comment">/* C(xres-50, yres-50) */</span><br>        get<span class="hljs-constructor">_calibrate_point_data(<span class="hljs-params">xres</span>-50, <span class="hljs-params">yres</span>-50, &amp;<span class="hljs-params">c_ts_x</span>, &amp;<span class="hljs-params">c_ts_y</span>)</span>;<br>    <span class="hljs-comment">//D坐标，X分辨率位置50，Y分辨率-50</span><br>        <span class="hljs-comment">/* D(50, yres-50) */</span><br>        get<span class="hljs-constructor">_calibrate_point_data(50, <span class="hljs-params">yres</span>-50, &amp;<span class="hljs-params">d_ts_x</span>, &amp;<span class="hljs-params">d_ts_y</span>)</span>;<span class="hljs-comment">//E坐标，X分辨率除2，Y分辨率除2</span><br>        <span class="hljs-comment">/* E(xres/2, yres/2) */</span><br>        get<span class="hljs-constructor">_calibrate_point_data(<span class="hljs-params">xres</span><span class="hljs-operator">/</span>2, <span class="hljs-params">yres</span><span class="hljs-operator">/</span>2, &amp;<span class="hljs-params">e_ts_x</span>, &amp;<span class="hljs-params">e_ts_y</span>)</span>;<br>    <span class="hljs-comment">//读取XY坐标值后确定XY是否反转</span><br>        <span class="hljs-comment">/* 确定触摸屏数据XY是否反转 */</span><br>        g_ts_xy_swap = is<span class="hljs-constructor">_ts_xy_swap(<span class="hljs-params">a_ts_x</span>, <span class="hljs-params">a_ts_y</span>, <span class="hljs-params">b_ts_x</span>, <span class="hljs-params">b_ts_y</span>)</span>;<br>    <span class="hljs-comment">//如果反转，对调所有点的XY坐标</span><br>        <span class="hljs-keyword">if</span> (g_ts_xy_swap)<br>        &#123;<br>                <span class="hljs-comment">/* 对调所有点的XY坐标 */</span><br>                swap<span class="hljs-constructor">_xy(&amp;<span class="hljs-params">a_ts_x</span>, &amp;<span class="hljs-params">a_ts_y</span>)</span>;<br>                swap<span class="hljs-constructor">_xy(&amp;<span class="hljs-params">b_ts_x</span>, &amp;<span class="hljs-params">b_ts_y</span>)</span>;<br>                swap<span class="hljs-constructor">_xy(&amp;<span class="hljs-params">c_ts_x</span>, &amp;<span class="hljs-params">c_ts_y</span>)</span>;<br>                swap<span class="hljs-constructor">_xy(&amp;<span class="hljs-params">d_ts_x</span>, &amp;<span class="hljs-params">d_ts_y</span>)</span>;<br>                swap<span class="hljs-constructor">_xy(&amp;<span class="hljs-params">e_ts_x</span>, &amp;<span class="hljs-params">e_ts_y</span>)</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><p><img src="/image/Chapter18_lesson10_003.png" alt="Chapter18_lesson10_003.png"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* 确定公式的参数并保存 */</span><br><span class="hljs-regexp">//</span>Ts_S1值=B点ts和A点tsX轴方向的距离<br>        ts_s1 = b_ts_x - a_ts_x;<br><span class="hljs-regexp">//</span>Ts_S2值<br>        ts_s2 = c_ts_x - d_ts_x;<br><span class="hljs-regexp">//</span>lcd_s值<br>        lcd_s = xres-<span class="hljs-number">50</span> - <span class="hljs-number">50</span>;<br><span class="hljs-regexp">//</span>ts_d1值<br>        ts_d1 = d_ts_y - a_ts_y;<br><span class="hljs-regexp">//</span>ts_d2值<br>        ts_d2 = c_ts_y - b_ts_y;<br><span class="hljs-regexp">//</span>lcd_d值<br>        lcd_d = yres-<span class="hljs-number">50</span>-<span class="hljs-number">50</span>;<br><span class="hljs-regexp">//</span>X轴的斜率<br>        g_kx = ((double)(<span class="hljs-number">2</span>*lcd_s)) / (ts_s1 + ts_s2);<br><span class="hljs-regexp">//</span>Y轴的斜率<br>        g_ky = ((double)(<span class="hljs-number">2</span>*lcd_d)) / (ts_d1 + ts_d2);<br><br><span class="hljs-regexp">//</span>中心点E点的坐标<br>        g_ts_xc = e_ts_x;<br>        g_ts_yc = e_ts_y;<br>        g_lcd_xc = xres/<span class="hljs-number">2</span>;<br>        g_lcd_yc = yres/<span class="hljs-number">2</span>;&#125;<br></code></pre></td></tr></table></figure><p>我们需要把 + 在LCD上显示出来并且读出数据</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void get<span class="hljs-constructor">_calibrate_point_data(<span class="hljs-params">int</span> <span class="hljs-params">lcd_x</span>, <span class="hljs-params">int</span> <span class="hljs-params">lcd_y</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">px</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">py</span>)</span><br>&#123;<br>        fb<span class="hljs-constructor">_disp_cross(<span class="hljs-params">lcd_x</span>, <span class="hljs-params">lcd_y</span>, 0xffffff)</span>;<br><br>        <span class="hljs-comment">/* 等待点击 */</span><br><br>        ts<span class="hljs-constructor">_read_raw(<span class="hljs-params">px</span>, <span class="hljs-params">py</span>)</span>;<br>&#125;<br><span class="hljs-comment">//比如我们之前发现上报的X轴Y轴值反了</span><br><span class="hljs-comment">//比如正常情况下从A点移动到B点是x值变化比较大y值不变，但是目前的情况是y值变化比较大，x值不变</span><br><span class="hljs-comment">//我分根据这个特性分辨</span><br><br><span class="hljs-built_in">int</span> is<span class="hljs-constructor">_ts_xy_swap(<span class="hljs-params">int</span> <span class="hljs-params">a_ts_x</span>, <span class="hljs-params">int</span> <span class="hljs-params">a_ts_y</span>, <span class="hljs-params">int</span> <span class="hljs-params">b_ts_x</span>, <span class="hljs-params">int</span> <span class="hljs-params">b_ts_y</span>)</span><br>&#123;<br>        <span class="hljs-built_in">int</span> dx = b_ts_x - a_ts_x;<br>        <span class="hljs-built_in">int</span> dy = b_ts_y - a_ts_y;<br><span class="hljs-comment">//减出来的值有可能是负数，我们需要取绝对值</span><br>        <span class="hljs-keyword">if</span> (dx &lt; <span class="hljs-number">0</span>)<br>                dx = <span class="hljs-number">0</span> - dx;<br>        <span class="hljs-keyword">if</span> (dy &lt; <span class="hljs-number">0</span>)<br>                dy = <span class="hljs-number">0</span> - dy;<br><br>        <span class="hljs-keyword">if</span>(dx &gt; dy)<br>                return <span class="hljs-number">0</span>; <span class="hljs-comment">/* xy没有反转 */</span><br>        <span class="hljs-keyword">else</span><br>                return <span class="hljs-number">1</span>; <span class="hljs-comment">/* xy反了 */</span><br>&#125;<br><br><span class="hljs-comment">//如果是反的我们需要调换回来，我们需要确定XY是否反转</span><br><br><span class="hljs-comment">//我们写出一个对调函数</span><br>void swap<span class="hljs-constructor">_xy(<span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">px</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">py</span>)</span><br>&#123;<br>        <span class="hljs-built_in">int</span> tmp = *px;<br>        *px = *py;<br>        *py = tmp;<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * 读TS原始数据, 转换为LCD坐标 </span><br><span class="hljs-comment"> */</span><br>void ts<span class="hljs-constructor">_read(<span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">lcd_x</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">lcd_y</span>)</span><br>&#123;<br>        <span class="hljs-built_in">int</span> ts_x, ts_y;<br>        <br>        ts<span class="hljs-constructor">_read_raw(&amp;<span class="hljs-params">ts_x</span>, <span class="hljs-params">ts_y</span>)</span>;<br>        <span class="hljs-keyword">if</span> (g_ts_xy_swap)<br>        &#123;<br>                swap<span class="hljs-constructor">_xy(&amp;<span class="hljs-params">ts_x</span>, &amp;<span class="hljs-params">ts_y</span>)</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/* 使用公式计算 */</span><br>    <span class="hljs-comment">//斜率 * (触摸屏坐标 - 中心点除，触摸屏坐标) + 中心点LCD坐标</span><br>        *lcd_x = g_kx<span class="hljs-operator"> * </span>(ts_x - g_ts_xc) + g_lcd_xc;<br>        *lcd_y = g_ky<span class="hljs-operator"> * </span>(ts_y - g_ts_yc) + g_lcd_yc;&#125;<br></code></pre></td></tr></table></figure><p>接下来我们画线, 我们在framebuffer.c中把清屏函数单独实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear_screen</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> color)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">int</span> x, y;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *p0;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *p;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *p2;<br><br>        <span class="hljs-comment">/* 往framebuffer中写数据 */</span><br>        <span class="hljs-keyword">if</span> (bpp == <span class="hljs-number">8</span>)<br>        &#123;<br>                <span class="hljs-comment">/* bpp: palette[color] */</span><br><br>                p0 = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)fb_base;<br>                <span class="hljs-keyword">for</span> (x = <span class="hljs-number">0</span>; x &lt; xres; x++)<br>                        <span class="hljs-keyword">for</span> (y = <span class="hljs-number">0</span>; y &lt; yres; y++)<br>                                *p0++ = color;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bpp == <span class="hljs-number">16</span>)<br>        &#123;<br>                <span class="hljs-comment">/* 让LCD输出整屏的红色 */</span><br><br>                <span class="hljs-comment">/* 565: 0xf700 */</span><br><br>                p = (<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *)fb_base;<br>                <span class="hljs-keyword">for</span> (x = <span class="hljs-number">0</span>; x &lt; xres; x++)<br>                        <span class="hljs-keyword">for</span> (y = <span class="hljs-number">0</span>; y &lt; yres; y++)<br>                                *p++ = <span class="hljs-built_in">convert32bppto16bpp</span>(color);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bpp == <span class="hljs-number">32</span>)<br>        &#123;<br>                p2 = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *)fb_base;<br>                <span class="hljs-keyword">for</span> (x = <span class="hljs-number">0</span>; x &lt; xres; x++)<br>                        <span class="hljs-keyword">for</span> (y = <span class="hljs-number">0</span>; y &lt; yres; y++)<br>                                *p2++ = color;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先显示一个一个点，让后显示开始校准提示， 校准完提示 ok draw</p><p>打开我们的 touchscreen_test.c文件</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void touchscreen<span class="hljs-constructor">_test(<span class="hljs-params">void</span>)</span><br>&#123;<br>        unsigned <span class="hljs-built_in">int</span> fb_base;<br>        <span class="hljs-built_in">int</span> xres, yres, bpp;<br><br>        <span class="hljs-built_in">int</span> x, y;<br><br>        <span class="hljs-comment">/* 获得LCD的参数: fb_base, xres, yres, bpp */</span><br>        get<span class="hljs-constructor">_lcd_params(&amp;<span class="hljs-params">fb_base</span>, &amp;<span class="hljs-params">xres</span>, &amp;<span class="hljs-params">yres</span>, &amp;<span class="hljs-params">bpp</span>)</span>;<br><br>        touchscreen<span class="hljs-constructor">_init()</span>;<br><br>        <span class="hljs-comment">/* 清屏 */</span><br>        clear<span class="hljs-constructor">_screen(0)</span>;<br>    <span class="hljs-comment">//我们在70像素的地方显示文字，背景白色显示文字</span><br>        <span class="hljs-comment">/* 显示文字提示较准 */</span><br>        fb<span class="hljs-constructor">_print_string(70, 70, <span class="hljs-string">&quot;Touc cross to calibrate touchscreen&quot;</span>, 0xffffff)</span>;<br>        ts<span class="hljs-constructor">_calibrate()</span>;<br><br>        <span class="hljs-comment">/* 显示文字提示绘画 */</span><br>        fb<span class="hljs-constructor">_print_string(70, <span class="hljs-params">yres</span> - 70, <span class="hljs-string">&quot;OK! To draw!&quot;</span>, 0xffffff)</span>;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        &#123;<br>                ts<span class="hljs-constructor">_read(&amp;<span class="hljs-params">x</span>, &amp;<span class="hljs-params">y</span>)</span>;<br>    <span class="hljs-comment">//我们先打印值</span><br>                printf(<span class="hljs-string">&quot; x = %d, y = %d\n\r&quot;</span>, x, y);<br>    <span class="hljs-comment">//描绿色的线</span><br>                fb<span class="hljs-constructor">_put_pixel(<span class="hljs-params">x</span>, <span class="hljs-params">y</span>, 0xff00)</span>;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们添加了 tslib.c需要修改Makefile</p><p>添加objs +&#x3D; adc_touchscreen&#x2F;tslib.o</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objs = start.o init.o nand_flash.o led.o uart.o main.o exception.o interrupt.o timer.o nor_flash.o my_printf.o string_utils.o lib1funcs.o<br>objs += lcd/font.o<br>objs += lcd/framebuffer.o<br>objs += lcd/geometry.o<br>objs += lcd/lcd.o<br>objs += lcd/lcd_4.3.o<br>objs += lcd/lcd_controller.o<br>objs += lcd/lcd_test.o<br>objs += lcd/s3c2440_lcd_controller.o<br>objs += lcd/font_8x16.o<br><br>objs += adc_touchscreen/adc.o<br>objs += adc_touchscreen/adc_test.o<br><br>objs += adc_touchscreen/touchscreen.o<br>objs += adc_touchscreen/touchscreen_test.o<br><br>objs += adc_touchscreen/tslib.o<br><br><span class="hljs-section">all: <span class="hljs-variable">$(objs)</span></span><br>        <span class="hljs-comment">#arm-linux-ld -Ttext 0 -Tdata 0x30000000  start.o led.o uart.o init.o main.o -o sdram.elf</span><br>        arm-linux-ld -T sdram.lds <span class="hljs-variable">$^</span> libgcc.a -o sdram.elf<br>        arm-linux-objcopy -O binary -S sdram.elf sdram.bin<br>        arm-linux-objdump -D sdram.elf &gt; sdram.dis<br><span class="hljs-section">clean:</span><br>        rm -f *.bin <span class="hljs-variable">$(objs)</span> *.elf *.dis<br>        <br>%.o : %.c<br>        arm-linux-gcc -march=armv4 -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br>%.o : %.S<br>        arm-linux-gcc -march=armv4 -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br></code></pre></td></tr></table></figure><p><strong>第011节_触摸屏编程_测试</strong></p><hr><ul><li>发现程序有bug,点击坐标一次，程序就完成执行,我们需要修改触摸屏文件tsib.c</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static double g_kx;<br>static double g_ky;<br><br>static <span class="hljs-built_in">int</span> g_ts_xc, g_ts_yc;<br>static <span class="hljs-built_in">int</span> g_lcd_xc, g_lcd_yc;<br>static <span class="hljs-built_in">int</span> g_ts_xy_swap = <span class="hljs-number">0</span>;<br><br>static unsigned <span class="hljs-built_in">int</span> fb_base;<br>static <span class="hljs-built_in">int</span> xres, yres, bpp;<br><br>void get<span class="hljs-constructor">_calibrate_point_data(<span class="hljs-params">int</span> <span class="hljs-params">lcd_x</span>, <span class="hljs-params">int</span> <span class="hljs-params">lcd_y</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">px</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">py</span>)</span><br>&#123;<br>        <span class="hljs-built_in">int</span> pressure;<br>        <span class="hljs-built_in">int</span> x, y;<br>        <br>        fb<span class="hljs-constructor">_disp_cross(<span class="hljs-params">lcd_x</span>, <span class="hljs-params">lcd_y</span>, 0xffffff)</span>;<br><br>        <span class="hljs-comment">/* 等待点击 */</span><br><br>        <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">//如果pressure一直是0的话我们丢掉这些数据</span><br>                ts<span class="hljs-constructor">_read_raw(&amp;<span class="hljs-params">x</span>, &amp;<span class="hljs-params">y</span>, &amp;<span class="hljs-params">pressure</span>)</span>;<br>        &#125; <span class="hljs-keyword">while</span> (pressure<span class="hljs-operator"> == </span><span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">//让后再次读</span><br>        <span class="hljs-keyword">do</span> &#123;<br>                *px = x;<br>                *py = y;<br>                ts<span class="hljs-constructor">_read_raw(&amp;<span class="hljs-params">x</span>, &amp;<span class="hljs-params">y</span>, &amp;<span class="hljs-params">pressure</span>)</span>;<br>                printf(<span class="hljs-string">&quot;get raw data: x = %08d, y = %08d\n\r&quot;</span>, x, y);<br>        &#125; <span class="hljs-keyword">while</span> (pressure);<br>        <br>        printf(<span class="hljs-string">&quot;return raw data: x = %08d, y = %08d\n\r&quot;</span>, *px, *py);<br><br>        <span class="hljs-comment">/* 直到松开才返回 */</span><br>        fb<span class="hljs-constructor">_disp_cross(<span class="hljs-params">lcd_x</span>, <span class="hljs-params">lcd_y</span>, 0)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改touchcreen.c文件添加压力值相关信息</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//定义压力值全局变量</span><br>static <span class="hljs-built_in">int</span> g_ts_pressure;<br>void report<span class="hljs-constructor">_ts_xy(<span class="hljs-params">int</span> <span class="hljs-params">x</span>, <span class="hljs-params">int</span> <span class="hljs-params">y</span>, <span class="hljs-params">int</span> <span class="hljs-params">pressure</span>)</span>;<br><br><span class="hljs-comment">//发现不能画线，修改 ts_read</span><br><span class="hljs-comment">//我们需要判断触摸笔是按下还是松开，需要添加压力值参数</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 读TS原始数据, 转换为LCD坐标</span><br><span class="hljs-comment"> * 我们需要加上压力值lcd_pressure</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">int</span> ts<span class="hljs-constructor">_read(<span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">lcd_x</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">lcd_y</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">lcd_pressure</span>)</span><br>&#123;<br>        <span class="hljs-built_in">int</span> ts_x, ts_y, ts_pressure;<br>        <span class="hljs-built_in">int</span> tmp_x, tmp_y;<br>    <span class="hljs-comment">//添加压力值参数        </span><br>        ts<span class="hljs-constructor">_read_raw(&amp;<span class="hljs-params">ts_x</span>, &amp;<span class="hljs-params">ts_y</span>, &amp;<span class="hljs-params">ts_pressure</span>)</span>;<br><br>        <span class="hljs-keyword">if</span> (g_ts_xy_swap)<br>        &#123;<br>                swap<span class="hljs-constructor">_xy(&amp;<span class="hljs-params">ts_x</span>, &amp;<span class="hljs-params">ts_y</span>)</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/* 使用公式计算 */</span><br>        tmp_x = g_kx<span class="hljs-operator"> * </span>(ts_x - g_ts_xc) + g_lcd_xc;<br>        tmp_y = g_ky<span class="hljs-operator"> * </span>(ts_y - g_ts_yc) + g_lcd_yc;<br><br>    <span class="hljs-comment">//如果值超出了LCD范围返回-1</span><br>        <span class="hljs-keyword">if</span> (tmp_x &lt; <span class="hljs-number">0</span><span class="hljs-operator"> || </span>tmp_x &gt;= xres<span class="hljs-operator"> || </span>tmp_y &lt; <span class="hljs-number">0</span><span class="hljs-operator"> || </span>tmp_y &gt;= yres)<br>                return -<span class="hljs-number">1</span>;<br>        <br>        *lcd_x = tmp_x;<br>        *lcd_y = tmp_y;<br>    <span class="hljs-comment">//压力值等于全局变量ts_pressure</span><br>        *lcd_pressure = ts_pressure;<br>        return <span class="hljs-number">0</span>;<br>&#125;<br><br>void ts<span class="hljs-constructor">_read_raw(<span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">px</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">py</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">ppressure</span>)</span><br>&#123;<br>        <span class="hljs-keyword">while</span> (g_ts_data_valid<span class="hljs-operator"> == </span><span class="hljs-number">0</span>);<br>        *px = g_ts_x;<br>        *py = g_ts_y;<br>        *ppressure = g_ts_pressure;<br>        g_ts_data_valid = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//我们需要report上报压力值数据</span><br>void report<span class="hljs-constructor">_ts_xy(<span class="hljs-params">int</span> <span class="hljs-params">x</span>, <span class="hljs-params">int</span> <span class="hljs-params">y</span>, <span class="hljs-params">int</span> <span class="hljs-params">pressure</span>)</span><br>&#123;<br>        <span class="hljs-comment">//printf(&quot;x = %08d, y = %08d\n\r&quot;, x, y);</span><br><br>        <span class="hljs-keyword">if</span> (g_ts_data_valid<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)<br>        &#123;<br>                g_ts_x = x;<br>                g_ts_y = y;<br>                g_ts_pressure = pressure;<br>                g_ts_data_valid = <span class="hljs-number">1</span>;<br>        &#125;<br>&#125;<br><br>void <span class="hljs-constructor">Isr_Tc(<span class="hljs-params">void</span>)</span><br>&#123;<br>        <span class="hljs-comment">//printf(&quot;ADCUPDN = 0x%x, ADCDAT0 = 0x%x, ADCDAT1 = 0x%x, ADCTSC = 0x%x\n\r&quot;, ADCUPDN, ADCDAT0, ADCDAT1, ADCTSC);</span><br>        <br>        <span class="hljs-keyword">if</span> (ADCDAT0 &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>))<br>        &#123;<br>                <span class="hljs-comment">//printf(&quot;pen up\n\r&quot;);</span><br><br>                enter<span class="hljs-constructor">_wait_pen_down_mode()</span>;<br>            <span class="hljs-comment">//如果松开就上报数据xy坐标00 压力值0</span><br>                report<span class="hljs-constructor">_ts_xy(0, 0, 0)</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>   <br>        &#123;<br>                <span class="hljs-comment">//printf(&quot;pen down\n\r&quot;);</span><br><br>                <span class="hljs-comment">/* 进入&quot;自动测量&quot;模式 */</span><br>                enter<span class="hljs-constructor">_auto_measure_mode()</span>;<br><br>                <span class="hljs-comment">/* 启动ADC */</span><br>                ADCCON <span class="hljs-pattern-match">|= (1&lt;&lt;0);</span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match">&#125;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">void <span class="hljs-constructor">Isr_Adc(<span class="hljs-params">void</span>)</span></span><br><span class="hljs-pattern-match">&#123;</span><br><span class="hljs-pattern-match">        <span class="hljs-built_in">int</span> x = <span class="hljs-constructor">ADCDAT0</span>;</span><br><span class="hljs-pattern-match">        <span class="hljs-built_in">int</span> y = <span class="hljs-constructor">ADCDAT1</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">        static <span class="hljs-built_in">int</span> adc<span class="hljs-constructor">_cnt</span> = 0;</span><br><span class="hljs-pattern-match">        static <span class="hljs-built_in">int</span> adc<span class="hljs-constructor">_x</span> = 0;</span><br><span class="hljs-pattern-match">        static <span class="hljs-built_in">int</span> adc<span class="hljs-constructor">_y</span> = 0;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">        <span class="hljs-keyword">if</span> (!(x &amp; (1&lt;&lt;15))) <span class="hljs-operator">/</span><span class="hljs-operator">*</span> 如果仍然按下才打印 <span class="hljs-operator">*</span><span class="hljs-operator">/</span></span><br><span class="hljs-pattern-match">        &#123;</span><br><span class="hljs-pattern-match">#<span class="hljs-keyword">if</span> 0                      </span><br><span class="hljs-pattern-match">            x &amp;= 0x3ff;          </span><br><span class="hljs-pattern-match">            y &amp;= 0x3ff;</span><br><span class="hljs-pattern-match">                    </span><br><span class="hljs-pattern-match">            <span class="hljs-operator">/</span><span class="hljs-operator">/</span>printf(&quot;x = %08d, y = %08d\n\r&quot;, x, y);</span><br><span class="hljs-pattern-match">        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>当我得到触电数据以后，如果当前仍是按下状态，会上报<span class="hljs-constructor">XY</span>坐标值并且上报压力值，压力值等于1          </span><br><span class="hljs-pattern-match">            report<span class="hljs-constructor">_ts_xy(<span class="hljs-params">x</span>, <span class="hljs-params">y</span>, 1)</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">          <span class="hljs-operator">/</span><span class="hljs-operator">*</span> 启动定时器以再次读取数据 <span class="hljs-operator">*</span><span class="hljs-operator">/</span>          </span><br><span class="hljs-pattern-match">            ts<span class="hljs-constructor">_timer_enable()</span>;</span><br><span class="hljs-pattern-match">#endif</span><br><span class="hljs-pattern-match">        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>防止数据在最后出现很大的误差</span><br><span class="hljs-pattern-match">                <span class="hljs-operator">/</span><span class="hljs-operator">*</span> 第1次启动<span class="hljs-constructor">ADC</span>后:          </span><br><span class="hljs-pattern-match">                 <span class="hljs-operator">*</span>   a. 要连续启动<span class="hljs-constructor">N</span>次, 获得<span class="hljs-constructor">N</span>个数据, 求平均值并上报          </span><br><span class="hljs-pattern-match">                 <span class="hljs-operator">*</span>   b. 得到<span class="hljs-constructor">N</span>次数据后, 再启动<span class="hljs-constructor">TIMER</span>           </span><br><span class="hljs-pattern-match">                 <span class="hljs-operator">*</span><span class="hljs-operator">/</span></span><br><span class="hljs-pattern-match">        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>我们直接累加</span><br><span class="hljs-pattern-match">                adc<span class="hljs-constructor">_x</span> += (x &amp; 0x3ff);</span><br><span class="hljs-pattern-match">                adc<span class="hljs-constructor">_y</span> += (y &amp; 0x3ff);</span><br><span class="hljs-pattern-match">                adc<span class="hljs-constructor">_cnt</span><span class="hljs-operator">++</span>;</span><br><span class="hljs-pattern-match">        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>我们取16的话右移4位比较容易操作</span><br><span class="hljs-pattern-match">                <span class="hljs-keyword">if</span> (adc<span class="hljs-constructor">_cnt</span> <span class="hljs-operator">==</span> 16)</span><br><span class="hljs-pattern-match">                &#123;</span><br><span class="hljs-pattern-match">        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>右移4位</span><br><span class="hljs-pattern-match">                        adc<span class="hljs-constructor">_x</span> &gt;&gt;= 4;</span><br><span class="hljs-pattern-match">                        adc<span class="hljs-constructor">_y</span> &gt;&gt;= 4;</span><br><span class="hljs-pattern-match">        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>上报</span><br><span class="hljs-pattern-match">                        report<span class="hljs-constructor">_ts_xy(<span class="hljs-params">adc_x</span>, <span class="hljs-params">adc_y</span>, 1)</span>;</span><br><span class="hljs-pattern-match">        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>恢复到初始值0</span><br><span class="hljs-pattern-match">                        adc<span class="hljs-constructor">_cnt</span> = 0;</span><br><span class="hljs-pattern-match">                        adc<span class="hljs-constructor">_x</span> = 0;</span><br><span class="hljs-pattern-match">                        adc<span class="hljs-constructor">_y</span> = 0;</span><br><span class="hljs-pattern-match">                        </span><br><span class="hljs-pattern-match">                        <span class="hljs-operator">/</span><span class="hljs-operator">*</span> 启动定时器以再次读取数据 <span class="hljs-operator">*</span><span class="hljs-operator">/</span></span><br><span class="hljs-pattern-match">                        ts<span class="hljs-constructor">_timer_enable()</span>;</span><br><span class="hljs-pattern-match">                &#125;</span><br><span class="hljs-pattern-match">                <span class="hljs-keyword">else</span></span><br><span class="hljs-pattern-match">                &#123;</span><br><span class="hljs-pattern-match">                        <span class="hljs-operator">/</span><span class="hljs-operator">*</span> 否则再次启动<span class="hljs-constructor">ADC</span> <span class="hljs-operator">*</span><span class="hljs-operator">/</span></span><br><span class="hljs-pattern-match">                        <span class="hljs-operator">/</span><span class="hljs-operator">*</span> 进入&quot;自动测量&quot;模式 <span class="hljs-operator">*</span><span class="hljs-operator">/</span></span><br><span class="hljs-pattern-match">                        enter<span class="hljs-constructor">_auto_measure_mode()</span>;</span><br><span class="hljs-pattern-match">                        </span><br><span class="hljs-pattern-match">                        <span class="hljs-operator">/</span><span class="hljs-operator">*</span> 启动<span class="hljs-constructor">ADC</span> <span class="hljs-operator">*</span><span class="hljs-operator">/</span></span><br><span class="hljs-pattern-match">                        <span class="hljs-constructor">ADCCON</span> |= (1&lt;&lt;0);</span><br><span class="hljs-pattern-match">                &#125;</span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match">        <span class="hljs-keyword">else</span></span><br><span class="hljs-pattern-match">        &#123;</span><br><span class="hljs-pattern-match">                adc<span class="hljs-constructor">_cnt</span> = 0;</span><br><span class="hljs-pattern-match">                adc<span class="hljs-constructor">_x</span> = 0;</span><br><span class="hljs-pattern-match">                adc<span class="hljs-constructor">_y</span> = 0;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">                ts<span class="hljs-constructor">_timer_disable()</span>;</span><br><span class="hljs-pattern-match">                enter<span class="hljs-constructor">_wait_pen_down_mode()</span>;</span><br><span class="hljs-pattern-match">        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>如果数据转换完之前再次松开，这里我也会上报数据，0，0，0</span><br><span class="hljs-pattern-match">                report<span class="hljs-constructor">_ts_xy(0, 0, 0)</span>;</span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match">        enter<span class="hljs-constructor">_wait_pen_up_mode()</span>;</span><br><span class="hljs-pattern-match">&#125;</span><br></code></pre></td></tr></table></figure><p>那么我们的tslib.c中</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void get<span class="hljs-constructor">_calibrate_point_data(<span class="hljs-params">int</span> <span class="hljs-params">lcd_x</span>, <span class="hljs-params">int</span> <span class="hljs-params">lcd_y</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">px</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">py</span>)</span><br>&#123;<br>        <span class="hljs-built_in">int</span> pressure;<br>        <span class="hljs-built_in">int</span> x, y;<br>        <br>        fb<span class="hljs-constructor">_disp_cross(<span class="hljs-params">lcd_x</span>, <span class="hljs-params">lcd_y</span>, 0xffffff)</span>;<br><br>        <span class="hljs-comment">/* 等待点击 */</span><br><br>        <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">//读取ts坐标值也加上压力值</span><br>                ts<span class="hljs-constructor">_read_raw(&amp;<span class="hljs-params">x</span>, &amp;<span class="hljs-params">y</span>, &amp;<span class="hljs-params">pressure</span>)</span>;<br>    <span class="hljs-comment">//直到压力等于0的时候才返回</span><br>        &#125; <span class="hljs-keyword">while</span> (pressure<span class="hljs-operator"> == </span><span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">do</span> &#123;<br>                *px = x;<br>                *py = y;<br>    <span class="hljs-comment">//压力值存在的情况下表示按下状态，就一直读取数据</span><br>                ts<span class="hljs-constructor">_read_raw(&amp;<span class="hljs-params">x</span>, &amp;<span class="hljs-params">y</span>, &amp;<span class="hljs-params">pressure</span>)</span>;<br>                printf(<span class="hljs-string">&quot;get raw data: x = %08d, y = %08d\n\r&quot;</span>, x, y);<br>        &#125; <span class="hljs-keyword">while</span> (pressure);<br>    <span class="hljs-comment">//打印坐标值</span><br>        printf(<span class="hljs-string">&quot;return raw data: x = %08d, y = %08d\n\r&quot;</span>, *px, *py);<br><br>        <span class="hljs-comment">/* 直到松开才返回 */</span><br>    <span class="hljs-comment">//我们操作完成后消除 +  </span><br>        fb<span class="hljs-constructor">_disp_cross(<span class="hljs-params">lcd_x</span>, <span class="hljs-params">lcd_y</span>, 0)</span>;<br>&#125;<br><br><span class="hljs-comment">//我们确定校准为什么不对，我们校准涉及 原始数据 校准公式</span><br><br><span class="hljs-comment">//我们把公式使用函数来表示int get_lcd_x_frm_ts_x(int ts_x)</span><br>&#123;<br>        return g_kx<span class="hljs-operator"> * </span>(ts_x - g_ts_xc) + g_lcd_xc;<br>&#125;<br><br><span class="hljs-built_in">int</span> get<span class="hljs-constructor">_lcd_y_frm_ts_y(<span class="hljs-params">int</span> <span class="hljs-params">ts_y</span>)</span><br>&#123;<br>        return g_ky<span class="hljs-operator"> * </span>(ts_y - g_ts_yc) + g_lcd_yc;<br>&#125;<br><br>void ts<span class="hljs-constructor">_calibrate(<span class="hljs-params">void</span>)</span><br>&#123;<br>        <span class="hljs-built_in">int</span> a_ts_x, a_ts_y;<br>        <span class="hljs-built_in">int</span> b_ts_x, b_ts_y;<br>        <span class="hljs-built_in">int</span> c_ts_x, c_ts_y;<br>        <span class="hljs-built_in">int</span> d_ts_x, d_ts_y;<br>        <span class="hljs-built_in">int</span> e_ts_x, e_ts_y;<br><br>        <span class="hljs-comment">/* X轴方向 */</span><br>        <span class="hljs-built_in">int</span> ts_s1, ts_s2;<br>        <span class="hljs-built_in">int</span> lcd_s;<br><br>        <span class="hljs-comment">/* Y轴方向 */</span><br>        <span class="hljs-built_in">int</span> ts_d1, ts_d2;<br>        <span class="hljs-built_in">int</span> lcd_d;<br><br>        <span class="hljs-comment">/* 获得LCD的参数: fb_base, xres, yres, bpp */</span><br>        get<span class="hljs-constructor">_lcd_params(&amp;<span class="hljs-params">fb_base</span>, &amp;<span class="hljs-params">xres</span>, &amp;<span class="hljs-params">yres</span>, &amp;<span class="hljs-params">bpp</span>)</span>;<br><br>        <span class="hljs-comment">/* 对于ABCDE, 循环: 显示&quot;+&quot;、点击、读ts原始值 */</span><br>        <span class="hljs-comment">/* A(50, 50) */</span><br>        get<span class="hljs-constructor">_calibrate_point_data(50, 50, &amp;<span class="hljs-params">a_ts_x</span>, &amp;<span class="hljs-params">a_ts_y</span>)</span>; <br>  <br>        <span class="hljs-comment">/* B(xres-50, 50) */</span><br>        get<span class="hljs-constructor">_calibrate_point_data(<span class="hljs-params">xres</span>-50, 50, &amp;<span class="hljs-params">b_ts_x</span>, &amp;<span class="hljs-params">b_ts_y</span>)</span>;<br><br>        <span class="hljs-comment">/* C(xres-50, yres-50) */</span><br>        get<span class="hljs-constructor">_calibrate_point_data(<span class="hljs-params">xres</span>-50, <span class="hljs-params">yres</span>-50, &amp;<span class="hljs-params">c_ts_x</span>, &amp;<span class="hljs-params">c_ts_y</span>)</span>;<br><br>        <span class="hljs-comment">/* D(50, yres-50) */</span><br>        get<span class="hljs-constructor">_calibrate_point_data(50, <span class="hljs-params">yres</span>-50, &amp;<span class="hljs-params">d_ts_x</span>, &amp;<span class="hljs-params">d_ts_y</span>)</span>;<br>        <br>        <span class="hljs-comment">/* E(xres/2, yres/2) */</span><br>        get<span class="hljs-constructor">_calibrate_point_data(<span class="hljs-params">xres</span><span class="hljs-operator">/</span>2, <span class="hljs-params">yres</span><span class="hljs-operator">/</span>2, &amp;<span class="hljs-params">e_ts_x</span>, &amp;<span class="hljs-params">e_ts_y</span>)</span>;<br><br>        <span class="hljs-comment">/* 确定触摸屏数据XY是否反转 */</span><br>        g_ts_xy_swap = is<span class="hljs-constructor">_ts_xy_swap(<span class="hljs-params">a_ts_x</span>, <span class="hljs-params">a_ts_y</span>, <span class="hljs-params">b_ts_x</span>, <span class="hljs-params">b_ts_y</span>)</span>;<br><br>        <span class="hljs-keyword">if</span> (g_ts_xy_swap)<br>        &#123;<br>                <span class="hljs-comment">/* 对调所有点的XY坐标 */</span><br>                swap<span class="hljs-constructor">_xy(&amp;<span class="hljs-params">a_ts_x</span>, &amp;<span class="hljs-params">a_ts_y</span>)</span>;<br>                swap<span class="hljs-constructor">_xy(&amp;<span class="hljs-params">b_ts_x</span>, &amp;<span class="hljs-params">b_ts_y</span>)</span>;<br>                swap<span class="hljs-constructor">_xy(&amp;<span class="hljs-params">c_ts_x</span>, &amp;<span class="hljs-params">c_ts_y</span>)</span>;<br>                swap<span class="hljs-constructor">_xy(&amp;<span class="hljs-params">d_ts_x</span>, &amp;<span class="hljs-params">d_ts_y</span>)</span>;<br>                swap<span class="hljs-constructor">_xy(&amp;<span class="hljs-params">e_ts_x</span>, &amp;<span class="hljs-params">e_ts_y</span>)</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/* 确定公式的参数并保存 */</span><br>        ts_s1 = b_ts_x - a_ts_x;<br>        ts_s2 = c_ts_x - d_ts_x;<br>        lcd_s = xres-<span class="hljs-number">50</span> - <span class="hljs-number">50</span>;<br><br>        ts_d1 = d_ts_y - a_ts_y;<br>        ts_d2 = c_ts_y - b_ts_y;<br>        lcd_d = yres-<span class="hljs-number">50</span>-<span class="hljs-number">50</span>;<br><br>        g_kx = ((double)(<span class="hljs-number">2</span>*lcd_s))<span class="hljs-operator"> / </span>(ts_s1 + ts_s2);<br>        g_ky = ((double)(<span class="hljs-number">2</span>*lcd_d))<span class="hljs-operator"> / </span>(ts_d1 + ts_d2);<br><br>        g_ts_xc = e_ts_x;<br>        g_ts_yc = e_ts_y;<br><br>        g_lcd_xc = xres/<span class="hljs-number">2</span>;<br>        g_lcd_yc = yres/<span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//打印ABCDE的坐标值</span><br>        printf(<span class="hljs-string">&quot;A lcd_x = %08d, lcd_y = %08d\n\r&quot;</span>, get<span class="hljs-constructor">_lcd_x_frm_ts_x(<span class="hljs-params">a_ts_x</span>)</span>, get<span class="hljs-constructor">_lcd_y_frm_ts_y(<span class="hljs-params">a_ts_y</span>)</span>);<br>        printf(<span class="hljs-string">&quot;B lcd_x = %08d, lcd_y = %08d\n\r&quot;</span>, get<span class="hljs-constructor">_lcd_x_frm_ts_x(<span class="hljs-params">b_ts_x</span>)</span>, get<span class="hljs-constructor">_lcd_y_frm_ts_y(<span class="hljs-params">b_ts_y</span>)</span>);<br>        printf(<span class="hljs-string">&quot;C lcd_x = %08d, lcd_y = %08d\n\r&quot;</span>, get<span class="hljs-constructor">_lcd_x_frm_ts_x(<span class="hljs-params">c_ts_x</span>)</span>, get<span class="hljs-constructor">_lcd_y_frm_ts_y(<span class="hljs-params">c_ts_y</span>)</span>);<br>        printf(<span class="hljs-string">&quot;D lcd_x = %08d, lcd_y = %08d\n\r&quot;</span>, get<span class="hljs-constructor">_lcd_x_frm_ts_x(<span class="hljs-params">d_ts_x</span>)</span>, get<span class="hljs-constructor">_lcd_y_frm_ts_y(<span class="hljs-params">d_ts_y</span>)</span>);<br>        printf(<span class="hljs-string">&quot;E lcd_x = %08d, lcd_y = %08d\n\r&quot;</span>, get<span class="hljs-constructor">_lcd_x_frm_ts_x(<span class="hljs-params">e_ts_x</span>)</span>, get<span class="hljs-constructor">_lcd_y_frm_ts_y(<span class="hljs-params">e_ts_y</span>)</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>我们转换出的XY坐标值不是特别稳定</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* 每10ms该函数被调用一次 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">touchscreen_timer_irq</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>        <span class="hljs-comment">/* 如果触摸屏仍被按下, 进入&quot;自动测量模式&quot;, 启动ADC */</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">get_status_of_ts_timer</span>() == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">ADCDAT0</span> &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>)) <span class="hljs-comment">/* 如果松开 */</span><br>        &#123;<br>                <span class="hljs-title function_">ts_timer_disable</span>();<br>                <span class="hljs-title function_">enter_wait_pen_down_mode</span>();<br>                <span class="hljs-comment">//report_ts_xy(0, 0, 0);</span><br>                <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 按下状态 */</span><br>        &#123;<br>                <span class="hljs-comment">/* 进入&quot;自动测量&quot;模式 */</span><br>                <span class="hljs-title function_">enter_auto_measure_mode</span>();<br><br>                <span class="hljs-comment">/* 启动ADC */</span><br>                <span class="hljs-variable constant_">ADCCON</span> |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>修改touchscreen-test.c文件</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void touchscreen<span class="hljs-constructor">_test(<span class="hljs-params">void</span>)</span><br>&#123;<br>        unsigned <span class="hljs-built_in">int</span> fb_base;<br>        <span class="hljs-built_in">int</span> xres, yres, bpp;<br><br>        <span class="hljs-built_in">int</span> x, y, pressure;<br><br>        <span class="hljs-comment">/* 获得LCD的参数: fb_base, xres, yres, bpp */</span><br>        get<span class="hljs-constructor">_lcd_params(&amp;<span class="hljs-params">fb_base</span>, &amp;<span class="hljs-params">xres</span>, &amp;<span class="hljs-params">yres</span>, &amp;<span class="hljs-params">bpp</span>)</span>;<br><br>        touchscreen<span class="hljs-constructor">_init()</span>;<br><br>        <span class="hljs-comment">/* 清屏 */</span><br>        clear<span class="hljs-constructor">_screen(0)</span>;<br><br>        <span class="hljs-comment">/* 显示文字提示较准 */</span><br>        fb<span class="hljs-constructor">_print_string(70, 70, <span class="hljs-string">&quot;Touc cross to calibrate touchscreen&quot;</span>, 0xffffff)</span>;<br>        ts<span class="hljs-constructor">_calibrate()</span>;<br><br>        <span class="hljs-comment">/* 显示文字提示绘画 */</span><br>        fb<span class="hljs-constructor">_print_string(70, <span class="hljs-params">yres</span> - 70, <span class="hljs-string">&quot;OK! To draw!&quot;</span>, 0xffffff)</span>;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        &#123;<br>    <span class="hljs-comment">//如果结果=0则继续执行下面操作</span><br>                <span class="hljs-keyword">if</span> (ts<span class="hljs-constructor">_read(&amp;<span class="hljs-params">x</span>, &amp;<span class="hljs-params">y</span>, &amp;<span class="hljs-params">pressure</span>)</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span>)<br>                &#123;<br>                        printf(<span class="hljs-string">&quot; x = %d, y = %d\n\r&quot;</span>, x, y);<br>    <span class="hljs-comment">//如果是按下状态，才会描点</span><br>                        <span class="hljs-keyword">if</span> (pressure)<br>                        &#123;<br>                                fb<span class="hljs-constructor">_put_pixel(<span class="hljs-params">x</span>, <span class="hljs-params">y</span>, 0xff00)</span>;<br>                        &#125;<br>                &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>把LCD的电压值，成功转化成屏幕的坐标 要点</p><p>1). 对于触摸屏要多次测量，求平均值</p><p>2). 要丢弃非法值（以LCD分辨率作为判断标准）</p><p>3). 校准时一定要点准</p><p>参考tslib库，</p><p><strong>第012节_触摸屏编程_完善</strong></p><hr><ul><li>我们触摸屏校准虽然可以正常运行，但是有些问题，比如在触摸屏上点一个点，同时屏幕上面会显示另一个点,我们按住屏幕不动的同时将其转换成LCD坐标并且描点，就表明数值不大稳定</li></ul><p>问题</p><ol><li>我们第一次点击触摸屏会出现两个点</li><li>长按，LCD上的点会越来越大</li></ol><ul><li>根源在于我们得到的LCD坐标值不稳定，根源ADC转换出来的xy坐标值不稳定</li></ul><p><img src="/image/700px-Chapter18_lesson12_001.jpg" alt="700px-Chapter18_lesson12_001.jpg"></p><p>我们打开touchscreen.c问题出现在这里面</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-comment">#include &quot;../s3c2440_soc.h&quot;</span><br><span class="hljs-comment">#define ADC_INT_BIT (10)</span><br><span class="hljs-comment">#define TC_INT_BIT  (9)</span><br><span class="hljs-comment">#define INT_ADC_TC   (31)</span><br><br><span class="hljs-comment">/* ADCTSC&#x27;s bits */</span><br><span class="hljs-comment">#define WAIT_PEN_DOWN    (0&lt;&lt;8)</span><br><span class="hljs-comment">#define WAIT_PEN_UP      (1&lt;&lt;8)</span><br><span class="hljs-comment">#define YM_ENABLE        (1&lt;&lt;7)</span><br><span class="hljs-comment">#define YM_DISABLE       (0&lt;&lt;7)</span><br><span class="hljs-comment">#define YP_ENABLE        (0&lt;&lt;6)</span><br><span class="hljs-comment">#define YP_DISABLE       (1&lt;&lt;6)</span><br><span class="hljs-comment">#define XM_ENABLE        (1&lt;&lt;5)</span><br><span class="hljs-comment">#define XM_DISABLE       (0&lt;&lt;5)</span><br><span class="hljs-comment">#define XP_ENABLE        (0&lt;&lt;4)</span><br><span class="hljs-comment">#define XP_DISABLE       (1&lt;&lt;4)</span><br><span class="hljs-comment">#define PULLUP_ENABLE    (0&lt;&lt;3)</span><br><span class="hljs-comment">#define PULLUP_DISABLE   (1&lt;&lt;3)</span><br><span class="hljs-comment">#define AUTO_PST         (1&lt;&lt;2)</span><br><span class="hljs-comment">#define WAIT_INT_MODE    (3)</span><br><span class="hljs-comment">#define NO_OPR_MODE      (0)</span><br><br><span class="hljs-keyword">static</span> <span class="hljs-variable">volatile</span> int <span class="hljs-variable">g_ts_timer_enable</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> int <span class="hljs-variable">g_ts_x</span>;<span class="hljs-keyword">static</span> int <span class="hljs-variable">g_ts_y</span>;<br><span class="hljs-keyword">static</span> int <span class="hljs-variable">g_ts_pressure</span>;<br><span class="hljs-keyword">static</span> int <span class="hljs-variable">g_ts_data_valid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//定义测试数据16</span><br><span class="hljs-keyword">static</span> int <span class="hljs-variable">test_x_array</span>[<span class="hljs-number">16</span>];<br><span class="hljs-keyword">static</span> int <span class="hljs-variable">test_y_array</span>[<span class="hljs-number">16</span>];<br><br><span class="hljs-variable">void</span> <span class="hljs-title function_">report_ts_xy</span>(int <span class="hljs-variable">x</span>, int <span class="hljs-variable">y</span>, int <span class="hljs-variable">pressure</span>);<br><br><span class="hljs-variable">void</span> <span class="hljs-title function_">enter_wait_pen_down_mode</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-variable">ADCTSC</span> <span class="hljs-operator">=</span> <span class="hljs-variable">WAIT_PEN_DOWN</span> <span class="hljs-operator">|</span> <span class="hljs-variable">PULLUP_ENABLE</span> <span class="hljs-operator">|</span> <span class="hljs-variable">YM_ENABLE</span> <span class="hljs-operator">|</span> <span class="hljs-variable">YP_DISABLE</span> <span class="hljs-operator">|</span> <span class="hljs-variable">XP_DISABLE</span> <span class="hljs-operator">|</span> <span class="hljs-variable">XM_DISABLE</span> <span class="hljs-operator">|</span> <span class="hljs-variable">WAIT_INT_MODE</span>;<br>&#125;<br><br><span class="hljs-variable">void</span> <span class="hljs-title function_">enter_wait_pen_up_mode</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-variable">ADCTSC</span> <span class="hljs-operator">=</span> <span class="hljs-variable">WAIT_PEN_UP</span> <span class="hljs-operator">|</span> <span class="hljs-variable">PULLUP_ENABLE</span> <span class="hljs-operator">|</span> <span class="hljs-variable">YM_ENABLE</span> <span class="hljs-operator">|</span> <span class="hljs-variable">YP_DISABLE</span> <span class="hljs-operator">|</span> <span class="hljs-variable">XP_DISABLE</span> <span class="hljs-operator">|</span> <span class="hljs-variable">XM_DISABLE</span> <span class="hljs-operator">|</span> <span class="hljs-variable">WAIT_INT_MODE</span>;<br>&#125;<br><br><span class="hljs-variable">void</span> <span class="hljs-title function_">enter_auto_measure_mode</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-variable">ADCTSC</span> <span class="hljs-operator">=</span> <span class="hljs-variable">AUTO_PST</span> <span class="hljs-operator">|</span> <span class="hljs-variable">NO_OPR_MODE</span>;<br>&#125;<br><br>int <span class="hljs-title function_">is_in_auto_mode</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">ADCTSC</span> <span class="hljs-operator">&amp;</span> <span class="hljs-variable">AUTO_PST</span>;<br>&#125;<br><br><span class="hljs-variable">void</span> <span class="hljs-title class_">Isr</span>_Tc(<span class="hljs-variable">void</span>)<br>&#123;<br>        <span class="hljs-comment">//printf(&quot;ADCUPDN = 0x%x, ADCDAT0 = 0x%x, ADCDAT1 = 0x%x, ADCTSC = 0x%x\n\r&quot;, ADCUPDN, ADCDAT0, ADCDAT1, ADCTSC);</span><br>        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">ADCDAT0</span> <span class="hljs-operator">&amp;</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">15</span>))<br>        &#123;<br>    <span class="hljs-comment">//按下状态启用触摸屏</span><br>    <span class="hljs-comment">//启动测量模式，转换结束产生adc中断</span><br>                <span class="hljs-comment">//printf(&quot;pen up\n\r&quot;);</span><br>                <span class="hljs-title function_">enter_wait_pen_down_mode</span>();<br>                <span class="hljs-title function_">report_ts_xy</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>   <br>        &#123;<br>                <span class="hljs-comment">//printf(&quot;pen down\n\r&quot;);</span><br><br>                <span class="hljs-comment">/* 进入&quot;自动测量&quot;模式 */</span><br>                <span class="hljs-title function_">enter_auto_measure_mode</span>();<br><br>                <span class="hljs-comment">/* 启动ADC */</span><br>                <span class="hljs-variable">ADCCON</span> <span class="hljs-operator">|</span><span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">0</span>);<br>        &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-variable">void</span> <span class="hljs-title function_">ts_timer_enable</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-variable">g_ts_timer_enable</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-variable">void</span> <span class="hljs-title function_">ts_timer_disable</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-variable">g_ts_timer_enable</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">static</span> int <span class="hljs-title function_">get_status_of_ts_timer</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">g_ts_timer_enable</span>;<br>&#125;<br><br><span class="hljs-variable">void</span> <span class="hljs-title function_">report_ts_xy</span>(<span class="hljs-params">int</span> <span class="hljs-params">x</span>, <span class="hljs-params">int</span> <span class="hljs-params">y</span>, <span class="hljs-params">int</span> <span class="hljs-params">pressure</span>)<br>&#123;<br>        <span class="hljs-comment">//printf(&quot;x = %08d, y = %08d\n\r&quot;, x, y);</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">g_ts_data_valid</span> <span class="hljs-operator">==</span> <span class="hljs-number">0</span>)<br>        &#123;<br>                <span class="hljs-variable">g_ts_x</span> <span class="hljs-operator">=</span> <span class="hljs-variable">x</span>;<br>                <span class="hljs-variable">g_ts_y</span> <span class="hljs-operator">=</span> <span class="hljs-variable">y</span>;<br>                <span class="hljs-variable">g_ts_pressure</span> <span class="hljs-operator">=</span> <span class="hljs-variable">pressure</span>;<br>                <span class="hljs-variable">g_ts_data_valid</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        &#125;<br>&#125;<br><br><span class="hljs-variable">void</span> <span class="hljs-title function_">ts_read_raw</span>(<span class="hljs-params">int</span> *<span class="hljs-params">px</span>, <span class="hljs-params">int</span> *<span class="hljs-params">py</span>, <span class="hljs-params">int</span> *<span class="hljs-params">ppressure</span>)<br>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-variable">g_ts_data_valid</span> <span class="hljs-operator">==</span> <span class="hljs-number">0</span>);<br>        <span class="hljs-operator">*</span><span class="hljs-variable">px</span> <span class="hljs-operator">=</span> <span class="hljs-variable">g_ts_x</span>;<br>        <span class="hljs-operator">*</span><span class="hljs-variable">py</span> <span class="hljs-operator">=</span> <span class="hljs-variable">g_ts_y</span>;<br>        <span class="hljs-operator">*</span><span class="hljs-variable">ppressure</span> <span class="hljs-operator">=</span> <span class="hljs-variable">g_ts_pressure</span>;<br>        <span class="hljs-variable">g_ts_data_valid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 每10ms该函数被调用一次 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-variable">void</span> <span class="hljs-title function_">touchscreen_timer_irq</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-comment">/* 如果触摸屏仍被按下, 进入&quot;自动测量模式&quot;, 启动ADC */</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">get_status_of_ts_timer</span>() <span class="hljs-operator">==</span> <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">is_in_auto_mode</span>())<br>                <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">/* 只有在&quot;等待中断模式&quot;下才可以使用ADCDAT0&#x27;BIT 15来判断触摸笔状态 */</span><br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">ADCDAT0</span> <span class="hljs-operator">&amp;</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">15</span>)) <span class="hljs-comment">/* 如果松开 */</span><br>        &#123;<br>                <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;timer set pen down<span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span>&quot;</span>);<br>                <span class="hljs-title function_">ts_timer_disable</span>();<br>                <span class="hljs-title function_">enter_wait_pen_down_mode</span>();<br>                <span class="hljs-title function_">report_ts_xy</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 按下状态 */</span><br>        &#123;<br>                <span class="hljs-comment">/* 进入&quot;自动测量&quot;模式 */</span><br>                <span class="hljs-title function_">enter_auto_measure_mode</span>();<br><br>                <span class="hljs-comment">/* 启动ADC */</span><br>                <span class="hljs-variable">ADCCON</span> <span class="hljs-operator">|</span><span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">0</span>);<br>        &#125;<br>&#125;<br><br><span class="hljs-variable">void</span> <span class="hljs-title class_">Isr</span>_Adc(<span class="hljs-variable">void</span>)<br>&#123;<br>        int <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-variable">ADCDAT0</span>;<br>        int <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-variable">ADCDAT1</span>;<br><br>        <span class="hljs-keyword">static</span> int <span class="hljs-variable">adc_cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">static</span> int <span class="hljs-variable">adc_x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">static</span> int <span class="hljs-variable">adc_y</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">/* 进入ADC中断时, TS处于&quot;自动测量模式&quot; */</span><br><br>        <span class="hljs-comment">/* 只有在&quot;等待中断模式&quot;下才可以使用ADCDAT0&#x27;BIT 15来判断触摸笔状态 */</span><br><br>        <span class="hljs-title function_">enter_wait_pen_up_mode</span>();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-operator">!</span>(<span class="hljs-variable">ADCDAT0</span> <span class="hljs-operator">&amp;</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">15</span>))) <span class="hljs-comment">/* 如果仍然按下才打印 */</span><br>        &#123;<br><span class="hljs-comment">#<span class="hljs-keyword">if</span> 0                      </span><br>            <span class="hljs-variable">x</span> <span class="hljs-operator">&amp;</span><span class="hljs-operator">=</span> <span class="hljs-number">0x3ff</span>;          <br>            <span class="hljs-variable">y</span> <span class="hljs-operator">&amp;</span><span class="hljs-operator">=</span> <span class="hljs-number">0x3ff</span>;                    <br><br>            <span class="hljs-comment">//printf(&quot;x =   %08d, y = %08d\n\r&quot;, x, y);          </span><br>            <span class="hljs-title function_">report_ts_xy</span>(<span class="hljs-variable">x</span>, <span class="hljs-variable">y</span>, <span class="hljs-number">1</span>);<br><br>            <span class="hljs-comment">/* 启动定时器以再次读取数据 */</span>          <br>            <span class="hljs-title function_">ts_timer_enable</span>();<br><span class="hljs-comment">#endif</span><br>            <span class="hljs-comment">/* 第1次启动ADC后:          </span><br><span class="hljs-comment">             *   a. 要连续启动N次, 获得N个数据, 求平均值并上报          </span><br><span class="hljs-comment">             *   b. 得到N次数据后, 再启动TIMER           </span><br><span class="hljs-comment">             */</span><br>                <span class="hljs-variable">adc_x</span> <span class="hljs-operator">+</span><span class="hljs-operator">=</span> (<span class="hljs-variable">x</span> <span class="hljs-operator">&amp;</span> <span class="hljs-number">0x3ff</span>);<br>                <span class="hljs-variable">adc_y</span> <span class="hljs-operator">+</span><span class="hljs-operator">=</span> (<span class="hljs-variable">y</span> <span class="hljs-operator">&amp;</span> <span class="hljs-number">0x3ff</span>);<br>        <span class="hljs-comment">//定义一个函数把这些值打印出来</span><br>                <span class="hljs-variable">test_x_array</span>[<span class="hljs-variable">adc_cnt</span>] <span class="hljs-operator">=</span> (<span class="hljs-variable">x</span> <span class="hljs-operator">&amp;</span> <span class="hljs-number">0x3ff</span>);<br>                <span class="hljs-variable">test_y_array</span>[<span class="hljs-variable">adc_cnt</span>] <span class="hljs-operator">=</span> (<span class="hljs-variable">y</span> <span class="hljs-operator">&amp;</span> <span class="hljs-number">0x3ff</span>);<br>                <br>                <span class="hljs-variable">adc_cnt</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span>;<br><br>                <span class="hljs-keyword">if</span> (<span class="hljs-variable">adc_cnt</span> <span class="hljs-operator">==</span> <span class="hljs-number">16</span>)<br>                &#123;<br>                        <span class="hljs-variable">adc_x</span> <span class="hljs-operator">&gt;&gt;</span><span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>                        <span class="hljs-variable">adc_y</span> <span class="hljs-operator">&gt;&gt;</span><span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>                        <span class="hljs-title function_">report_ts_xy</span>(<span class="hljs-variable">adc_x</span>, <span class="hljs-variable">adc_y</span>, <span class="hljs-number">1</span>);<br>                        <span class="hljs-variable">adc_cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                        <span class="hljs-variable">adc_x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                        <span class="hljs-variable">adc_y</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                        <br>                        <span class="hljs-comment">/* 启动定时器以再次读取数据 */</span><br>                        <span class="hljs-comment">/* 先设置TS进入&quot;等待中断模式&quot; */</span><br>        <span class="hljs-comment">//有按下就会有松开</span><br>                        <span class="hljs-title function_">enter_wait_pen_up_mode</span>();<br>                        <span class="hljs-title function_">ts_timer_enable</span>();<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                        <span class="hljs-comment">/* 再次启动ADC */</span><br>                        <span class="hljs-comment">/* 进入&quot;自动测量&quot;模式 */</span><br>                        <span class="hljs-title function_">enter_auto_measure_mode</span>();<br>                        <br>                        <span class="hljs-comment">/* 启动ADC */</span><br>                        <span class="hljs-variable">ADCCON</span> <span class="hljs-operator">|</span><span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">0</span>);<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>                <span class="hljs-variable">adc_cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-variable">adc_x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-variable">adc_y</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;adc report pen down<span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span>&quot;</span>);<br>                <span class="hljs-title function_">ts_timer_disable</span>();<br>                <span class="hljs-title function_">enter_wait_pen_down_mode</span>();<br>                <span class="hljs-title function_">report_ts_xy</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-comment">//enter_wait_pen_up_mode();  /* 启动ADC时不应该进入这个模式, 它会影响数据 */&#125;</span><br><br><span class="hljs-variable">void</span> <span class="hljs-title class_">AdcTsIntHandle</span>(int <span class="hljs-variable">irq</span>)<br>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">SUBSRCPND</span> <span class="hljs-operator">&amp;</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-variable">TC_INT_BIT</span>))  <span class="hljs-comment">/* 如果是触摸屏中断 */</span><br>                <span class="hljs-title class_">Isr</span>_Tc();<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">SUBSRCPND</span> <span class="hljs-operator">&amp;</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-variable">ADC_INT_BIT</span>))  <span class="hljs-comment">/* ADC中断 */</span><br>                <span class="hljs-title class_">Isr</span>_Adc();<br>        <span class="hljs-variable">SUBSRCPND</span> <span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-variable">TC_INT_BIT</span>) <span class="hljs-operator">|</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-variable">ADC_INT_BIT</span>);<br>&#125;<br><br><span class="hljs-variable">void</span> <span class="hljs-title function_">adc_ts_int_init</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-variable">SUBSRCPND</span> <span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-variable">TC_INT_BIT</span>) <span class="hljs-operator">|</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-variable">ADC_INT_BIT</span>);<br><br>        <span class="hljs-comment">/* 注册中断处理函数 */</span><br>        <span class="hljs-title function_">register_irq</span>(<span class="hljs-number">31</span>, <span class="hljs-title class_">AdcTsIntHandle</span>);<br><br>        <span class="hljs-comment">/* 使能中断 */</span><br>        <span class="hljs-variable">INTSUBMSK</span> <span class="hljs-operator">&amp;</span><span class="hljs-operator">=</span> <span class="hljs-operator">~</span>((<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-variable">ADC_INT_BIT</span>) <span class="hljs-operator">|</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-variable">TC_INT_BIT</span>));<br>        <span class="hljs-comment">//INTMSK    &amp;= ~(1&lt;&lt;INT_ADC_TC);</span><br>&#125;<br><br><span class="hljs-variable">void</span> <span class="hljs-title function_">adc_ts_reg_init</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-comment">/* [15] : ECFLG,  1 = End of A/D conversion  </span><br><span class="hljs-comment">         * [14] : PRSCEN, 1 = A/D converter prescaler enable  </span><br><span class="hljs-comment">         * [13:6]: PRSCVL, adc clk = PCLK / (PRSCVL + 1)  </span><br><span class="hljs-comment">         * [5:3] : SEL_MUX, 000 = AIN 0  * [2]   : STDBM  </span><br><span class="hljs-comment">         * [0]   : 1 = A/D conversion starts and this bit is cleared after the startup.  </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-variable">ADCCON</span> <span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">14</span>) <span class="hljs-operator">|</span> (<span class="hljs-number">49</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">6</span>) <span class="hljs-operator">|</span> (<span class="hljs-number">0</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">/*  按下触摸屏, 延时一会再发出TC中断  </span><br><span class="hljs-comment">         *  延时时间 = ADCDLY * 晶振周期 = ADCDLY * 1 / 12000000 = 5ms  </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-variable">ADCDLY</span> <span class="hljs-operator">=</span> <span class="hljs-number">60000</span>;      <br>&#125;<br><br><span class="hljs-variable">void</span> <span class="hljs-title function_">touchscreen_init</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-comment">/* 设置触摸屏接口:寄存器 */</span><br>        <span class="hljs-title function_">adc_ts_reg_init</span>();<br><br>        <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;ADCUPDN = 0x%x, SUBSRCPND = 0x%x, SRCPND = 0x%x<span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span>&quot;</span>, <span class="hljs-variable">ADCUPDN</span>, <span class="hljs-variable">SUBSRCPND</span>, <span class="hljs-variable">SRCPND</span>);<br><br>        <span class="hljs-comment">/* 设置中断 */</span><br>        <span class="hljs-title function_">adc_ts_int_init</span>();<br><br>        <span class="hljs-comment">/* 注册定时器处理函数 */</span><br>        <span class="hljs-title function_">register_timer</span>(<span class="hljs-string">&quot;touchscreen&quot;</span>, <span class="hljs-variable">touchscreen_timer_irq</span>);<br><br>        <span class="hljs-comment">/* 让触摸屏控制器进入&quot;等待中断模式&quot; */</span><br>        <span class="hljs-title function_">enter_wait_pen_down_mode</span>();<br>&#125;<br><br><span class="hljs-comment">//打印数组定义的那些值</span><br><span class="hljs-variable">void</span> <span class="hljs-title function_">print_test_array</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        int <span class="hljs-variable">i</span>;<br><br>        <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;test array x : &quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-variable">i</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">16</span>; <span class="hljs-variable">i</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span>)<br>                <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;%08d &quot;</span>, <span class="hljs-variable">test_x_array</span>[<span class="hljs-variable">i</span>]);<br>        <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;<span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span>&quot;</span>);<br><br>        <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;test array y : &quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-variable">i</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">16</span>; <span class="hljs-variable">i</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span>)<br>                <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;%08d &quot;</span>, <span class="hljs-variable">test_y_array</span>[<span class="hljs-variable">i</span>]);<br>        <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;<span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span>&quot;</span>);<br>&#125;<br><br><span class="hljs-variable">void</span> <span class="hljs-title function_">ts_read_raw_test</span>(<span class="hljs-params">int</span> *<span class="hljs-params">px</span>, <span class="hljs-params">int</span> *<span class="hljs-params">py</span>, <span class="hljs-params">int</span> *<span class="hljs-params">ppressure</span>)<br>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-variable">g_ts_data_valid</span> <span class="hljs-operator">==</span> <span class="hljs-number">0</span>);<br>        <span class="hljs-operator">*</span><span class="hljs-variable">px</span> <span class="hljs-operator">=</span> <span class="hljs-variable">g_ts_x</span>;<br>        <span class="hljs-operator">*</span><span class="hljs-variable">py</span> <span class="hljs-operator">=</span> <span class="hljs-variable">g_ts_y</span>;<br>        <span class="hljs-operator">*</span><span class="hljs-variable">ppressure</span> <span class="hljs-operator">=</span> <span class="hljs-variable">g_ts_pressure</span>;<br>        <span class="hljs-title function_">print_test_array</span>();<br>        <span class="hljs-variable">g_ts_data_valid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>tslib.c使用了ts_read_raw函数</li></ul><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs hsp">void get_calibrate_point_data(<span class="hljs-keyword">int</span> lcd_x, <span class="hljs-keyword">int</span> lcd_y, <span class="hljs-keyword">int</span> *px, <span class="hljs-keyword">int</span> *py)<br>&#123;<br>        <span class="hljs-keyword">int</span> pressure<span class="hljs-comment">;</span><br>        <span class="hljs-keyword">int</span> x, y<span class="hljs-comment">;</span><br>        <span class="hljs-keyword">int</span> sum_x = <span class="hljs-number">0</span>, sum_y = <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>        <span class="hljs-keyword">int</span> <span class="hljs-keyword">cnt</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>        <br>        fb_disp_cross(lcd_x, lcd_y, <span class="hljs-number">0</span>xffffff)<span class="hljs-comment">;</span><br><br>        <span class="hljs-comment">/* 等待点击 */</span><br><br>        <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-comment">//ts_read_raw(&amp;x, &amp;y, &amp;pressure); </span><br>            <span class="hljs-comment">//我们使用测试程序去读这些值</span><br>                ts_read_raw_test(&amp;x, &amp;y, &amp;pressure)<span class="hljs-comment">;</span><br>        &#125; <span class="hljs-keyword">while</span> (pressure == <span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br><br>        <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">cnt</span> &lt; <span class="hljs-number">128</span>)<br>                &#123;<br>                        sum_x += x<span class="hljs-comment">;</span><br>                        sum_y += y<span class="hljs-comment">;</span><br>                        <span class="hljs-keyword">cnt</span>++<span class="hljs-comment">;</span><br>                &#125;<br>                <span class="hljs-comment">//ts_read_raw(&amp;x, &amp;y, &amp;pressure);</span><br><br>                <span class="hljs-comment">//ts_read_raw_test(&amp;x, &amp;y, &amp;pressure);</span><br>                printf(<span class="hljs-string">&quot;get raw data: x = %08d, y = %08d, cnt = %d\n\r&quot;</span>, x, y, <span class="hljs-keyword">cnt</span>)<span class="hljs-comment">;</span><br>        &#125; <span class="hljs-keyword">while</span> (pressure)<span class="hljs-comment">;</span><br><br>        *px = sum_x / <span class="hljs-keyword">cnt</span><span class="hljs-comment">;</span><br>        *py = sum_y / <span class="hljs-keyword">cnt</span><span class="hljs-comment">;</span><br><br>        printf(<span class="hljs-string">&quot;return raw data: x = %08d, y = %08d\n\r&quot;</span>, *px, *py)<span class="hljs-comment">;</span><br><br>        <span class="hljs-comment">/* 直到松开才返回 */</span><br>        fb_disp_cross(lcd_x, lcd_y, <span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看点击一下是不是得到了距离非常远的两个值</p><p><img src="/image/700px-Chapter18_lesson12_002.png" alt="700px-Chapter18_lesson12_002.png"></p><p>对于同一个点得到的是255 945 945 944</p><p>发现 945 944经常出现</p><p>我们查一下原因,进入touchscreen.c中</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs awk">void Isr_Adc(void)<br>&#123;<br>        int x = ADCDAT0;<br>        int y = ADCDAT1;<br><br>        static int adc_cnt = <span class="hljs-number">0</span>;<br>        static int adc_x = <span class="hljs-number">0</span>;<br>        static int adc_y = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-regexp">/* 进入ADC中断时, TS处于&quot;自动测量模式&quot; */</span><br><br>        <span class="hljs-regexp">/* 只有在&quot;等待中断模式&quot;下才可以使用ADCDAT0&#x27;BIT 15来判断触摸笔状态 */</span><br><br>        enter_wait_pen_up_mode();<br>        <span class="hljs-keyword">if</span> (!(ADCDAT0 &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>))) <span class="hljs-regexp">/* 如果仍然按下才打印 */</span><br>        &#123;<br><span class="hljs-comment">#if 0                      </span><br>            x &amp;= <span class="hljs-number">0</span>x3ff;          <br>            y &amp;= <span class="hljs-number">0</span>x3ff;     <br>               <br>            <span class="hljs-regexp">//</span>printf(<span class="hljs-string">&quot;x = %08d, y = %08d\n\r&quot;</span>, x, y);          <br>            report_ts_xy(x, y, <span class="hljs-number">1</span>);<br><br>            <span class="hljs-regexp">/* 启动定时器以再次读取数据 */</span>          <br>            ts_timer_enable();<span class="hljs-comment">#endif</span><br>                /* 第<span class="hljs-number">1</span>次启动ADC后:          <br>                 *   a. 要连续启动N次, 获得N个数据, 求平均值并上报          <br>                 *   b. 得到N次数据后, 再启动TIMER           <br>                 */<br>                adc_x += (x &amp; <span class="hljs-number">0</span>x3ff);<br>                adc_y += (y &amp; <span class="hljs-number">0</span>x3ff);<br><br>                test_x_array[adc_cnt] = (x &amp; <span class="hljs-number">0</span>x3ff);<br>                test_y_array[adc_cnt] = (y &amp; <span class="hljs-number">0</span>x3ff);<br>                <br>                adc_cnt++;<br><br>                <span class="hljs-keyword">if</span> (adc_cnt == <span class="hljs-number">16</span>)<br>                &#123;<br>                        adc_x &gt;&gt;= <span class="hljs-number">4</span>;<br>                        adc_y &gt;&gt;= <span class="hljs-number">4</span>;<br>                        report_ts_xy(adc_x, adc_y, <span class="hljs-number">1</span>);<br>                        adc_cnt = <span class="hljs-number">0</span>;<br>                        adc_x = <span class="hljs-number">0</span>;<br>                        adc_y = <span class="hljs-number">0</span>;<br>                        <br>                        <span class="hljs-regexp">/* 启动定时器以再次读取数据 */</span><br>                        <span class="hljs-regexp">/* 先设置TS进入&quot;等待中断模式&quot; */</span><br>                        enter_wait_pen_up_mode();<br>                        ts_timer_enable();<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                        <span class="hljs-regexp">/* 再次启动ADC */</span><br>                        <span class="hljs-regexp">/* 进入&quot;自动测量&quot;模式 */</span><br>                        enter_auto_measure_mode();<br>                        <br>                        <span class="hljs-regexp">/* 启动ADC */</span><br>                        ADCCON |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>);<br>                &#125;<br>                <br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>                adc_cnt = <span class="hljs-number">0</span>;<br>                adc_x = <span class="hljs-number">0</span>;<br>                adc_y = <span class="hljs-number">0</span>;<br>                printf(<span class="hljs-string">&quot;adc report pen down\n\r&quot;</span>);<br>                ts_timer_disable();<br>                enter_wait_pen_down_mode();<br>                report_ts_xy(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        &#125;<br>    <span class="hljs-regexp">//</span>启动ADC后又再次进入enter_wait_pen_up_mode电阻上拉，多次一举<br>        <span class="hljs-regexp">//</span>enter_wait_pen_up_mode();  <span class="hljs-regexp">/* 启动ADC时不应该进入这个模式, 它会影响数据 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/700px-Chapter18_lesson12_003.png" alt="700px-Chapter18_lesson12_003.png"></p><p>发现这些值中还有944，我需要继续查找原因, 在touchscreen.c时钟处理函数中添加打印信息</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/* 每10ms该函数被调用一次  </span><br><span class="hljs-comment">*/</span>void touchscreen<span class="hljs-constructor">_timer_irq(<span class="hljs-params">void</span>)</span><br>&#123;<br>        <span class="hljs-comment">/* 如果触摸屏仍被按下, 进入&quot;自动测量模式&quot;, 启动ADC */</span><br>        <span class="hljs-keyword">if</span> (get<span class="hljs-constructor">_status_of_ts_timer()</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span>)<br>                return;<br><br>        <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">_in_auto_mode()</span>)<br>                return;<br><br>        <span class="hljs-comment">/* 只有在&quot;等待中断模式&quot;下才可以使用ADCDAT0&#x27;BIT 15来判断触摸笔状态 */</span><br><br>        <span class="hljs-keyword">if</span> (ADCDAT0 &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>)) <span class="hljs-comment">/* 如果松开 */</span><br>        &#123;<br>    <span class="hljs-comment">//添加打印信息</span><br>                printf(<span class="hljs-string">&quot;timer set pen down\n\r&quot;</span>);<br>                ts<span class="hljs-constructor">_timer_disable()</span>;<br>    <span class="hljs-comment">//进入enter_wait_pen_down_mode，来判断触摸笔是按下还是松开</span><br>                enter<span class="hljs-constructor">_wait_pen_down_mode()</span>;<br>                report<span class="hljs-constructor">_ts_xy(0, 0, 0)</span>;<br>                return;<br>        &#125;<br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 按下状态 */</span><br>        &#123;<br>                <span class="hljs-comment">/* 进入&quot;自动测量&quot;模式 */</span><br>                enter<span class="hljs-constructor">_auto_measure_mode()</span>;<br><br>                <span class="hljs-comment">/* 启动ADC */</span><br>                ADCCON <span class="hljs-pattern-match">|= (1&lt;&lt;0);</span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match">&#125;</span><br></code></pre></td></tr></table></figure><p><img src="/image/700px-Chapter18_lesson12_004.png" alt="700px-Chapter18_lesson12_004.png"></p><p>非常频繁打印timer set pen down</p><ul><li>我们的判断有问题</li></ul><p>打开芯片手册，搜索这个寄存器,Bit15确实是判断按下或者松开</p><p><img src="/image/700px-Chapter18_lesson12_005.png" alt="700px-Chapter18_lesson12_005.png"></p><p>只有在中断模式下，这一位才可以正确反应是按下还是松开的状态,修改touchscreen_timer_irq函数</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-comment">/* 每10ms该函数被调用一次  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-variable">void</span> <span class="hljs-title function_">touchscreen_timer_irq</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-comment">/* 如果触摸屏仍被按下, 进入&quot;自动测量模式&quot;, 启动ADC */</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">get_status_of_ts_timer</span>() <span class="hljs-operator">==</span> <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment">//如果定时器中断在ADC中间产生，应该立刻返回啥都不做，不需要timer去做任何操作</span><br><span class="hljs-comment">//我们需要写出这个函数</span><br><span class="hljs-comment">//如果不是自动模式，那么就是等待中断模式</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">is_in_auto_mode</span>())<br>                <span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment">//中断处理函数，</span><br>        <span class="hljs-comment">/* 只有在&quot;等待中断模式&quot;下才可以使用ADCDAT0&#x27;BIT 15来判断触摸笔状态 */</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">ADCDAT0</span> <span class="hljs-operator">&amp;</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">15</span>)) <span class="hljs-comment">/* 如果松开 */</span><br>        &#123;<br>                <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;timer set pen down<span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span>&quot;</span>);<br>                <span class="hljs-title function_">ts_timer_disable</span>();<br>                <span class="hljs-title function_">enter_wait_pen_down_mode</span>();<br>                <span class="hljs-title function_">report_ts_xy</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 按下状态 */</span><br>        &#123;<br>                <span class="hljs-comment">/* 进入&quot;自动测量&quot;模式 */</span><br>                <span class="hljs-title function_">enter_auto_measure_mode</span>();<br>                <span class="hljs-comment">/* 启动ADC */</span><br>                <span class="hljs-variable">ADCCON</span> <span class="hljs-operator">|</span><span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">0</span>);<br>        &#125;<br>&#125;<br><br><span class="hljs-comment">//判断是否是模式模式的函数</span><br><br>int <span class="hljs-title function_">is_in_auto_mode</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">ADCTSC</span> <span class="hljs-operator">&amp;</span> <span class="hljs-variable">AUTO_PST</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们接着实验</p><p><img src="/image/700px-Chapter18_lesson12_006.png" alt="700px-Chapter18_lesson12_006.png"></p><p>发现并没有捕捉到笔的松开模式 , 修改tslib，取消ts_read_raw_test 重新进行测试.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs perl">void get_calibrate_point_data(<span class="hljs-keyword">int</span> lcd_x, <span class="hljs-keyword">int</span> lcd_y, <span class="hljs-keyword">int</span> *px, <span class="hljs-keyword">int</span> *py)<br>&#123;<br>        <span class="hljs-keyword">int</span> pressure;<br>        <span class="hljs-keyword">int</span> <span class="hljs-keyword">x</span>, <span class="hljs-keyword">y</span>;<br>        <span class="hljs-keyword">int</span> sum_x = <span class="hljs-number">0</span>, sum_y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <br>        fb_disp_cross(lcd_x, lcd_y, <span class="hljs-number">0xffffff</span>);<br><br>        <span class="hljs-regexp">/* 等待点击 */</span><br><br>        <span class="hljs-keyword">do</span> &#123;<br>                ts_read_raw(&amp;<span class="hljs-keyword">x</span>, &amp;<span class="hljs-keyword">y</span>, &amp;pressure);<br>                <span class="hljs-regexp">//</span>ts_read_raw_test(&amp;<span class="hljs-keyword">x</span>, &amp;<span class="hljs-keyword">y</span>, &amp;pressure);<br>        &#125; <span class="hljs-keyword">while</span> (pressure == <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (cnt &lt; <span class="hljs-number">128</span>)<br>                &#123;<br>                        sum_x += <span class="hljs-keyword">x</span>;<br>                        sum_y += <span class="hljs-keyword">y</span>;<br>                        cnt++;<br>                &#125;<br>                ts_read_raw(&amp;<span class="hljs-keyword">x</span>, &amp;<span class="hljs-keyword">y</span>, &amp;pressure);<br>                <span class="hljs-regexp">//</span>ts_read_raw_test(&amp;<span class="hljs-keyword">x</span>, &amp;<span class="hljs-keyword">y</span>, &amp;pressure);<br>                <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;get raw data: x = %08d, y = %08d, cnt = %d\n\r&quot;</span>, <span class="hljs-keyword">x</span>, <span class="hljs-keyword">y</span>, cnt);<br>        &#125; <span class="hljs-keyword">while</span> (pressure);<br><br>        *px = sum_x / cnt;<br>        *py = sum_y / cnt;<br><br>        <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;return raw data: x = %08d, y = %08d\n\r&quot;</span>, *px, *py);<br><br>        <span class="hljs-regexp">/* 直到松开才返回 */</span><br>        fb_disp_cross(lcd_x, lcd_y, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在发现点点不准确</p><p><img src="/image/700px-Chapter18_lesson12_007.png" alt="700px-Chapter18_lesson12_007.png"></p><p>发现校准的值和我们之前的不一样,修改我们的tslib校准程序</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs perl">void get_calibrate_point_data(<span class="hljs-keyword">int</span> lcd_x, <span class="hljs-keyword">int</span> lcd_y, <span class="hljs-keyword">int</span> *px, <span class="hljs-keyword">int</span> *py)<br>&#123;<br>        <span class="hljs-keyword">int</span> pressure;<br>        <span class="hljs-keyword">int</span> <span class="hljs-keyword">x</span>, <span class="hljs-keyword">y</span>;<br>        <span class="hljs-keyword">int</span> sum_x = <span class="hljs-number">0</span>, sum_y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <br>        fb_disp_cross(lcd_x, lcd_y, <span class="hljs-number">0xffffff</span>);<br><br>        <span class="hljs-regexp">/* 等待点击 */</span><br>        <span class="hljs-keyword">do</span> &#123;<br>                ts_read_raw(&amp;<span class="hljs-keyword">x</span>, &amp;<span class="hljs-keyword">y</span>, &amp;pressure);<br>                <span class="hljs-regexp">//</span>ts_read_raw_test(&amp;<span class="hljs-keyword">x</span>, &amp;<span class="hljs-keyword">y</span>, &amp;pressure);<br>        &#125; <span class="hljs-keyword">while</span> (pressure == <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-regexp">//</span>我们把求和的次数限制为<span class="hljs-number">128</span>次<br>                <span class="hljs-keyword">if</span> (cnt &lt; <span class="hljs-number">128</span>)<br>                &#123;<br>                        sum_x += <span class="hljs-keyword">x</span>;<br>                        sum_y += <span class="hljs-keyword">y</span>;<br>                        cnt++;<br>                &#125;<br>                ts_read_raw(&amp;<span class="hljs-keyword">x</span>, &amp;<span class="hljs-keyword">y</span>, &amp;pressure);<br>                <span class="hljs-regexp">//</span>ts_read_raw_test(&amp;<span class="hljs-keyword">x</span>, &amp;<span class="hljs-keyword">y</span>, &amp;pressure);<br>                <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;get raw data: x = %08d, y = %08d, cnt = %d\n\r&quot;</span>, <span class="hljs-keyword">x</span>, <span class="hljs-keyword">y</span>, cnt);<br>        &#125; <span class="hljs-keyword">while</span> (pressure);<br><br>        *px = sum_x / cnt;<br>        *py = sum_y / cnt;<br><br>        <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;return raw data: x = %08d, y = %08d\n\r&quot;</span>, *px, *py);<br><br>        <span class="hljs-regexp">/* 直到松开才返回 */</span><br>        fb_disp_cross(lcd_x, lcd_y, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以参考tslib</p><p>1). 使用矩阵进行校准，适用性更强</p><p>2). 使用多种方法消除误差，多次测量求平均值</p><p>判断相领点的距离，如果突然变化很大，就有可能是错误值</p><p>1). …</p><p>第一期的视频在于裸机基本操作</p><p><strong>视频的要点在于</strong></p><p><strong>修改要点</strong></p><p>1). 启动ADC时不应该进入等待中断模式，它会影响数据</p><p>2). 只有在”等待中断模式”下才可以使用ADCDAT0’BIT 15来判断触摸笔状态</p><p>3). 校准非常重要，所以在程序种多次测量求平均值(不仅仅是在adc中断种求平均值)</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第018课 ADC和触摸屏</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AC%AC018%E8%AF%BE_ADC%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>目录</strong></p><hr><ol><li>第001节_ADC硬件原理</li><li>第002节_ADC编程</li><li>第003节_电阻触摸屏硬件原</li><li>第004节_S3C2440触摸屏接口</li><li>第005节_触摸屏编程_按下松开检测</li><li>第006节_触摸屏编程_ADC中断</li><li>第007节_触摸屏编程_定时器程序优化</li><li>第008节_触摸屏编程_使用定时器支持长按</li><li>第009节_触摸屏编程_较准原理</li><li>第010节_触摸屏编程_较准与画线编</li><li>第011节_触摸屏编程_测试</li><li>第012节_触摸屏编程_完善</li></ol><p><strong>第001节_ADC硬件原理</strong></p><hr><p>模数转换器即A&#x2F;D转换器，或简称ADC，通常是指一个将模拟信号转变为数字信号的电子元件。</p><p>通常的模数转换器是把经过与标准量比较处理后的模拟量转换成以二进制数值表示的离散信号的转换器。</p><p>故任何一个模数转换器都需要一个参考模拟量作为转换的标准，比较常见的参考标准为最大的可转换信号大小。而输出的数字量则表示输入信号相对于参考信号的大小。</p><p>如图，是把可变电阻上的电压值变换的模拟信号通过ADC转换，输出数字信号。</p><p><img src="/image/700px-Chapter18_lesson1_001.jpg" alt="700px-Chapter18_lesson1_001.jpg"></p><p>对于数字信号我们需要得到它的几个属性</p><ul><li>用多少位来存储这个数据（假设10bit）。</li><li>最大值0b111111111</li><li>它对应的电压是多少伏（模拟信号输入的最大值是多少）我们就可以根据模拟信号(电压)的最大值，来计算出对应的数值。</li><li>采样&#x2F;转换速度。</li></ul><p>对于程序员，我们不关心ADC的内部机制，我们只关心：</p><ul><li>怎么启动ADC</li><li>启动之后怎么得到数据，</li></ul><p>总之：我们都是通过寄存器操作的。</p><p><img src="/image/700px-Chapter18_lesson1_002.png" alt="700px-Chapter18_lesson1_002.png"></p><p>从图1-1-1可以看出ADC有8个多路选择器，显然，以后我们写程序的时候，我们可以8个多路选择之一， 下面是编写程序要做的步骤：</p><ol><li>确定是哪一路信号：设置8：1MUX，选择要测量哪一个引脚，（看原理图选择要测量的引脚）</li><li>设置工作时钟（从工作室中，可以算出转换一次，需要多长时间）</li><li>启动</li><li>读状态，判断ADC转换是否成功。</li><li>读数据</li></ol><p>ADC寄存器介绍</p><hr><p><strong>1.ADC 控制寄存器（ADCCON）</strong></p><p>ADCCON控制寄存器，用于标志转换是否完成，控制是否使能预分频器，输入通道选择，工作模式，ADC是否启动。它的各位含义如下图所示。</p><p><img src="/image/700px-Chapter18_lesson1_003.png" alt="700px-Chapter18_lesson1_003.png"></p><p><strong>2.ADC 启动延时寄存器（ADCDLY）</strong></p><p>ADCDLY 启动延时寄存器用于启动或初始化延时寄存器。它的各位含义如下图所示</p><p><img src="/image/700px-Chapter18_lesson1_004.png" alt="700px-Chapter18_lesson1_004.png"></p><p><strong>3.ADC 转换数据寄存器（ADCDAT0）</strong></p><p>ADCDAT0转换数据寄存器，本节中只用到该寄存器的前10位(用于保存转换后的结果)。</p><p><img src="/image/700px-Chapter18_lesson1_005.png" alt="700px-Chapter18_lesson1_005.png"></p><p><strong>第002节_ADC编程</strong></p><hr><p>编程步骤：</p><ol><li>初始化ADC</li><li>读数据，</li><li>在串口上显示出来。</li></ol><p><img src="/image/Chapter18_lesson2_001.png" alt="Chapter18_lesson2_001.png"></p><p>1). 初始化ADC</p><p>下面的函数实现对ADC的初始化。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">03 </span>void adc_init(void)<br><span class="hljs-number">04</span>   &#123;<br><span class="hljs-number">05</span>   /* [<span class="hljs-number">15</span>] : ECFLG,  <span class="hljs-number">1</span> = <span class="hljs-keyword">End</span> of A/D conversion<br><span class="hljs-number">06</span>               * [<span class="hljs-number">14</span>] : PRSCEN, <span class="hljs-number">1</span> = A/D converter prescaler enable<br><span class="hljs-number">07</span>               * [<span class="hljs-number">13</span>:<span class="hljs-number">6</span>]: PRSCVL, adc clk = PCLK / (PRSCVL + <span class="hljs-number">1</span>)<br><span class="hljs-number">08</span>               * [<span class="hljs-number">5</span>:<span class="hljs-number">3</span>] : SEL_MUX, <span class="hljs-number">000</span> = AIN <span class="hljs-number">0</span><br><span class="hljs-number">09</span>                * [<span class="hljs-number">2</span>]   : STDBM<br><span class="hljs-number">10</span>               * [<span class="hljs-number">0</span>]   : <span class="hljs-number">1</span> = A/D conversion starts <span class="hljs-keyword">and</span> this bit is cleared after the startup.<br><span class="hljs-number">11</span>               */<br><span class="hljs-number">12</span>           ADCCON = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">14</span>) | (<span class="hljs-number">49</span>&lt;&lt;<span class="hljs-number">6</span>) | (<span class="hljs-number">0</span>&lt;&lt;<span class="hljs-number">3</span>);<br><span class="hljs-number">13</span><br><span class="hljs-number">14</span>           ADCDLY = <span class="hljs-number">0</span>xff;       <br><span class="hljs-number">15</span>   &#125;<br></code></pre></td></tr></table></figure><ul><li>第12行：配置ADCCON寄存器，使能A&#x2F;D 转换器预分频器，设置A&#x2F;D 转换器预分频值，上拉使能。</li><li>第14行：设置ADC 转换启动延时值。</li></ul><p>2). 读数据</p><p>在这个读函数中启动ADC，并且等待ADC转换成功。然后返回数据，</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">17 </span><span class="hljs-keyword">int</span> adc_read_ain0(void)<br><span class="hljs-number">18</span>   &#123;<br><span class="hljs-number">19</span>                   /* 启动ADC */<br><span class="hljs-number">20</span>           ADCCON |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>);<br><span class="hljs-number">21</span><br><span class="hljs-number">22</span>           <span class="hljs-keyword">while</span> (!(ADCCON &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>)));  /* 等待ADC结束 */<br><span class="hljs-number">23</span><br><span class="hljs-number">24</span>           <span class="hljs-keyword">return</span> ADCDAT0 &amp; <span class="hljs-number">0</span>x3ff;    //只关心其中的十位<br><span class="hljs-number">25</span>   &#125;<br></code></pre></td></tr></table></figure><ul><li>第20行：启动ADC。</li><li>第22行：等待A&#x2F;D转换结束(ADCCON第15位置1)，</li><li>第24行：返回转换的值。(ADCDAT0寄存器的前10位，是保存转换后的值)。</li></ul><p>3). ADC测试</p><p>函数代码如下: 函数功能：在串口&#x2F;LCD上打印ADC转换后的结果。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-number">04</span> void adc<span class="hljs-constructor">_test(<span class="hljs-params">void</span>)</span><br><span class="hljs-number">05</span>   &#123;<br><span class="hljs-number">06</span>           <span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>;<br><span class="hljs-number">07</span>           double vol;<br><span class="hljs-number">08</span>           <span class="hljs-built_in">int</span> m; <span class="hljs-comment">/* 整数部分 */</span><br><span class="hljs-number">09</span>           <span class="hljs-built_in">int</span> n; <span class="hljs-comment">/* 小数部分 */</span><br><span class="hljs-number">10</span>   <br><span class="hljs-number">11</span>           adc<span class="hljs-constructor">_init()</span>;<br><span class="hljs-number">12</span><br><span class="hljs-number">13</span>           <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br><span class="hljs-number">14</span>           &#123;<br><span class="hljs-number">15</span>                   <span class="hljs-keyword">val</span> = adc<span class="hljs-constructor">_read_ain0()</span>;<br><span class="hljs-number">16</span>                   vol = (double)<span class="hljs-keyword">val</span>/<span class="hljs-number">1023</span>*<span class="hljs-number">3.3</span>;   <span class="hljs-comment">/* 1023----3.3v */</span><br><span class="hljs-number">17</span>                   m = (<span class="hljs-built_in">int</span>)vol;   <span class="hljs-comment">/* 3.01, m = 3 */</span><br><span class="hljs-number">18</span>                   vol = vol - m;  <span class="hljs-comment">/* 小数部分: 0.01 */</span><br><span class="hljs-number">19</span>                   n = vol<span class="hljs-operator"> * </span><span class="hljs-number">1000</span>;  <span class="hljs-comment">/* 10 */</span><br><span class="hljs-number">20</span><br><span class="hljs-number">21</span>                   <span class="hljs-comment">/* 在串口上打印 */</span><br><span class="hljs-number">22</span>                   printf(<span class="hljs-string">&quot;vol: %d.%03dv&quot;</span>, m, n);  <span class="hljs-comment">/* 3.010v */</span><br><span class="hljs-number">23</span><br><span class="hljs-number">24</span>                   <span class="hljs-comment">/* 在LCD上打印 */</span><br><span class="hljs-number">25</span>                   <span class="hljs-comment">//fb_print_string();</span><br><span class="hljs-number">26</span>                   &#125;<br><span class="hljs-number">27</span>   &#125;<br></code></pre></td></tr></table></figure><ul><li>第11行：初始化ADC.</li><li>第15行：把ADC转换得到的值赋值给变量val.</li><li>第16行：把变量val的值转化为电压值。</li><li>第17行：取vol整数部分赋值给变量m。</li><li>第18行：取vol的小数部分赋值给vol。</li></ul><p>测试</p><p>把生成的二进制文件烧录到开发板上，接上SPI模块，旋转可变电阻就可以在串口上看到电压值发生变化。</p><p><strong>第003节_电阻触摸屏硬件原</strong></p><hr><p>这节课我们来讲电阻触摸屏的硬件原理</p><p>假设有一个比较长的电阻,电阻是R 上面接3.3V电压，下面接地</p><p><img src="/image/Chapter18_lesson3_001.png" alt="Chapter18_lesson3_001.png"></p><p>假设整个电阻的阻值是R某一个触电它的阻值是R1 根据欧姆定律</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tp"><span class="hljs-number">3</span><span class="hljs-number">.3</span>v/<span class="hljs-keyword">R</span> = V/<span class="hljs-keyword">R</span><span class="hljs-number">1</span><br>V=<span class="hljs-number">3</span><span class="hljs-number">.3</span> *(<span class="hljs-keyword">R</span><span class="hljs-number">1</span>/<span class="hljs-keyword">R</span>)<br></code></pre></td></tr></table></figure><p>假设R1是x坐标 R的长度是L 这个电阻非常的均匀，那么这个电压就等于 3.3V * (x &#x2F; l) 这个电压和这个触电的x坐标有一个线性关系 我使用ADC把这个电压算出来，就可以间接得到这个触电的x坐标 电阻触摸屏就是使用欧姆定律使用电阻原理作出来的</p><p>可以上百度图片搜索触摸屏，就知道了触摸屏的样子,它是一个透明的薄膜,注意 LCD是LCD 触摸屏是触摸屏它是两个设备, 我们只不过是把触摸屏做的和LCD大小一样，粘在LCD上面, 实际上触摸屏是由两层膜组成，他们靠的非常近</p><p>上面这层右边引出来，代表xp ，p代表正极</p><p>上面这层左边引出来，代表xm, m代表负极</p><p><img src="/image/Chapter18_lesson3_002.png" alt="Chapter18_lesson3_002.png"></p><p>下面这层膜 前面这条边引出来为yp，后面这层边为ym</p><p>假设我们手指要点击触摸屏，那么上下就会粘贴在一起，我怎么算出这个 x y点的坐标呢？ 测量触电x坐标: xp接3.3v,xm接GND</p><p><img src="/image/Chapter18_lesson3_003.png" alt="Chapter18_lesson3_003.png"></p><p>yp,ym不接电源</p><p>2 测yp电压 上下膜连接在一起，我就可以通过yp测量这个触电的电压 这个yp就像探测一样，从前面的原理我们可以知道，当这个触电越靠近左边这个电压越小，越靠近右边电压越大 这个yp的电压就可以认为是这个触电的坐标(x坐标)</p><p>类似的我们怎么测量触电y坐标 类似的xp xm不接电源，同样yp接3.3v， ym接GND，这时候电流就从 yp这里流向ym,让后我们就可以测量xp电压 当按下屏幕时，上下两层膜链接在一起，这个xp就像探针一样，这个触电越靠近yp电压值越大，越靠近ym电压值越小</p><p><img src="/image/Chapter18_lesson3_004.png" alt="Chapter18_lesson3_004.png"></p><p>yp接3.3V ym接GND，xp xm不接电源 测量xp电压,就是y坐标</p><p>注意 x y坐标都是电压值，不是屏幕上480 * 272 这些值，我们需要把电压值转换为坐标值，这需要经过一些转换</p><p>我们测量xp yp可以得到触点的两个方向的电压值，这些电压值和坐标是线性关系 我们现在总结下使用触摸屏的流程</p><ol><li><p>按下触摸屏 按下触摸屏时，对于一个高效的系统，产生中断，这是触摸屏中断</p></li><li><p>在触摸中断程序中启动ADC，(获得数据，xy坐标)启动ADC就开始模数转换，不可能瞬间完成。</p></li><li><p>ADC完成， 产生中断</p></li><li><p>在ADC中断中读取x y坐标，我们来想想，在这个流程里，启动触摸屏的源头是按下触摸屏，那如果长按触摸屏，我按下之后一直不松开滑动手指呢</p><ul><li>那么谁来触发后续的多次ADC转换呢 不可能只启动一次吧, 为了支持长按滑动操作，我们需要启用定时器.</li></ul></li><li><p>松开启动定时器(为了支持长按滑动等)</p></li></ol><p>       6. 定时器中断发生，判断触摸屏是否仍被按下，如果按下就循环上述过程(由2开始)</p><p>a. 在触摸中断程序中启动ADC，(获得数据，xy坐标)启动ADC就开始模数转换，不可能瞬间完成</p><p>b. ADC完成，产生中断</p><p>c. ADC中断中读取x y坐标，)</p><ol><li>松开结束一个流程</li></ol><p>平时的时候上下两层膜并不连接，我们按下触摸屏的时候就会产生中断，那么你怎么知道产生中断，肯定是由某个引脚的电平发生变化,平时 Y_ADC&#x2F;xp是高电平,按下之后Y_ADC就接地了，就是被拉低了，就产生了低电平</p><p><img src="/image/Chapter18_lesson3_005.png" alt="Chapter18_lesson3_005.png"></p><p>产生低电平后就知道触摸屏被按下了，这个时候就需要测量电压值读取x坐标,XP XM通电我就测量YP的电压，这不就是 x 点的坐标</p><p><img src="/image/Chapter18_lesson3_006.png" alt="Chapter18_lesson3_006.png"></p><p>读取Y坐标</p><p>YP YM 通电，按下后XP通电，这不就是y点的坐标么</p><p><img src="/image/Chapter18_lesson3_007.png" alt="Chapter18_lesson3_007.png"></p><p><strong>第004节_S3C2440触摸屏接口</strong></p><hr><p>回顾上节触摸屏使用原理</p><p><img src="/image/Chapter18_lesson4_001.png" alt="Chapter18_lesson4_001.png"></p><p>在不使用触摸屏的时候，必须要把 S1 S2 S3断开，S4 S5闭合，只有这样当我按下触摸屏，上面的电平才能从高变低，会产生一个中断信号,而当我去读取X坐标的值时</p><p><img src="/image/Chapter18_lesson4_002.png" alt="Chapter18_lesson4_002.png"></p><p>必须让S1 S3闭合，这样电流才可以通过，同时让S2 S4 S5断开,这时候YP这层膜就相当于探针一样去测量电压</p><p>当我读取y坐标值</p><p><img src="/image/Chapter18_lesson4_003.png" alt="Chapter18_lesson4_003.png"></p><p>必须让S2 S4闭合，这样电流才可以流 下来，同时S1 S3 S5断开，这个时候XP这层膜就相当于探针一样，我可以来测量这里的电压，从而得到Y坐标的电压值</p><p>在测量x y坐标时，这个S5上拉电阻都要断开, 我们需要控制这几个开关，实际上2440的触摸屏接口就提供了这几个开关的控制方法, 打开2440的芯片手册, 从440到450， 我们看有一个8:1 MUX的多路选择器，以及XP YP</p><p><img src="/image/700px-Chapter18_lesson4_004.png" alt="700px-Chapter18_lesson4_004.png"></p><p>442页触摸屏接口模式</p><p><img src="/image/700px-Chapter18_lesson4_005.png" alt="700px-Chapter18_lesson4_005.png"></p><p><strong>正常模式，在上节视频中我们有讲解过</strong></p><p><strong>x y分离转换模式,</strong></p><p>看看我们的X Y坐标原理图，可以单独转换X坐标 单独转换Y坐标</p><p>换句话说就是逐个去测量X Y坐标,</p><p>他首先会启动X坐标的ADC转换，转换成功后数据会保存在ADCDAT0里，同时会产生一个中断，在这个中断服务程序里，就可以把X坐标读取出来，让后可以启动Y坐标的转换，转换成功后数据会保存在ADCDAT，同时会产生一个中断，进入这个中断把Y坐标读取出来 测量一次会产生２个中断，一个是X坐标中断，一个是Y坐标中断</p><p><strong>自动的或连续的X／Y坐标转换模式</strong></p><p>也就是说不需要单独控制，不需要单独去读取X坐标Y坐标，可以设置寄存器，让它一次性的测量X坐标测量Y坐标，X坐标保存在ADCDAT０　Y坐标保存在ADCDAT１，最后产生一个中断，也就是读取X／Y坐标只需要产生一次中断</p><p><strong>等待中断模式</strong></p><p>所谓等待中断模式，就是等待按下或者等待松开</p><p>对于下面这幅图，我按下的时候XP从高电平变为低电平，松开时，XP从低电平变为高电平，这就是按下松开都可以检测到</p><p>我们要等待按下或者松开时　需要设置rADCTSC &#x3D;0xd3这个值</p><p>Standby Mode静默模式&#x2F;省电模式(我们不关心这个)</p><p><img src="/image/700px-Chapter18_lesson4_006.png" alt="700px-Chapter18_lesson4_006.png"></p><p>443页编程要点</p><p><img src="/image/700px-Chapter18_lesson4_007.png" alt="700px-Chapter18_lesson4_007.png"></p><ul><li>AD转换数据时可以通过中断或者查询模式来得到数据，使用中断模式时，从AD转换开始，到得到数据可能会有些延迟，因为中断服务程序的进入和退出需要一定的时间，(也就是说，如果你对数据转换的速度要求的非常高，就可以使用查询方式)，可以查询ADCCON[15]来判断是否转换结束</li></ul><p>444页 剩下就是寄存器操作</p><p><img src="/image/700px-Chapter18_lesson4_008.png" alt="700px-Chapter18_lesson4_008.png"></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">ECFLG状态位 AD转换是否结束<br>PRSCEN 使能ADC转换<br>PRSCVL 设置A/D转换预分频值<br>SEL<span class="hljs-emphasis">_MUX选择输入通道，后面我们使用自动转换XY坐标，所以这里不需要设置</span><br><span class="hljs-emphasis">ENABLE_</span>START 启动转换<br></code></pre></td></tr></table></figure><p>445页</p><p>ADCTSC这个寄存器是重要的</p><p><img src="/image/700px-Chapter18_lesson4_009.png" alt="700px-Chapter18_lesson4_009.png"></p><ul><li>UD_SEN Bit8是用来判断触摸屏是被按下还是被松开<ul><li>0表明被按下，1表明被松开</li></ul></li><li>YM_SEN Bit7  YM开关使能控制S4</li></ul><p><img src="/image/Chapter18_lesson4_001.png" alt="Chapter18_lesson4_001.png"></p><pre><code class="hljs">- 0表示断开 1闭合</code></pre><ul><li>YP_SEN Bit6 YP开关 0表示闭合 1 表示断开<ul><li>寄存器位的含义不同</li></ul></li><li>XM_SEN Bit5 XM开关 0 断开 1 闭合<ul><li>XP_SEN Bit4 XP开关</li></ul></li></ul><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>闭合 <span class="hljs-number">1</span> 断开<br></code></pre></td></tr></table></figure><ul><li>PULL_UP Bit3 控制S5开关 0 上拉(闭合)</li></ul><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>断开<br></code></pre></td></tr></table></figure><ul><li>AUTO_PST Bit2 自动连续转换X坐标Y坐标</li></ul><p>上节视频里我们设置是 0 正常的ADC转换</p><p>如果需要连续转换ADC坐标的话，需要设置为1 ，如果需要手动转换ADC坐标的话，需要设置为0</p><ul><li>XY_PST Bit[1:0] 对于手动转换X Y坐标我们需要手动设置XY_PST 里面的位，是测量X坐标还是测量Y坐标, 也可以设置这两位等于11 让其等于等待模式, 也就是等待触摸屏被按下或者被松开.</li></ul><p>如果设置自动连续转换的话，Bit2 AUTO_PST设置为1 XY_PST设置为00</p><p>如果使用手动转换的话设置AUTO_PST为0 XY_PST设置为01 手动转换X坐标模式 或者设置为10 Y坐标转换模式</p><p>447页ADCDATA0 ADC数据寄存器</p><p><img src="/image/700px-Chapter18_lesson4_0010.png" alt="700px-Chapter18_lesson4_0010.png"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">UPDOWN</span> Bit15 可以读取这一位去判断触摸屏是按下还是松开<br><span class="hljs-attribute">AUTO_PST</span> Bit14 自动测量<br><span class="hljs-attribute">XY_PST</span> Bit[<span class="hljs-number">13</span>:<span class="hljs-number">12</span>] 和上面ADCTSC寄存器中 AUTO_PST Bit2   XY_PST Bit[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>]原理相同<br><span class="hljs-attribute">XPDATA</span> Bit[<span class="hljs-number">9</span>:<span class="hljs-number">0</span>]最低<span class="hljs-number">10</span>位用来保存ADC的值<br></code></pre></td></tr></table></figure><p>448页’ADCDAT1寄存器 和ADCDAT0功能一样的，只不过保存的数据不同</p><p><img src="/image/700px-Chapter18_lesson4_0011.png" alt="700px-Chapter18_lesson4_0011.png"></p><p>这个的低10位是用来保存 Y坐标的值</p><p>接下来是ADCUPDN触摸屏按下或者松开检查寄存器</p><p><img src="/image/700px-Chapter18_lesson4_0012.png" alt="700px-Chapter18_lesson4_0012.png"></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">TST_UP <span class="hljs-keyword">Bit1 </span>触摸屏松开中断产生<br>TST_DN <span class="hljs-keyword">Bit0 </span>触摸屏按下中断产生<br></code></pre></td></tr></table></figure><p>手册看完了，涉及到中断，我们看下这个图</p><p><img src="/image/Chapter18_lesson4_001.png" alt="Chapter18_lesson4_001.png"></p><p>它会涉及两个中断，按下或者松开，即触摸笔的状态中断，另外一个启动ADC以后，ADC结束时也会产生一个中断，但是这个手册里没有看到中断的使能寄存器</p><p>那我们猜测一下，ADC模块或者触摸屏模块一定会发出中断</p><p>首先是ADC或者触摸屏产生中断，通过中断控制器发送中断给CPU</p><p><img src="/image/700px-Chapter18_lesson4_0013.png" alt="700px-Chapter18_lesson4_0013.png"></p><p>肯定有寄存器禁止／使能ADC或者触摸屏中断</p><p>我们看看中断控制器芯片手册中都需要设置什么</p><p><img src="/image/700px-Chapter18_lesson4_0013-1.png" alt="700px-Chapter18_lesson4_0013-1.png"></p><p>ADC中断源</p><p><img src="/image/700px-Chapter18_lesson4_0014.png" alt="700px-Chapter18_lesson4_0014.png"></p><p>ADC结束中断或者触摸屏中断，看来他们合起来用一个中断 既然合并必然还会有一个寄存器来分辨到底是ADC还是触摸屏发生的中断变化</p><p>SRCPND寄存器 31位为ADC中断</p><p><img src="/image/700px-Chapter18_lesson4_0015.png" alt="700px-Chapter18_lesson4_0015.png"></p><p><img src="/image/700px-Chapter18_lesson4_0016.png" alt="700px-Chapter18_lesson4_0016.png"></p><p>设置Bit[31]</p><p>INTMOD寄存器 来决定是普通中断还是快中断模式</p><p><img src="/image/700px-Chapter18_lesson4_0017.png" alt="700px-Chapter18_lesson4_0017.png"></p><p>设置Bit[31]</p><p><img src="/image/700px-Chapter18_lesson4_0018.png" alt="700px-Chapter18_lesson4_0018.png"></p><p>INTMSK寄存器 用来表示是否屏蔽这个中断</p><p><img src="/image/700px-Chapter18_lesson4_0019.png" alt="700px-Chapter18_lesson4_0019.png"></p><p>设置Bit[31]</p><p><img src="/image/700px-Chapter18_lesson4_0020.png" alt="700px-Chapter18_lesson4_0020.png"></p><p>INTOFFSET 设置Bit[31]</p><p><img src="/image/700px-Chapter18_lesson4_0023.png" alt="700px-Chapter18_lesson4_0023.png"></p><p>到底是ADC中断还是触摸屏中断，肯定有其他寄存器可以设置</p><p>SUBSOURCE PENDING寄存器</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">INT_ADC_S</span> Bit[<span class="hljs-number">10</span>]表示ADC中断<br><span class="hljs-attribute">INT_TC</span> Bit[<span class="hljs-number">9</span>]表示触摸屏中断<br></code></pre></td></tr></table></figure><p><img src="/image/700px-Chapter18_lesson4_0024.png" alt="700px-Chapter18_lesson4_0024.png"></p><p>INTSUBMSK 也是同样的位</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">INT_ADC_S</span> Bit[<span class="hljs-number">10</span>]表示ADC中断激活/屏蔽<br><span class="hljs-attribute">INT_TC</span> Bit[<span class="hljs-number">9</span>]表示触摸屏中断激活/屏蔽<br></code></pre></td></tr></table></figure><p><img src="/image/700px-Chapter18_lesson4_0025.png" alt="700px-Chapter18_lesson4_0025.png"></p><p>我们可以通过INTSUBMSK来屏蔽ADC中断或者TouchScreen中断 当然也可以是能某个中断 可以通过SUBSRCPND来分辨到底产生那个中断，再使用INTSUBMSK屏蔽某一个，最后和SUBSOURCPND这两个寄存器都会汇集到一起 变成一个叫做INT_ADC的中断来发送给CPU</p><p>框图就是这样</p><p><img src="/image/700px-Chapter18_lesson4_0026.png" alt="700px-Chapter18_lesson4_0026.png"></p><p>我们怎么写程序？ 写出一个框架</p><ol><li><p>初始化ADC&#x2F;TouchScreen接口(ADCCON,时钟,接口等)</p></li><li><p>一开始触摸屏是没有被按下的，设置TS处于等待中断模式</p></li><li><p>设置中断</p><ul><li>INTSUBMSK使能ADC中断和触摸屏中断</li><li>设置INTMSK使能INT_ADC让他能够发给CPU</li></ul></li><li><p>按下触摸屏，进入TS中断</p><ul><li>进入自动采集模式(自动转换XY坐标)</li><li>启动ADC</li></ul></li></ol><p>       5. 转换完之后产生ADC中断</p><pre><code class="hljs">- 读数据- 再次进入 “&#39;等待中断”&#39;模式\(等待触摸屏被松开\)- 启动定时器，处理长按或者滑动</code></pre><p>       6. 定时器中断</p><pre><code class="hljs">- 判断笔是否松开，若松开结束- 若仍然按下重新执行，重新4.2启动ADC步骤</code></pre><p><strong>第005节_触摸屏编程_按下松开检测</strong></p><hr><p><img src="/image/Chapter18_lesson5_001.png" alt="Chapter18_lesson5_001.png"></p><p>看懂这张图的关键点在于 里面有个中断程序 AdcTsIntHandle 它是总的中断，这里面要分辨if, 如果是ADC中断 那么就调用Isr_adc来处理中段 else if, 如果是触摸屏中断，那么就调用Isr_tc中断</p><p>我们看看是怎么做的</p><ul><li>一开始设置中断</li><li>初始化触摸屏控制器，进入等待中断模式</li><li>这个时候如果按下触摸屏就会进入Pen Down中断</li><li>就会进入AdcTsIntHandle这个总中断函数</li><li>这里面分辨是按下触摸屏</li><li>进入自动(连续) X&#x2F;Y轴坐标转换模式，启动ADC,</li><li>ADC结束之后会产生一个ADC中断</li><li>又再次进入这个AdcTsIntHandle总中断</li><li>这里面分辨是ADC中断，这里面调用Isr_Adc</li><li>我可以读出这里面的数据，再次设置寄存器</li><li>进入等待Pen UP中断模式</li><li>松开触摸笔会再次产生一个中断 </li><li>进入总中断AdcTsIntHandle这里面分辨，原来是松开了触摸笔，再次调用Isr_tc </li><li>这里面又会设置进入等待Pen Down中断模式</li></ul><p>我们开始写代码，再上一个视频ADC代码上进行修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">002_touchscreen_018_005/adc_touchscreen<br></code></pre></td></tr></table></figure><p>我们在adc_touchscreen目录下添加几个文件</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">touchscreen_test.<span class="hljs-keyword">c</span><br>touchscreen.<span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure><p>先写touchscreen.c文件</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-built_in">touchscreen_init</span>(void)&#123;<br>        看看上面流程图<br>        <span class="hljs-comment">/*1 设置中断我们需要提供中断处理函数 */</span><br>        <span class="hljs-comment">/*2 设置触摸屏接口:也就是寄存器 */</span><br>        <span class="hljs-comment">/*3 让触摸屏控制器进入&quot;等待中断模式&quot; */</span><br>&#125;<br>我们设置中断处理函数<br>void <span class="hljs-built_in">AdcTsIntHandle</span>(void)<br>&#123;<br>&#125;<br><br>看一下之前我们是怎么写中断的,看一下interrupt<span class="hljs-selector-class">.c</span>文件<br>void <span class="hljs-built_in">key_eint_irq</span>(int irq)<br>有个中断号<br><br>那么我们也定义个int irq参数<br>void <span class="hljs-built_in">AdcTsIntHandle</span>(int irq)<br>我们在这个里面分辨一下<br>if (SUBSRCPND &amp; (<span class="hljs-number">1</span>&lt;&lt;TC_INT_BIT))  <span class="hljs-comment">/* 如果是触摸屏中断 */</span><br>        <span class="hljs-built_in">Isr_Tc</span>();    <span class="hljs-comment">/* 调用 */</span>   <br>else if <span class="hljs-comment">/* 如果是ADC中断 */</span><br>        <span class="hljs-built_in">Isr_Adc</span>();    <span class="hljs-comment">/* 调用 */</span><br>我们等会实现这两个函数<br><br>我们继续写代码<br>void <span class="hljs-built_in">touchscreen_init</span>(void)<br>&#123;<br>        看看上面流程图<br>        <span class="hljs-comment">/*1 设置中断，我们需要提供中断处理函数 */</span><br>        <span class="hljs-built_in">adc_ts_int_init</span>();<br>        <span class="hljs-comment">/*2 设置触摸屏接口:也就是寄存器 */</span><br>        <span class="hljs-built_in">adc_ts_reg_init</span>();<br>        <span class="hljs-comment">/*3 让触摸屏控制器进入&quot;等待中断模式&quot; */</span><br>        <span class="hljs-built_in">enter_wait_pen_down_mode</span>();<br>&#125;<br><br><span class="hljs-comment">//我们先来实现 adc_ts_int_init</span><br><br>void <span class="hljs-built_in">adc_ts_int_init</span>(void)<br>&#123;<br>        <span class="hljs-comment">/*注册中断处理函数*/</span><br><span class="hljs-comment">//怎么注册看之前的代码</span><br>        <span class="hljs-built_in">register_irq</span>(irq, irq_handle);<br>        <span class="hljs-comment">/* 使能中断 */</span><br></code></pre></td></tr></table></figure><p>中断号是多少？</p><p>打开芯片手册，找到中断控制器</p><p><img src="/image/700px-Chapter18_lesson4_0015.png" alt="700px-Chapter18_lesson4_0015.png"></p><p><img src="/image/700px-Chapter18_lesson4_0016.png" alt="700px-Chapter18_lesson4_0016.png"></p><p>我们是31号中断</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">register_ir<span class="hljs-string">q(31, AdcTsIntHandle)</span>;   <br></code></pre></td></tr></table></figure><p>怎么使能中断?</p><p>我们需要把&lt;code&gt; INTSUBMISK寄存器的Bit9 Bit10设置为0 宏定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADC_INT_BIT (10)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TC_INT_BIT  (9)</span><br></code></pre></td></tr></table></figure><p>使能中断，清零</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">INTSUBMSK</span> &amp;= ~((<span class="hljs-number">1</span>&lt;&lt;ADC_INT_BIT) | (<span class="hljs-number">1</span>&lt;&lt;TC_INT_BIT));<br></code></pre></td></tr></table></figure><p>还有INTMSK我们也需要把Bit31清零</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INT_ADC_TC (31)</span><br></code></pre></td></tr></table></figure><p>Bit31位清零操作</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">INTMSK    <span class="hljs-meta">&amp;= ~(1&lt;&lt;INT_ADC_TC);</span><br></code></pre></td></tr></table></figure><p>这句可以不用设置，因为register_irq已经设置</p><p>假设产生中断就会进入AdcTsIntHandle函数中 分辨是触摸屏终端还是ADC中断</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-built_in">AdcTsIntHandle</span>(int irq)<br>&#123;<br>        if   <span class="hljs-comment">/* 如果是触摸屏中断 */</span><br>                <span class="hljs-built_in">Isr_Tc</span>();<br>        if  <span class="hljs-comment">/* ADC中断 */</span><br>                <span class="hljs-built_in">Isr_Adc</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>如何进行分辨</p><p><img src="/image/700px-Chapter18_lesson4_0024.png" alt="700px-Chapter18_lesson4_0024.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs shell">if (SUBSRCPND &amp; (1&lt;&lt;TC_INT_BIT))  /* 如果是触摸屏中断 */<br>        Isr_Tc();<br>if (SUBSRCPND &amp; (1&lt;&lt;ADC_INT_BIT))  /* ADC中断 */<br>        Isr_Adc();<br><br>//我们要引用寄存器地址头文件<br><span class="hljs-meta prompt_">#</span><span class="language-bash">include <span class="hljs-string">&quot;../s3c2440_soc.h&quot;</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define ADC_INT_BIT (10)</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define TC_INT_BIT  (9)</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define INT_ADC_TC   (31)</span><br>/* ADCTSC&#x27;s bits */<br><span class="hljs-meta prompt_">#</span><span class="language-bash">define WAIT_PEN_DOWN    (0&lt;&lt;<span class="hljs-string">8)</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-string">define WAIT_PEN_UP      (1&lt;&lt;8</span>)</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define YM_ENABLE        (1&lt;&lt;<span class="hljs-string">7)</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-string">define YM_DISABLE       (0&lt;&lt;7</span>)</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define YP_ENABLE        (0&lt;&lt;<span class="hljs-string">6)</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-string">define YP_DISABLE       (1&lt;&lt;6</span>)</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define XM_ENABLE        (1&lt;&lt;<span class="hljs-string">5)</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-string">define XM_DISABLE       (0&lt;&lt;5</span>)</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define XP_ENABLE        (0&lt;&lt;<span class="hljs-string">4)</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-string">define XP_DISABLE       (1&lt;&lt;4</span>)</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define PULLUP_ENABLE    (0&lt;&lt;<span class="hljs-string">3)</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-string">define PULLUP_DISABLE   (1&lt;&lt;3</span>)</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">define AUTO_PST         (1&lt;&lt;<span class="hljs-string">2)</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-string">define WAIT_INT_MODE    (3)</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-string">define NO_OPR_MODE      (0)</span></span><br>void enter_wait_pen_down_mode(void)<br>&#123;<br>        ADCTSC = WAIT_PEN_DOWN | PULLUP_ENABLE | YM_ENABLE | YP_DISABLE | XP_DISABLE | XM_DISABLE | WAIT_INT_MODE;<br>&#125;<br>void enter_wait_pen_up_mode(void)<br>&#123;<br>        ADCTSC = WAIT_PEN_UP | PULLUP_ENABLE | YM_ENABLE | YP_DISABLE | XP_DISABLE | XM_DISABLE | WAIT_INT_MODE;<br>&#125;<br></code></pre></td></tr></table></figure><p>读一下寄存器,找到触摸屏的寄存器触摸笔,按下松开状态寄存器</p><p><img src="/image/Chapter18_lesson5_001.png" alt="Chapter18_lesson5_001.png"></p><p>我们可以读它 Bit1表示up Bit0表示down</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Isr_Tc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ADCUPDN = 0x%x, ADCDAT0 = 0x%x, ADCDAT1 = 0x%x, ADCTSC = 0x%x\n\r&quot;</span>, ADCUPDN, ADCDAT0, ADCDAT1, ADCTSC);<br>        <br>        <span class="hljs-keyword">if</span> (ADCDAT0 &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>))<br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pen up\n\r&quot;</span>);<br>                <span class="hljs-built_in">enter_wait_pen_down_mode</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span>   <br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pen down\n\r&quot;</span>);<br><br>                <span class="hljs-comment">/* 进入&quot;等待触摸笔松开的模式&quot; */</span><br>                <span class="hljs-built_in">enter_wait_pen_up_mode</span>();<br>        &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AdcTsIntHandle</span><span class="hljs-params">(<span class="hljs-type">int</span> irq)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">if</span> (SUBSRCPND &amp; (<span class="hljs-number">1</span>&lt;&lt;TC_INT_BIT))  <span class="hljs-comment">/* 如果是触摸屏中断 */</span><br>                <span class="hljs-built_in">Isr_Tc</span>();<br><br><span class="hljs-comment">//       if (SUBSRCPND &amp; (1&lt;&lt;ADC_INT_BIT))  /* ADC中断*/</span><br><span class="hljs-comment">//               Isr_Adc();</span><br>        SUBSRCPND = (<span class="hljs-number">1</span>&lt;&lt;TC_INT_BIT) | (<span class="hljs-number">1</span>&lt;&lt;ADC_INT_BIT); <span class="hljs-comment">/* 清中断 */</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">adc_ts_int_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        SUBSRCPND = (<span class="hljs-number">1</span>&lt;&lt;TC_INT_BIT) | (<span class="hljs-number">1</span>&lt;&lt;ADC_INT_BIT);<br><br>        <span class="hljs-comment">/* 注册中断处理函数 */</span><br>        <span class="hljs-built_in">register_irq</span>(<span class="hljs-number">31</span>, AdcTsIntHandle);<br><br>        <span class="hljs-comment">/* 使能中断 */</span><br>        INTSUBMSK &amp;= ~((<span class="hljs-number">1</span>&lt;&lt;ADC_INT_BIT) | (<span class="hljs-number">1</span>&lt;&lt;TC_INT_BIT));<br>        <span class="hljs-comment">//INTMSK    &amp;= ~(1&lt;&lt;INT_ADC_TC);</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">adc_ts_reg_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-comment">/* [15] : ECFLG,  1 = End of A/D conversion  </span><br><span class="hljs-comment">         * [14] : PRSCEN, 1 = A/D converter prescaler enable  </span><br><span class="hljs-comment">         * [13:6]: PRSCVL, adc clk = PCLK / (PRSCVL + 1)  </span><br><span class="hljs-comment">         * [5:3] : SEL_MUX, 000 = AIN 0  * [2]   : STDBM  </span><br><span class="hljs-comment">         * [0]   : 1 = A/D conversion starts and this bit is cleared after the startup.  </span><br><span class="hljs-comment">         */</span><br>        ADCCON = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">14</span>) | (<span class="hljs-number">49</span>&lt;&lt;<span class="hljs-number">6</span>) | (<span class="hljs-number">0</span>&lt;&lt;<span class="hljs-number">3</span>);<br><br>        ADCDLY = <span class="hljs-number">0xff</span>;       <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">touchscreen_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-comment">/* 设置触摸屏接口:寄存器 */</span><br>        <span class="hljs-built_in">adc_ts_reg_init</span>();<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ADCUPDN = 0x%x, SUBSRCPND = 0x%x, SRCPND = 0x%x\n\r&quot;</span>, ADCUPDN, SUBSRCPND, SRCPND);<br><br>        <span class="hljs-comment">/* 设置中断 */</span><br>        <span class="hljs-built_in">adc_ts_int_init</span>();<br><br>        <span class="hljs-comment">/* 让触摸屏控制器进入&quot;等待中断模式&quot; */</span><br>        <span class="hljs-built_in">enter_wait_pen_down_mode</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第006节_触摸屏编程_ADC中断</strong></p><hr><p>这节课我们加上ADC中断把触点的xy坐标读出来</p><p>查看touchscreen.c</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">写出这个自动测量的函数<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">enter_auto_measure_mode</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br><span class="hljs-comment">//现在是自动测量，我们没有机会分别设置这些开关</span><br><br>设置<span class="hljs-variable constant_">AUTO_PST</span> =<span class="hljs-number">1</span><br><span class="hljs-variable constant_">XY_PST</span> = <span class="hljs-number">00</span><br><br>        <span class="hljs-variable constant_">ADCTSC</span> = <span class="hljs-variable constant_">AUTO_PST</span> | <span class="hljs-variable constant_">NO_OPR_MODE</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;现在是自动测量，我们没有机会分别设置这些开关</p><p><img src="/image/700px-Chapter18_lesson6_001.png" alt="700px-Chapter18_lesson6_001.png"></p><p>进入中断处理函数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void <span class="hljs-constructor">AdcTsIntHandle(<span class="hljs-params">int</span> <span class="hljs-params">irq</span>)</span><br>&#123;<br>        <span class="hljs-keyword">if</span> (SUBSRCPND &amp; (<span class="hljs-number">1</span>&lt;&lt;TC_INT_BIT))  <span class="hljs-comment">/* 如果是触摸屏中断 */</span><br>                <span class="hljs-constructor">Isr_Tc()</span>;<br><br>        <span class="hljs-keyword">if</span> (SUBSRCPND &amp; (<span class="hljs-number">1</span>&lt;&lt;ADC_INT_BIT))  <span class="hljs-comment">/* ADC中断，则会进入Adc中断处理函数 */</span><br>                <span class="hljs-constructor">Isr_Adc()</span>;<br><br>        SUBSRCPND = (<span class="hljs-number">1</span>&lt;&lt;TC_INT_BIT) <span class="hljs-pattern-match">| (1&lt;&lt;<span class="hljs-constructor">ADC_INT_BIT</span>);</span><br><span class="hljs-pattern-match">&#125;</span><br></code></pre></td></tr></table></figure><p>进入触摸屏中断处理函数</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk">void Isr_Tc(void)<br>&#123;<br>        <span class="hljs-regexp">//</span>printf(<span class="hljs-string">&quot;ADCUPDN = 0x%x, ADCDAT0 = 0x%x, ADCDAT1 = 0x%x, ADCTSC = 0x%x\n\r&quot;</span>, ADCUPDN, ADCDAT0, ADCDAT1, ADCTSC);<br>        <br>        <span class="hljs-keyword">if</span> (ADCDAT0 &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>))<br>        &#123;<br>                <span class="hljs-regexp">//</span>printf(<span class="hljs-string">&quot;pen up\n\r&quot;</span>);<br>                enter_wait_pen_down_mode();<br>        &#125;<br>        <span class="hljs-keyword">else</span>   <br>        &#123;<br>                <span class="hljs-regexp">/* 进入&quot;自动测量&quot;模式 */</span><br>                enter_auto_measure_mode();<br><br>                <span class="hljs-regexp">/* 启动ADC */</span><br>ENABLE_START = <span class="hljs-number">1</span>就可以了<br>                ADCCON |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;* 启动ADC *&#x2F;</p><p><img src="/image/700px-Chapter18_lesson6_002.png" alt="700px-Chapter18_lesson6_002.png"></p><p>Adc中断处理函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Isr_Adc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        进入adc中断后，等待触摸笔松开<br>        <span class="hljs-type">int</span> x = ADCDAT0 &amp; <span class="hljs-number">0x3ff</span>;<br>        <span class="hljs-type">int</span> y = ADCDAT1 &amp; <span class="hljs-number">0x3ff</span>;<br>                <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x = %08d, y = %08d\n\r&quot;</span>, x, y);<br><br><span class="hljs-comment">//等待触摸笔松开模式</span><br>        <span class="hljs-built_in">enter_wait_pen_up_mode</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>烧写 实验发现打印一堆乱码</p><p><img src="/image/700px-Chapter18_lesson6_003.png" alt="700px-Chapter18_lesson6_003.png"></p><p>应该是printf函数出了问题 打开my_printf.c文件，找到printf函数 应该是处理第二个数据的时候，没有设置初始值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*reference :   int vprintf(const char *format, va_list ap); */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">my_vprintf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt, va_list ap)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">char</span> lead=<span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-type">int</span>  maxwidth=<span class="hljs-number">0</span>;<br>        <br>         <span class="hljs-keyword">for</span>(; *fmt != <span class="hljs-string">&#x27;\0&#x27;</span>; fmt++)<br>         &#123;<br>                 <span class="hljs-keyword">if</span> (*fmt != <span class="hljs-string">&#x27;%&#x27;</span>) <br>                &#123;<br>                    <span class="hljs-built_in">outc</span>(*fmt);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>        <span class="hljs-comment">//碰到 % 就重新处理， 初始值应该重新设置初始值上去</span><br>                lead=<span class="hljs-string">&#x27; &#x27;</span>;<br>                maxwidth=<span class="hljs-number">0</span>;<br>                <br>                <span class="hljs-comment">//format : %08d, %8d,%d,%u,%x,%f,%c,%s</span><br>                    fmt++;<br>                <span class="hljs-keyword">if</span>(*fmt == <span class="hljs-string">&#x27;0&#x27;</span>)<br>                &#123;<br>                        lead = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                        fmt++;  <br>                &#125;<br>                <br>                <span class="hljs-keyword">while</span>(*fmt &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; *fmt &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)<br>                &#123;<br>                        maxwidth *=<span class="hljs-number">10</span>;<br>                        maxwidth += (*fmt - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                        fmt++;<br>                &#125;<br>                <br>                        <span class="hljs-keyword">switch</span> (*fmt) <br>            &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>: <span class="hljs-built_in">out_num</span>(<span class="hljs-built_in">va_arg</span>(ap, <span class="hljs-type">int</span>),          <span class="hljs-number">10</span>,lead,maxwidth); <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;o&#x27;</span>: <span class="hljs-built_in">out_num</span>(<span class="hljs-built_in">va_arg</span>(ap, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>),  <span class="hljs-number">8</span>,lead,maxwidth); <span class="hljs-keyword">break</span>;                                <br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;u&#x27;</span>: <span class="hljs-built_in">out_num</span>(<span class="hljs-built_in">va_arg</span>(ap, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>), <span class="hljs-number">10</span>,lead,maxwidth); <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;x&#x27;</span>: <span class="hljs-built_in">out_num</span>(<span class="hljs-built_in">va_arg</span>(ap, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>), <span class="hljs-number">16</span>,lead,maxwidth); <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-built_in">outc</span>(<span class="hljs-built_in">va_arg</span>(ap, <span class="hljs-type">int</span>   )); <br><span class="hljs-keyword">break</span>;         <br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>: <span class="hljs-built_in">outs</span>(<span class="hljs-built_in">va_arg</span>(ap, <span class="hljs-type">char</span> *)); <span class="hljs-keyword">break</span>;                               <br>                                <br>                <span class="hljs-keyword">default</span>: <span class="hljs-built_in">outc</span>(*fmt);<br><span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>重新烧写执行，发现数据变化幅度很大，但至少Adc已经有输出</p><p><img src="/image/Chapter18_lesson6_004.png" alt="Chapter18_lesson6_004.png"></p><p>我们需要解决输出值不线性的问题</p><p>到底是触摸屏质量问题，还是Adc转化精度问题， 觉得应该是触摸屏电压不稳定 之前不知道DELAY寄存器是用来干嘛的</p><p><img src="/image/700px-Chapter18_lesson6_005.png" alt="700px-Chapter18_lesson6_005.png"></p><p>等待中断模式时，当触摸笔按下时我们会产生中断，但是可以通过 DELAY来延时产生中断</p><p>在前面有一张图</p><p><img src="/image/700px-Chapter18_lesson6_006.png" alt="700px-Chapter18_lesson6_006.png"></p><p>按下触摸笔，延迟A 才可以产生中断，你才可以测量X Y坐标 A &#x3D; D（晶振的周期） D就是 DELAY就是那个寄存器的值 晶振周期时12M 我们需要设置一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">adc_ts_reg_init</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>        <span class="hljs-comment">/* [15] : ECFLG,  1 = End of A/D conversion  </span><br><span class="hljs-comment">         * [14] : PRSCEN, 1 = A/D converter prescaler enable  </span><br><span class="hljs-comment">         * [13:6]: PRSCVL, adc clk = PCLK / (PRSCVL + 1)  </span><br><span class="hljs-comment">         * [5:3] : SEL_MUX, 000 = AIN 0  * [2]   : STDBM  </span><br><span class="hljs-comment">         * [0]   : 1 = A/D conversion starts and this bit is cleared after the startup.  </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-variable constant_">ADCCON</span> = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">14</span>) | (<span class="hljs-number">49</span>&lt;&lt;<span class="hljs-number">6</span>) | (<span class="hljs-number">0</span>&lt;&lt;<span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">/*  按下触摸屏, 延时一会再发出TC中断  </span><br><span class="hljs-comment">         * 10ms为120000  </span><br><span class="hljs-comment">         *  延时时间 = ADCDLY </span><br><span class="hljs-comment">         * 晶振周期 = ADCDLY </span><br><span class="hljs-comment">         * 1 / 12000000 = 5ms  </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-variable constant_">ADCDLY</span> = <span class="hljs-number">60000</span>;      <br>&#125;<br></code></pre></td></tr></table></figure><p>再次烧写，发现数据并不规律 我们需要再次改进程序</p><p>我们按下触摸屏会产生触摸屏中断，启动自动测量，启动Adc，Adc成功后会进入Adc中断，在函数中打印数据</p><p>也许测量过程很长 我们就需要判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Isr_Adc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">int</span> x = ADCDAT0;<br>        <span class="hljs-type">int</span> y = ADCDAT1;<span class="hljs-comment">//松开的话打印也是错误的值，所以如果仍然按下才打印</span><br>        <span class="hljs-keyword">if</span> (!(x &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>))) <span class="hljs-comment">/* 如果仍然按下才打印 */</span><br>        &#123;<br>                x &amp;= <span class="hljs-number">0x3ff</span>;<br>                y &amp;= <span class="hljs-number">0x3ff</span>;<br>                <span class="hljs-comment">//打印10进制</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x = %08d, y = %08d\n\r&quot;</span>, x, y);<br>        &#125;<br>        <span class="hljs-built_in">enter_wait_pen_up_mode</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>烧写执行 发现X Y轴输出有问题</p><p><img src="/image/Chapter18_lesson6_007.png" alt="Chapter18_lesson6_007.png"></p><p>厂家把X　Y轴搞反了</p><p>电路图中</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">TSYP</span>　TSXP接反<br>TSYM　TSXM接反<br></code></pre></td></tr></table></figure><p><img src="/image/Chapter18_lesson6_008.png" alt="Chapter18_lesson6_008.png"></p><p>我们后面使用触摸屏时会使用软件处理这点，不会导致任何问题　</p><p>有一个缺点 我们按下触摸屏会输出一个数据，再按下触摸屏又输出一个数据 我长按并没有输出数据，我滑动也没有输出数据 我们需要使用定时器改进这个问题</p><p>各种方向的旋转都可以由软件转换</p><p><img src="/image/Chapter18_lesson6_009.png" alt="Chapter18_lesson6_009.png"></p><p>我们需要把触摸屏的坐标TS　XY坐标转换成LCD的XY坐标 需要用应用程序做 我们常使用Tslib库来做，这些旋转倒置都没有问题</p><p><strong>第007节_触摸屏编程_定时器程序优化</strong></p><hr><ul><li>有一个缺点</li><li>我们按下触摸屏会输出一个数据，再按下触摸屏又输出一个数据</li><li>我长按并没有输出数据，我滑动也没有输出数据</li><li>我们需要使用定时器改进这个问题</li></ul><p>这个处理流程是怎么样的？</p><ul><li>按下期间启动定时器 </li><li>定时器每过10ms &#x2F; 20ms就中断一次</li><li>在中断函数里测量触电的XY坐标</li><li>这样就可以得到连续的数据</li></ul><p>打开定时器Timer.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;s3c2440_soc.h&quot;</span></span><br><br><span class="hljs-comment">//定义一个宏 TIMER_NUM = 32</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TIMER_NUM  32</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL  ((void *)0)</span><br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*timer_func)</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-comment">//定义一个结构体 ，既存放有函数指针又存放有数据</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timer_desc</span> &#123;<br>        <span class="hljs-type">char</span> *name;<br>        timer_func fp;&#125;timer_desc, *p_timer_desc;<br><br><span class="hljs-comment">//我们需要往这个结构体数组里面添加函数，注册Timer函数</span><br>timer_desc timer_array[TIMER_NUM];<br><br><span class="hljs-comment">//注册Timer函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">register_timer</span><span class="hljs-params">(<span class="hljs-type">char</span> *name, timer_func fp)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">int</span> i;<br><span class="hljs-comment">//搜索这个数组，如果fp等于0的话，就表示没有占用这个数组项，我就把它填充进去</span><br><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; TIMER_NUM; i++)<br>        &#123;<br>                <span class="hljs-keyword">if</span> (!timer_array[i].fp)<br>                &#123;        <br>                         [i].name = name;<br>                        timer_array[i].fp   = fp;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//注册成功</span><br>                &#125;<br>        &#125;<br>        <span class="hljs-comment">//否则，表示已经满了，注册失败</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们不需要使用Timer定时器的时候unregister_timer函数, 考虑到我们需要从数组里面把这个Timer去掉，我们怎么找到这个Timer？</p><p>传入一个函数指针，以后卸载使用名字找到对应的项.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unregister_timer</span><span class="hljs-params">(<span class="hljs-type">char</span> *name)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-comment">//对于unregister_timer就反过来操作，遍历每一项</span><br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; TIMER_NUM; i++)<br>        &#123;<br>        <span class="hljs-comment">//如果这个数组项里面的名字等于我传进来我名字</span><br>                <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(timer_array[i].name, name))<br>                &#123;<br>        <span class="hljs-comment">//也就表示我找到了这两项，设置成NULL</span><br>                        timer_array[i].name = <span class="hljs-literal">NULL</span>;<br>                        timer_array[i].fp   = <span class="hljs-literal">NULL</span>;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                &#125;<br>        &#125;<br>        <span class="hljs-comment">//否则return -1;找不到选择的项</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>应该让其从某个数组里面把需要定时器处理的函数依次执行，这样做，我们以后添加定时器处理函数时就不需要修改Timer.c</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs perl">void timer_ir<span class="hljs-string">q(void)</span><br>&#123;<br>        <span class="hljs-keyword">int</span> i;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; TIMER_NUM; i++)<br>        &#123;<br>        <span class="hljs-regexp">//</span>判断指针是否为空，如果不是空的话就继续执行timer_array[i].fp();这个函数<br>                <span class="hljs-keyword">if</span> (timer_array[i].fp)<br>                &#123;<br>                        timer_array[i].fp();<br>                &#125;<br>        &#125;        <br>&#125;<br></code></pre></td></tr></table></figure><p>如果想继续点灯的话，需要单独注册led_timer_irq 在led.c文件里注册led_timer_irq 把这个函数放在led_timer_irq函数下面，防止编译错误,每10ms改函数被调用一次.</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">led_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-comment">/* 设置GPFCON让GPF4/5/6配置为输出引脚 */</span><br>        GPFCON &amp;= ~((<span class="hljs-number">3</span>&lt;&lt;<span class="hljs-number">8</span>) | (<span class="hljs-number">3</span>&lt;&lt;<span class="hljs-number">10</span>) | (<span class="hljs-number">3</span>&lt;&lt;<span class="hljs-number">12</span>));<br>        GPFCON |=  ((<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">8</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">10</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">12</span>));<br>    <span class="hljs-comment">//led是名字，led_timer_irq是函数指针</span><br>        <span class="hljs-built_in">register_timer</span>(<span class="hljs-string">&quot;led&quot;</span>, led_timer_irq);<br>&#125;<br><br><span class="hljs-comment">/* 每10ms该函数被调用一次  </span><br><span class="hljs-comment"> * 每500ms操作一下LED实现计数 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">led_timer_irq</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-comment">/* 点灯计数 */</span><br>        <span class="hljs-type">static</span> <span class="hljs-type">int</span> timer_num = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">static</span> <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> tmp;<br><br>        timer_num++;<br>        <span class="hljs-keyword">if</span> (timer_num &lt; <span class="hljs-number">50</span>)<br>                <span class="hljs-keyword">return</span>;<br>        timer_num = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//操作led</span><br>        cnt++;<br><br>        tmp = ~cnt;<br>        tmp &amp;= <span class="hljs-number">7</span>;<br>        GPFDAT &amp;= ~(<span class="hljs-number">7</span>&lt;&lt;<span class="hljs-number">4</span>);<br>        GPFDAT |= (tmp&lt;&lt;<span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>修改main.c</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs scss">int <span class="hljs-selector-tag">main</span>(void)<br>&#123;<br>        <span class="hljs-built_in">led_init</span>();<span class="hljs-comment">//初始化led</span><br>        <span class="hljs-comment">//interrupt_init();    /* 初始化中断控制器 */</span><br>        <span class="hljs-built_in">key_eint_init</span>();       <span class="hljs-comment">/* 初始化按键, 设为中断源 */</span><br>        <span class="hljs-built_in">timer_init</span>();<span class="hljs-comment">//打开定时器</span><br>        <br>        <span class="hljs-built_in">puts</span>(&quot;\n\rg_A = &quot;);<br>        <span class="hljs-built_in">printHex</span>(g_A);<br>        <span class="hljs-built_in">puts</span>(&quot;\n\r&quot;);<br><br>        <span class="hljs-comment">//nor_flash_test();</span><br>        <span class="hljs-built_in">lcd_test</span>();<br><br>        <span class="hljs-comment">//adc_test();</span><br><br>        <span class="hljs-built_in">touchscreen_test</span>();<br><br>        while (<span class="hljs-number">1</span>);<br>        <br>        return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改timer.c文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs awk">void timer_init(void)<br>&#123;<br>        <span class="hljs-regexp">/* 设置TIMER0的时钟 修改时钟频录让其10ms中断一次 */</span><br>        <span class="hljs-regexp">/* Timer clk = PCLK /</span> &#123;prescaler value+<span class="hljs-number">1</span>&#125; / &#123;divider value&#125;<br>                     = <span class="hljs-number">50000000</span><span class="hljs-regexp">/(49+1)/</span><span class="hljs-number">16</span>              <br>                     = <span class="hljs-number">62500</span>  <br>        */<br>        TCFG0 = <span class="hljs-number">49</span>;  <span class="hljs-regexp">/* Prescaler 0 = 49, 用于timer0,1 */</span><br>        TCFG1 &amp;= ~<span class="hljs-number">0</span>xf;<br>        TCFG1 |= <span class="hljs-number">3</span>;  <span class="hljs-regexp">/* MUX0 : 1/</span><span class="hljs-number">16</span> */<br><br>        <span class="hljs-regexp">/* 设置TIMER0的初值 */</span><br>        TCNTB0 = <span class="hljs-number">625</span>;  <span class="hljs-regexp">/* 10Ms中断一次 */</span><br><br>        <span class="hljs-regexp">/* 加载初值, 启动timer0 */</span><br>        TCON |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>);   <span class="hljs-regexp">/* Update from TCNTB0 &amp; TCMPB0 */</span><br><br>        <span class="hljs-regexp">/* 设置为自动加载并启动 */</span><br>        TCON &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>);<br>        TCON |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">3</span>);  <span class="hljs-regexp">/* bit0: start, bit3: auto reload */</span><br><br>        <span class="hljs-regexp">/* 设置中断 */</span><br>        register_irq(<span class="hljs-number">10</span>, timer_irq);<br>&#125;<br></code></pre></td></tr></table></figure><p>烧写到nandflash发现无输出，可能是前重定位前的代码超出了4k，所以我们使用Norflash启动,发现可以正常运行</p><p>我们修改Makefile把负责重定位代码往前移，其他无关代码往后放,接着看star.S</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">.text</span><br><span class="hljs-symbol">.global</span> _start<br><br><span class="hljs-symbol">_start:</span><br>        <span class="hljs-keyword">b</span> reset                    <span class="hljs-comment">/* vector 0 : reset */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, und_addr           <span class="hljs-comment">/* vector 4 : und */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, swi_addr           <span class="hljs-comment">/* vector 8 : swi */</span><br>        <span class="hljs-keyword">b</span> halt                     <span class="hljs-comment">/* vector 0x0c : prefetch aboot */</span><br>        <span class="hljs-keyword">b</span> halt                     <span class="hljs-comment">/* vector 0x10 : data abort */</span><br>        <span class="hljs-keyword">b</span> halt                     <span class="hljs-comment">/* vector 0x14 : reserved */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, irq_addr           <span class="hljs-comment">/* vector 0x18 : irq */</span><br>        <span class="hljs-keyword">b</span> halt                     <span class="hljs-comment">/* vector 0x1c : fiq */</span><br><br><span class="hljs-comment">//我们需要把这些异常往后放</span><br><span class="hljs-symbol">und_addr:</span><br>        <span class="hljs-meta">.word</span> do_und<br><br><span class="hljs-symbol">swi_addr:</span><br>        <span class="hljs-meta">.word</span> do_swi<br><br><span class="hljs-symbol">irq_addr:</span><br>        <span class="hljs-meta">.word</span> do_irq<br><br><span class="hljs-symbol">reset:</span><br>        <span class="hljs-comment">/* 关闭看门狗 */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-number">=0x53000000</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r1</span>, <span class="hljs-number">=0</span><br>        <span class="hljs-keyword">str</span> <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r0</span>]<br>        <br>        <span class="hljs-comment">/* 设置MPLL, FCLK : HCLK : PCLK = 400m : 100m : 50m */</span><br>        <span class="hljs-comment">/* LOCKTIME(0x4C000000) = 0xFFFFFFFF */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-number">=0x4C000000</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r1</span>, <span class="hljs-number">=0xFFFFFFFF</span><br>        <span class="hljs-keyword">str</span> <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r0</span>]<br><br>        <span class="hljs-comment">/* CLKDIVN(0x4C000014) = 0X5, tFCLK:tHCLK:tPCLK = 1:4:8  */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-number">=0x4C000014</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r1</span>, <span class="hljs-number">=0x5</span><br>        <span class="hljs-keyword">str</span> <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r0</span>]<br><br>        <span class="hljs-comment">/* 设置CPU工作于异步模式 */</span><br>        <span class="hljs-keyword">mrc</span> <span class="hljs-built_in">p15</span>,<span class="hljs-number">0</span>,<span class="hljs-built_in">r0</span>,<span class="hljs-built_in">c1</span>,<span class="hljs-built_in">c0</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">orr</span> <span class="hljs-built_in">r0</span>,<span class="hljs-built_in">r0</span>,<span class="hljs-number">#0xc0000000</span>   <span class="hljs-comment">//R1_nF:OR:R1_iA</span><br>        mcr <span class="hljs-built_in">p15</span>,<span class="hljs-number">0</span>,<span class="hljs-built_in">r0</span>,<span class="hljs-built_in">c1</span>,<span class="hljs-built_in">c0</span>,<span class="hljs-number">0</span><br><br>        <span class="hljs-comment">/* 设置MPLLCON(0x4C000004) = (92&lt;&lt;12)|(1&lt;&lt;4)|(1&lt;&lt;0)   </span><br><span class="hljs-comment">         *  m = MDIV+8 = 92+8=100  </span><br><span class="hljs-comment">         *  p = PDIV+2 = 1+2 = 3  </span><br><span class="hljs-comment">         *  s = SDIV = 1  </span><br><span class="hljs-comment">         *  FCLK = 2*m*Fin/(p*2^s) = 2*100*12/(3*2^1)=400M  </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-number">=0x4C000004</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r1</span>, =(<span class="hljs-number">92</span>&lt;&lt;<span class="hljs-number">12</span>)<span class="hljs-title">|(1&lt;&lt;4)|</span>(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">str</span> <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r0</span>]<br><br>        <span class="hljs-comment">/* 一旦设置PLL, 就会锁定lock time直到PLL输出稳定  </span><br><span class="hljs-comment">         * 然后CPU工作于新的频率FCLK  </span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-comment">/* 设置内存: sp 栈 */</span><br>        <span class="hljs-comment">/* 分辨是nor/nand启动  </span><br><span class="hljs-comment">         * 写0到0地址, 再读出来  </span><br><span class="hljs-comment">         * 如果得到0, 表示0地址上的内容被修改了, 它对应ram, 这就是nand启动  </span><br><span class="hljs-comment">         * 否则就是nor启动  </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">r1</span>, <span class="hljs-number">#0</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, [<span class="hljs-built_in">r1</span>] <span class="hljs-comment">/* 读出原来的值备份 */</span><br>        <span class="hljs-keyword">str</span> <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r1</span>] <span class="hljs-comment">/* 0-&gt;[0] */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r2</span>, [<span class="hljs-built_in">r1</span>] <span class="hljs-comment">/* r2=[0] */</span><br>        <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">r1</span>, <span class="hljs-built_in">r2</span>   <span class="hljs-comment">/* r1==r2? 如果相等表示是NAND启动 */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">=0x40000000</span>+<span class="hljs-number">4096</span> <span class="hljs-comment">/* 先假设是nor启动 */</span><br>        <span class="hljs-keyword">moveq</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">#4096</span>  <span class="hljs-comment">/* nand启动 */</span><br>         <span class="hljs-keyword">streq</span> <span class="hljs-built_in">r0</span>, [<span class="hljs-built_in">r1</span>]   <span class="hljs-comment">/* 恢复原来的值 */</span><br><br>        <span class="hljs-keyword">bl</span> sdram_init<br>        <span class="hljs-comment">//bl sdram_init2  /* 用到有初始值的数组, 不是位置无关码 */</span><br><br>        <span class="hljs-comment">/* 重定位text, rodata, data段整个程序 */</span><br>        <span class="hljs-keyword">bl</span> copy2sdram<br><br>        <span class="hljs-comment">/* 清除BSS段 */</span><br>        <span class="hljs-keyword">bl</span> clean_bss<br><br>        <span class="hljs-comment">/* 复位之后, cpu处于svc模式  </span><br><span class="hljs-comment">         * 现在, 切换到usr模式  </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">mrs</span> <span class="hljs-built_in">r0</span>, <span class="hljs-keyword">cpsr</span>         <span class="hljs-comment">/* 读出cpsr */</span><br>        <span class="hljs-keyword">bic</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">r0</span>, <span class="hljs-number">#0xf</span>     <span class="hljs-comment">/* 修改M4-M0为0b10000, 进入usr模式 */</span><br>        <span class="hljs-keyword">bic</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">r0</span>, #(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">7</span>)  <span class="hljs-comment">/* 清除I位, 使能中断 */</span><br>        <span class="hljs-keyword">msr</span> cpsr, <span class="hljs-built_in">r0</span><br><br>        <span class="hljs-comment">/* 设置 sp_usr */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">=0x33f00000</span><br><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, <span class="hljs-symbol">=sdram</span><br><span class="hljs-symbol">sdram:</span><br>        <span class="hljs-keyword">bl</span> uart0_init<br><br>        <span class="hljs-keyword">bl</span> print1<br>        <span class="hljs-comment">/* 故意加入一条未定义指令 */</span><br></code></pre></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">init.c 需要放在前面<br>nand<span class="hljs-emphasis">_init</span><br><span class="hljs-emphasis">sdram_</span>init初始化也放前面<br>sdram:<br></code></pre></td></tr></table></figure><p>bl uart0_init</p><p>这就跳到sdram了，重定位后就随便操作</p><p>修改Makefile 我们把 start.o init.o nand_flash.o放在最前面</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objs = start.o init.o nand_flash.o led.o uart.o main.o exception.o interrupt.o timer.o nor_flash.o my_printf.o string_utils.o lib1funcs.o<br><br>objs += lcd/font.o<br>objs += lcd/framebuffer.o<br>objs += lcd/geometry.o<br>objs += lcd/lcd.o<br>objs += lcd/lcd_4.3.o<br>objs += lcd/lcd_controller.o<br>objs += lcd/lcd_test.o<br>objs += lcd/s3c2440_lcd_controller.o<br>objs += lcd/font_8x16.o<br><br>objs += adc_touchscreen/adc.o<br>objs += adc_touchscreen/adc_test.o<br><br>objs += adc_touchscreen/touchscreen.o<br>objs += adc_touchscreen/touchscreen_test.o<br><br><span class="hljs-section">all: <span class="hljs-variable">$(objs)</span></span><br>        <span class="hljs-comment">#arm-linux-ld -Ttext 0 -Tdata 0x30000000  start.o led.o uart.o init.o main.o -o sdram.elf</span><br>        arm-linux-ld -T sdram.lds <span class="hljs-variable">$^</span> libgcc.a -o sdram.elf<br>        arm-linux-objcopy -O binary -S sdram.elf sdram.bin<br>        arm-linux-objdump -D sdram.elf &gt; sdram.dis<br><span class="hljs-section">clean:</span><br>        rm -f *.bin <span class="hljs-variable">$(objs)</span> *.elf *.dis<br>        <br>%.o : %.c<br>        arm-linux-gcc -march=armv4 -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><br>%.o : %.S<br>        arm-linux-gcc -march=armv4 -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br></code></pre></td></tr></table></figure><p>这节课讲定时器的优化, 下节课讲怎么使用定时器来改进触摸屏</p><p><strong>第008节_触摸屏编程_使用定时器支持长按</strong></p><hr><p>可以使用定时器把长按或者滑动触摸屏的值读出来,我们按下触摸屏就会产生触摸屏中断，这个时候可以启动ADC,ADC成功后再次产生中段,在这个中断中启动定时器,我们也可以在触摸屏中断里启动定时器.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;../s3c2440_soc.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADC_INT_BIT (10)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TC_INT_BIT  (9)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INT_ADC_TC   (31)</span><br><br><span class="hljs-comment">/* ADCTSC&#x27;s bits */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WAIT_PEN_DOWN    (0&lt;&lt;8)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WAIT_PEN_UP      (1&lt;&lt;8)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> YM_ENABLE        (1&lt;&lt;7)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> YM_DISABLE       (0&lt;&lt;7)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> YP_ENABLE        (0&lt;&lt;6)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> YP_DISABLE       (1&lt;&lt;6)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XM_ENABLE        (1&lt;&lt;5)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XM_DISABLE       (0&lt;&lt;5)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XP_ENABLE        (0&lt;&lt;4)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XP_DISABLE       (1&lt;&lt;4)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PULLUP_ENABLE    (0&lt;&lt;3)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PULLUP_DISABLE   (1&lt;&lt;3)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AUTO_PST         (1&lt;&lt;2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WAIT_INT_MODE    (3)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NO_OPR_MODE      (0)</span><br><br><span class="hljs-comment">//定义一个全局变量设置timer状态</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> g_ts_timer_enable = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">adc_ts_int_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        SUBSRCPND = (<span class="hljs-number">1</span>&lt;&lt;TC_INT_BIT) | (<span class="hljs-number">1</span>&lt;&lt;ADC_INT_BIT);<br><span class="hljs-comment">//注册中断处理函数，才可以在处理函数中启动定时器</span><br><br>        <span class="hljs-comment">/* 注册中断处理函数 */</span><br>        <span class="hljs-built_in">register_irq</span>(<span class="hljs-number">31</span>, AdcTsIntHandle);<br><br>        <span class="hljs-comment">/* 使能中断 */</span><br>        INTSUBMSK &amp;= ~((<span class="hljs-number">1</span>&lt;&lt;ADC_INT_BIT) | (<span class="hljs-number">1</span>&lt;&lt;TC_INT_BIT));<br>        <span class="hljs-comment">//INTMSK    &amp;= ~(1&lt;&lt;INT_ADC_TC);&#125;</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">touchscreen_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-comment">/* 设置触摸屏接口:寄存器 */</span><br>        <span class="hljs-built_in">adc_ts_reg_init</span>();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ADCUPDN = 0x%x, SUBSRCPND = 0x%x, SRCPND = 0x%x\n\r&quot;</span>, ADCUPDN, SUBSRCPND, SRCPND);<br><br>        <span class="hljs-comment">/* 设置中断 */</span><br>        <span class="hljs-built_in">adc_ts_int_init</span>();<br><br>        <span class="hljs-comment">/* 注册定时器处理函数 */</span><br>    <span class="hljs-comment">//首先是一个名字，其次是定时器处理函数</span><br>        <span class="hljs-built_in">register_timer</span>(<span class="hljs-string">&quot;touchscreen&quot;</span>, touchscreen_timer_irq);<br><br>        <span class="hljs-comment">/* 让触摸屏控制器进入&quot;等待中断模式&quot; */</span><br>        <span class="hljs-built_in">enter_wait_pen_down_mode</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>进入touchscreen.c adc中断处理函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Isr_Adc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">int</span> x = ADCDAT0;<br>        <span class="hljs-type">int</span> y = ADCDAT1;<br><br>        <span class="hljs-keyword">if</span> (!(x &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>))) <span class="hljs-comment">/* 如果仍然按下才打印 */</span><br>        &#123;<br>                x &amp;= <span class="hljs-number">0x3ff</span>;<br>                y &amp;= <span class="hljs-number">0x3ff</span>;<br>                <br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x = %08d, y = %08d\n\r&quot;</span>, x, y);<br>    <span class="hljs-comment">//添加定时器函数</span><br>                <span class="hljs-comment">/* 启动定时器以再次读取数据 */</span><br>                <span class="hljs-built_in">ts_timer_enable</span>();<br>        &#125;<br>    <span class="hljs-comment">//松开操作</span><br>        <span class="hljs-keyword">else</span><br>        &#123;<br>                <span class="hljs-built_in">ts_timer_disable</span>();<br>                <span class="hljs-built_in">enter_wait_pen_down_mode</span>();<br>        &#125;<br>        <span class="hljs-built_in">enter_wait_pen_up_mode</span>();<br>&#125;<br><br><span class="hljs-comment">//触摸屏定时器处理函数</span><br><span class="hljs-comment">/* 每10ms该函数被调用一次  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">touchscreen_timer_irq</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-comment">/* 如果触摸屏仍被按下, 进入&quot;自动测量模式&quot;, 启动ADC */</span><br>    <span class="hljs-comment">//如果定时器并没有被使能，则return</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">get_status_of_ts_timer</span>() == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">//如果松开，则什么事情都不做</span><br>        <span class="hljs-keyword">if</span> (ADCDAT0 &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>)) <span class="hljs-comment">/* 如果松开 */</span><br>        &#123;<br>    <span class="hljs-comment">//设置定时器状态</span><br>                <span class="hljs-built_in">ts_timer_disable</span>();<br>    <span class="hljs-comment">//触摸笔进入等待模式</span><br>                <span class="hljs-built_in">enter_wait_pen_down_mode</span>();<br>                <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>    <span class="hljs-comment">//否则启动测量</span><br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 按下状态，启动下一次测量 */</span><br>        &#123;<br>                <span class="hljs-comment">/* 进入&quot;自动测量&quot;模式 */</span><br>                <span class="hljs-built_in">enter_auto_measure_mode</span>();<br><br>                <span class="hljs-comment">/* 启动ADC */</span><br>                ADCCON |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>);<br>        &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">ts_timer_enable</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//我们使用定时器时把它的状态设置为1</span><br>        g_ts_timer_enable = <span class="hljs-number">1</span>;<br>&#125;<br><br>    <span class="hljs-comment">//有启用定时器就有关闭定时器</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">ts_timer_disable</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//我们不使用定时器把定时器状态设置为0</span><br>        g_ts_timer_enable = <span class="hljs-number">0</span>;<br>&#125;<br><br>    <span class="hljs-comment">//我们如何获取定时器状态？</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">get_status_of_ts_timer</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//返回定时器状态</span><br>        <span class="hljs-keyword">return</span> g_ts_timer_enable;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们回顾一下处理过程，根据流程图分析</p><ul><li>首先从main.c函数开始</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scss">int <span class="hljs-selector-tag">main</span>(void)<br>&#123;<br>        <span class="hljs-built_in">led_init</span>();<br>        <span class="hljs-comment">//interrupt_init();  /* 初始化中断控制器 */</span><br>        <span class="hljs-built_in">key_eint_init</span>();     <span class="hljs-comment">/* 初始化按键, 设为中断源 */</span><br>        <span class="hljs-built_in">timer_init</span>();<br>        <br>        <span class="hljs-built_in">puts</span>(&quot;\n\rg_A = &quot;);<br>        <span class="hljs-built_in">printHex</span>(g_A);<br>        <span class="hljs-built_in">puts</span>(&quot;\n\r&quot;);<br>        <span class="hljs-comment">//nor_flash_test();</span><br>        <span class="hljs-built_in">lcd_test</span>();<br>        <span class="hljs-comment">//adc_test();</span><br>           <span class="hljs-comment">//执行touchscreen_test</span><br>        <span class="hljs-built_in">touchscreen_test</span>();<br>        while (<span class="hljs-number">1</span>);<br>        <br>        return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>进入touchscreen_test.c文件执行init初始化程序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">touchscreen_test</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>        <span class="hljs-title function_">touchscreen_init</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>进入touchscreen.c文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs awk">void touchscreen_init(void)<br>&#123;<br>        <span class="hljs-regexp">/* 设置触摸屏接口:寄存器 */</span><br>        adc_ts_reg_init();<br><br>        printf(<span class="hljs-string">&quot;ADCUPDN = 0x%x, SUBSRCPND = 0x%x, SRCPND = 0x%x\n\r&quot;</span>, ADCUPDN, SUBSRCPND, SRCPND);<br><br>        <span class="hljs-regexp">/* 设置中断 */</span><br>        adc_ts_int_init();<br><br>        <span class="hljs-regexp">/* 让触摸屏控制器进入&quot;等待中断模式&quot; */</span><br>        enter_wait_pen_down_mode();<br>&#125;<br><br>void adc_ts_reg_init(void)<br>&#123;<br>        <span class="hljs-regexp">/* [15] : ECFLG,  1 = End of A/</span>D conversion  <br>         * [<span class="hljs-number">14</span>] : PRSCEN, <span class="hljs-number">1</span> = A/D converter prescaler enable  <br>         * [<span class="hljs-number">13</span>:<span class="hljs-number">6</span>]: PRSCVL, adc clk = PCLK / (PRSCVL + <span class="hljs-number">1</span>)  <br>         * [<span class="hljs-number">5</span>:<span class="hljs-number">3</span>] : SEL_MUX, <span class="hljs-number">000</span> = AIN <span class="hljs-number">0</span>  * [<span class="hljs-number">2</span>]   : STDBM  <br>         * [<span class="hljs-number">0</span>]   : <span class="hljs-number">1</span> = A/D conversion starts and this bit is cleared after the startup.  <br>         */<br>        ADCCON = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">14</span>) | (<span class="hljs-number">49</span>&lt;&lt;<span class="hljs-number">6</span>) | (<span class="hljs-number">0</span>&lt;&lt;<span class="hljs-number">3</span>);<br><br>        /*  按下触摸屏, 延时一会再发出TC中断  <br>         *  延时时间 = ADCDLY <br>         * 晶振周期 = ADCDLY <br>         * <span class="hljs-number">1</span> / <span class="hljs-number">12000000</span> = <span class="hljs-number">5</span>ms  <br>         */<br>        ADCDLY = <span class="hljs-number">60000</span>;      <br>&#125;<br><br><span class="hljs-regexp">//</span>进入adc触摸屏中断处理<br>void adc_ts_int_init(void)<br>&#123;<br>        SUBSRCPND = (<span class="hljs-number">1</span>&lt;&lt;TC_INT_BIT) | (<span class="hljs-number">1</span>&lt;&lt;ADC_INT_BIT);<br><br>        <span class="hljs-regexp">/* 注册中断处理函数 */</span><br>        register_irq(<span class="hljs-number">31</span>, AdcTsIntHandle);<br><br>        <span class="hljs-regexp">/* 使能中断 */</span><br>        INTSUBMSK &amp;= ~((<span class="hljs-number">1</span>&lt;&lt;ADC_INT_BIT) | (<span class="hljs-number">1</span>&lt;&lt;TC_INT_BIT));<br>        <span class="hljs-regexp">//</span>INTMSK    &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;INT_ADC_TC);<br>&#125;<br><br>void AdcTsIntHandle(int irq)<br>&#123;<br>        <span class="hljs-keyword">if</span> (SUBSRCPND &amp; (<span class="hljs-number">1</span>&lt;&lt;TC_INT_BIT))  <span class="hljs-regexp">/* 如果是触摸屏中断 */</span><br>                Isr_Tc();<br><br>        <span class="hljs-keyword">if</span> (SUBSRCPND &amp; (<span class="hljs-number">1</span>&lt;&lt;ADC_INT_BIT))  <span class="hljs-regexp">/* ADC中断 */</span><br>                Isr_Adc();<br>        SUBSRCPND = (<span class="hljs-number">1</span>&lt;&lt;TC_INT_BIT) | (<span class="hljs-number">1</span>&lt;&lt;ADC_INT_BIT);<br>&#125;<br><br><span class="hljs-regexp">//</span>进入触摸屏处理函数<br><span class="hljs-regexp">//</span>触摸屏定时器处理函数<br><span class="hljs-regexp">/* 每10ms该函数被调用一次  */</span><br>void touchscreen_timer_irq(void)<br>&#123;<br>        <span class="hljs-regexp">/* 如果触摸屏仍被按下, 进入&quot;自动测量模式&quot;, 启动ADC */</span><br>    <span class="hljs-regexp">//</span>如果定时器并没有被使能，则return<br>        <span class="hljs-keyword">if</span> (get_status_of_ts_timer() == <span class="hljs-number">0</span>)<br>                return;<br>    <span class="hljs-regexp">//</span>如果松开，则什么事情都不做<br>        <span class="hljs-keyword">if</span> (ADCDAT0 &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>)) <span class="hljs-regexp">/* 如果松开 */</span><br>        &#123;<br>    <span class="hljs-regexp">//</span>设置定时器状态<br>                ts_timer_disable();<br>    <span class="hljs-regexp">//</span>触摸笔进入等待模式<br>                enter_wait_pen_down_mode();<br>                return;<br>        &#125;<br><br>    <span class="hljs-regexp">//</span>否则启动测量<br>        <span class="hljs-keyword">else</span>  <span class="hljs-regexp">/* 按下状态，启动下一次测量 */</span><br>        &#123;<br>                <span class="hljs-regexp">/* 进入&quot;自动测量&quot;模式 */</span><br>                enter_auto_measure_mode();<br><br>                <span class="hljs-regexp">/* 启动ADC */</span><br>                ADCCON |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第009节_触摸屏编程_较准原理</strong></p><hr><p>我们需要校准触摸屏，所谓校准就是找到一个公式把电压值转换为坐标值</p><p>触摸屏和LCD是两个东西,触摸屏覆盖在LCD上.</p><p><img src="/image/Chapter18_lesson9_001.png" alt="Chapter18_lesson9_001.png"></p><p><strong>问：得到触电的(x1,y1)怎么换算出LCD的坐标值 (X,Y)?</strong></p><p><img src="/image/Chapter18_lesson9_002.png" alt="Chapter18_lesson9_002.png"></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">x</span><span class="hljs-operator">=</span><span class="hljs-number">479</span><span class="hljs-number">-0</span>/<span class="hljs-keyword">x</span><span class="hljs-number">2</span>-<span class="hljs-keyword">x</span><span class="hljs-number">1</span> * (<span class="hljs-keyword">x</span><span class="hljs-number">3</span>-<span class="hljs-keyword">x</span><span class="hljs-number">1</span>) + <span class="hljs-number">0</span><br><span class="hljs-keyword">x</span><span class="hljs-operator">=</span>长度的比例<br><span class="hljs-keyword">x</span><span class="hljs-number">1</span> <span class="hljs-number">0</span> 原点的触摸屏/LCD坐标<br></code></pre></td></tr></table></figure><p>我们只需要确定两个点就可以把lcd坐标确定下来，但是我们可以做的更好</p><p>假设由于制作工艺问题，导致触摸屏和LCD坐标并不相同，需要其他公式计算</p><ul><li>X轴方向</li></ul><p><img src="/image/Chapter18_lesson9_003.png" alt="Chapter18_lesson9_003.png"></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-built_in">s1</span><span class="hljs-string">&#x27;是TS上X轴两个点的距离</span><br><span class="hljs-string">s1 是LCD上X轴两个点的距离</span><br><span class="hljs-string">s2&#x27;</span> <span class="hljs-built_in">s2</span><br></code></pre></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">Kx= LCD距离/触摸屏距离<br><span class="hljs-section">= (s1 + s2) / (s1&#x27; + s2&#x27;)</span><br><span class="hljs-section">= 2s/(s1&#x27; + s2&#x27;)</span><br></code></pre></td></tr></table></figure><ul><li>Y轴方向</li></ul><p><img src="/image/Chapter18_lesson9_004.png" alt="Chapter18_lesson9_004.png"></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">TS</span>距离是<span class="hljs-built_in">d1</span><span class="hljs-string">&#x27;</span><br><span class="hljs-string">LCD距离是d1</span><br></code></pre></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">Ky=(d1 <span class="hljs-code">+ d2) / (d1&#x27; +</span> d2&#x27;)<br><span class="hljs-section">= 2d / (d1&#x27; + d2&#x27;)</span><br></code></pre></td></tr></table></figure><p>我们现在有了斜率，给定一个坐标，我们需要需要原点的触屏LCD坐标</p><p>原点我们选在最中间 可以忽略掉上下左右的偏差</p><p><img src="/image/Chapter18_lesson9_005.png" alt="Chapter18_lesson9_005.png"></p><p>原点坐标在触摸屏上是xc’ yc’,在LCD上是 xc yc ,那我们的校准公式,对于给定的x3,我们如何求出x</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">X</span>= (x3 - xc<span class="hljs-string">&#x27; ) * Kx + xc</span><br></code></pre></td></tr></table></figure><p>对于给定的y’我们如何算出Y轴坐标？</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">y</span> = (y<span class="hljs-string">&#x27; - yc&#x27;</span>) * Ky + yc<br></code></pre></td></tr></table></figure><p>我们需要点击触摸屏上这5个点，同时需要把这五个点坐标打印显示出来.</p><p>这节视频我们讲的时校准原理</p><p><strong>第010节_触摸屏编程_较准与画线编</strong></p><hr><p>这个程序我们怎么写</p><p><img src="/image/Chapter18_lesson9_005.png" alt="Chapter18_lesson9_005.png"></p><p>我们需要得到这5个点的坐标 给这5个点分别设置为ABCDE</p><p>第一步</p><ul><li>在A点显示 +</li><li>客户点击 +</li><li>记录触摸屏的坐标</li><li>在BCDE上循环操作,显示点击读取的操作</li></ul><p>第二步</p><ul><li>根据这些数据，确定公式</li></ul><p>第三步</p><ul><li>以后得到TS触点时，可转换出LCD坐标</li></ul><p>我们需要实现这几个函数</p><p>显示 + 在x y 中显示 fb_disp_cross(int x , int y)</p><p>如何记录 ts_read_raw ,读到原始数据,根据这些数据，确定公式 ts_calibrate</p><p><strong>如何转换出LCD坐标?</strong></p><p>ts_read</p><p>我们实现这几个函数</p><ul><li><p>我们先实现 +</p></li><li><p>我们既然画线就在geometry.c中实现</p></li></ul><p><img src="/image/Chapter18_lesson10_002.png" alt="Chapter18_lesson10_002.png"></p><p>画十字架, 原点x,y</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">x</span>-<span class="hljs-number">10</span> y<br><span class="hljs-attribute">x</span>+<span class="hljs-number">10</span> y<br><span class="hljs-attribute">x</span> y+<span class="hljs-number">10</span><br><span class="hljs-attribute">x</span> y+<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void fb<span class="hljs-constructor">_disp_cross(<span class="hljs-params">int</span> <span class="hljs-params">x</span>, <span class="hljs-params">int</span> <span class="hljs-params">y</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">color</span>)</span><br>&#123;<br>        draw<span class="hljs-constructor">_line(<span class="hljs-params">x</span>-10, <span class="hljs-params">y</span>, <span class="hljs-params">x</span>+10, <span class="hljs-params">y</span>, <span class="hljs-params">color</span>)</span>;<br>        draw<span class="hljs-constructor">_line(<span class="hljs-params">x</span>, <span class="hljs-params">y</span>-10, <span class="hljs-params">x</span>, <span class="hljs-params">y</span>+10, <span class="hljs-params">color</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编辑touchscreen.c</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//+ 坐标的x值</span><br>static <span class="hljs-built_in">int</span> g_ts_x;<br><span class="hljs-comment">//+ 坐标Y值</span><br>static <span class="hljs-built_in">int</span> g_ts_y;<br><br><span class="hljs-comment">//表示数据并未有效</span><br><span class="hljs-comment">//设置成volatile类型，有两个地方会用到一个是中断report_ts_xy</span><br><span class="hljs-comment">//另一个是程序ts_read_raw，我们一定确保这个值是从内存中读取出来</span><br><span class="hljs-comment">//让双方得到真实的值</span><br>static　volatile <span class="hljs-built_in">char</span> g_ts_data_valid = <span class="hljs-number">0</span>;<br><br>void <span class="hljs-constructor">Isr_Adc(<span class="hljs-params">void</span>)</span><br>&#123;<br>        <span class="hljs-built_in">int</span> x = ADCDAT0;<br>        <span class="hljs-built_in">int</span> y = ADCDAT1;<br><br>        <span class="hljs-keyword">if</span> (!(x &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>))) <span class="hljs-comment">/* 如果仍然按下才打印 */</span><br>        &#123;<br>                x &amp;= <span class="hljs-number">0x3ff</span>;<br>                y &amp;= <span class="hljs-number">0x3ff</span>;<br>            <span class="hljs-comment">//我们现在不能打印               </span><br>                <span class="hljs-comment">//printf(&quot;x = %08d, y = %08d\n\r&quot;, x, y);</span><br>            <span class="hljs-comment">//实现report_ts_xy函数来打印</span><br>                report<span class="hljs-constructor">_ts_xy(<span class="hljs-params">x</span>, <span class="hljs-params">y</span>)</span>;<br><br>                <span class="hljs-comment">/* 启动定时器以再次读取数据 */</span><br>                ts<span class="hljs-constructor">_timer_enable()</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>                ts<span class="hljs-constructor">_timer_disable()</span>;<br>                enter<span class="hljs-constructor">_wait_pen_down_mode()</span>;<br>        &#125;<br><br>        enter<span class="hljs-constructor">_wait_pen_up_mode()</span>;<br>&#125;<br><br><span class="hljs-comment">//report_ts_xy函数的实现</span><br><br>void report<span class="hljs-constructor">_ts_xy(<span class="hljs-params">int</span> <span class="hljs-params">x</span>, <span class="hljs-params">int</span> <span class="hljs-params">y</span>)</span><br>&#123;<br>        <span class="hljs-comment">//printf(&quot;x = %08d, y = %08d\n\r&quot;, x, y);</span><br>    <span class="hljs-comment">//一开始标记位=0表示没有数据</span><br>        <span class="hljs-keyword">if</span> (g_ts_data_valid<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)<br>        &#123;<br>                g_ts_x = x;<br>                g_ts_y = y;<br>                g_ts_data_valid = <span class="hljs-number">1</span>;<br>        &#125;<br>&#125;<br><br><span class="hljs-comment">//读到原始数据</span><br>void ts<span class="hljs-constructor">_read_raw(<span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">px</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">py</span>)</span><br>&#123;<br>    <span class="hljs-comment">//当按下触摸屏时会产生ADC中断</span><br>        <span class="hljs-keyword">while</span> (g_ts_data_valid<span class="hljs-operator"> == </span><span class="hljs-number">0</span>);<br>        *px = g_ts_x;<br>        *py = g_ts_y;<br>    <span class="hljs-comment">//读完数据清零</span><br>        g_ts_data_valid = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们实现ts_calibrate校准函数,在tslib.c文件中</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//设置斜率为全局变量</span><br>static double g_kx;<br>static double g_ky;<br>static <span class="hljs-built_in">int</span> g_ts_xc, g_ts_yc;<br>static <span class="hljs-built_in">int</span> g_lcd_xc, g_lcd_yc;<br><br><span class="hljs-comment">//加一个调换的全局变量</span><br>static <span class="hljs-built_in">int</span> g_ts_xy_swap = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">----------------------------</span><br><span class="hljs-comment">|                          |</span><br><span class="hljs-comment">|  +(A)              (B)+  |</span><br><span class="hljs-comment">|                          |</span><br><span class="hljs-comment">|                          |</span><br><span class="hljs-comment">|                          |</span><br><span class="hljs-comment">|            +(E)          |</span><br><span class="hljs-comment">|                          |</span><br><span class="hljs-comment">|                          |</span><br><span class="hljs-comment">|                          |</span><br><span class="hljs-comment">|  +(D)              (C)+  |</span><br><span class="hljs-comment">|                          |</span><br><span class="hljs-comment">----------------------------</span><br><span class="hljs-comment">*/</span><br>把ABCDE这<span class="hljs-number">5</span>个点都实现<br><br>void ts<span class="hljs-constructor">_calibrate(<span class="hljs-params">void</span>)</span><br>&#123;<br>        unsigned <span class="hljs-built_in">int</span> fb_base;<br>        <span class="hljs-built_in">int</span> xres, yres, bpp;<br>    <span class="hljs-comment">//定义ABCDE触摸屏坐标</span><br>        <span class="hljs-built_in">int</span> a_ts_x, a_ts_y;<br>        <span class="hljs-built_in">int</span> b_ts_x, b_ts_y;<br>        <span class="hljs-built_in">int</span> c_ts_x, c_ts_y;<br>        <span class="hljs-built_in">int</span> d_ts_x, d_ts_y;<br>        <span class="hljs-built_in">int</span> e_ts_x, e_ts_y;<br><br>        <span class="hljs-comment">/* X轴方向 */</span><br>        <span class="hljs-built_in">int</span> ts_s1, ts_s2;<br>        <span class="hljs-built_in">int</span> lcd_s;<br><br>        <span class="hljs-comment">/* Y轴方向 */</span><br>        <span class="hljs-built_in">int</span> ts_d1, ts_d2;<br>        <span class="hljs-built_in">int</span> lcd_d;<br>    <span class="hljs-comment">//通过调用framebuffer.c里面的函数，来获取LCD坐标</span><br>        <span class="hljs-comment">/* 获得LCD的参数: fb_base, xres, yres, bpp */</span><br>        get<span class="hljs-constructor">_lcd_params(&amp;<span class="hljs-params">fb_base</span>, &amp;<span class="hljs-params">xres</span>, &amp;<span class="hljs-params">yres</span>, &amp;<span class="hljs-params">bpp</span>)</span>;<br><br>        <span class="hljs-comment">/* 对于ABCDE, 循环: 显示&quot;+&quot;、点击、读ts原始值 */</span><br>    <span class="hljs-comment">//A坐标，X分辨率50， Y分辨率50</span><br>        <span class="hljs-comment">/* A(50, 50) */</span><br>        get<span class="hljs-constructor">_calibrate_point_data(50, 50, &amp;<span class="hljs-params">a_ts_x</span>, &amp;<span class="hljs-params">a_ts_y</span>)</span>;<br>    <span class="hljs-comment">//B坐标，X分辨率-50</span><br>        <span class="hljs-comment">/* B(xres-50, 50) */</span><br>        get<span class="hljs-constructor">_calibrate_point_data(<span class="hljs-params">xres</span>-50, 50, &amp;<span class="hljs-params">b_ts_x</span>, &amp;<span class="hljs-params">b_ts_y</span>)</span>;<br>    <span class="hljs-comment">//C坐标，X分辨率-50，Y分辨率-50</span><br>        <span class="hljs-comment">/* C(xres-50, yres-50) */</span><br>        get<span class="hljs-constructor">_calibrate_point_data(<span class="hljs-params">xres</span>-50, <span class="hljs-params">yres</span>-50, &amp;<span class="hljs-params">c_ts_x</span>, &amp;<span class="hljs-params">c_ts_y</span>)</span>;<br>    <span class="hljs-comment">//D坐标，X分辨率位置50，Y分辨率-50</span><br>        <span class="hljs-comment">/* D(50, yres-50) */</span><br>        get<span class="hljs-constructor">_calibrate_point_data(50, <span class="hljs-params">yres</span>-50, &amp;<span class="hljs-params">d_ts_x</span>, &amp;<span class="hljs-params">d_ts_y</span>)</span>;<span class="hljs-comment">//E坐标，X分辨率除2，Y分辨率除2</span><br>        <span class="hljs-comment">/* E(xres/2, yres/2) */</span><br>        get<span class="hljs-constructor">_calibrate_point_data(<span class="hljs-params">xres</span><span class="hljs-operator">/</span>2, <span class="hljs-params">yres</span><span class="hljs-operator">/</span>2, &amp;<span class="hljs-params">e_ts_x</span>, &amp;<span class="hljs-params">e_ts_y</span>)</span>;<br>    <span class="hljs-comment">//读取XY坐标值后确定XY是否反转</span><br>        <span class="hljs-comment">/* 确定触摸屏数据XY是否反转 */</span><br>        g_ts_xy_swap = is<span class="hljs-constructor">_ts_xy_swap(<span class="hljs-params">a_ts_x</span>, <span class="hljs-params">a_ts_y</span>, <span class="hljs-params">b_ts_x</span>, <span class="hljs-params">b_ts_y</span>)</span>;<br>    <span class="hljs-comment">//如果反转，对调所有点的XY坐标</span><br>        <span class="hljs-keyword">if</span> (g_ts_xy_swap)<br>        &#123;<br>                <span class="hljs-comment">/* 对调所有点的XY坐标 */</span><br>                swap<span class="hljs-constructor">_xy(&amp;<span class="hljs-params">a_ts_x</span>, &amp;<span class="hljs-params">a_ts_y</span>)</span>;<br>                swap<span class="hljs-constructor">_xy(&amp;<span class="hljs-params">b_ts_x</span>, &amp;<span class="hljs-params">b_ts_y</span>)</span>;<br>                swap<span class="hljs-constructor">_xy(&amp;<span class="hljs-params">c_ts_x</span>, &amp;<span class="hljs-params">c_ts_y</span>)</span>;<br>                swap<span class="hljs-constructor">_xy(&amp;<span class="hljs-params">d_ts_x</span>, &amp;<span class="hljs-params">d_ts_y</span>)</span>;<br>                swap<span class="hljs-constructor">_xy(&amp;<span class="hljs-params">e_ts_x</span>, &amp;<span class="hljs-params">e_ts_y</span>)</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><p><img src="/image/Chapter18_lesson10_003.png" alt="Chapter18_lesson10_003.png"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* 确定公式的参数并保存 */</span><br><span class="hljs-regexp">//</span>Ts_S1值=B点ts和A点tsX轴方向的距离<br>        ts_s1 = b_ts_x - a_ts_x;<br><span class="hljs-regexp">//</span>Ts_S2值<br>        ts_s2 = c_ts_x - d_ts_x;<br><span class="hljs-regexp">//</span>lcd_s值<br>        lcd_s = xres-<span class="hljs-number">50</span> - <span class="hljs-number">50</span>;<br><span class="hljs-regexp">//</span>ts_d1值<br>        ts_d1 = d_ts_y - a_ts_y;<br><span class="hljs-regexp">//</span>ts_d2值<br>        ts_d2 = c_ts_y - b_ts_y;<br><span class="hljs-regexp">//</span>lcd_d值<br>        lcd_d = yres-<span class="hljs-number">50</span>-<span class="hljs-number">50</span>;<br><span class="hljs-regexp">//</span>X轴的斜率<br>        g_kx = ((double)(<span class="hljs-number">2</span>*lcd_s)) / (ts_s1 + ts_s2);<br><span class="hljs-regexp">//</span>Y轴的斜率<br>        g_ky = ((double)(<span class="hljs-number">2</span>*lcd_d)) / (ts_d1 + ts_d2);<br><br><span class="hljs-regexp">//</span>中心点E点的坐标<br>        g_ts_xc = e_ts_x;<br>        g_ts_yc = e_ts_y;<br>        g_lcd_xc = xres/<span class="hljs-number">2</span>;<br>        g_lcd_yc = yres/<span class="hljs-number">2</span>;&#125;<br></code></pre></td></tr></table></figure><p>我们需要把 + 在LCD上显示出来并且读出数据</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void get<span class="hljs-constructor">_calibrate_point_data(<span class="hljs-params">int</span> <span class="hljs-params">lcd_x</span>, <span class="hljs-params">int</span> <span class="hljs-params">lcd_y</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">px</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">py</span>)</span><br>&#123;<br>        fb<span class="hljs-constructor">_disp_cross(<span class="hljs-params">lcd_x</span>, <span class="hljs-params">lcd_y</span>, 0xffffff)</span>;<br><br>        <span class="hljs-comment">/* 等待点击 */</span><br><br>        ts<span class="hljs-constructor">_read_raw(<span class="hljs-params">px</span>, <span class="hljs-params">py</span>)</span>;<br>&#125;<br><span class="hljs-comment">//比如我们之前发现上报的X轴Y轴值反了</span><br><span class="hljs-comment">//比如正常情况下从A点移动到B点是x值变化比较大y值不变，但是目前的情况是y值变化比较大，x值不变</span><br><span class="hljs-comment">//我分根据这个特性分辨</span><br><br><span class="hljs-built_in">int</span> is<span class="hljs-constructor">_ts_xy_swap(<span class="hljs-params">int</span> <span class="hljs-params">a_ts_x</span>, <span class="hljs-params">int</span> <span class="hljs-params">a_ts_y</span>, <span class="hljs-params">int</span> <span class="hljs-params">b_ts_x</span>, <span class="hljs-params">int</span> <span class="hljs-params">b_ts_y</span>)</span><br>&#123;<br>        <span class="hljs-built_in">int</span> dx = b_ts_x - a_ts_x;<br>        <span class="hljs-built_in">int</span> dy = b_ts_y - a_ts_y;<br><span class="hljs-comment">//减出来的值有可能是负数，我们需要取绝对值</span><br>        <span class="hljs-keyword">if</span> (dx &lt; <span class="hljs-number">0</span>)<br>                dx = <span class="hljs-number">0</span> - dx;<br>        <span class="hljs-keyword">if</span> (dy &lt; <span class="hljs-number">0</span>)<br>                dy = <span class="hljs-number">0</span> - dy;<br><br>        <span class="hljs-keyword">if</span>(dx &gt; dy)<br>                return <span class="hljs-number">0</span>; <span class="hljs-comment">/* xy没有反转 */</span><br>        <span class="hljs-keyword">else</span><br>                return <span class="hljs-number">1</span>; <span class="hljs-comment">/* xy反了 */</span><br>&#125;<br><br><span class="hljs-comment">//如果是反的我们需要调换回来，我们需要确定XY是否反转</span><br><br><span class="hljs-comment">//我们写出一个对调函数</span><br>void swap<span class="hljs-constructor">_xy(<span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">px</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">py</span>)</span><br>&#123;<br>        <span class="hljs-built_in">int</span> tmp = *px;<br>        *px = *py;<br>        *py = tmp;<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * 读TS原始数据, 转换为LCD坐标 </span><br><span class="hljs-comment"> */</span><br>void ts<span class="hljs-constructor">_read(<span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">lcd_x</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">lcd_y</span>)</span><br>&#123;<br>        <span class="hljs-built_in">int</span> ts_x, ts_y;<br>        <br>        ts<span class="hljs-constructor">_read_raw(&amp;<span class="hljs-params">ts_x</span>, <span class="hljs-params">ts_y</span>)</span>;<br>        <span class="hljs-keyword">if</span> (g_ts_xy_swap)<br>        &#123;<br>                swap<span class="hljs-constructor">_xy(&amp;<span class="hljs-params">ts_x</span>, &amp;<span class="hljs-params">ts_y</span>)</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/* 使用公式计算 */</span><br>    <span class="hljs-comment">//斜率 * (触摸屏坐标 - 中心点除，触摸屏坐标) + 中心点LCD坐标</span><br>        *lcd_x = g_kx<span class="hljs-operator"> * </span>(ts_x - g_ts_xc) + g_lcd_xc;<br>        *lcd_y = g_ky<span class="hljs-operator"> * </span>(ts_y - g_ts_yc) + g_lcd_yc;&#125;<br></code></pre></td></tr></table></figure><p>接下来我们画线, 我们在framebuffer.c中把清屏函数单独实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear_screen</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> color)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">int</span> x, y;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *p0;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *p;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *p2;<br><br>        <span class="hljs-comment">/* 往framebuffer中写数据 */</span><br>        <span class="hljs-keyword">if</span> (bpp == <span class="hljs-number">8</span>)<br>        &#123;<br>                <span class="hljs-comment">/* bpp: palette[color] */</span><br><br>                p0 = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)fb_base;<br>                <span class="hljs-keyword">for</span> (x = <span class="hljs-number">0</span>; x &lt; xres; x++)<br>                        <span class="hljs-keyword">for</span> (y = <span class="hljs-number">0</span>; y &lt; yres; y++)<br>                                *p0++ = color;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bpp == <span class="hljs-number">16</span>)<br>        &#123;<br>                <span class="hljs-comment">/* 让LCD输出整屏的红色 */</span><br><br>                <span class="hljs-comment">/* 565: 0xf700 */</span><br><br>                p = (<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *)fb_base;<br>                <span class="hljs-keyword">for</span> (x = <span class="hljs-number">0</span>; x &lt; xres; x++)<br>                        <span class="hljs-keyword">for</span> (y = <span class="hljs-number">0</span>; y &lt; yres; y++)<br>                                *p++ = <span class="hljs-built_in">convert32bppto16bpp</span>(color);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bpp == <span class="hljs-number">32</span>)<br>        &#123;<br>                p2 = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *)fb_base;<br>                <span class="hljs-keyword">for</span> (x = <span class="hljs-number">0</span>; x &lt; xres; x++)<br>                        <span class="hljs-keyword">for</span> (y = <span class="hljs-number">0</span>; y &lt; yres; y++)<br>                                *p2++ = color;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先显示一个一个点，让后显示开始校准提示， 校准完提示 ok draw</p><p>打开我们的 touchscreen_test.c文件</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void touchscreen<span class="hljs-constructor">_test(<span class="hljs-params">void</span>)</span><br>&#123;<br>        unsigned <span class="hljs-built_in">int</span> fb_base;<br>        <span class="hljs-built_in">int</span> xres, yres, bpp;<br><br>        <span class="hljs-built_in">int</span> x, y;<br><br>        <span class="hljs-comment">/* 获得LCD的参数: fb_base, xres, yres, bpp */</span><br>        get<span class="hljs-constructor">_lcd_params(&amp;<span class="hljs-params">fb_base</span>, &amp;<span class="hljs-params">xres</span>, &amp;<span class="hljs-params">yres</span>, &amp;<span class="hljs-params">bpp</span>)</span>;<br><br>        touchscreen<span class="hljs-constructor">_init()</span>;<br><br>        <span class="hljs-comment">/* 清屏 */</span><br>        clear<span class="hljs-constructor">_screen(0)</span>;<br>    <span class="hljs-comment">//我们在70像素的地方显示文字，背景白色显示文字</span><br>        <span class="hljs-comment">/* 显示文字提示较准 */</span><br>        fb<span class="hljs-constructor">_print_string(70, 70, <span class="hljs-string">&quot;Touc cross to calibrate touchscreen&quot;</span>, 0xffffff)</span>;<br>        ts<span class="hljs-constructor">_calibrate()</span>;<br><br>        <span class="hljs-comment">/* 显示文字提示绘画 */</span><br>        fb<span class="hljs-constructor">_print_string(70, <span class="hljs-params">yres</span> - 70, <span class="hljs-string">&quot;OK! To draw!&quot;</span>, 0xffffff)</span>;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        &#123;<br>                ts<span class="hljs-constructor">_read(&amp;<span class="hljs-params">x</span>, &amp;<span class="hljs-params">y</span>)</span>;<br>    <span class="hljs-comment">//我们先打印值</span><br>                printf(<span class="hljs-string">&quot; x = %d, y = %d\n\r&quot;</span>, x, y);<br>    <span class="hljs-comment">//描绿色的线</span><br>                fb<span class="hljs-constructor">_put_pixel(<span class="hljs-params">x</span>, <span class="hljs-params">y</span>, 0xff00)</span>;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们添加了 tslib.c需要修改Makefile</p><p>添加objs +&#x3D; adc_touchscreen&#x2F;tslib.o</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objs = start.o init.o nand_flash.o led.o uart.o main.o exception.o interrupt.o timer.o nor_flash.o my_printf.o string_utils.o lib1funcs.o<br>objs += lcd/font.o<br>objs += lcd/framebuffer.o<br>objs += lcd/geometry.o<br>objs += lcd/lcd.o<br>objs += lcd/lcd_4.3.o<br>objs += lcd/lcd_controller.o<br>objs += lcd/lcd_test.o<br>objs += lcd/s3c2440_lcd_controller.o<br>objs += lcd/font_8x16.o<br><br>objs += adc_touchscreen/adc.o<br>objs += adc_touchscreen/adc_test.o<br><br>objs += adc_touchscreen/touchscreen.o<br>objs += adc_touchscreen/touchscreen_test.o<br><br>objs += adc_touchscreen/tslib.o<br><br><span class="hljs-section">all: <span class="hljs-variable">$(objs)</span></span><br>        <span class="hljs-comment">#arm-linux-ld -Ttext 0 -Tdata 0x30000000  start.o led.o uart.o init.o main.o -o sdram.elf</span><br>        arm-linux-ld -T sdram.lds <span class="hljs-variable">$^</span> libgcc.a -o sdram.elf<br>        arm-linux-objcopy -O binary -S sdram.elf sdram.bin<br>        arm-linux-objdump -D sdram.elf &gt; sdram.dis<br><span class="hljs-section">clean:</span><br>        rm -f *.bin <span class="hljs-variable">$(objs)</span> *.elf *.dis<br>        <br>%.o : %.c<br>        arm-linux-gcc -march=armv4 -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br>%.o : %.S<br>        arm-linux-gcc -march=armv4 -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br></code></pre></td></tr></table></figure><p><strong>第011节_触摸屏编程_测试</strong></p><hr><ul><li>发现程序有bug,点击坐标一次，程序就完成执行,我们需要修改触摸屏文件tsib.c</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static double g_kx;<br>static double g_ky;<br><br>static <span class="hljs-built_in">int</span> g_ts_xc, g_ts_yc;<br>static <span class="hljs-built_in">int</span> g_lcd_xc, g_lcd_yc;<br>static <span class="hljs-built_in">int</span> g_ts_xy_swap = <span class="hljs-number">0</span>;<br><br>static unsigned <span class="hljs-built_in">int</span> fb_base;<br>static <span class="hljs-built_in">int</span> xres, yres, bpp;<br><br>void get<span class="hljs-constructor">_calibrate_point_data(<span class="hljs-params">int</span> <span class="hljs-params">lcd_x</span>, <span class="hljs-params">int</span> <span class="hljs-params">lcd_y</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">px</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">py</span>)</span><br>&#123;<br>        <span class="hljs-built_in">int</span> pressure;<br>        <span class="hljs-built_in">int</span> x, y;<br>        <br>        fb<span class="hljs-constructor">_disp_cross(<span class="hljs-params">lcd_x</span>, <span class="hljs-params">lcd_y</span>, 0xffffff)</span>;<br><br>        <span class="hljs-comment">/* 等待点击 */</span><br><br>        <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">//如果pressure一直是0的话我们丢掉这些数据</span><br>                ts<span class="hljs-constructor">_read_raw(&amp;<span class="hljs-params">x</span>, &amp;<span class="hljs-params">y</span>, &amp;<span class="hljs-params">pressure</span>)</span>;<br>        &#125; <span class="hljs-keyword">while</span> (pressure<span class="hljs-operator"> == </span><span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">//让后再次读</span><br>        <span class="hljs-keyword">do</span> &#123;<br>                *px = x;<br>                *py = y;<br>                ts<span class="hljs-constructor">_read_raw(&amp;<span class="hljs-params">x</span>, &amp;<span class="hljs-params">y</span>, &amp;<span class="hljs-params">pressure</span>)</span>;<br>                printf(<span class="hljs-string">&quot;get raw data: x = %08d, y = %08d\n\r&quot;</span>, x, y);<br>        &#125; <span class="hljs-keyword">while</span> (pressure);<br>        <br>        printf(<span class="hljs-string">&quot;return raw data: x = %08d, y = %08d\n\r&quot;</span>, *px, *py);<br><br>        <span class="hljs-comment">/* 直到松开才返回 */</span><br>        fb<span class="hljs-constructor">_disp_cross(<span class="hljs-params">lcd_x</span>, <span class="hljs-params">lcd_y</span>, 0)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改touchcreen.c文件添加压力值相关信息</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//定义压力值全局变量</span><br>static <span class="hljs-built_in">int</span> g_ts_pressure;<br>void report<span class="hljs-constructor">_ts_xy(<span class="hljs-params">int</span> <span class="hljs-params">x</span>, <span class="hljs-params">int</span> <span class="hljs-params">y</span>, <span class="hljs-params">int</span> <span class="hljs-params">pressure</span>)</span>;<br><br><span class="hljs-comment">//发现不能画线，修改 ts_read</span><br><span class="hljs-comment">//我们需要判断触摸笔是按下还是松开，需要添加压力值参数</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 读TS原始数据, 转换为LCD坐标</span><br><span class="hljs-comment"> * 我们需要加上压力值lcd_pressure</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">int</span> ts<span class="hljs-constructor">_read(<span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">lcd_x</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">lcd_y</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">lcd_pressure</span>)</span><br>&#123;<br>        <span class="hljs-built_in">int</span> ts_x, ts_y, ts_pressure;<br>        <span class="hljs-built_in">int</span> tmp_x, tmp_y;<br>    <span class="hljs-comment">//添加压力值参数        </span><br>        ts<span class="hljs-constructor">_read_raw(&amp;<span class="hljs-params">ts_x</span>, &amp;<span class="hljs-params">ts_y</span>, &amp;<span class="hljs-params">ts_pressure</span>)</span>;<br><br>        <span class="hljs-keyword">if</span> (g_ts_xy_swap)<br>        &#123;<br>                swap<span class="hljs-constructor">_xy(&amp;<span class="hljs-params">ts_x</span>, &amp;<span class="hljs-params">ts_y</span>)</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/* 使用公式计算 */</span><br>        tmp_x = g_kx<span class="hljs-operator"> * </span>(ts_x - g_ts_xc) + g_lcd_xc;<br>        tmp_y = g_ky<span class="hljs-operator"> * </span>(ts_y - g_ts_yc) + g_lcd_yc;<br><br>    <span class="hljs-comment">//如果值超出了LCD范围返回-1</span><br>        <span class="hljs-keyword">if</span> (tmp_x &lt; <span class="hljs-number">0</span><span class="hljs-operator"> || </span>tmp_x &gt;= xres<span class="hljs-operator"> || </span>tmp_y &lt; <span class="hljs-number">0</span><span class="hljs-operator"> || </span>tmp_y &gt;= yres)<br>                return -<span class="hljs-number">1</span>;<br>        <br>        *lcd_x = tmp_x;<br>        *lcd_y = tmp_y;<br>    <span class="hljs-comment">//压力值等于全局变量ts_pressure</span><br>        *lcd_pressure = ts_pressure;<br>        return <span class="hljs-number">0</span>;<br>&#125;<br><br>void ts<span class="hljs-constructor">_read_raw(<span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">px</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">py</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">ppressure</span>)</span><br>&#123;<br>        <span class="hljs-keyword">while</span> (g_ts_data_valid<span class="hljs-operator"> == </span><span class="hljs-number">0</span>);<br>        *px = g_ts_x;<br>        *py = g_ts_y;<br>        *ppressure = g_ts_pressure;<br>        g_ts_data_valid = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//我们需要report上报压力值数据</span><br>void report<span class="hljs-constructor">_ts_xy(<span class="hljs-params">int</span> <span class="hljs-params">x</span>, <span class="hljs-params">int</span> <span class="hljs-params">y</span>, <span class="hljs-params">int</span> <span class="hljs-params">pressure</span>)</span><br>&#123;<br>        <span class="hljs-comment">//printf(&quot;x = %08d, y = %08d\n\r&quot;, x, y);</span><br><br>        <span class="hljs-keyword">if</span> (g_ts_data_valid<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)<br>        &#123;<br>                g_ts_x = x;<br>                g_ts_y = y;<br>                g_ts_pressure = pressure;<br>                g_ts_data_valid = <span class="hljs-number">1</span>;<br>        &#125;<br>&#125;<br><br>void <span class="hljs-constructor">Isr_Tc(<span class="hljs-params">void</span>)</span><br>&#123;<br>        <span class="hljs-comment">//printf(&quot;ADCUPDN = 0x%x, ADCDAT0 = 0x%x, ADCDAT1 = 0x%x, ADCTSC = 0x%x\n\r&quot;, ADCUPDN, ADCDAT0, ADCDAT1, ADCTSC);</span><br>        <br>        <span class="hljs-keyword">if</span> (ADCDAT0 &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>))<br>        &#123;<br>                <span class="hljs-comment">//printf(&quot;pen up\n\r&quot;);</span><br><br>                enter<span class="hljs-constructor">_wait_pen_down_mode()</span>;<br>            <span class="hljs-comment">//如果松开就上报数据xy坐标00 压力值0</span><br>                report<span class="hljs-constructor">_ts_xy(0, 0, 0)</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>   <br>        &#123;<br>                <span class="hljs-comment">//printf(&quot;pen down\n\r&quot;);</span><br><br>                <span class="hljs-comment">/* 进入&quot;自动测量&quot;模式 */</span><br>                enter<span class="hljs-constructor">_auto_measure_mode()</span>;<br><br>                <span class="hljs-comment">/* 启动ADC */</span><br>                ADCCON <span class="hljs-pattern-match">|= (1&lt;&lt;0);</span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match">&#125;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">void <span class="hljs-constructor">Isr_Adc(<span class="hljs-params">void</span>)</span></span><br><span class="hljs-pattern-match">&#123;</span><br><span class="hljs-pattern-match">        <span class="hljs-built_in">int</span> x = <span class="hljs-constructor">ADCDAT0</span>;</span><br><span class="hljs-pattern-match">        <span class="hljs-built_in">int</span> y = <span class="hljs-constructor">ADCDAT1</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">        static <span class="hljs-built_in">int</span> adc<span class="hljs-constructor">_cnt</span> = 0;</span><br><span class="hljs-pattern-match">        static <span class="hljs-built_in">int</span> adc<span class="hljs-constructor">_x</span> = 0;</span><br><span class="hljs-pattern-match">        static <span class="hljs-built_in">int</span> adc<span class="hljs-constructor">_y</span> = 0;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">        <span class="hljs-keyword">if</span> (!(x &amp; (1&lt;&lt;15))) <span class="hljs-operator">/</span><span class="hljs-operator">*</span> 如果仍然按下才打印 <span class="hljs-operator">*</span><span class="hljs-operator">/</span></span><br><span class="hljs-pattern-match">        &#123;</span><br><span class="hljs-pattern-match">#<span class="hljs-keyword">if</span> 0                      </span><br><span class="hljs-pattern-match">            x &amp;= 0x3ff;          </span><br><span class="hljs-pattern-match">            y &amp;= 0x3ff;</span><br><span class="hljs-pattern-match">                    </span><br><span class="hljs-pattern-match">            <span class="hljs-operator">/</span><span class="hljs-operator">/</span>printf(&quot;x = %08d, y = %08d\n\r&quot;, x, y);</span><br><span class="hljs-pattern-match">        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>当我得到触电数据以后，如果当前仍是按下状态，会上报<span class="hljs-constructor">XY</span>坐标值并且上报压力值，压力值等于1          </span><br><span class="hljs-pattern-match">            report<span class="hljs-constructor">_ts_xy(<span class="hljs-params">x</span>, <span class="hljs-params">y</span>, 1)</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">          <span class="hljs-operator">/</span><span class="hljs-operator">*</span> 启动定时器以再次读取数据 <span class="hljs-operator">*</span><span class="hljs-operator">/</span>          </span><br><span class="hljs-pattern-match">            ts<span class="hljs-constructor">_timer_enable()</span>;</span><br><span class="hljs-pattern-match">#endif</span><br><span class="hljs-pattern-match">        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>防止数据在最后出现很大的误差</span><br><span class="hljs-pattern-match">                <span class="hljs-operator">/</span><span class="hljs-operator">*</span> 第1次启动<span class="hljs-constructor">ADC</span>后:          </span><br><span class="hljs-pattern-match">                 <span class="hljs-operator">*</span>   a. 要连续启动<span class="hljs-constructor">N</span>次, 获得<span class="hljs-constructor">N</span>个数据, 求平均值并上报          </span><br><span class="hljs-pattern-match">                 <span class="hljs-operator">*</span>   b. 得到<span class="hljs-constructor">N</span>次数据后, 再启动<span class="hljs-constructor">TIMER</span>           </span><br><span class="hljs-pattern-match">                 <span class="hljs-operator">*</span><span class="hljs-operator">/</span></span><br><span class="hljs-pattern-match">        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>我们直接累加</span><br><span class="hljs-pattern-match">                adc<span class="hljs-constructor">_x</span> += (x &amp; 0x3ff);</span><br><span class="hljs-pattern-match">                adc<span class="hljs-constructor">_y</span> += (y &amp; 0x3ff);</span><br><span class="hljs-pattern-match">                adc<span class="hljs-constructor">_cnt</span><span class="hljs-operator">++</span>;</span><br><span class="hljs-pattern-match">        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>我们取16的话右移4位比较容易操作</span><br><span class="hljs-pattern-match">                <span class="hljs-keyword">if</span> (adc<span class="hljs-constructor">_cnt</span> <span class="hljs-operator">==</span> 16)</span><br><span class="hljs-pattern-match">                &#123;</span><br><span class="hljs-pattern-match">        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>右移4位</span><br><span class="hljs-pattern-match">                        adc<span class="hljs-constructor">_x</span> &gt;&gt;= 4;</span><br><span class="hljs-pattern-match">                        adc<span class="hljs-constructor">_y</span> &gt;&gt;= 4;</span><br><span class="hljs-pattern-match">        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>上报</span><br><span class="hljs-pattern-match">                        report<span class="hljs-constructor">_ts_xy(<span class="hljs-params">adc_x</span>, <span class="hljs-params">adc_y</span>, 1)</span>;</span><br><span class="hljs-pattern-match">        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>恢复到初始值0</span><br><span class="hljs-pattern-match">                        adc<span class="hljs-constructor">_cnt</span> = 0;</span><br><span class="hljs-pattern-match">                        adc<span class="hljs-constructor">_x</span> = 0;</span><br><span class="hljs-pattern-match">                        adc<span class="hljs-constructor">_y</span> = 0;</span><br><span class="hljs-pattern-match">                        </span><br><span class="hljs-pattern-match">                        <span class="hljs-operator">/</span><span class="hljs-operator">*</span> 启动定时器以再次读取数据 <span class="hljs-operator">*</span><span class="hljs-operator">/</span></span><br><span class="hljs-pattern-match">                        ts<span class="hljs-constructor">_timer_enable()</span>;</span><br><span class="hljs-pattern-match">                &#125;</span><br><span class="hljs-pattern-match">                <span class="hljs-keyword">else</span></span><br><span class="hljs-pattern-match">                &#123;</span><br><span class="hljs-pattern-match">                        <span class="hljs-operator">/</span><span class="hljs-operator">*</span> 否则再次启动<span class="hljs-constructor">ADC</span> <span class="hljs-operator">*</span><span class="hljs-operator">/</span></span><br><span class="hljs-pattern-match">                        <span class="hljs-operator">/</span><span class="hljs-operator">*</span> 进入&quot;自动测量&quot;模式 <span class="hljs-operator">*</span><span class="hljs-operator">/</span></span><br><span class="hljs-pattern-match">                        enter<span class="hljs-constructor">_auto_measure_mode()</span>;</span><br><span class="hljs-pattern-match">                        </span><br><span class="hljs-pattern-match">                        <span class="hljs-operator">/</span><span class="hljs-operator">*</span> 启动<span class="hljs-constructor">ADC</span> <span class="hljs-operator">*</span><span class="hljs-operator">/</span></span><br><span class="hljs-pattern-match">                        <span class="hljs-constructor">ADCCON</span> |= (1&lt;&lt;0);</span><br><span class="hljs-pattern-match">                &#125;</span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match">        <span class="hljs-keyword">else</span></span><br><span class="hljs-pattern-match">        &#123;</span><br><span class="hljs-pattern-match">                adc<span class="hljs-constructor">_cnt</span> = 0;</span><br><span class="hljs-pattern-match">                adc<span class="hljs-constructor">_x</span> = 0;</span><br><span class="hljs-pattern-match">                adc<span class="hljs-constructor">_y</span> = 0;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">                ts<span class="hljs-constructor">_timer_disable()</span>;</span><br><span class="hljs-pattern-match">                enter<span class="hljs-constructor">_wait_pen_down_mode()</span>;</span><br><span class="hljs-pattern-match">        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>如果数据转换完之前再次松开，这里我也会上报数据，0，0，0</span><br><span class="hljs-pattern-match">                report<span class="hljs-constructor">_ts_xy(0, 0, 0)</span>;</span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match">        enter<span class="hljs-constructor">_wait_pen_up_mode()</span>;</span><br><span class="hljs-pattern-match">&#125;</span><br></code></pre></td></tr></table></figure><p>那么我们的tslib.c中</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void get<span class="hljs-constructor">_calibrate_point_data(<span class="hljs-params">int</span> <span class="hljs-params">lcd_x</span>, <span class="hljs-params">int</span> <span class="hljs-params">lcd_y</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">px</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">py</span>)</span><br>&#123;<br>        <span class="hljs-built_in">int</span> pressure;<br>        <span class="hljs-built_in">int</span> x, y;<br>        <br>        fb<span class="hljs-constructor">_disp_cross(<span class="hljs-params">lcd_x</span>, <span class="hljs-params">lcd_y</span>, 0xffffff)</span>;<br><br>        <span class="hljs-comment">/* 等待点击 */</span><br><br>        <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">//读取ts坐标值也加上压力值</span><br>                ts<span class="hljs-constructor">_read_raw(&amp;<span class="hljs-params">x</span>, &amp;<span class="hljs-params">y</span>, &amp;<span class="hljs-params">pressure</span>)</span>;<br>    <span class="hljs-comment">//直到压力等于0的时候才返回</span><br>        &#125; <span class="hljs-keyword">while</span> (pressure<span class="hljs-operator"> == </span><span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">do</span> &#123;<br>                *px = x;<br>                *py = y;<br>    <span class="hljs-comment">//压力值存在的情况下表示按下状态，就一直读取数据</span><br>                ts<span class="hljs-constructor">_read_raw(&amp;<span class="hljs-params">x</span>, &amp;<span class="hljs-params">y</span>, &amp;<span class="hljs-params">pressure</span>)</span>;<br>                printf(<span class="hljs-string">&quot;get raw data: x = %08d, y = %08d\n\r&quot;</span>, x, y);<br>        &#125; <span class="hljs-keyword">while</span> (pressure);<br>    <span class="hljs-comment">//打印坐标值</span><br>        printf(<span class="hljs-string">&quot;return raw data: x = %08d, y = %08d\n\r&quot;</span>, *px, *py);<br><br>        <span class="hljs-comment">/* 直到松开才返回 */</span><br>    <span class="hljs-comment">//我们操作完成后消除 +  </span><br>        fb<span class="hljs-constructor">_disp_cross(<span class="hljs-params">lcd_x</span>, <span class="hljs-params">lcd_y</span>, 0)</span>;<br>&#125;<br><br><span class="hljs-comment">//我们确定校准为什么不对，我们校准涉及 原始数据 校准公式</span><br><br><span class="hljs-comment">//我们把公式使用函数来表示int get_lcd_x_frm_ts_x(int ts_x)</span><br>&#123;<br>        return g_kx<span class="hljs-operator"> * </span>(ts_x - g_ts_xc) + g_lcd_xc;<br>&#125;<br><br><span class="hljs-built_in">int</span> get<span class="hljs-constructor">_lcd_y_frm_ts_y(<span class="hljs-params">int</span> <span class="hljs-params">ts_y</span>)</span><br>&#123;<br>        return g_ky<span class="hljs-operator"> * </span>(ts_y - g_ts_yc) + g_lcd_yc;<br>&#125;<br><br>void ts<span class="hljs-constructor">_calibrate(<span class="hljs-params">void</span>)</span><br>&#123;<br>        <span class="hljs-built_in">int</span> a_ts_x, a_ts_y;<br>        <span class="hljs-built_in">int</span> b_ts_x, b_ts_y;<br>        <span class="hljs-built_in">int</span> c_ts_x, c_ts_y;<br>        <span class="hljs-built_in">int</span> d_ts_x, d_ts_y;<br>        <span class="hljs-built_in">int</span> e_ts_x, e_ts_y;<br><br>        <span class="hljs-comment">/* X轴方向 */</span><br>        <span class="hljs-built_in">int</span> ts_s1, ts_s2;<br>        <span class="hljs-built_in">int</span> lcd_s;<br><br>        <span class="hljs-comment">/* Y轴方向 */</span><br>        <span class="hljs-built_in">int</span> ts_d1, ts_d2;<br>        <span class="hljs-built_in">int</span> lcd_d;<br><br>        <span class="hljs-comment">/* 获得LCD的参数: fb_base, xres, yres, bpp */</span><br>        get<span class="hljs-constructor">_lcd_params(&amp;<span class="hljs-params">fb_base</span>, &amp;<span class="hljs-params">xres</span>, &amp;<span class="hljs-params">yres</span>, &amp;<span class="hljs-params">bpp</span>)</span>;<br><br>        <span class="hljs-comment">/* 对于ABCDE, 循环: 显示&quot;+&quot;、点击、读ts原始值 */</span><br>        <span class="hljs-comment">/* A(50, 50) */</span><br>        get<span class="hljs-constructor">_calibrate_point_data(50, 50, &amp;<span class="hljs-params">a_ts_x</span>, &amp;<span class="hljs-params">a_ts_y</span>)</span>; <br>  <br>        <span class="hljs-comment">/* B(xres-50, 50) */</span><br>        get<span class="hljs-constructor">_calibrate_point_data(<span class="hljs-params">xres</span>-50, 50, &amp;<span class="hljs-params">b_ts_x</span>, &amp;<span class="hljs-params">b_ts_y</span>)</span>;<br><br>        <span class="hljs-comment">/* C(xres-50, yres-50) */</span><br>        get<span class="hljs-constructor">_calibrate_point_data(<span class="hljs-params">xres</span>-50, <span class="hljs-params">yres</span>-50, &amp;<span class="hljs-params">c_ts_x</span>, &amp;<span class="hljs-params">c_ts_y</span>)</span>;<br><br>        <span class="hljs-comment">/* D(50, yres-50) */</span><br>        get<span class="hljs-constructor">_calibrate_point_data(50, <span class="hljs-params">yres</span>-50, &amp;<span class="hljs-params">d_ts_x</span>, &amp;<span class="hljs-params">d_ts_y</span>)</span>;<br>        <br>        <span class="hljs-comment">/* E(xres/2, yres/2) */</span><br>        get<span class="hljs-constructor">_calibrate_point_data(<span class="hljs-params">xres</span><span class="hljs-operator">/</span>2, <span class="hljs-params">yres</span><span class="hljs-operator">/</span>2, &amp;<span class="hljs-params">e_ts_x</span>, &amp;<span class="hljs-params">e_ts_y</span>)</span>;<br><br>        <span class="hljs-comment">/* 确定触摸屏数据XY是否反转 */</span><br>        g_ts_xy_swap = is<span class="hljs-constructor">_ts_xy_swap(<span class="hljs-params">a_ts_x</span>, <span class="hljs-params">a_ts_y</span>, <span class="hljs-params">b_ts_x</span>, <span class="hljs-params">b_ts_y</span>)</span>;<br><br>        <span class="hljs-keyword">if</span> (g_ts_xy_swap)<br>        &#123;<br>                <span class="hljs-comment">/* 对调所有点的XY坐标 */</span><br>                swap<span class="hljs-constructor">_xy(&amp;<span class="hljs-params">a_ts_x</span>, &amp;<span class="hljs-params">a_ts_y</span>)</span>;<br>                swap<span class="hljs-constructor">_xy(&amp;<span class="hljs-params">b_ts_x</span>, &amp;<span class="hljs-params">b_ts_y</span>)</span>;<br>                swap<span class="hljs-constructor">_xy(&amp;<span class="hljs-params">c_ts_x</span>, &amp;<span class="hljs-params">c_ts_y</span>)</span>;<br>                swap<span class="hljs-constructor">_xy(&amp;<span class="hljs-params">d_ts_x</span>, &amp;<span class="hljs-params">d_ts_y</span>)</span>;<br>                swap<span class="hljs-constructor">_xy(&amp;<span class="hljs-params">e_ts_x</span>, &amp;<span class="hljs-params">e_ts_y</span>)</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/* 确定公式的参数并保存 */</span><br>        ts_s1 = b_ts_x - a_ts_x;<br>        ts_s2 = c_ts_x - d_ts_x;<br>        lcd_s = xres-<span class="hljs-number">50</span> - <span class="hljs-number">50</span>;<br><br>        ts_d1 = d_ts_y - a_ts_y;<br>        ts_d2 = c_ts_y - b_ts_y;<br>        lcd_d = yres-<span class="hljs-number">50</span>-<span class="hljs-number">50</span>;<br><br>        g_kx = ((double)(<span class="hljs-number">2</span>*lcd_s))<span class="hljs-operator"> / </span>(ts_s1 + ts_s2);<br>        g_ky = ((double)(<span class="hljs-number">2</span>*lcd_d))<span class="hljs-operator"> / </span>(ts_d1 + ts_d2);<br><br>        g_ts_xc = e_ts_x;<br>        g_ts_yc = e_ts_y;<br><br>        g_lcd_xc = xres/<span class="hljs-number">2</span>;<br>        g_lcd_yc = yres/<span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//打印ABCDE的坐标值</span><br>        printf(<span class="hljs-string">&quot;A lcd_x = %08d, lcd_y = %08d\n\r&quot;</span>, get<span class="hljs-constructor">_lcd_x_frm_ts_x(<span class="hljs-params">a_ts_x</span>)</span>, get<span class="hljs-constructor">_lcd_y_frm_ts_y(<span class="hljs-params">a_ts_y</span>)</span>);<br>        printf(<span class="hljs-string">&quot;B lcd_x = %08d, lcd_y = %08d\n\r&quot;</span>, get<span class="hljs-constructor">_lcd_x_frm_ts_x(<span class="hljs-params">b_ts_x</span>)</span>, get<span class="hljs-constructor">_lcd_y_frm_ts_y(<span class="hljs-params">b_ts_y</span>)</span>);<br>        printf(<span class="hljs-string">&quot;C lcd_x = %08d, lcd_y = %08d\n\r&quot;</span>, get<span class="hljs-constructor">_lcd_x_frm_ts_x(<span class="hljs-params">c_ts_x</span>)</span>, get<span class="hljs-constructor">_lcd_y_frm_ts_y(<span class="hljs-params">c_ts_y</span>)</span>);<br>        printf(<span class="hljs-string">&quot;D lcd_x = %08d, lcd_y = %08d\n\r&quot;</span>, get<span class="hljs-constructor">_lcd_x_frm_ts_x(<span class="hljs-params">d_ts_x</span>)</span>, get<span class="hljs-constructor">_lcd_y_frm_ts_y(<span class="hljs-params">d_ts_y</span>)</span>);<br>        printf(<span class="hljs-string">&quot;E lcd_x = %08d, lcd_y = %08d\n\r&quot;</span>, get<span class="hljs-constructor">_lcd_x_frm_ts_x(<span class="hljs-params">e_ts_x</span>)</span>, get<span class="hljs-constructor">_lcd_y_frm_ts_y(<span class="hljs-params">e_ts_y</span>)</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>我们转换出的XY坐标值不是特别稳定</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* 每10ms该函数被调用一次 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">touchscreen_timer_irq</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>        <span class="hljs-comment">/* 如果触摸屏仍被按下, 进入&quot;自动测量模式&quot;, 启动ADC */</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">get_status_of_ts_timer</span>() == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">ADCDAT0</span> &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>)) <span class="hljs-comment">/* 如果松开 */</span><br>        &#123;<br>                <span class="hljs-title function_">ts_timer_disable</span>();<br>                <span class="hljs-title function_">enter_wait_pen_down_mode</span>();<br>                <span class="hljs-comment">//report_ts_xy(0, 0, 0);</span><br>                <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 按下状态 */</span><br>        &#123;<br>                <span class="hljs-comment">/* 进入&quot;自动测量&quot;模式 */</span><br>                <span class="hljs-title function_">enter_auto_measure_mode</span>();<br><br>                <span class="hljs-comment">/* 启动ADC */</span><br>                <span class="hljs-variable constant_">ADCCON</span> |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>修改touchscreen-test.c文件</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void touchscreen<span class="hljs-constructor">_test(<span class="hljs-params">void</span>)</span><br>&#123;<br>        unsigned <span class="hljs-built_in">int</span> fb_base;<br>        <span class="hljs-built_in">int</span> xres, yres, bpp;<br><br>        <span class="hljs-built_in">int</span> x, y, pressure;<br><br>        <span class="hljs-comment">/* 获得LCD的参数: fb_base, xres, yres, bpp */</span><br>        get<span class="hljs-constructor">_lcd_params(&amp;<span class="hljs-params">fb_base</span>, &amp;<span class="hljs-params">xres</span>, &amp;<span class="hljs-params">yres</span>, &amp;<span class="hljs-params">bpp</span>)</span>;<br><br>        touchscreen<span class="hljs-constructor">_init()</span>;<br><br>        <span class="hljs-comment">/* 清屏 */</span><br>        clear<span class="hljs-constructor">_screen(0)</span>;<br><br>        <span class="hljs-comment">/* 显示文字提示较准 */</span><br>        fb<span class="hljs-constructor">_print_string(70, 70, <span class="hljs-string">&quot;Touc cross to calibrate touchscreen&quot;</span>, 0xffffff)</span>;<br>        ts<span class="hljs-constructor">_calibrate()</span>;<br><br>        <span class="hljs-comment">/* 显示文字提示绘画 */</span><br>        fb<span class="hljs-constructor">_print_string(70, <span class="hljs-params">yres</span> - 70, <span class="hljs-string">&quot;OK! To draw!&quot;</span>, 0xffffff)</span>;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        &#123;<br>    <span class="hljs-comment">//如果结果=0则继续执行下面操作</span><br>                <span class="hljs-keyword">if</span> (ts<span class="hljs-constructor">_read(&amp;<span class="hljs-params">x</span>, &amp;<span class="hljs-params">y</span>, &amp;<span class="hljs-params">pressure</span>)</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span>)<br>                &#123;<br>                        printf(<span class="hljs-string">&quot; x = %d, y = %d\n\r&quot;</span>, x, y);<br>    <span class="hljs-comment">//如果是按下状态，才会描点</span><br>                        <span class="hljs-keyword">if</span> (pressure)<br>                        &#123;<br>                                fb<span class="hljs-constructor">_put_pixel(<span class="hljs-params">x</span>, <span class="hljs-params">y</span>, 0xff00)</span>;<br>                        &#125;<br>                &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>把LCD的电压值，成功转化成屏幕的坐标 要点</p><p>1). 对于触摸屏要多次测量，求平均值</p><p>2). 要丢弃非法值（以LCD分辨率作为判断标准）</p><p>3). 校准时一定要点准</p><p>参考tslib库，</p><p><strong>第012节_触摸屏编程_完善</strong></p><hr><ul><li>我们触摸屏校准虽然可以正常运行，但是有些问题，比如在触摸屏上点一个点，同时屏幕上面会显示另一个点,我们按住屏幕不动的同时将其转换成LCD坐标并且描点，就表明数值不大稳定</li></ul><p>问题</p><ol><li>我们第一次点击触摸屏会出现两个点</li><li>长按，LCD上的点会越来越大</li></ol><ul><li>根源在于我们得到的LCD坐标值不稳定，根源ADC转换出来的xy坐标值不稳定</li></ul><p><img src="/image/700px-Chapter18_lesson12_001.jpg" alt="700px-Chapter18_lesson12_001.jpg"></p><p>我们打开touchscreen.c问题出现在这里面</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-comment">#include &quot;../s3c2440_soc.h&quot;</span><br><span class="hljs-comment">#define ADC_INT_BIT (10)</span><br><span class="hljs-comment">#define TC_INT_BIT  (9)</span><br><span class="hljs-comment">#define INT_ADC_TC   (31)</span><br><br><span class="hljs-comment">/* ADCTSC&#x27;s bits */</span><br><span class="hljs-comment">#define WAIT_PEN_DOWN    (0&lt;&lt;8)</span><br><span class="hljs-comment">#define WAIT_PEN_UP      (1&lt;&lt;8)</span><br><span class="hljs-comment">#define YM_ENABLE        (1&lt;&lt;7)</span><br><span class="hljs-comment">#define YM_DISABLE       (0&lt;&lt;7)</span><br><span class="hljs-comment">#define YP_ENABLE        (0&lt;&lt;6)</span><br><span class="hljs-comment">#define YP_DISABLE       (1&lt;&lt;6)</span><br><span class="hljs-comment">#define XM_ENABLE        (1&lt;&lt;5)</span><br><span class="hljs-comment">#define XM_DISABLE       (0&lt;&lt;5)</span><br><span class="hljs-comment">#define XP_ENABLE        (0&lt;&lt;4)</span><br><span class="hljs-comment">#define XP_DISABLE       (1&lt;&lt;4)</span><br><span class="hljs-comment">#define PULLUP_ENABLE    (0&lt;&lt;3)</span><br><span class="hljs-comment">#define PULLUP_DISABLE   (1&lt;&lt;3)</span><br><span class="hljs-comment">#define AUTO_PST         (1&lt;&lt;2)</span><br><span class="hljs-comment">#define WAIT_INT_MODE    (3)</span><br><span class="hljs-comment">#define NO_OPR_MODE      (0)</span><br><br><span class="hljs-keyword">static</span> <span class="hljs-variable">volatile</span> int <span class="hljs-variable">g_ts_timer_enable</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> int <span class="hljs-variable">g_ts_x</span>;<span class="hljs-keyword">static</span> int <span class="hljs-variable">g_ts_y</span>;<br><span class="hljs-keyword">static</span> int <span class="hljs-variable">g_ts_pressure</span>;<br><span class="hljs-keyword">static</span> int <span class="hljs-variable">g_ts_data_valid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//定义测试数据16</span><br><span class="hljs-keyword">static</span> int <span class="hljs-variable">test_x_array</span>[<span class="hljs-number">16</span>];<br><span class="hljs-keyword">static</span> int <span class="hljs-variable">test_y_array</span>[<span class="hljs-number">16</span>];<br><br><span class="hljs-variable">void</span> <span class="hljs-title function_">report_ts_xy</span>(int <span class="hljs-variable">x</span>, int <span class="hljs-variable">y</span>, int <span class="hljs-variable">pressure</span>);<br><br><span class="hljs-variable">void</span> <span class="hljs-title function_">enter_wait_pen_down_mode</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-variable">ADCTSC</span> <span class="hljs-operator">=</span> <span class="hljs-variable">WAIT_PEN_DOWN</span> <span class="hljs-operator">|</span> <span class="hljs-variable">PULLUP_ENABLE</span> <span class="hljs-operator">|</span> <span class="hljs-variable">YM_ENABLE</span> <span class="hljs-operator">|</span> <span class="hljs-variable">YP_DISABLE</span> <span class="hljs-operator">|</span> <span class="hljs-variable">XP_DISABLE</span> <span class="hljs-operator">|</span> <span class="hljs-variable">XM_DISABLE</span> <span class="hljs-operator">|</span> <span class="hljs-variable">WAIT_INT_MODE</span>;<br>&#125;<br><br><span class="hljs-variable">void</span> <span class="hljs-title function_">enter_wait_pen_up_mode</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-variable">ADCTSC</span> <span class="hljs-operator">=</span> <span class="hljs-variable">WAIT_PEN_UP</span> <span class="hljs-operator">|</span> <span class="hljs-variable">PULLUP_ENABLE</span> <span class="hljs-operator">|</span> <span class="hljs-variable">YM_ENABLE</span> <span class="hljs-operator">|</span> <span class="hljs-variable">YP_DISABLE</span> <span class="hljs-operator">|</span> <span class="hljs-variable">XP_DISABLE</span> <span class="hljs-operator">|</span> <span class="hljs-variable">XM_DISABLE</span> <span class="hljs-operator">|</span> <span class="hljs-variable">WAIT_INT_MODE</span>;<br>&#125;<br><br><span class="hljs-variable">void</span> <span class="hljs-title function_">enter_auto_measure_mode</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-variable">ADCTSC</span> <span class="hljs-operator">=</span> <span class="hljs-variable">AUTO_PST</span> <span class="hljs-operator">|</span> <span class="hljs-variable">NO_OPR_MODE</span>;<br>&#125;<br><br>int <span class="hljs-title function_">is_in_auto_mode</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">ADCTSC</span> <span class="hljs-operator">&amp;</span> <span class="hljs-variable">AUTO_PST</span>;<br>&#125;<br><br><span class="hljs-variable">void</span> <span class="hljs-title class_">Isr</span>_Tc(<span class="hljs-variable">void</span>)<br>&#123;<br>        <span class="hljs-comment">//printf(&quot;ADCUPDN = 0x%x, ADCDAT0 = 0x%x, ADCDAT1 = 0x%x, ADCTSC = 0x%x\n\r&quot;, ADCUPDN, ADCDAT0, ADCDAT1, ADCTSC);</span><br>        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">ADCDAT0</span> <span class="hljs-operator">&amp;</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">15</span>))<br>        &#123;<br>    <span class="hljs-comment">//按下状态启用触摸屏</span><br>    <span class="hljs-comment">//启动测量模式，转换结束产生adc中断</span><br>                <span class="hljs-comment">//printf(&quot;pen up\n\r&quot;);</span><br>                <span class="hljs-title function_">enter_wait_pen_down_mode</span>();<br>                <span class="hljs-title function_">report_ts_xy</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>   <br>        &#123;<br>                <span class="hljs-comment">//printf(&quot;pen down\n\r&quot;);</span><br><br>                <span class="hljs-comment">/* 进入&quot;自动测量&quot;模式 */</span><br>                <span class="hljs-title function_">enter_auto_measure_mode</span>();<br><br>                <span class="hljs-comment">/* 启动ADC */</span><br>                <span class="hljs-variable">ADCCON</span> <span class="hljs-operator">|</span><span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">0</span>);<br>        &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-variable">void</span> <span class="hljs-title function_">ts_timer_enable</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-variable">g_ts_timer_enable</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-variable">void</span> <span class="hljs-title function_">ts_timer_disable</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-variable">g_ts_timer_enable</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">static</span> int <span class="hljs-title function_">get_status_of_ts_timer</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">g_ts_timer_enable</span>;<br>&#125;<br><br><span class="hljs-variable">void</span> <span class="hljs-title function_">report_ts_xy</span>(<span class="hljs-params">int</span> <span class="hljs-params">x</span>, <span class="hljs-params">int</span> <span class="hljs-params">y</span>, <span class="hljs-params">int</span> <span class="hljs-params">pressure</span>)<br>&#123;<br>        <span class="hljs-comment">//printf(&quot;x = %08d, y = %08d\n\r&quot;, x, y);</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">g_ts_data_valid</span> <span class="hljs-operator">==</span> <span class="hljs-number">0</span>)<br>        &#123;<br>                <span class="hljs-variable">g_ts_x</span> <span class="hljs-operator">=</span> <span class="hljs-variable">x</span>;<br>                <span class="hljs-variable">g_ts_y</span> <span class="hljs-operator">=</span> <span class="hljs-variable">y</span>;<br>                <span class="hljs-variable">g_ts_pressure</span> <span class="hljs-operator">=</span> <span class="hljs-variable">pressure</span>;<br>                <span class="hljs-variable">g_ts_data_valid</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        &#125;<br>&#125;<br><br><span class="hljs-variable">void</span> <span class="hljs-title function_">ts_read_raw</span>(<span class="hljs-params">int</span> *<span class="hljs-params">px</span>, <span class="hljs-params">int</span> *<span class="hljs-params">py</span>, <span class="hljs-params">int</span> *<span class="hljs-params">ppressure</span>)<br>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-variable">g_ts_data_valid</span> <span class="hljs-operator">==</span> <span class="hljs-number">0</span>);<br>        <span class="hljs-operator">*</span><span class="hljs-variable">px</span> <span class="hljs-operator">=</span> <span class="hljs-variable">g_ts_x</span>;<br>        <span class="hljs-operator">*</span><span class="hljs-variable">py</span> <span class="hljs-operator">=</span> <span class="hljs-variable">g_ts_y</span>;<br>        <span class="hljs-operator">*</span><span class="hljs-variable">ppressure</span> <span class="hljs-operator">=</span> <span class="hljs-variable">g_ts_pressure</span>;<br>        <span class="hljs-variable">g_ts_data_valid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 每10ms该函数被调用一次 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-variable">void</span> <span class="hljs-title function_">touchscreen_timer_irq</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-comment">/* 如果触摸屏仍被按下, 进入&quot;自动测量模式&quot;, 启动ADC */</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">get_status_of_ts_timer</span>() <span class="hljs-operator">==</span> <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">is_in_auto_mode</span>())<br>                <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">/* 只有在&quot;等待中断模式&quot;下才可以使用ADCDAT0&#x27;BIT 15来判断触摸笔状态 */</span><br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">ADCDAT0</span> <span class="hljs-operator">&amp;</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">15</span>)) <span class="hljs-comment">/* 如果松开 */</span><br>        &#123;<br>                <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;timer set pen down<span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span>&quot;</span>);<br>                <span class="hljs-title function_">ts_timer_disable</span>();<br>                <span class="hljs-title function_">enter_wait_pen_down_mode</span>();<br>                <span class="hljs-title function_">report_ts_xy</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 按下状态 */</span><br>        &#123;<br>                <span class="hljs-comment">/* 进入&quot;自动测量&quot;模式 */</span><br>                <span class="hljs-title function_">enter_auto_measure_mode</span>();<br><br>                <span class="hljs-comment">/* 启动ADC */</span><br>                <span class="hljs-variable">ADCCON</span> <span class="hljs-operator">|</span><span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">0</span>);<br>        &#125;<br>&#125;<br><br><span class="hljs-variable">void</span> <span class="hljs-title class_">Isr</span>_Adc(<span class="hljs-variable">void</span>)<br>&#123;<br>        int <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-variable">ADCDAT0</span>;<br>        int <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-variable">ADCDAT1</span>;<br><br>        <span class="hljs-keyword">static</span> int <span class="hljs-variable">adc_cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">static</span> int <span class="hljs-variable">adc_x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">static</span> int <span class="hljs-variable">adc_y</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">/* 进入ADC中断时, TS处于&quot;自动测量模式&quot; */</span><br><br>        <span class="hljs-comment">/* 只有在&quot;等待中断模式&quot;下才可以使用ADCDAT0&#x27;BIT 15来判断触摸笔状态 */</span><br><br>        <span class="hljs-title function_">enter_wait_pen_up_mode</span>();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-operator">!</span>(<span class="hljs-variable">ADCDAT0</span> <span class="hljs-operator">&amp;</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">15</span>))) <span class="hljs-comment">/* 如果仍然按下才打印 */</span><br>        &#123;<br><span class="hljs-comment">#<span class="hljs-keyword">if</span> 0                      </span><br>            <span class="hljs-variable">x</span> <span class="hljs-operator">&amp;</span><span class="hljs-operator">=</span> <span class="hljs-number">0x3ff</span>;          <br>            <span class="hljs-variable">y</span> <span class="hljs-operator">&amp;</span><span class="hljs-operator">=</span> <span class="hljs-number">0x3ff</span>;                    <br><br>            <span class="hljs-comment">//printf(&quot;x =   %08d, y = %08d\n\r&quot;, x, y);          </span><br>            <span class="hljs-title function_">report_ts_xy</span>(<span class="hljs-variable">x</span>, <span class="hljs-variable">y</span>, <span class="hljs-number">1</span>);<br><br>            <span class="hljs-comment">/* 启动定时器以再次读取数据 */</span>          <br>            <span class="hljs-title function_">ts_timer_enable</span>();<br><span class="hljs-comment">#endif</span><br>            <span class="hljs-comment">/* 第1次启动ADC后:          </span><br><span class="hljs-comment">             *   a. 要连续启动N次, 获得N个数据, 求平均值并上报          </span><br><span class="hljs-comment">             *   b. 得到N次数据后, 再启动TIMER           </span><br><span class="hljs-comment">             */</span><br>                <span class="hljs-variable">adc_x</span> <span class="hljs-operator">+</span><span class="hljs-operator">=</span> (<span class="hljs-variable">x</span> <span class="hljs-operator">&amp;</span> <span class="hljs-number">0x3ff</span>);<br>                <span class="hljs-variable">adc_y</span> <span class="hljs-operator">+</span><span class="hljs-operator">=</span> (<span class="hljs-variable">y</span> <span class="hljs-operator">&amp;</span> <span class="hljs-number">0x3ff</span>);<br>        <span class="hljs-comment">//定义一个函数把这些值打印出来</span><br>                <span class="hljs-variable">test_x_array</span>[<span class="hljs-variable">adc_cnt</span>] <span class="hljs-operator">=</span> (<span class="hljs-variable">x</span> <span class="hljs-operator">&amp;</span> <span class="hljs-number">0x3ff</span>);<br>                <span class="hljs-variable">test_y_array</span>[<span class="hljs-variable">adc_cnt</span>] <span class="hljs-operator">=</span> (<span class="hljs-variable">y</span> <span class="hljs-operator">&amp;</span> <span class="hljs-number">0x3ff</span>);<br>                <br>                <span class="hljs-variable">adc_cnt</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span>;<br><br>                <span class="hljs-keyword">if</span> (<span class="hljs-variable">adc_cnt</span> <span class="hljs-operator">==</span> <span class="hljs-number">16</span>)<br>                &#123;<br>                        <span class="hljs-variable">adc_x</span> <span class="hljs-operator">&gt;&gt;</span><span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>                        <span class="hljs-variable">adc_y</span> <span class="hljs-operator">&gt;&gt;</span><span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>                        <span class="hljs-title function_">report_ts_xy</span>(<span class="hljs-variable">adc_x</span>, <span class="hljs-variable">adc_y</span>, <span class="hljs-number">1</span>);<br>                        <span class="hljs-variable">adc_cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                        <span class="hljs-variable">adc_x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                        <span class="hljs-variable">adc_y</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                        <br>                        <span class="hljs-comment">/* 启动定时器以再次读取数据 */</span><br>                        <span class="hljs-comment">/* 先设置TS进入&quot;等待中断模式&quot; */</span><br>        <span class="hljs-comment">//有按下就会有松开</span><br>                        <span class="hljs-title function_">enter_wait_pen_up_mode</span>();<br>                        <span class="hljs-title function_">ts_timer_enable</span>();<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                        <span class="hljs-comment">/* 再次启动ADC */</span><br>                        <span class="hljs-comment">/* 进入&quot;自动测量&quot;模式 */</span><br>                        <span class="hljs-title function_">enter_auto_measure_mode</span>();<br>                        <br>                        <span class="hljs-comment">/* 启动ADC */</span><br>                        <span class="hljs-variable">ADCCON</span> <span class="hljs-operator">|</span><span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">0</span>);<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>                <span class="hljs-variable">adc_cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-variable">adc_x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-variable">adc_y</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;adc report pen down<span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span>&quot;</span>);<br>                <span class="hljs-title function_">ts_timer_disable</span>();<br>                <span class="hljs-title function_">enter_wait_pen_down_mode</span>();<br>                <span class="hljs-title function_">report_ts_xy</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-comment">//enter_wait_pen_up_mode();  /* 启动ADC时不应该进入这个模式, 它会影响数据 */&#125;</span><br><br><span class="hljs-variable">void</span> <span class="hljs-title class_">AdcTsIntHandle</span>(int <span class="hljs-variable">irq</span>)<br>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">SUBSRCPND</span> <span class="hljs-operator">&amp;</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-variable">TC_INT_BIT</span>))  <span class="hljs-comment">/* 如果是触摸屏中断 */</span><br>                <span class="hljs-title class_">Isr</span>_Tc();<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">SUBSRCPND</span> <span class="hljs-operator">&amp;</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-variable">ADC_INT_BIT</span>))  <span class="hljs-comment">/* ADC中断 */</span><br>                <span class="hljs-title class_">Isr</span>_Adc();<br>        <span class="hljs-variable">SUBSRCPND</span> <span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-variable">TC_INT_BIT</span>) <span class="hljs-operator">|</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-variable">ADC_INT_BIT</span>);<br>&#125;<br><br><span class="hljs-variable">void</span> <span class="hljs-title function_">adc_ts_int_init</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-variable">SUBSRCPND</span> <span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-variable">TC_INT_BIT</span>) <span class="hljs-operator">|</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-variable">ADC_INT_BIT</span>);<br><br>        <span class="hljs-comment">/* 注册中断处理函数 */</span><br>        <span class="hljs-title function_">register_irq</span>(<span class="hljs-number">31</span>, <span class="hljs-title class_">AdcTsIntHandle</span>);<br><br>        <span class="hljs-comment">/* 使能中断 */</span><br>        <span class="hljs-variable">INTSUBMSK</span> <span class="hljs-operator">&amp;</span><span class="hljs-operator">=</span> <span class="hljs-operator">~</span>((<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-variable">ADC_INT_BIT</span>) <span class="hljs-operator">|</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-variable">TC_INT_BIT</span>));<br>        <span class="hljs-comment">//INTMSK    &amp;= ~(1&lt;&lt;INT_ADC_TC);</span><br>&#125;<br><br><span class="hljs-variable">void</span> <span class="hljs-title function_">adc_ts_reg_init</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-comment">/* [15] : ECFLG,  1 = End of A/D conversion  </span><br><span class="hljs-comment">         * [14] : PRSCEN, 1 = A/D converter prescaler enable  </span><br><span class="hljs-comment">         * [13:6]: PRSCVL, adc clk = PCLK / (PRSCVL + 1)  </span><br><span class="hljs-comment">         * [5:3] : SEL_MUX, 000 = AIN 0  * [2]   : STDBM  </span><br><span class="hljs-comment">         * [0]   : 1 = A/D conversion starts and this bit is cleared after the startup.  </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-variable">ADCCON</span> <span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">14</span>) <span class="hljs-operator">|</span> (<span class="hljs-number">49</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">6</span>) <span class="hljs-operator">|</span> (<span class="hljs-number">0</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">/*  按下触摸屏, 延时一会再发出TC中断  </span><br><span class="hljs-comment">         *  延时时间 = ADCDLY * 晶振周期 = ADCDLY * 1 / 12000000 = 5ms  </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-variable">ADCDLY</span> <span class="hljs-operator">=</span> <span class="hljs-number">60000</span>;      <br>&#125;<br><br><span class="hljs-variable">void</span> <span class="hljs-title function_">touchscreen_init</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-comment">/* 设置触摸屏接口:寄存器 */</span><br>        <span class="hljs-title function_">adc_ts_reg_init</span>();<br><br>        <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;ADCUPDN = 0x%x, SUBSRCPND = 0x%x, SRCPND = 0x%x<span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span>&quot;</span>, <span class="hljs-variable">ADCUPDN</span>, <span class="hljs-variable">SUBSRCPND</span>, <span class="hljs-variable">SRCPND</span>);<br><br>        <span class="hljs-comment">/* 设置中断 */</span><br>        <span class="hljs-title function_">adc_ts_int_init</span>();<br><br>        <span class="hljs-comment">/* 注册定时器处理函数 */</span><br>        <span class="hljs-title function_">register_timer</span>(<span class="hljs-string">&quot;touchscreen&quot;</span>, <span class="hljs-variable">touchscreen_timer_irq</span>);<br><br>        <span class="hljs-comment">/* 让触摸屏控制器进入&quot;等待中断模式&quot; */</span><br>        <span class="hljs-title function_">enter_wait_pen_down_mode</span>();<br>&#125;<br><br><span class="hljs-comment">//打印数组定义的那些值</span><br><span class="hljs-variable">void</span> <span class="hljs-title function_">print_test_array</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        int <span class="hljs-variable">i</span>;<br><br>        <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;test array x : &quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-variable">i</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">16</span>; <span class="hljs-variable">i</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span>)<br>                <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;%08d &quot;</span>, <span class="hljs-variable">test_x_array</span>[<span class="hljs-variable">i</span>]);<br>        <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;<span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span>&quot;</span>);<br><br>        <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;test array y : &quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-variable">i</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">16</span>; <span class="hljs-variable">i</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span>)<br>                <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;%08d &quot;</span>, <span class="hljs-variable">test_y_array</span>[<span class="hljs-variable">i</span>]);<br>        <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;<span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span>&quot;</span>);<br>&#125;<br><br><span class="hljs-variable">void</span> <span class="hljs-title function_">ts_read_raw_test</span>(<span class="hljs-params">int</span> *<span class="hljs-params">px</span>, <span class="hljs-params">int</span> *<span class="hljs-params">py</span>, <span class="hljs-params">int</span> *<span class="hljs-params">ppressure</span>)<br>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-variable">g_ts_data_valid</span> <span class="hljs-operator">==</span> <span class="hljs-number">0</span>);<br>        <span class="hljs-operator">*</span><span class="hljs-variable">px</span> <span class="hljs-operator">=</span> <span class="hljs-variable">g_ts_x</span>;<br>        <span class="hljs-operator">*</span><span class="hljs-variable">py</span> <span class="hljs-operator">=</span> <span class="hljs-variable">g_ts_y</span>;<br>        <span class="hljs-operator">*</span><span class="hljs-variable">ppressure</span> <span class="hljs-operator">=</span> <span class="hljs-variable">g_ts_pressure</span>;<br>        <span class="hljs-title function_">print_test_array</span>();<br>        <span class="hljs-variable">g_ts_data_valid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>tslib.c使用了ts_read_raw函数</li></ul><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs hsp">void get_calibrate_point_data(<span class="hljs-keyword">int</span> lcd_x, <span class="hljs-keyword">int</span> lcd_y, <span class="hljs-keyword">int</span> *px, <span class="hljs-keyword">int</span> *py)<br>&#123;<br>        <span class="hljs-keyword">int</span> pressure<span class="hljs-comment">;</span><br>        <span class="hljs-keyword">int</span> x, y<span class="hljs-comment">;</span><br>        <span class="hljs-keyword">int</span> sum_x = <span class="hljs-number">0</span>, sum_y = <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>        <span class="hljs-keyword">int</span> <span class="hljs-keyword">cnt</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>        <br>        fb_disp_cross(lcd_x, lcd_y, <span class="hljs-number">0</span>xffffff)<span class="hljs-comment">;</span><br><br>        <span class="hljs-comment">/* 等待点击 */</span><br><br>        <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-comment">//ts_read_raw(&amp;x, &amp;y, &amp;pressure); </span><br>            <span class="hljs-comment">//我们使用测试程序去读这些值</span><br>                ts_read_raw_test(&amp;x, &amp;y, &amp;pressure)<span class="hljs-comment">;</span><br>        &#125; <span class="hljs-keyword">while</span> (pressure == <span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br><br>        <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">cnt</span> &lt; <span class="hljs-number">128</span>)<br>                &#123;<br>                        sum_x += x<span class="hljs-comment">;</span><br>                        sum_y += y<span class="hljs-comment">;</span><br>                        <span class="hljs-keyword">cnt</span>++<span class="hljs-comment">;</span><br>                &#125;<br>                <span class="hljs-comment">//ts_read_raw(&amp;x, &amp;y, &amp;pressure);</span><br><br>                <span class="hljs-comment">//ts_read_raw_test(&amp;x, &amp;y, &amp;pressure);</span><br>                printf(<span class="hljs-string">&quot;get raw data: x = %08d, y = %08d, cnt = %d\n\r&quot;</span>, x, y, <span class="hljs-keyword">cnt</span>)<span class="hljs-comment">;</span><br>        &#125; <span class="hljs-keyword">while</span> (pressure)<span class="hljs-comment">;</span><br><br>        *px = sum_x / <span class="hljs-keyword">cnt</span><span class="hljs-comment">;</span><br>        *py = sum_y / <span class="hljs-keyword">cnt</span><span class="hljs-comment">;</span><br><br>        printf(<span class="hljs-string">&quot;return raw data: x = %08d, y = %08d\n\r&quot;</span>, *px, *py)<span class="hljs-comment">;</span><br><br>        <span class="hljs-comment">/* 直到松开才返回 */</span><br>        fb_disp_cross(lcd_x, lcd_y, <span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看点击一下是不是得到了距离非常远的两个值</p><p><img src="/image/700px-Chapter18_lesson12_002.png" alt="700px-Chapter18_lesson12_002.png"></p><p>对于同一个点得到的是255 945 945 944</p><p>发现 945 944经常出现</p><p>我们查一下原因,进入touchscreen.c中</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs awk">void Isr_Adc(void)<br>&#123;<br>        int x = ADCDAT0;<br>        int y = ADCDAT1;<br><br>        static int adc_cnt = <span class="hljs-number">0</span>;<br>        static int adc_x = <span class="hljs-number">0</span>;<br>        static int adc_y = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-regexp">/* 进入ADC中断时, TS处于&quot;自动测量模式&quot; */</span><br><br>        <span class="hljs-regexp">/* 只有在&quot;等待中断模式&quot;下才可以使用ADCDAT0&#x27;BIT 15来判断触摸笔状态 */</span><br><br>        enter_wait_pen_up_mode();<br>        <span class="hljs-keyword">if</span> (!(ADCDAT0 &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>))) <span class="hljs-regexp">/* 如果仍然按下才打印 */</span><br>        &#123;<br><span class="hljs-comment">#if 0                      </span><br>            x &amp;= <span class="hljs-number">0</span>x3ff;          <br>            y &amp;= <span class="hljs-number">0</span>x3ff;     <br>               <br>            <span class="hljs-regexp">//</span>printf(<span class="hljs-string">&quot;x = %08d, y = %08d\n\r&quot;</span>, x, y);          <br>            report_ts_xy(x, y, <span class="hljs-number">1</span>);<br><br>            <span class="hljs-regexp">/* 启动定时器以再次读取数据 */</span>          <br>            ts_timer_enable();<span class="hljs-comment">#endif</span><br>                /* 第<span class="hljs-number">1</span>次启动ADC后:          <br>                 *   a. 要连续启动N次, 获得N个数据, 求平均值并上报          <br>                 *   b. 得到N次数据后, 再启动TIMER           <br>                 */<br>                adc_x += (x &amp; <span class="hljs-number">0</span>x3ff);<br>                adc_y += (y &amp; <span class="hljs-number">0</span>x3ff);<br><br>                test_x_array[adc_cnt] = (x &amp; <span class="hljs-number">0</span>x3ff);<br>                test_y_array[adc_cnt] = (y &amp; <span class="hljs-number">0</span>x3ff);<br>                <br>                adc_cnt++;<br><br>                <span class="hljs-keyword">if</span> (adc_cnt == <span class="hljs-number">16</span>)<br>                &#123;<br>                        adc_x &gt;&gt;= <span class="hljs-number">4</span>;<br>                        adc_y &gt;&gt;= <span class="hljs-number">4</span>;<br>                        report_ts_xy(adc_x, adc_y, <span class="hljs-number">1</span>);<br>                        adc_cnt = <span class="hljs-number">0</span>;<br>                        adc_x = <span class="hljs-number">0</span>;<br>                        adc_y = <span class="hljs-number">0</span>;<br>                        <br>                        <span class="hljs-regexp">/* 启动定时器以再次读取数据 */</span><br>                        <span class="hljs-regexp">/* 先设置TS进入&quot;等待中断模式&quot; */</span><br>                        enter_wait_pen_up_mode();<br>                        ts_timer_enable();<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                        <span class="hljs-regexp">/* 再次启动ADC */</span><br>                        <span class="hljs-regexp">/* 进入&quot;自动测量&quot;模式 */</span><br>                        enter_auto_measure_mode();<br>                        <br>                        <span class="hljs-regexp">/* 启动ADC */</span><br>                        ADCCON |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>);<br>                &#125;<br>                <br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>                adc_cnt = <span class="hljs-number">0</span>;<br>                adc_x = <span class="hljs-number">0</span>;<br>                adc_y = <span class="hljs-number">0</span>;<br>                printf(<span class="hljs-string">&quot;adc report pen down\n\r&quot;</span>);<br>                ts_timer_disable();<br>                enter_wait_pen_down_mode();<br>                report_ts_xy(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        &#125;<br>    <span class="hljs-regexp">//</span>启动ADC后又再次进入enter_wait_pen_up_mode电阻上拉，多次一举<br>        <span class="hljs-regexp">//</span>enter_wait_pen_up_mode();  <span class="hljs-regexp">/* 启动ADC时不应该进入这个模式, 它会影响数据 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/700px-Chapter18_lesson12_003.png" alt="700px-Chapter18_lesson12_003.png"></p><p>发现这些值中还有944，我需要继续查找原因, 在touchscreen.c时钟处理函数中添加打印信息</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/* 每10ms该函数被调用一次  </span><br><span class="hljs-comment">*/</span>void touchscreen<span class="hljs-constructor">_timer_irq(<span class="hljs-params">void</span>)</span><br>&#123;<br>        <span class="hljs-comment">/* 如果触摸屏仍被按下, 进入&quot;自动测量模式&quot;, 启动ADC */</span><br>        <span class="hljs-keyword">if</span> (get<span class="hljs-constructor">_status_of_ts_timer()</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span>)<br>                return;<br><br>        <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">_in_auto_mode()</span>)<br>                return;<br><br>        <span class="hljs-comment">/* 只有在&quot;等待中断模式&quot;下才可以使用ADCDAT0&#x27;BIT 15来判断触摸笔状态 */</span><br><br>        <span class="hljs-keyword">if</span> (ADCDAT0 &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>)) <span class="hljs-comment">/* 如果松开 */</span><br>        &#123;<br>    <span class="hljs-comment">//添加打印信息</span><br>                printf(<span class="hljs-string">&quot;timer set pen down\n\r&quot;</span>);<br>                ts<span class="hljs-constructor">_timer_disable()</span>;<br>    <span class="hljs-comment">//进入enter_wait_pen_down_mode，来判断触摸笔是按下还是松开</span><br>                enter<span class="hljs-constructor">_wait_pen_down_mode()</span>;<br>                report<span class="hljs-constructor">_ts_xy(0, 0, 0)</span>;<br>                return;<br>        &#125;<br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 按下状态 */</span><br>        &#123;<br>                <span class="hljs-comment">/* 进入&quot;自动测量&quot;模式 */</span><br>                enter<span class="hljs-constructor">_auto_measure_mode()</span>;<br><br>                <span class="hljs-comment">/* 启动ADC */</span><br>                ADCCON <span class="hljs-pattern-match">|= (1&lt;&lt;0);</span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match">&#125;</span><br></code></pre></td></tr></table></figure><p><img src="/image/700px-Chapter18_lesson12_004.png" alt="700px-Chapter18_lesson12_004.png"></p><p>非常频繁打印timer set pen down</p><ul><li>我们的判断有问题</li></ul><p>打开芯片手册，搜索这个寄存器,Bit15确实是判断按下或者松开</p><p><img src="/image/700px-Chapter18_lesson12_005.png" alt="700px-Chapter18_lesson12_005.png"></p><p>只有在中断模式下，这一位才可以正确反应是按下还是松开的状态,修改touchscreen_timer_irq函数</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-comment">/* 每10ms该函数被调用一次  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-variable">void</span> <span class="hljs-title function_">touchscreen_timer_irq</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-comment">/* 如果触摸屏仍被按下, 进入&quot;自动测量模式&quot;, 启动ADC */</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">get_status_of_ts_timer</span>() <span class="hljs-operator">==</span> <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment">//如果定时器中断在ADC中间产生，应该立刻返回啥都不做，不需要timer去做任何操作</span><br><span class="hljs-comment">//我们需要写出这个函数</span><br><span class="hljs-comment">//如果不是自动模式，那么就是等待中断模式</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">is_in_auto_mode</span>())<br>                <span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment">//中断处理函数，</span><br>        <span class="hljs-comment">/* 只有在&quot;等待中断模式&quot;下才可以使用ADCDAT0&#x27;BIT 15来判断触摸笔状态 */</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">ADCDAT0</span> <span class="hljs-operator">&amp;</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">15</span>)) <span class="hljs-comment">/* 如果松开 */</span><br>        &#123;<br>                <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;timer set pen down<span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span>&quot;</span>);<br>                <span class="hljs-title function_">ts_timer_disable</span>();<br>                <span class="hljs-title function_">enter_wait_pen_down_mode</span>();<br>                <span class="hljs-title function_">report_ts_xy</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 按下状态 */</span><br>        &#123;<br>                <span class="hljs-comment">/* 进入&quot;自动测量&quot;模式 */</span><br>                <span class="hljs-title function_">enter_auto_measure_mode</span>();<br>                <span class="hljs-comment">/* 启动ADC */</span><br>                <span class="hljs-variable">ADCCON</span> <span class="hljs-operator">|</span><span class="hljs-operator">=</span> (<span class="hljs-number">1</span><span class="hljs-operator">&lt;&lt;</span><span class="hljs-number">0</span>);<br>        &#125;<br>&#125;<br><br><span class="hljs-comment">//判断是否是模式模式的函数</span><br><br>int <span class="hljs-title function_">is_in_auto_mode</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">ADCTSC</span> <span class="hljs-operator">&amp;</span> <span class="hljs-variable">AUTO_PST</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们接着实验</p><p><img src="/image/700px-Chapter18_lesson12_006.png" alt="700px-Chapter18_lesson12_006.png"></p><p>发现并没有捕捉到笔的松开模式 , 修改tslib，取消ts_read_raw_test 重新进行测试.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs perl">void get_calibrate_point_data(<span class="hljs-keyword">int</span> lcd_x, <span class="hljs-keyword">int</span> lcd_y, <span class="hljs-keyword">int</span> *px, <span class="hljs-keyword">int</span> *py)<br>&#123;<br>        <span class="hljs-keyword">int</span> pressure;<br>        <span class="hljs-keyword">int</span> <span class="hljs-keyword">x</span>, <span class="hljs-keyword">y</span>;<br>        <span class="hljs-keyword">int</span> sum_x = <span class="hljs-number">0</span>, sum_y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <br>        fb_disp_cross(lcd_x, lcd_y, <span class="hljs-number">0xffffff</span>);<br><br>        <span class="hljs-regexp">/* 等待点击 */</span><br><br>        <span class="hljs-keyword">do</span> &#123;<br>                ts_read_raw(&amp;<span class="hljs-keyword">x</span>, &amp;<span class="hljs-keyword">y</span>, &amp;pressure);<br>                <span class="hljs-regexp">//</span>ts_read_raw_test(&amp;<span class="hljs-keyword">x</span>, &amp;<span class="hljs-keyword">y</span>, &amp;pressure);<br>        &#125; <span class="hljs-keyword">while</span> (pressure == <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (cnt &lt; <span class="hljs-number">128</span>)<br>                &#123;<br>                        sum_x += <span class="hljs-keyword">x</span>;<br>                        sum_y += <span class="hljs-keyword">y</span>;<br>                        cnt++;<br>                &#125;<br>                ts_read_raw(&amp;<span class="hljs-keyword">x</span>, &amp;<span class="hljs-keyword">y</span>, &amp;pressure);<br>                <span class="hljs-regexp">//</span>ts_read_raw_test(&amp;<span class="hljs-keyword">x</span>, &amp;<span class="hljs-keyword">y</span>, &amp;pressure);<br>                <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;get raw data: x = %08d, y = %08d, cnt = %d\n\r&quot;</span>, <span class="hljs-keyword">x</span>, <span class="hljs-keyword">y</span>, cnt);<br>        &#125; <span class="hljs-keyword">while</span> (pressure);<br><br>        *px = sum_x / cnt;<br>        *py = sum_y / cnt;<br><br>        <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;return raw data: x = %08d, y = %08d\n\r&quot;</span>, *px, *py);<br><br>        <span class="hljs-regexp">/* 直到松开才返回 */</span><br>        fb_disp_cross(lcd_x, lcd_y, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在发现点点不准确</p><p><img src="/image/700px-Chapter18_lesson12_007.png" alt="700px-Chapter18_lesson12_007.png"></p><p>发现校准的值和我们之前的不一样,修改我们的tslib校准程序</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs perl">void get_calibrate_point_data(<span class="hljs-keyword">int</span> lcd_x, <span class="hljs-keyword">int</span> lcd_y, <span class="hljs-keyword">int</span> *px, <span class="hljs-keyword">int</span> *py)<br>&#123;<br>        <span class="hljs-keyword">int</span> pressure;<br>        <span class="hljs-keyword">int</span> <span class="hljs-keyword">x</span>, <span class="hljs-keyword">y</span>;<br>        <span class="hljs-keyword">int</span> sum_x = <span class="hljs-number">0</span>, sum_y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <br>        fb_disp_cross(lcd_x, lcd_y, <span class="hljs-number">0xffffff</span>);<br><br>        <span class="hljs-regexp">/* 等待点击 */</span><br>        <span class="hljs-keyword">do</span> &#123;<br>                ts_read_raw(&amp;<span class="hljs-keyword">x</span>, &amp;<span class="hljs-keyword">y</span>, &amp;pressure);<br>                <span class="hljs-regexp">//</span>ts_read_raw_test(&amp;<span class="hljs-keyword">x</span>, &amp;<span class="hljs-keyword">y</span>, &amp;pressure);<br>        &#125; <span class="hljs-keyword">while</span> (pressure == <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-regexp">//</span>我们把求和的次数限制为<span class="hljs-number">128</span>次<br>                <span class="hljs-keyword">if</span> (cnt &lt; <span class="hljs-number">128</span>)<br>                &#123;<br>                        sum_x += <span class="hljs-keyword">x</span>;<br>                        sum_y += <span class="hljs-keyword">y</span>;<br>                        cnt++;<br>                &#125;<br>                ts_read_raw(&amp;<span class="hljs-keyword">x</span>, &amp;<span class="hljs-keyword">y</span>, &amp;pressure);<br>                <span class="hljs-regexp">//</span>ts_read_raw_test(&amp;<span class="hljs-keyword">x</span>, &amp;<span class="hljs-keyword">y</span>, &amp;pressure);<br>                <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;get raw data: x = %08d, y = %08d, cnt = %d\n\r&quot;</span>, <span class="hljs-keyword">x</span>, <span class="hljs-keyword">y</span>, cnt);<br>        &#125; <span class="hljs-keyword">while</span> (pressure);<br><br>        *px = sum_x / cnt;<br>        *py = sum_y / cnt;<br><br>        <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;return raw data: x = %08d, y = %08d\n\r&quot;</span>, *px, *py);<br><br>        <span class="hljs-regexp">/* 直到松开才返回 */</span><br>        fb_disp_cross(lcd_x, lcd_y, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以参考tslib</p><p>1). 使用矩阵进行校准，适用性更强</p><p>2). 使用多种方法消除误差，多次测量求平均值</p><p>判断相领点的距离，如果突然变化很大，就有可能是错误值</p><p>1). …</p><p>第一期的视频在于裸机基本操作</p><p><strong>视频的要点在于</strong></p><p><strong>修改要点</strong></p><p>1). 启动ADC时不应该进入等待中断模式，它会影响数据</p><p>2). 只有在”等待中断模式”下才可以使用ADCDAT0’BIT 15来判断触摸笔状态</p><p>3). 校准非常重要，所以在程序种多次测量求平均值(不仅仅是在adc中断种求平均值)</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第017课 LCD编程</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AC%AC017%E8%AF%BE_LCD%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AC%AC017%E8%AF%BE_LCD%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>目录</strong></p><hr><ol><li>第001节_LCD硬件原理</li><li>第002节_S3C2440_LCD控制器</li><li>第003节_编程_框架与准备</li><li>第004节_编程_抽象出重要结构体</li><li>第005节_编程_LCD控制器</li><li>第006节_编程_LCD设置</li><li>第007节_编程_简单测试</li><li>第008节_编程_画点线圆</li><li>第009节_编程_显示文字</li><li>第010节_编程_添加除法</li><li>第011节_编程_使用调色板</li></ol><p><strong>第001节_LCD硬件原理</strong></p><hr><p>先简单介绍下LCD的操作原理。 如下图的LCD示意图，里面的每个点就是一个像素点。</p><p><img src="/image/400px-Chapter17_lesson1_001.jpg" alt="400px-Chapter17_lesson1_001.jpg"></p><p>想象有一个电子枪，一边移动，一边发出各种颜色的光。这里有很多细节问题，我们一个一个的梳理。</p><ul><li><ol><li>电子枪是如何移动的？</li></ol></li></ul><p>答：有一条CLK时钟线与LCD相连，每发出一次CLK(高低电平)，电子枪就移动一个像素。</p><ul><li><ol start="2"><li>颜色如何确定？</li></ol></li></ul><p>答：由连接LCD的三组线：R(Red)、G(Green)、B(Blue)确定。</p><ul><li><ol start="3"><li>电子枪如何得知应跳到下一行？</li></ol></li></ul><p>答：有一条HSYNC信号线与LCD相连，每发出一次脉冲(高低电平)，电子枪就跳到下一行。</p><ul><li><ol start="4"><li>电子枪如何得知应跳到原点？</li></ol></li></ul><p>答：有一条VSYNC信号线与LCD相连，每发出一次脉冲(高低电平)，电子枪就跳到原点。</p><ul><li><ol start="5"><li>RGB线上的数据从何而来？</li></ol></li></ul><p>答：内存里面划分一块显存(FrameBuffer)，里面存放了要显示的数据，LCD控制器从里面将数据读出来，通过RGB三组线传给电子枪，电子枪再转成红绿蓝三个颜色依次打到显示屏上。</p><ul><li><ol start="6"><li>前面的信号由谁发给LCD？</li></ol></li></ul><p>答：有S3C2440里面的LCD控制器来控制发出信号。</p><p>通过JZ2440原理图对上面进行验证，下图的LCD控制器接口图。</p><p><img src="/image/700px-Chapter17_lesson1_002.jpg" alt="700px-Chapter17_lesson1_002.jpg"></p><p>①是时钟信号，每来一个CLK，电子枪就移动一个像素；</p><p>②是用来传输颜色数据；</p><p>③是垂直方向同步信号，FRAME(帧)；</p><p>④是水平方向同步信号，LINE(行)；</p><p>再来看看LCD的芯片手册。</p><p><img src="/image/700px-Chapter17_lesson1_003.jpg" alt="700px-Chapter17_lesson1_003.jpg"></p><p>先是VLED+、VLED-背光灯电源。VDD、VDD是LCD电源。</p><p>R0-R7、G0-G7、B0-B7是红绿蓝颜色信号。</p><p>PCLK是像素时钟信号。DISP是像素开关。</p><p>HSYNC、VSYNC分别是水平方向、垂直方向信号。</p><p>DE数据使能。X1、Y1、X2、Y2是触摸屏信号。</p><p>内存中划分出一个区域为FrameBuffer，在FrameBuffer里我们构造好每个像素对应的颜色的数据，而这些值最终会被lcd控制器读出来，通过RGB三组线传给电子枪，电子枪再把它们转成红绿蓝三组颜色打到像素上去，即每个像素在FrameBuffer里都有它对应的存储空间，里面存有它的值(颜色)</p><p>可以看出LCD有很多信号，这些信号要根据时序图传输才能正确显示。参考JZ2440_4.3寸LCD手册_AT043TN24的时序如下：</p><p><img src="/image/d528c75e7c2fb0735c8dcd5bfdf65ced.png" alt="d528c75e7c2fb0735c8dcd5bfdf65ced.png"></p><p>从最小的像素开始分析，电子枪每次在CLK下降沿(本开发板是下降沿)从数据线Dn0-Dn7上得到数据，发射到像素上，然后移动到下一个位置。Dn0-Dn7上的数据来源就是前面介绍的FrameBuffer。就这样从一行的最左边，一直移动到一行的最右边，完成了一行的显示，假设为x。</p><p>当打完一行的最后一个数据后，就会收到Hsync行同步信号，根据时序图，一个Hsync周期可以大致分为五部分组成：thp、thb、1&#x2F;tc、thd、thf。thp称为脉冲宽度，这个时间不能太短，太短电子枪可能识别不到。电子枪正确识别到thp后，会从最右端移动最左端，这个移动的时间就是thb，称之为移动时间。thf表示显示完最右像素，再过多久Hsync才来。</p><p>同理，当电子枪一行一行的从上面移动到最下面时，会收到一个Vsync信号，Vsync垂直同步信号就让电子枪移动回最上边。Vsync中的tvp是脉冲宽度，tvb是移动时间，tvf表示显示完最下一行像素，再过多久Vsync才来。 假设一共有y个Hsync,每个Hsync有x个像素，则LCD的分辨率就是x*y。</p><p>关于显示原理，可以参考这篇博客：<a href="http://www.cnblogs.com/shangdawei/p/4760933.html">http://www.cnblogs.com/shangdawei/p/4760933.html</a></p><p>里面有一个LCD显示配置示意图如下：</p><p><img src="/image/700px-Chapter17_lesson1_005.jpg" alt="700px-Chapter17_lesson1_005.jpg"></p><p>当发出一个HSYNC信号后，电子枪就会从最右边花费HBP时长移动到最左边，等到了最右边后，等待HFP时长HSYNC信号才回来。因此，HBP和HFP分别决定了左边和右边的黑框。</p><p>同理，当发出一个VSYNC信号后，电子枪就会从最下边花费VBP时长移动到最上边，等到了最下边后，等待VFP时长VSYNC信号才回来。因此，VBP和VFP分别决定了上边和下边的黑框。 中间灰色区域才是有效显示区域。</p><p>再来解决最后一个问题：每个像素在FrameBuffer中，占据多少位BPP(Bits Per Pixels)？ 前面的LCD引脚功能图里，R0-R7、G0-G7、B0-B7，每个像素是占据3*8&#x3D;24位的，即硬件上LCD的BPP是确定的。</p><p>虽然LCD上的引脚是固定的，但我们使用的时候，可以根据实际情况进行取舍，比如我们的JZ2440使用的是16BPP，因此LCD只需要R0-R4、G0-G5、B0-B4与SOC相连，5+6+5&#x3D;16BPP，每个像素就只占据16位数据。</p><p>我们写程序的思路如下：</p><ol><li>查看LCD芯片手册，查看相关的时间参数、分辨率、引脚极性；</li><li>根据以上信息设置LCD控制器寄存器，让其发出正确信号；</li><li>在内存里面分配一个FrameBuffer，在里面用若干位表示一个像素，再把首地址告诉LCD控制器；</li></ol><p>之后LCD控制器就能周而复始取出FrameBuffer里面的像素数据，配合其它控制信号，发送给电子枪，电子枪再让在LCD上显示出来。以后我们想显示图像，只需要编写程序向FrameBuffer填入相应数据即可，硬件会自动的完成显示操作。</p><p><strong>第002节_S3C2440_LCD控制器</strong></p><hr><p>LCD控制器主要功能和需要的设置：</p><ol><li>取：从内存(FrameBuffer)取出某个像素的数据；之后需要把FrameBuffer地址、BPP、分辨率告诉LCD控制器；</li><li>发：配合其它信号把FrameBuffer数据发给LCD；需要设置LCD控制器时序、设置引脚极性(高&#x2F;低脉冲有效)；</li></ol><p>这里主要的难点就是如何配合其它信号，需要我们阅读LCD芯片手册，知道其时序要求，然后设置相应的LCD控制器。</p><p>S3C2440芯片手册介绍了LCD控制器支持TFT和STN两种LCD，我们常用的都是TFT材质的，因此主要看TFT相关的部分。</p><p>先看下S3C2440芯片手册上的LCD控制器框图：</p><p><img src="/image/700px-Chapter17_lesson2_001.png" alt="700px-Chapter17_lesson2_001.png"></p><p>LCDCDMA会自动(无需CPU参与)把内存上FrameBuffer里的数据，通过VIDPRCS发送到引脚VD[23:0]上，再配合VIDEOMUX引脚的控制信号，使LCD正确的显示出来。</p><p>通过设置REGBANK(寄存器组)来设置TIMEGEN，从而控制LCD控制器让这些引脚发出合适的时序极性.</p><p>翻开芯片手册</p><p>使用8BPP会使用到调色板</p><p><strong>调色板的概念：</strong></p><p>画油画的时候，通常先在调色板里配好想要的颜色，再用画笔沾到画布上作画。LCD控制器里也借用了这个概念，从FrameBuffer获得数据，这个数据作为索引从调色板获得对应数据，再发给电子枪显示出来。</p><p><img src="/image/700px-Chapter17_lesson2_002.jpg" alt="700px-Chapter17_lesson2_002.jpg"></p><p>如图，假如是16BPP的数据，LCD控制器从FB取出16bit数据，显示到LCD上。</p><p>当如果想节约内存，对颜色要求也没那么高，就可以采用调色板的方式，调色板里存放了256个16bit的数据，FB只存放每个像素的索引，根据索引去调色板找到对应的数据传给LCD控制器，再通过电子枪显示出来。调色板就是一块内存</p><p>假设现在想要LCD只显示一种颜色怎么办？</p><p>如果是16BPP&#x2F;24BPP需要修改FB里面的数据，填充同一个值。</p><p>如果是8BPP可以修改FB为同一种颜色，也可以设置调色板为同一种颜色，对于S3C22440有个临时调色板的特性，一旦使能了临时 调色板，不管FB里面是什么数据，都只调用临时调色板的数据。</p><p><strong>第003节_编程_框架与准备</strong></p><hr><p>本节主要有两个目的：</p><ul><li>讲解后续程序的框架；</li><li>准备一个支持NAND、NOR启动的程序；</li></ul><p>我们的目的是在LCD显示屏上画线、画圆(geomentry.c)和写字(font.c)其核心是画点(farmebuffer.c)，这些都属于纯软件。此外还需要一个lcd_test.c测试程序提供操作菜单，调用画线、画圆和写字操作。</p><p>往下操作的是LCD相关的内容，不同的LCD，其配置的参数也会不一样，通过lcd_3.5.c或lcd_4.3.c来设置。</p><p>根据LCD的特性，来设置LCD控制器，对于我们开发板，就是s3c2440_lcd_controller.c，假如希望在其它开发板上也实现LCD显示，只需添加相应的代码文件即可。</p><p>这就是LCD编程的框架，尽可能的“高内聚低耦合”。</p><p><img src="/image/700px-Chapter17_lesson3_001.jpg" alt="700px-Chapter17_lesson3_001.jpg"></p><p>我们先实现LCD控制器，再实现lcd_4.3.c，最后在framebuffer.c里实现画点，在画点的基础上在geometry.c中实现画线化圆写字，然后写下lcd_tet.c来提供测试菜单</p><p>为了让程序更加好扩展，下面介绍“面向对象编程”的概念。</p><p>假如我们写好程序后，有两款尺寸大小的lcd，如何快速的在两个lcd上切换？</p><p>首先我们抽象出lcd_3.5.c和lcd_4.3.c的共同点，比如都有初始化函数init(),我们可以新建一个lcd.c，然后定义一个结构体：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">struct</span> lcd_opr<br>&#123;<br>    <span class="hljs-keyword">void</span> (*<span class="hljs-keyword">init</span>)(<span class="hljs-keyword">void</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>用户不接触lcd_3.5.c和lcd_4.3.c，只需要在lcd.c里通过指针访问对应的结构体的函数，也就调用了不同init()。</p><p><img src="/image/700px-Chapter17_lesson3_002.jpg" alt="700px-Chapter17_lesson3_002.jpg"></p><p>前面我们的程序大小都没超过4K，因此无论Nor&#x2F;Nand启动，都是正常的，现在的LCD相关代码比较大，超过4K，因此需要修改启动部分的代码。</p><p>目前还未讲解nand flash，因此直接将19课准备的nand_flash程序部分复制到当前代码里即可，关于这部分可以参考nand flash讲解部分。</p><p><strong>第004节_编程_抽象出重要结构体</strong></p><hr><p>面向对象编程结构化编程&#x2F;：</p><p>假设面向不同尺寸的lcd有lcd_3.5.c和lcd_4.3.c两个程序，我们抽象出lcd_3.5和lcd_4.3的共同点：比如init函数</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp">那么定义一个结构体<br><span class="hljs-keyword">struct</span> lcd_opr&#123;<br>    <span class="hljs-keyword">void</span> (*<span class="hljs-keyword">init</span>)(<span class="hljs-keyword">void</span>)<br>&#125;<br>同样在lcd_3<span class="hljs-number">.5</span>.c和lcd_4<span class="hljs-number">.3</span>.c两个文件中定义如下结构体<br><span class="hljs-keyword">struct</span> lcd_opr lcd_3_5_opr&#123;<br>    .<span class="hljs-keyword">init</span> = lcd_3_5_init;<br>&#125;<br><span class="hljs-keyword">struct</span> lcd_opr lcd_4_3_opr&#123;<br>    .<span class="hljs-keyword">init</span> = lcd_4_3_init;<br>&#125;<br>在这两个程序的上层lcd.c定义<br><span class="hljs-keyword">struct</span> lcd_opr *lo;<br>当想使用<span class="hljs-number">3.5</span>寸或者<span class="hljs-number">4.3</span>寸的时候，将lo指向对应的结构体(lcd_3_5_opr或lcd_4_3_opr)<br>同理于lcd_controller.c和s3c2440_lcd_controller.c与ti_lcd_controller.c<br></code></pre></td></tr></table></figure><p>就是说将lcd.c这些上层代码与下层分开，当你换开发板或lcd时只要修改或增加下层的调用代码即可，而无需动上层的代码，增加了代码的拓展性</p><p>开始正式编写程序，根据前面的框架，新建如下文件：</p><p>font.c、framebuffer.c、geometry.c、lcd.c、lcd_4.3.c、lcd_controller.c、s3c2440_lcd_controller.c、lcd_test.c</p><p>首先编写lcd_controller.c，它向上要接收不同尺寸LCD的参数，向下要使用这些参数设置对应的LCD控制器。</p><p>前面我们列举了LCD的参数，例如引脚的极性、时序、数据的格式bpp、分辨率等，使用面向对象的思维方式，将这些参数封装成结构体放在lcd.h中：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">/* lcd.h */</span> lcd.h是所有参数<br><span class="hljs-keyword">enum</span> &#123;<br>        NORMAL = <span class="hljs-number">0</span>,<br>        INVERT = <span class="hljs-number">1</span>,<br>&#125;;<br><br><span class="hljs-comment">/* NORMAL : 正常极性(默认的为低电平有效) </span><br><span class="hljs-comment"> * INVERT : 反转极性 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> struct pins_polarity &#123;                <span class="hljs-comment">//引脚极性，将可能反转的引脚打包</span><br>        <span class="hljs-built_in">int</span> vclk;  <span class="hljs-comment">/* normal: 在下降沿获取数据 */</span><br>        <span class="hljs-built_in">int</span> rgb;   <span class="hljs-comment">/* normal: 高电平表示1 */</span><br>        <span class="hljs-built_in">int</span> hsync; <span class="hljs-comment">/* normal: 高脉冲 (看时序图猜，不对再修改)*/</span><br>        <span class="hljs-built_in">int</span> vsync; <span class="hljs-comment">/* normal: 高脉冲 (看时序图猜，不对再修改)*/</span><br>&#125;pins_polarity, *p_pins_polarity;<br><br><span class="hljs-keyword">typedef</span> struct time_sequence                 <span class="hljs-comment">//时序，将要设置的时序打包</span><br>&#123;<br>        <span class="hljs-comment">/* 垂直方向 */</span><br>        <span class="hljs-built_in">int</span> tvp; <span class="hljs-comment">/* vysnc脉冲宽度 */</span><br>        <span class="hljs-built_in">int</span> tvb; <span class="hljs-comment">/* 上边黑框, Vertical Back porch */</span><br>        <span class="hljs-built_in">int</span> tvf; <span class="hljs-comment">/* 下边黑框, Vertical Front porch */</span><br><br>        <span class="hljs-comment">/* 水平方向 */</span><br>        <span class="hljs-built_in">int</span> thp; <span class="hljs-comment">/* hsync脉冲宽度 */</span><br>        <span class="hljs-built_in">int</span> thb; <span class="hljs-comment">/* 左边黑框, Horizontal Back porch */</span><br>        <span class="hljs-built_in">int</span> thf; <span class="hljs-comment">/* 右边黑框, Horizontal Front porch */</span><br><br>        <span class="hljs-built_in">int</span> vclk;<br>&#125;time_sequence, *p_time_sequence;<br><br><span class="hljs-keyword">typedef</span> struct lcd_params         <span class="hljs-comment">//存储了lcd的参数</span><br>&#123;<br>        <span class="hljs-comment">/* 引脚极性 */</span><br>        pins_polarity pins_pol;<br>        <br>        <span class="hljs-comment">/* 时序 */</span><br>        time_sequence time_seq;<br>        <br>        <span class="hljs-comment">/* 分辨率, bpp */</span><br>        <span class="hljs-built_in">int</span> xres;<br>        <span class="hljs-built_in">int</span> yres;<br>        <span class="hljs-built_in">int</span> bpp;<br>        <br>        <span class="hljs-comment">/* framebuffer的地址 */</span><br>        unsigned <span class="hljs-built_in">int</span> fb_base;<br>&#125;lcd_params, *p_lcd_params;<br></code></pre></td></tr></table></figure><p>以后就使用lcd_params结构体来表示lcd参数。</p><p>比如在lcd_4.3.c中</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nim">lcd_params lcd_4_3_params = <span class="hljs-meta">&#123;...&#125;</span>;    //以后完善<br></code></pre></td></tr></table></figure><p>这些参数传递给lcd_controller.c</p><p>对于有多个lcd的情况，再定义个一个结构体，包含指针初始化函数和使能函数，放在lcd_controller.h里面：</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs thrift"><span class="hljs-comment">/* lcd_controller.h */</span><br><span class="hljs-comment">/* lcd_controller.c下面有很多开发板，这些板子的lcd控制器的操作肯定不一样，连寄存器都不一样，所以我们需要再抽象出一个lcd控制器的操作结构体(lcd_con_opr)，即以下的lcd_controller结构体.(结构体一般定义在h文件中) */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lcd_controller</span> </span><br><span class="hljs-class"></span>&#123;<br>        <span class="hljs-keyword">void</span> (*init)(p_lcd_params plcdparams);    <span class="hljs-comment">//lcd.c中的lcd参数结构体指针，不同lcd有不同的参数</span><br>        <span class="hljs-keyword">void</span> (*enable)(<span class="hljs-keyword">void</span>);        <span class="hljs-comment">//使能这个lcd控制器</span><br>        <span class="hljs-keyword">void</span> (*disable)(<span class="hljs-keyword">void</span>);<br>&#125;lcd_controller, *p_lcd_controller;<br></code></pre></td></tr></table></figure><p>最后在lcd_controller.c里传入lcd参数，再通过指针函数初始化对应的lcd控制器：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* lcd_controller.c */</span><br><span class="hljs-regexp">/* 上层将参数传递给它，它在使用这些参数设置下面选中的某一个lcd控制器 */</span><br>void lcd_controller_init(p_lcd_params plcdparams)    <span class="hljs-regexp">//</span>lcd.c中的lcd参数结构体指针<br>&#123;<br>        <span class="hljs-regexp">/* 比如调用2440的LCD控制器的初始化函数 */</span><br>        lcd_controller.init(plcdparams);        <span class="hljs-regexp">//</span>调用lcd_controller中的某一个init函数，并把参数传递给它，而调用的函数就在对应板子的lcd_controller中实现<br>&#125;<br></code></pre></td></tr></table></figure><p>在s3c2440_lcd_controller.c还需构造一个当前soc的lcd控制器结构体：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* s3c2440_lcd_controller.c */</span><br>struct lcd_controller s3c2440_lcd_controller = <br>&#123;<br>        .init    = xxx,<br>        .enalbe  = xxx,<br>        .disable = xxx,        <span class="hljs-regexp">//</span>三个待构造函数<br>&#125;;    <br></code></pre></td></tr></table></figure><p><strong>第005节_编程_LCD控制器</strong></p><hr><p>s3c2440_lcd_controller.c：对传入的参数进行符合s3c2440板子的操作，按照s3c2440的lcd控制器的规范将参数写入对应寄存器</p><p>继续上一节的代码，修改s3c2440_lcd_controller.c：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs llvm">struct lcd_controller s<span class="hljs-number">3</span><span class="hljs-keyword">c</span><span class="hljs-number">2440</span>_lcd_controller <span class="hljs-operator">=</span> <br>&#123;<br>        .init    <span class="hljs-operator">=</span> s<span class="hljs-number">3</span><span class="hljs-keyword">c</span><span class="hljs-number">2440</span>_lcd_controller_init<span class="hljs-punctuation">,</span><br>        .enalbe  <span class="hljs-operator">=</span> s<span class="hljs-number">3</span><span class="hljs-keyword">c</span><span class="hljs-number">2440</span>_lcd_controller_enalbe<span class="hljs-punctuation">,</span><br>        .disable <span class="hljs-operator">=</span> xs<span class="hljs-number">3</span><span class="hljs-keyword">c</span><span class="hljs-number">2440</span>_lcd_controller_disable<span class="hljs-punctuation">,</span><br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>然后对每个函数进行功能实现，首先是s3c2440_lcd_controller_init，按照芯片手册依次设置LCD控制器寄存器，先是LCD寄存器1：</p><p><img src="/image/700px-Chapter17_lesson5_001.png" alt="700px-Chapter17_lesson5_001.png"></p><p>[27:18]为只读数据位，不需要设置；</p><p>[17:8]用于设置CLKVAL(像素时钟频率)，我们使用的是TFT屏，因此采用的公式是VCLK &#x3D; HCLK &#x2F; [(CLKVAL+1) x 2]，其中HCLK为100M。LCD手册里面(Timing Characterisitics)Clock cycle的要求范围为5-12MHz即可，即假设VCLK&#x3D;9，根据公式9&#x3D;100&#x2F;[(CLKVAL+1)x2],算出CLKVAL≈4.5&#x3D;5。VCLK为plcdparams-&gt;time_seq.vclk，则clkval &#x3D; HCLK&#x2F;plcdparams-&gt;time_seq.vclk&#x2F;2-1+0.5;</p><p>[7]不用管，默认即可；</p><p>[6:5]TFT lcd配置为0b11；</p><p>[4:1]设置bpp模式，根据传入的plcdparams-&gt;bpp配置为相应的数值；</p><p>[0]LCD输出使能，先暂时关闭不输出；</p><p>寄存器2：</p><p><img src="/image/700px-Chapter17_lesson5_002.png" alt="700px-Chapter17_lesson5_002.png"></p><p>对比2440LCD部分时序图和LCD时序图，得出两者之间关系，以后就可通过plcdparams传参数进来设置相关寄存器。</p><p>[31:24] : VBPD &#x3D; tvb - 1</p><p>[23:14] : LINEVAL &#x3D; line - 1</p><p>[13:6]  : VFPD &#x3D; tvf - 1</p><p>[5:0]  : VSPW &#x3D; tvp - 1</p><p>寄存器3：</p><p><img src="/image/700px-Chapter17_lesson5_003.png" alt="700px-Chapter17_lesson5_003.png"></p><p>[25:19] : HBPD &#x3D; thb - 1</p><p>[18:8]  : HOZVAL &#x3D; 列 - 1</p><p>[7:0]  : HFPD &#x3D; thf - 1</p><p>寄存器4：</p><p><img src="/image/700px-Chapter17_lesson5_004.png" alt="700px-Chapter17_lesson5_004.png"></p><p>[7:0]  : HSPW&#x3D; thp - 1</p><p>寄存器5：</p><p><img src="/image/700px-Chapter17_lesson5_005.png" alt="700px-Chapter17_lesson5_005.png"></p><p>用来设置极性, 设置16bpp, 设置内存中象素存放的格式</p><p>[12] : BPP24BL</p><p>[11] : FRM565, 1-565</p><p>[10] : INVVCLK, 0 &#x3D; The video data is fetched at VCLK falling edge</p><p>[9]  : HSYNC是否反转</p><p>[8]  : VSYNC是否反转</p><p>[7]  : INVVD, rgb是否反转</p><p>[6]  : INVVDEN</p><p>[5]  : INVPWREN</p><p>[4]  : INVLEND</p><p>[3]  : PWREN, LCD_PWREN output signal enable&#x2F;disable</p><p>[2]  : ENLEND</p><p>[1]  : BSWP</p><p>[0]  : HWSWP</p><p>然后再设置framebuffer地址，先是 LCDSADDR1：</p><p><img src="/image/700px-Chapter17_lesson5_006.png" alt="700px-Chapter17_lesson5_006.png"></p><p>[29:21] : LCDBANK, A[30:22] of fb</p><p>[20:0]  : LCDBASEU, A[21:1] of fb</p><p>即用[29:0]表示起始地址的[30:1]。</p><p><strong>LCDSADDR2：</strong></p><p><img src="/image/700px-Chapter17_lesson5_007.png" alt="700px-Chapter17_lesson5_007.png"></p><p>[20:0] : LCDBASEL, A[21:1] of end addr</p><p>即framebuffer的结束地址。</p><p>最后还要设置相关引脚，包括背光控制引脚、LCD专用引脚、电源控制引脚：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">jz2440_lcd_pin_init</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>        <span class="hljs-comment">/* 初始化引脚 : 背光引脚 */</span><br>        <span class="hljs-variable constant_">GPBCON</span> &amp;= ~<span class="hljs-number">0x3</span>;<br>        <span class="hljs-variable constant_">GPBCON</span> |= <span class="hljs-number">0x01</span>;<br><br>        <span class="hljs-comment">/* LCD专用引脚 */</span><br>        <span class="hljs-variable constant_">GPCCON</span> = <span class="hljs-number">0xaaaaaaaa</span>;<br>        <span class="hljs-variable constant_">GPDCON</span> = <span class="hljs-number">0xaaaaaaaa</span>;<br><br>        <span class="hljs-comment">/* PWREN */</span><br>        <span class="hljs-variable constant_">GPGCON</span> |= (<span class="hljs-number">3</span>&lt;&lt;<span class="hljs-number">8</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>LCD所有寄存器的具体设置如下：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment">#define HCLK 100</span><br><br><span class="hljs-literal">void</span> jz2440_lcd_pin_init(<span class="hljs-literal">void</span>)<br>&#123;<br>        <span class="hljs-comment">/* 初始化引脚 : 背光引脚 */</span><br>        GPBCON &amp;= ~<span class="hljs-number">0x3</span>;<br>        GPBCON |= <span class="hljs-number">0x01</span>;<br><br>        <span class="hljs-comment">/* LCD专用引脚 */</span><br>        GPCCON = <span class="hljs-number">0xaaaaaaaa</span>;<br>        GPDCON = <span class="hljs-number">0xaaaaaaaa</span>;<br><br>        <span class="hljs-comment">/* PWREN */</span><br>        GPGCON |= (<span class="hljs-number">3</span>&lt;&lt;<span class="hljs-number">8</span>);&#125;<br><br><span class="hljs-comment">/* 根据传入的LCD参数设置LCD控制器 */</span><br><span class="hljs-literal">void</span> s3c2440_lcd_controller_init(p_lcd_params plcdparams)<br>&#123;<br>        int pixelplace;<br>        unsigned int addr;<br><br>        jz2440_lcd_pin_init();<br>        <br>        <span class="hljs-comment">/* [17:8]: clkval, vclk = HCLK / [(CLKVAL+1) x 2]  </span><br><span class="hljs-comment">         *                   9  = 100M /[(CLKVAL+1) x 2], clkval = 4.5 = 5  </span><br><span class="hljs-comment">         *               CLKVAL = 100/vclk/2-1  </span><br><span class="hljs-comment">         * [6:5]: 0b11, tft lcd  </span><br><span class="hljs-comment">         * [4:1]: bpp mode  </span><br><span class="hljs-comment">         * [0]  : LCD video output and the logic enable/disable  </span><br><span class="hljs-comment">         */</span><br>        int clkval = (double)HCLK/plcdparams-&gt;time_seq.vclk/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>+<span class="hljs-number">0.5</span>;<br>        int bppmode = plcdparams-&gt;bpp == <span class="hljs-number">8</span>  ? <span class="hljs-number">0xb</span> :<span class="hljs-string">\</span><br>                                  plcdparams-&gt;bpp == <span class="hljs-number">16</span> ? <span class="hljs-number">0xc</span> :<span class="hljs-string">\</span><br>                                  <span class="hljs-number">0xd</span>;  <span class="hljs-comment">/* 0xd: 24bpp */</span><br>        LCDCON1 = (clkval&lt;&lt;<span class="hljs-number">8</span>) | (<span class="hljs-number">3</span>&lt;&lt;<span class="hljs-number">5</span>) | (bppmode&lt;&lt;<span class="hljs-number">1</span>) ;<br><br>        <span class="hljs-comment">/* [31:24] : VBPD    = tvb - 1  </span><br><span class="hljs-comment">         * [23:14] : LINEVAL = line - 1  </span><br><span class="hljs-comment">         * [13:6]  : VFPD    = tvf - 1  </span><br><span class="hljs-comment">         * [5:0]   : VSPW    = tvp - 1  </span><br><span class="hljs-comment">         */</span><br>        LCDCON2 = ((plcdparams-&gt;time_seq.tvb - <span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-number">24</span>) | <span class="hljs-string">\</span><br>                  ((plcdparams-&gt;yres - <span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-number">14</span>)         | <span class="hljs-string">\</span><br>                  ((plcdparams-&gt;time_seq.tvf - <span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-number">6</span>)  | <span class="hljs-string">\</span><br>                  ((plcdparams-&gt;time_seq.tvp - <span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">/* [25:19] : HBPD    = thb - 1  </span><br><span class="hljs-comment">         * [18:8]  : HOZVAL  = 列 - 1  </span><br><span class="hljs-comment">         * [7:0]   : HFPD    = thf - 1  </span><br><span class="hljs-comment">         */</span><br>        LCDCON3 =      ((plcdparams-&gt;time_seq.thb - <span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-number">19</span>) | <span class="hljs-string">\</span><br>                       ((plcdparams-&gt;xres - <span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-number">8</span>)          | <span class="hljs-string">\</span><br>                       ((plcdparams-&gt;time_seq.thf - <span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">/*   </span><br><span class="hljs-comment">         * [7:0]   : HSPW        = thp - 1  </span><br><span class="hljs-comment">         */</span><br>        LCDCON4 = ((plcdparams-&gt;time_seq.thp - <span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/* 用来设置引脚极性, 设置16bpp, 设置内存中象素存放的格式     </span><br><span class="hljs-comment">     * [12] : BPP24BL  </span><br><span class="hljs-comment">     * [11] : FRM565, 1-565  </span><br><span class="hljs-comment">     * [10] : INVVCLK, 0 = The video data is fetched at VCLK falling edge  </span><br><span class="hljs-comment">     * [9]  : HSYNC是否反转  </span><br><span class="hljs-comment">     * [8]  : VSYNC是否反转  </span><br><span class="hljs-comment">     * [7]  : INVVD, rgb是否反转  </span><br><span class="hljs-comment">     * [6]  : INVVDEN  </span><br><span class="hljs-comment">     * [5]  : INVPWREN  </span><br><span class="hljs-comment">     * [4]  : INVLEND  </span><br><span class="hljs-comment">     * [3]  : PWREN, LCD_PWREN output signal enable/disable  </span><br><span class="hljs-comment">     * [2]  : ENLEND  </span><br><span class="hljs-comment">     * [1]  : BSWP  </span><br><span class="hljs-comment">     * [0]  : HWSWP  </span><br><span class="hljs-comment">     */</span><br><br>        pixelplace = plcdparams-&gt;bpp == <span class="hljs-number">24</span> ? (<span class="hljs-number">0</span>) : |<span class="hljs-string">\</span><br>                     plcdparams-&gt;bpp == <span class="hljs-number">16</span> ? (<span class="hljs-number">1</span>) : |<span class="hljs-string">\</span><br>                     (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>);  <span class="hljs-comment">/* 8bpp */</span><br>        LCDCON5 = (plcdparams-&gt;pins_pol.vclk&lt;&lt;<span class="hljs-number">10</span>) |<span class="hljs-string">\</span><br>                  (plcdparams-&gt;pins_pol.rgb&lt;&lt;<span class="hljs-number">7</span>)   |<span class="hljs-string">\</span><br>                  (plcdparams-&gt;pins_pol.hsync&lt;&lt;<span class="hljs-number">9</span>) |<span class="hljs-string">\</span><br>                  (plcdparams-&gt;pins_pol.vsync&lt;&lt;<span class="hljs-number">8</span>) |<span class="hljs-string">\</span><br>                          (plcdparams-&gt;pins_pol.de&lt;&lt;<span class="hljs-number">6</span>)    |<span class="hljs-string">\</span><br>                          (plcdparams-&gt;pins_pol.pwren&lt;&lt;<span class="hljs-number">5</span>) |<span class="hljs-string">\</span><br>                          (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">11</span>) | pixelplace;<br><br>        <span class="hljs-comment">/* framebuffer地址 */</span><br>        <span class="hljs-comment">/*  </span><br><span class="hljs-comment">         * [29:21] : LCDBANK, A[30:22] of fb  </span><br><span class="hljs-comment">         * [20:0]  : LCDBASEU, A[21:1] of fb  </span><br><span class="hljs-comment">         */</span><br>        addr = plcdparams-&gt;fb_base &amp; ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>);<br>        LCDSADDR1 = (addr &gt;&gt; <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">/*   </span><br><span class="hljs-comment">         * [20:0] : LCDBASEL, A[21:1] of end addr  </span><br><span class="hljs-comment">         */</span><br>        addr = plcdparams-&gt;fb_base + plcdparams-&gt;xres*plcdparams-&gt;yres*plcdparams-&gt;bpp/<span class="hljs-number">8</span>;<br>        addr &gt;&gt;=<span class="hljs-number">1</span>;<br>        addr &amp;= <span class="hljs-number">0x1fffff</span>;<br>        LCDSADDR2 = addr;<span class="hljs-regexp">//       &#125;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">void s3c2440_lcd_controller_enalbe(void)</span><br><span class="hljs-regexp">&#123;</span><br><span class="hljs-regexp">        /* 背光引脚 : GPB0 */</span><br><span class="hljs-regexp">        GPBDAT |= (1&lt;&lt;0);</span><br><span class="hljs-regexp">        </span><br><span class="hljs-regexp">        /* pwren    : 给LCD提供AVDD  */</span><br><span class="hljs-regexp">        LCDCON5 |= (1&lt;&lt;3);</span><br><span class="hljs-regexp">        </span><br><span class="hljs-regexp">        /* LCDCON1&#x27;BIT 0 : 设置LCD控制器是否输出信号 */</span><br><span class="hljs-regexp">        LCDCON1 |= (1&lt;&lt;0);</span><br><span class="hljs-regexp">&#125;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">void s3c2440_lcd_controller_disable(void)</span><br><span class="hljs-regexp">&#123;</span><br><span class="hljs-regexp">        /* 背光引脚 : GPB0 */</span><br><span class="hljs-regexp">        GPBDAT &amp;= ~(1&lt;&lt;0);</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">        /* pwren : 给LCD提供AVDD  */</span><br><span class="hljs-regexp">        LCDCON5 &amp;= ~(1&lt;&lt;3);</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">        /* LCDCON1&#x27;BIT 0 : 设置LCD控制器是否输出信号 */</span><br><span class="hljs-regexp">        LCDCON1 &amp;= ~(1&lt;&lt;0);</span><br><span class="hljs-regexp">&#125;</span><br></code></pre></td></tr></table></figure><p>这就完成了s3c2440_lcd_controller.c的编写，后面只需要向s3c2440_lcd_controller_init()传入构造好的参数即可。</p><p><strong>第006节_编程_LCD设置</strong></p><hr><p>前面编写了s3c2440_lcd_controller.c，以后我们只需往里面传入参数即可控制LCD控制器，对于我们的4.3寸LCD，配合LCD手册时序的介绍，相关的设置如下:</p><p><img src="/image/Chapter17_lesson6_001.png" alt="Chapter17_lesson6_001.png"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#define LCD_FB_BASE 0x33c00000</span><br><br>lcd_params lcd_4_3_params = <br>&#123;<br>        .name = <span class="hljs-string">&quot;lcd_4.3&quot;</span><br>        .pins_polarity = &#123;<br>        .de    = NORMAL,  <span class="hljs-regexp">/* normal: 高电平时可以传输数据 */</span><br>        .pwren = NORMAL,    <span class="hljs-regexp">/* normal: 高电平有效 */</span><br>        .vclk  = NORMAL,  <span class="hljs-regexp">/* normal: 在下降沿获取数据 */</span><br>        .rgb   = NORMAL,  <span class="hljs-regexp">/* normal: 高电平表示1 */</span><br>        .hsync = INVERT,    <span class="hljs-regexp">/* normal: 高脉冲 */</span><br>        .vsync = INVERT,  <span class="hljs-regexp">/* normal: 高脉冲 */</span><br>        &#125;,<br>        .time_sequence = <br>        &#123;<br>             <span class="hljs-regexp">/* 垂直方向 */</span><br>            .tvp=   <span class="hljs-number">10</span>, <span class="hljs-regexp">/* vysnc脉冲宽度 */</span><br>            .tvb=   <span class="hljs-number">2</span>,  <span class="hljs-regexp">/* 上边黑框, Vertical Back porch */</span><br>            .tvf=   <span class="hljs-number">2</span>,  <span class="hljs-regexp">/* 下边黑框, Vertical Front porch */</span><br><br>             <span class="hljs-regexp">/* 水平方向 */</span><br>             .thp=   <span class="hljs-number">41</span>, <span class="hljs-regexp">/* hsync脉冲宽度 */</span><br>             .thb=   <span class="hljs-number">2</span>,  <span class="hljs-regexp">/* 左边黑框, Horizontal Back porch */</span><br>             .thf=   <span class="hljs-number">2</span>,  <span class="hljs-regexp">/* 右边黑框, Horizontal Front porch */</span><br><br>             .vclk=  <span class="hljs-number">9</span>,  <span class="hljs-regexp">/* MHz */</span><br>        &#125;,<br>        .xres = <span class="hljs-number">480</span>,<br>        .yres = <span class="hljs-number">272</span>,<br>        .bpp  = <span class="hljs-number">16</span>,<br>        .fb_base = LCD_FB_BASE,&#125;;<br></code></pre></td></tr></table></figure><p>完成了lcd控制器和参数的代码，现在还需要一个管理的中间层将两者连在一起。</p><p>我们用lcd_controller.c管理s3c2440_lcd_controller.c，它向上接受传入的LCD参数，向下传给对应的LCD控制器。</p><p>lcd_controller.c管理下级的控制器的思路如下：</p><ol><li>用数组保存下面各种lcd_controller；</li><li>提供register_lcd_controller给下面的代码设置数组；</li><li>提供select_lcd_controller(name)给上面的代码选择某个lcd_controller;</li></ol><p>lcd_controller.c代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_CONTROLLER_NUM 10</span><br><br><span class="hljs-type">static</span> p_lcd_controller p_array_lcd_controller[LCD_CONTROLLER_NUM];<br>    <span class="hljs-comment">//用来保存各种lcd_controller</span><br><span class="hljs-type">static</span> p_lcd_controller g_p_lcd_controller_selected;<br><br><span class="hljs-comment">/* 把lcd控制器程序往数组里面放 */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">register_lcd_controller</span><span class="hljs-params">(p_lcd_controller plcdcon)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; LCD_CONTROLLER_NUM; i++)<br>        &#123;<br>                <span class="hljs-keyword">if</span> (!p_array_lcd_controller[i])<br>                &#123;<br>                        p_array_lcd_controller[i] = plcdcon;<br>                        <span class="hljs-keyword">return</span> i;<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;         <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">select_lcd_controller</span><span class="hljs-params">(<span class="hljs-type">char</span> *name)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; LCD_CONTROLLER_NUM; i++)<br>        &#123;<br>                <span class="hljs-keyword">if</span> (p_array_lcd_controller[i] &amp;&amp;  !<span class="hljs-built_in">strcmp</span>(p_array_lcd_controller[i]-&gt;name, name))    <span class="hljs-comment">//传入的名字和循环到的那一项名字相同，即找到了对应函数</span><br>                &#123;<br>                        g_p_lcd_controller_selected = p_array_lcd_controller[i];<br>                        <span class="hljs-keyword">return</span> i;<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;         <br>&#125;<br><br><span class="hljs-comment">/* 向上: 接收不同LCD的参数 </span><br><span class="hljs-comment"> * 向下: 使用这些参数设置对应的LCD控制器 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lcd_controller_init</span><span class="hljs-params">(p_lcd_params plcdparams)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-comment">/* 调用所选择的LCD控制器的初始化函数 */</span><br>        <span class="hljs-keyword">if</span> (g_p_lcd_controller_selected)<br>        &#123;<br>                g_p_lcd_controller_selected-&gt;<span class="hljs-built_in">init</span>(plcdparams);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lcd_contoller_add</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>        <span class="hljs-built_in">s3c2440_lcd_contoller_add</span>();<br>&#125;<br><br>同时，在s3c2440_lcd_controller.c里注册控制器：<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">s3c2440_lcd_contoller_add</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-built_in">register_lcd_controller</span>(&amp;s3c2440_lcd_controller);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，s3c2440_lcd_controller.c里的register_lcd_controller()将自己放在p_array_lcd_controller[]这个数组，然后上层的lcd_controller.c调用select_lcd_controller()传入要选择的LCD控制器，然后在数组里面找到名字名字匹配的LCD控制器进行相应的初始化。</p><p>同理，也通过lcd.c去管理lcd_4.3.c,思路如下：</p><ul><li>有一个数组存放各类lcd的参数；</li><li>有一个register_led给下面的lcd程序来设置数组；</li><li>有一个select_lcd，供上层选择某款LCD；</li></ul><p>参考前面的lcd_controller.c编辑lcd_controller.c如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCD_NUM 10</span><br><br><span class="hljs-type">static</span> p_lcd_params p_array_lcd[LCD_NUM];<br><span class="hljs-type">static</span> p_lcd_params g_p_lcd_selected;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">register_lcd</span><span class="hljs-params">(p_lcd_params plcd)</span></span>&#123;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; LCD_NUM; i++)<br>        &#123;<br>                <span class="hljs-keyword">if</span> (!p_array_lcd[i])<br>                &#123;<br>                        p_array_lcd[i] = plcd;<br>                        <span class="hljs-keyword">return</span> i;<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;         <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">select_lcd</span><span class="hljs-params">(<span class="hljs-type">char</span> *name)</span></span>&#123;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; LCD_NUM; i++)<br>        &#123;<br>                <span class="hljs-keyword">if</span> (p_array_lcd[i] &amp;&amp; !<span class="hljs-built_in">strcmp</span>(p_array_lcd[i]-&gt;name, name))<br>                &#123;<br>                        g_p_lcd_selected = p_array_lcd[i];<br>                        <span class="hljs-keyword">return</span> i;<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;         <br>&#125;<br></code></pre></td></tr></table></figure><p>在lcd_4.3.c里面把lcd参数注册进去：</p><p>void lcd_4_3_add(void) { register_lcd(&amp;lcd_4_3_params); }</p><p>以后只需要在lcd.c里面选择某款lcd和某款lcd控制器即可，底层的只管添加种类即可。</p><p>在lcd.c里面添加初始化函数如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scss">int <span class="hljs-built_in">lcd_init</span>(void)<br>&#123;<br>        <span class="hljs-comment">/* 注册LCD */</span><br>        <span class="hljs-built_in">lcd_4_3_add</span>();<br><br>        <span class="hljs-comment">/* 注册LCD控制器 */</span><br>        <span class="hljs-built_in">s3c2440_lcd_contoller_add</span>();<br>        <br>        <span class="hljs-comment">/* 选择某款LCD */</span><br>        <span class="hljs-built_in">select_lcd</span>(&quot;lcd_4.<span class="hljs-number">3</span>&quot;);<br><br>        <span class="hljs-comment">/* 选择某款LCD控制器 */</span><br>        <span class="hljs-built_in">select_lcd_controller</span>(&quot;s3c2440&quot;);<br><br>        <span class="hljs-comment">/* 使用LCD的参数, 初始化LCD控制器 */</span><br>        <span class="hljs-built_in">lcd_controller_init</span>(g_p_lcd_selected);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第007节_编程_简单测试</strong></p><hr><p>首先向lcd_test.c里面添加一个测试函数lcd_test()，用于向framebuffer写数据，所需步骤如下：</p><ol><li>初始化LCD</li><li>使能LCD</li><li>获取LCD参数: fb_base, xres, yres, bpp</li><li>往framebuffer中写数据</li></ol><p>1). 初始化LCD</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">lcd_intit</span>();<br></code></pre></td></tr></table></figure><p>2). 使能LCD</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">lcd_enable</span>();<br></code></pre></td></tr></table></figure><p>该函数实际调用的是lcd_controller_enable()</p><p>3). 获取LCD参数: fb_base, xres, yres, bpp</p><p>只有获取到LCD的参数信息，才能根据这些信息进行相应显示。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">get<span class="hljs-constructor">_lcd_params(&amp;<span class="hljs-params">fb_base</span>, &amp;<span class="hljs-params">xres</span>, &amp;<span class="hljs-params">yres</span>, &amp;<span class="hljs-params">bpp</span>)</span>;<br></code></pre></td></tr></table></figure><p>该函数是在lcd.c里面实现：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void get<span class="hljs-constructor">_lcd_params(<span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">fb_base</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">xres</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">yres</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">bpp</span>)</span><br>&#123;<br>        *fb_base = g_p_lcd_selected-&gt;fb_base;<br>        *xres = g_p_lcd_selected-&gt;xres;<br>        *yres = g_p_lcd_selected-&gt;yres;<br>        *bpp = g_p_lcd_selected-&gt;bpp;<br>&#125;<br></code></pre></td></tr></table></figure><p>4). 往framebuffer中写数据</p><p>假设现在BPP&#x3D;16，想让全屏显示红色，就需要从framebuffer基地址开始一直填充对应的颜色数据。 对于16BPP，RGB&#x3D;565，想显示红色，即[15:11]全为1表示红色，[10:5]全为0表示无绿色，[4:0]全为0表示无蓝色，0b1111100000000000&#x3D;0xF700。</p><p>以基地址为起点，分别以xres和yres为边界，依次填充颜色。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">              p = (unsigned short *)fb_base;</span><br><span class="hljs-comment">                for (x = 0; x</span> &lt; <span class="hljs-comment">xres; x</span><span class="hljs-literal">++</span><span class="hljs-comment">)</span><br><span class="hljs-comment">                        for (y = 0; y</span> &lt; <span class="hljs-comment">yres; y</span><span class="hljs-literal">++</span><span class="hljs-comment">)</span><br><span class="hljs-comment">                                *p</span><span class="hljs-literal">++</span> <span class="hljs-comment">= 0xf700;</span><br></code></pre></td></tr></table></figure><p>编写好程序后，修改Makefile:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objs = start.o led.o uart.o init.o nand_flash.o main.o exception.o interrupt.o timer.o nor_flash.o my_printf.o string_utils.o lib1funcs.o<br><br>objs += lcd/font.o<br>objs += lcd/framebuffer.o<br>objs += lcd/geometry.o<br>objs += lcd/lcd.oobjs += lcd/lcd_4.3.o<br>objs += lcd/lcd_controller.oobjs += lcd/lcd_test.o<br>objs += lcd/s3c2440_lcd_controller.o<br><span class="hljs-section">all: <span class="hljs-variable">$(objs)</span></span><br>        <span class="hljs-comment">#arm-linux-ld -Ttext 0 -Tdata 0x30000000  start.o led.o uart.o init.o main.o -o sdram.elf</span><br>        arm-linux-ld -T sdram.lds <span class="hljs-variable">$^</span> -o sdram.elf<br>        arm-linux-objcopy -O binary -S sdram.elf sdram.bin<br>        arm-linux-objdump -D sdram.elf &gt; sdram.dis<br><span class="hljs-section">clean:</span><br>        rm *.bin *.o *.elf *.dis<br>        <br>%.o : %.c<br>        arm-linux-gcc -march=armv4 -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br>%.o : %.S<br>        arm-linux-gcc -march=armv4 -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br></code></pre></td></tr></table></figure><p>然后把工程文件放到虚拟机上交叉编译，根据编译提示结果进行对应修改。</p><p>常见问题包括：头文件未添加、数据类型错误等。</p><p>同理，假如现在是24BPP，即RGB:888，每个颜色占8位，一共占据24位。</p><p>虽然颜色数据只占据24位，但实际中是占据的32位(1字节)方便存储计算，即[23:0]存放的是数据，[31：24]空闲无数据。</p><p>对于32BPP，大多数情况下和24BPP差不多的，即RGB:888，每个颜色占8位，一共占据24位。因此想依次显示红绿蓝，代码如下：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs gcode">    <span class="hljs-comment">/* 0xRRGGBB */</span><br>    <span class="hljs-comment">/* red */</span><br>    p<span class="hljs-number">2</span> = <span class="hljs-comment">(unsigned int *)</span>fb_base;<br>    for <span class="hljs-comment">(x = 0; x &lt; xres; x++)</span><br>        for <span class="hljs-comment">(y = 0; y &lt; yres; y++)</span><br>            *p<span class="hljs-number">2</span>++ = <span class="hljs-number">0</span>xff<span class="hljs-number">0000</span>;<br><br>    <span class="hljs-comment">/* green */</span><br>    p<span class="hljs-number">2</span> = <span class="hljs-comment">(unsigned int *)</span>fb_base;<br>    for <span class="hljs-comment">(x = 0; x &lt; xres; x++)</span><br>        for <span class="hljs-comment">(y = 0; y &lt; yres; y++)</span><br>            *p<span class="hljs-number">2</span>++ = <span class="hljs-number">0</span>x<span class="hljs-number">00</span>ff<span class="hljs-number">00</span>;<br><br>    <span class="hljs-comment">/* blue */</span><br>    p<span class="hljs-number">2</span> = <span class="hljs-comment">(unsigned int *)</span>fb_base;<br>    for <span class="hljs-comment">(x = 0; x &lt; xres; x++)</span><br>        for <span class="hljs-comment">(y = 0; y &lt; yres; y++)</span><br>            *p<span class="hljs-number">2</span>++ = <span class="hljs-number">0</span>x<span class="hljs-number">0000</span>ff;<br></code></pre></td></tr></table></figure><p>之前我们讲数据是8BPP的时候，可以通过调色板转成16BPP，在LCD上显示出相应颜色。</p><p>那前面的24BPP、32BPP是怎样在 只能接收16BPP(硬件上只有16根数据线)的LCD上显示的呢？</p><p>这是因为在使用24BPP时，发出的8条红色，8条绿色，8条蓝色数据，只用了高5条红色，高6条绿色，高5条蓝色与LCD相连。</p><p><strong>第008节_编程_画点线圆</strong></p><hr><p>本节将在LCD上画点画圆，无论是何种图形，都是基于点来构成的，因此我们需要先实现画点。</p><p>在前面**第003节_编程_框架与准备**所讲的框架里，计划的是在farmebuffer.c实现画点，在geomentry.c实现画线、画圆，font.c实现写字。</p><p>我们先在farmebuffer.c实现画点，一个点(x，y)在FB中的位置如图：</p><p><img src="/image/700px-Chapter17_lesson8_001.jpg" alt="700px-Chapter17_lesson8_001.jpg"></p><p>可以得出其计算公式：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">(x，y)像素起始地址=fb_base+(xres*bpp<span class="hljs-regexp">/8)*y + x*bpp/</span><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>同时利用yres来分辨y方向的边界。</p><p>因此，需要先从LCD中获取参数：fb_base、xres、yres、bpp;</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static unsigned <span class="hljs-built_in">int</span> fb_base;<br>static <span class="hljs-built_in">int</span> xres, yres, bpp;<br>void fb<span class="hljs-constructor">_get_lcd_params(<span class="hljs-params">void</span>)</span><br>&#123;<br>        get<span class="hljs-constructor">_lcd_params(&amp;<span class="hljs-params">fb_base</span>, &amp;<span class="hljs-params">xres</span>, &amp;<span class="hljs-params">yres</span>, &amp;<span class="hljs-params">bpp</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>再实现画点操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fb_put_pixel</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> color)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>  *pc;  <span class="hljs-comment">/* 8bpp */</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *pw;  <span class="hljs-comment">/* 16bpp */</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>   *pdw; <span class="hljs-comment">/* 32bpp */</span><br><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> pixel_base = fb_base + (xres * bpp / <span class="hljs-number">8</span>) * y + x * bpp / <span class="hljs-number">8</span>;<br><br>        <span class="hljs-keyword">switch</span> (bpp)<br>        &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>                        pc = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) pixel_base;<br>                        *pc = color;<br>                        <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">16</span>:<br>                        pw = (<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *) pixel_base;<br>                        *pw = <span class="hljs-built_in">convert32bppto16bpp</span>(color);<br>                        <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">32</span>:<br>                        pdw = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *) pixel_base;<br>                        *pdw = color;<br>                        <span class="hljs-keyword">break</span>;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于8PP，每个像素只占据8位(1字节)，因此采用unsigned char类型；</p><p>对于16PP，每个像素只占据16位(2字节)，因此采用unsigned short类型；</p><p>对于32PP，每个像素只占据32位(4字节)，因此采用unsigned int类型；</p><p>再根据传入的x,y坐标，计算出对应的显存位置。</p><p>根据BPP的不同，修改相应位的显存数据。</p><p>传入的颜色数据一般都是32bit的，即格式为：0x00RRGGBB,</p><p>对于8PP，通过的是调色板索引实现的，这个后续再讲解，直接*pc &#x3D; color即可。</p><p>对于16PP，需要进行颜色转换。</p><p>对于32PP，大小刚好对应，直接*pc &#x3D; color即可。</p><p>使用convert32bppto16bpp()函数进行颜色数据转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-title">convert32bppto16bpp</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> rgb)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">int</span> r = (rgb &gt;&gt; <span class="hljs-number">16</span>)&amp; <span class="hljs-number">0xff</span>;<br>        <span class="hljs-type">int</span> g = (rgb &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>;<br>        <span class="hljs-type">int</span> b = rgb &amp; <span class="hljs-number">0xff</span>;<br><br>        <span class="hljs-comment">/* rgb565 */</span><br>        r = r &gt;&gt; <span class="hljs-number">3</span>;<br>        g = g &gt;&gt; <span class="hljs-number">2</span>;<br>        b = b &gt;&gt; <span class="hljs-number">3</span>;<br><br>        <span class="hljs-keyword">return</span> ((r&lt;&lt;<span class="hljs-number">11</span>) | (g&lt;&lt;<span class="hljs-number">5</span>) | (b));<br>&#125;<br></code></pre></td></tr></table></figure><p>先分别取出RGB，再相应的清除低位数据，实现将RGB888变为RGB565，最后再组成unsigned short类型数据返回。</p><p>画圆画线的具体原理不是我们的主要内容，我们直接百度“C语言 LCD 画圆”可以得到相关的实现代码，比如这篇博客：<a href="http://blog.csdn.net/p1126500468/article/details/50428613">http://blog.csdn.net/p1126500468/article/details/50428613</a></p><p>新建一个geometry.c，复制博客中代码，替换里面的描点显示函数即可。</p><p>最后在主函数测试程序里，加上画圆画线的测试代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">    <span class="hljs-comment">/* 画线 */</span><br>        draw<span class="hljs-constructor">_line(0, 0, <span class="hljs-params">xres</span> - 1, 0, 0xff0000)</span>;<br>        draw<span class="hljs-constructor">_line(<span class="hljs-params">xres</span> - 1, 0, <span class="hljs-params">xres</span> - 1, <span class="hljs-params">yres</span> - 1, 0xffff00)</span>;<br>        draw<span class="hljs-constructor">_line(0, <span class="hljs-params">yres</span> - 1, <span class="hljs-params">xres</span> - 1, <span class="hljs-params">yres</span> - 1, 0xff00aa)</span>;<br>        draw<span class="hljs-constructor">_line(0, 0, 0, <span class="hljs-params">yres</span> - 1, 0xff00ef)</span>;<br>        draw<span class="hljs-constructor">_line(0, 0, <span class="hljs-params">xres</span> - 1, <span class="hljs-params">yres</span> - 1, 0xff4500)</span>;<br>        draw<span class="hljs-constructor">_line(<span class="hljs-params">xres</span> - 1, 0, 0, <span class="hljs-params">yres</span> - 1, 0xff0780)</span>;<br><br>        delay(<span class="hljs-number">1000000</span>);<br><br>        <span class="hljs-comment">/* 画圆 */</span><br>        draw<span class="hljs-constructor">_circle(<span class="hljs-params">xres</span><span class="hljs-operator">/</span>2, <span class="hljs-params">yres</span><span class="hljs-operator">/</span>2, <span class="hljs-params">yres</span><span class="hljs-operator">/</span>4, 0xff00)</span>;<br></code></pre></td></tr></table></figure><p>希望在LCD上显示如下图形，由6条线和一个圆组成。</p><p>将线的起始坐标作为参数传入画线函数。</p><p>将圆心和半径作为参数传入画圆函数。</p><p><img src="/image/700px-Chapter17_lesson8_002.jpg" alt="700px-Chapter17_lesson8_002.jpg"></p><p><strong>第009节_编程_显示文字</strong></p><hr><p>文字也是由点构成的，一个个点组成的点阵，宏观的来看，就是文字。</p><p>可以参考Linux内核源码中的相关操作，在内核中搜索“font”，打开font_8x16.c，可以看到里面的A字符内容如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk">      <span class="hljs-regexp">/* 65 0x41 &#x27;A&#x27; */</span><br>        <span class="hljs-number">0</span>x00, <span class="hljs-regexp">/* 00000000 */</span><br>        <span class="hljs-number">0</span>x00, <span class="hljs-regexp">/* 00000000 */</span><br>        <span class="hljs-number">0</span>x10, <span class="hljs-regexp">/* 00010000 */</span><br>        <span class="hljs-number">0</span>x38, <span class="hljs-regexp">/* 00111000 */</span><br>        <span class="hljs-number">0</span>x6c, <span class="hljs-regexp">/* 01101100 */</span><br>        <span class="hljs-number">0</span>xc6, <span class="hljs-regexp">/* 11000110 */</span><br>        <span class="hljs-number">0</span>xc6, <span class="hljs-regexp">/* 11000110 */</span><br>        <span class="hljs-number">0</span>xfe, <span class="hljs-regexp">/* 11111110 */</span><br>        <span class="hljs-number">0</span>xc6, <span class="hljs-regexp">/* 11000110 */</span><br>        <span class="hljs-number">0</span>xc6, <span class="hljs-regexp">/* 11000110 */</span><br>        <span class="hljs-number">0</span>xc6, <span class="hljs-regexp">/* 11000110 */</span><br>        <span class="hljs-number">0</span>xc6, <span class="hljs-regexp">/* 11000110 */</span><br>        <span class="hljs-number">0</span>x00, <span class="hljs-regexp">/* 00000000 */</span><br>        <span class="hljs-number">0</span>x00, <span class="hljs-regexp">/* 00000000 */</span><br>        <span class="hljs-number">0</span>x00, <span class="hljs-regexp">/* 00000000 */</span><br>        <span class="hljs-number">0</span>x00, <span class="hljs-regexp">/* 00000000 */</span><br></code></pre></td></tr></table></figure><p>根据这些数据，在一个8*16的区域里，将为1的点显示出来，为0的则不显示，最终将呈现一个字母“A”。</p><p>新建一个font.c，根据字母的点阵在LCD上描画文字，需要的步骤如下：</p><ol><li>根据带显示的字符的ascii码在fontdata_8x16中得到点阵数据</li><li>根据点阵来设置对应象素的颜色</li><li>根据点阵的某位决定是否描颜色</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void fb<span class="hljs-constructor">_print_char(<span class="hljs-params">int</span> <span class="hljs-params">x</span>, <span class="hljs-params">int</span> <span class="hljs-params">y</span>, <span class="hljs-params">char</span> <span class="hljs-params">c</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">color</span>)</span><br>&#123;<br>        <span class="hljs-built_in">int</span> i, j;<br>        <br>        <span class="hljs-comment">/* 根据c的ascii码在fontdata_8x16中得到点阵数据 */</span><br>        unsigned <span class="hljs-built_in">char</span> *dots = &amp;fontdata_8x16<span class="hljs-literal">[<span class="hljs-identifier">c</span> <span class="hljs-operator">*</span> <span class="hljs-number">16</span>]</span>;<br><br>        unsigned <span class="hljs-built_in">char</span> data;<br>        <span class="hljs-built_in">int</span> bit;<br><br>        <span class="hljs-comment">/* 根据点阵来设置对应象素的颜色 */</span><br>        <span class="hljs-keyword">for</span> (j = y; j &lt; y+<span class="hljs-number">16</span>; j++)<br>        &#123;<br>                data = *dots++;<br>                bit = <span class="hljs-number">7</span>;<br>                <span class="hljs-keyword">for</span> (i = x; i &lt; x+<span class="hljs-number">8</span>; i++)<br>                &#123;<br>                        <span class="hljs-comment">/* 根据点阵的某位决定是否描颜色 */</span><br>                        <span class="hljs-keyword">if</span> (data &amp; (<span class="hljs-number">1</span>&lt;&lt;bit))<br>                                fb<span class="hljs-constructor">_put_pixel(<span class="hljs-params">i</span>, <span class="hljs-params">j</span>, <span class="hljs-params">color</span>)</span>;<br>                        bit--;<br>                &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在font_8x16.c里面，每个字符占据16位，因此想要根据ascii码找到对应的点阵数据，需要对应的乘16，再取地址，得到该字符的首地址。</p><p>再根据每个点阵数据每位是否为1，来调用描点函数fb_put_pixel()。这样，依次显示16个点阵数据，获得字符图形。</p><p>同样的，在显示之前，还需要获取LCD参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> fontdata_8x16[];<span class="hljs-comment">/* 获得LCD参数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fb_base;<span class="hljs-type">static</span> <span class="hljs-type">int</span> xres, yres, bpp;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">font_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-built_in">get_lcd_params</span>(&amp;fb_base, &amp;xres, &amp;yres, &amp;bpp);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想显示字符串，那就在每显示完一个字符后，x轴加8即可，同时考虑是否超出屏幕显示范围进行换行处理：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/* &quot;abc\n\r123&quot; */</span><br>void fb<span class="hljs-constructor">_print_string(<span class="hljs-params">int</span> <span class="hljs-params">x</span>, <span class="hljs-params">int</span> <span class="hljs-params">y</span>, <span class="hljs-params">char</span><span class="hljs-operator">*</span> <span class="hljs-params">str</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">color</span>)</span><br>&#123;<br>        <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>, j;<br>        <br>        <span class="hljs-keyword">while</span> (str<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>)<br>        &#123;<br>                <span class="hljs-keyword">if</span> (str<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-operator"> == </span><span class="hljs-character">&#x27;\n&#x27;</span>)<br>                        y = y+<span class="hljs-number">16</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-operator"> == </span><span class="hljs-character">&#x27;\r&#x27;</span>)<br>                        x = <span class="hljs-number">0</span>;<br><br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                        fb<span class="hljs-constructor">_print_char(<span class="hljs-params">x</span>, <span class="hljs-params">y</span>, <span class="hljs-params">str</span>[<span class="hljs-params">i</span>], <span class="hljs-params">color</span>)</span>;<br>                        x = x+<span class="hljs-number">8</span>;<br>                        <span class="hljs-keyword">if</span> (x &gt;= xres) <span class="hljs-comment">/* 换行 */</span><br>                        &#123;<br>                                x = <span class="hljs-number">0</span>;<br>                                y = y+<span class="hljs-number">16</span>;<br>                        &#125;<br>                &#125;<br>                i++;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后在在主函数里，加上显示字符串的函数，传入希望显示的字符串。</p><p><strong>第010节_编程_添加除法</strong></p><hr><p>在s3c2440_lcd_controller.c里，以前我们使用如下除法：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> clkval = (double)HCLK/plcdparams-&gt;time_seq.vclk/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>+<span class="hljs-number">0</span>.<span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>编译的时候会提示出错：</p><p><img src="/image/800px-Chapter17_lesson10_001.png" alt="800px-Chapter17_lesson10_001.png"></p><p>我们的lib1funcs.S里面是有除法的，但除法的功能不够强，将前面除法计算代码中的double改成精度更小的float还是不行。</p><p>对于未实现的函数：</p><ul><li>去uboot中查找</li><li>去内核源码中查找</li><li>去库函数中查找(一般来说编译器自带有很多库)</li></ul><p>在库函数中查找步骤：</p><ol><li>输入命令arm-linux-gcc -v，查看当前使用的交叉编译工具链；</li><li>输入命令echo $PATH，在环境变量中找到当前使用的交叉编译工具链所在的路径；</li><li>进入交叉编译工具链所在目录搜索相关函数，例如grep “__floatsisf” * -nR；</li><li>提取出其中的静态库(.a后缀文件)，复制文件到代码文件；</li><li>修改Makefile，依次尝试加入的每个静态库，直至编译成功；</li></ol><p>注意:如果你更换了编译器，需要自己去编译器目录里找出对应的libgcc.a;</p><p>有可能有多个libgcc.a，逐个尝试；</p><p><strong>第011节_编程_使用调色板</strong></p><hr><p>前面我们写的程序都是采用的16BPP或者24BPP(也就是32BPP)，假如我们要使用8PP，就得使用调色板。</p><p>如图所示8PP工作原理示意图，在FB只存放8bit得每个像素索引，根据这个索引，在去去调色板找到对应的数据传给LCD控制器，再通过电子枪显示出来。</p><p>调色板里面有2^8(256)个颜色数据，每个颜色数据为16bit，表示一种颜色。</p><p><img src="/image/700px-Chapter17_lesson11_001.jpg" alt="700px-Chapter17_lesson11_001.jpg"></p><p>在硬件上，我们要初始化这个调色板，才能通过索引得到颜色。</p><p>根据第三节的软件框架，调色板的初始化应该放在s3c2440_lcd_controller.c里面。</p><p>在lcd_controller结构体里添加调色板初始化函数：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">struct lcd_controller s3c2440_lcd_controller = <br>&#123;<br>        <span class="hljs-string">.name</span>    = <span class="hljs-string">&quot;s3c2440&quot;</span>,<br>        <span class="hljs-string">.init</span>    = s3c2440_lcd_controller_init,<br>        <span class="hljs-string">.enable</span>  = s3c2440_lcd_controller_enalbe,<br>        <span class="hljs-string">.disable</span> = s3c2440_lcd_controller_disable,<br>        <span class="hljs-string">.init_palette</span> = s3c2440_lcd_controller_init_palette,<br>&#125;;<br></code></pre></td></tr></table></figure><p>调色板对应一块内存，我们需要找到他的位置和格式。</p><p><img src="/image/700px-Chapter17_lesson11_002.png" alt="700px-Chapter17_lesson11_002.png"></p><p>从芯片手册了解到，其起始地址为0x4D000400，且设置调色板前，需要关闭LCD控制器。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">s3c2440_lcd_controller_init_palette</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *palette_base =  (<span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *)<span class="hljs-number">0x4D000400</span>;<br>        <span class="hljs-type">int</span> i;<br><br>        <span class="hljs-type">int</span> bit = LCDCON1 &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">/* LCDCON1&#x27;BIT 0 : 设置LCD控制器是否输出信号 */</span><br>        <span class="hljs-keyword">if</span> (bit)<br>                LCDCON1 &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)<br>        &#123;<br>                <span class="hljs-comment">/* 低16位 : rgb565 */</span>       <br>                *palette_base++ = i;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (bit)<br>                LCDCON1 |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>设置调色板前，先判断LCD控制器是否打开，如果打开了就先关闭，且设置完成后再打开。(芯片手册要求)</p><p>再网上搜索了一下，没有找到调色板数据数组，这里作为实验，就随便设置，让其为i。</p><p>我们让调色板数据等于i，0-255，只占据8位，最后的颜色范围为B5G3R0，因此会比较偏蓝。</p><p>修改lcd_4.3.c，将BPP改为8，</p><p>再修改lcd_controller.c的初始化函数，加入调色板初始化函数。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scss">int <span class="hljs-built_in">lcd_controller_init</span>(p_lcd_params plcdparams)<br>&#123;<br>        <span class="hljs-comment">/* 调用所选择的LCD控制器的初始化函数 */</span><br>        if (g_p_lcd_controller_selected)<br>        &#123;<br>                g_p_lcd_controller_selected-&gt;<span class="hljs-built_in">init</span>(plcdparams);<br>                g_p_lcd_controller_selected-&gt;<span class="hljs-built_in">init_palette</span>();<br>                return <span class="hljs-number">0</span>;<br>        &#125;<br>        return -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>再修改lcd_test.c，加入bpp&#x3D;8的情况：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-keyword">if</span> <span class="hljs-comment">(bpp == 8)</span><br>        &#123;<br>                <span class="hljs-comment">/* 让LCD输出整屏的红色 */</span><br><br>                <span class="hljs-comment">/* bpp: palette[12] */</span><br><br>                p<span class="hljs-number">0</span> = <span class="hljs-comment">(unsigned char *)</span>fb_base;<br>                for <span class="hljs-comment">(x = 0; x &lt; xres; x++)</span><br>                        for <span class="hljs-comment">(y = 0; y &lt; yres; y++)</span><br>                                *p<span class="hljs-number">0</span>++ = <span class="hljs-number">12</span>;<br><br>                <span class="hljs-comment">/* palette[47] */</span><br>                p<span class="hljs-number">0</span> = <span class="hljs-comment">(unsigned char *)</span>fb_base;<br>                for <span class="hljs-comment">(x = 0; x &lt; xres; x++)</span><br>                        for <span class="hljs-comment">(y = 0; y &lt; yres; y++)</span><br>                                *p<span class="hljs-number">0</span>++ = <span class="hljs-number">47</span>;<br><br>                <span class="hljs-comment">/* palette[88] */</span><br>                p<span class="hljs-number">0</span> = <span class="hljs-comment">(unsigned char *)</span>fb_base;<br>                for <span class="hljs-comment">(x = 0; x &lt; xres; x++)</span><br>                        for <span class="hljs-comment">(y = 0; y &lt; yres; y++)</span><br>                                *p<span class="hljs-number">0</span>++ = <span class="hljs-number">88</span>;<br><br>                <span class="hljs-comment">/* palette[0] */</span><br>                p<span class="hljs-number">0</span> = <span class="hljs-comment">(unsigned char *)</span>fb_base;<br>                for <span class="hljs-comment">(x = 0; x &lt; xres; x++)</span><br>                        for <span class="hljs-comment">(y = 0; y &lt; yres; y++)</span><br>                                *p<span class="hljs-number">0</span>++ = <span class="hljs-number">0</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><p>随便让其全屏显示某个颜色。</p><p>最后在画线画圆，显示文字的函数里，修改下颜色：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">      <span class="hljs-comment">/* 画线 */</span><br>        draw<span class="hljs-constructor">_line(0, 0, <span class="hljs-params">xres</span> - 1, 0, 0x23ff77)</span>;<br>        draw<span class="hljs-constructor">_line(<span class="hljs-params">xres</span> - 1, 0, <span class="hljs-params">xres</span> - 1, <span class="hljs-params">yres</span> - 1, 0xffff)</span>;<br>        draw<span class="hljs-constructor">_line(0, <span class="hljs-params">yres</span> - 1, <span class="hljs-params">xres</span> - 1, <span class="hljs-params">yres</span> - 1, 0xff00aa)</span>;<br>        draw<span class="hljs-constructor">_line(0, 0, 0, <span class="hljs-params">yres</span> - 1, 0xff00ef)</span>;<br>        draw<span class="hljs-constructor">_line(0, 0, <span class="hljs-params">xres</span> - 1, <span class="hljs-params">yres</span> - 1, 0xff45)</span>;<br>        draw<span class="hljs-constructor">_line(<span class="hljs-params">xres</span> - 1, 0, 0, <span class="hljs-params">yres</span> - 1, 0xff0780)</span>;<br><br>        delay(<span class="hljs-number">1000000</span>);<br><br>        <span class="hljs-comment">/* 画圆 */</span><br>        draw<span class="hljs-constructor">_circle(<span class="hljs-params">xres</span><span class="hljs-operator">/</span>2, <span class="hljs-params">yres</span><span class="hljs-operator">/</span>2, <span class="hljs-params">yres</span><span class="hljs-operator">/</span>4, 0xff)</span>;<br><br>        <span class="hljs-comment">/* 输出文字 */</span><br>        fb<span class="hljs-constructor">_print_string(10, 10, <span class="hljs-string">&quot;www.100ask.net\n\r100ask.taobao.com&quot;</span>, 0xff)</span>;<br></code></pre></td></tr></table></figure><p>上面的颜色数据，其实只有低两位有效，因为前面的调色板映射范围是0-255。</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第016课 Nand Flash</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AC%AC016%E8%AF%BE_Nand_Flash/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AC%AC016%E8%AF%BE_Nand_Flash/</url>
    
    <content type="html"><![CDATA[<p><strong>目录</strong></p><hr><ol><li>第001节_NAND_FLASH操作原理</li><li>第002节_NandFlash时序及初始化</li><li>第003节_NandFlash的芯片id读取</li><li>第004节_NandFlash的数据读取</li><li>第005节_NandFlash的擦除与烧写</li></ol><p><strong>第001节_NAND_FLASH操作原理</strong></p><hr><p>NAND FLASH原理图</p><p><img src="/image/Chapter16_lesson1_001.png" alt="Chapter16_lesson1_001.png"></p><p><img src="/image/1362557976_6234.jpg" alt="1362557976_6234.jpg"></p><p>上图是常见的Nand Flash所拥有的引脚（Pin）所对应的功能，简单翻译如下：</p><ul><li>I&#x2F;O0 ~ I&#x2F;O7：用于输入地址&#x2F;数据&#x2F;命令，输出数据</li><li>CLE：Command Latch Enable，命令锁存使能，在输入命令之前，要先在模式寄存器中，设置CLE使能</li><li>ALE：Address Latch Enable，地址锁存使能，在输入地址之前，要先在模式寄存器中，设置ALE使能</li><li>CE#：Chip Enable，芯片使能，在操作Nand Flash之前，要先选中此芯片，才能操作</li><li>RE#：Read Enable，读使能，在读取数据之前，要先使CE＃有效。</li><li>WE#：Write Enable，写使能,在写取数据之前，要先使WE＃有效。</li><li>WP#：Write Protect，写保护</li><li>R&#x2F;B#:Ready&#x2F;Busy Output,就绪&#x2F;忙,主要用于在发送完编程&#x2F;擦除命令后,检测这些操作是否完成,忙,表示编程&#x2F;擦除操作仍在进行中,就绪表示操作完成.</li><li>Vcc：Power，电源</li><li>Vss：Ground，接地</li><li>N.C：Non-Connection,未定义，未连接。</li></ul><p>NAND FLASH是一个存储芯片</p><p>那么: 这样的操作很合理”读地址A的数据，把数据B写到地址A”</p><p><strong>问1：原理图上NAND FLASH和S3C2440之间只有数据线，怎么传输地址？</strong></p><p>答1：复用，在DATA0～DATA7上既传输数据，又传输地址当ALE为高电平时传输的是地址，</p><p>那么在数据线上是不是只传输数据和只传输地址呢？</p><p>我们参考NAND FLASH的芯片手册可以知道，对NAND FLASH的操作还需要发出命令，下面有个NAND FLASH的命令表格</p><p><img src="/image/800px-Chapter16_lesson1_002.png" alt="800px-Chapter16_lesson1_002.png"></p><p>左边是可执行的命令，右边是需要进行的操作</p><p><strong>问2：从NAND FLASH芯片手册可知，要操作NAND FLASH需要先发出命令怎么传入命令？</strong></p><p>答2：在DATA0～DATA7上既传输数据，又传输地址，也传输命令：</p><ol><li><p>当ALE为高电平时传输的是地址。</p></li><li><p>当CLE为高电平时传输的是命令。</p></li><li><p>当ALE和CLE都为低电平时传输的是数据。</p></li></ol><p><strong>问3： 数据线既接到NAND FLASH，也接到NOR FLASH，还接到SDRAM、DM9000等等</strong></p><p><strong>那么怎么避免干扰？</strong></p><p>答3：这些设备，要访问之必须”选中”，没有选中的芯片不会工作，相当于没接一样。</p><p><strong>问4：假设烧写NAND FLASH，把命令、地址、数据发给它之后，NAND FLASH肯定不可能瞬间完成烧写的，怎么判断烧写完成？</strong></p><p>答4：通过状态引脚RnB来判断：它为高电平表示就绪，它为低电平表示正忙</p><p><strong>问5：怎么操作NAND FLASH呢？</strong></p><p>答5：根据NAND FLASH的芯片手册，一般的过程是：</p><p>a. 发出命令</p><p>b. 发出地址</p><p>c. 发出数据&#x2F;读数据</p><p>看上面的命令表格，不容易看，我们看一下读ID的时序图，</p><p><img src="/image/800px-Chapter16_lesson1_003.png" alt="800px-Chapter16_lesson1_003.png"></p><p>每个NAND FLASH都内嵌一些ID(譬如：厂家ID，设备ID)，时序图从左往右看，纵向放是一列一列的看。</p><p>这个时序图是针对Read ID这个操作的，从图中可以看出在发出第一个命令90h之前，需要使能CLE引脚，说明你将要通过I&#x2F;O复用端口发送进入Nand Flash的是命令；还要使能CE引脚，因为你既然要向Nand Flash发命令，那么先要选中它；还有使能WE引脚，因为接下来是往nand Flash里面写命令；然后发出90h这条命令说明我们要使用Read ID操作，然后使能ALE引脚，说明我们接下来输入的数据是一个地址(<span style="background-color: #ffaaaa">输入要读的是哪个地址</span>)，发出00h这个数据了然后就可以读数据了，可以看到RE引脚使能，在I&#x2F;Ox引脚(即八条数据线)上得的数据第一个是ECh，第二个是Device Code………</p><p>tAR,tREA是操作时序</p><p>2440和外设连接的简易图，如下图所示</p><p><img src="/image/800px-Chapter16_lesson1_004.png" alt="800px-Chapter16_lesson1_004.png"></p><p>对于s3c2440来说，内部集成了一个NAND FLASH控制器，s3c2440内部的nand flash控制器 做了大部分的工作，你需要做的基本就是设置 几个时间参数而已。然后nand flash会自动进行这些时序操作。当然如果处理器上没有集成 nand flash的控制器 那么久必须要自己来写时序操作了</p><p>NAND FLASH控制器，帮我们简化了对NAND FLASH的操作，下面来分析一下不使用NAND FLASH控制器和使用NAND FLASH控制器对外设NAND FLASH的操作。</p><p><strong>发命令：</strong></p><p><img src="/image/b428c25bb72b17946d079bda117732a9.png" alt="b428c25bb72b17946d079bda117732a9.png"></p><p><strong>发地址：</strong></p><p><img src="/image/e9c3be8df1635af51e589f2cbd77fcfe.png" alt="e9c3be8df1635af51e589f2cbd77fcfe.png"></p><p><strong>发数据：</strong></p><p><img src="/image/17872e17638863d18976f28271831714.png" alt="17872e17638863d18976f28271831714.png"></p><p><strong>读数据 ：</strong></p><p><img src="/image/0b748ab15390630340f243d91daecb6d.png" alt="0b748ab15390630340f243d91daecb6d.png"></p><p>写脉冲：WE 读脉冲：RE</p><p>用UBOOT来体验NAND FLASH的操作：</p><p>1). 读ID</p><p><img src="/image/d497bd3b8615bb3eac96f71a3e6ea6c8.png" alt="d497bd3b8615bb3eac96f71a3e6ea6c8.png"></p><p>.b 一字节  .w 两字节  .l四字节</p><p>下图是读操作时序图</p><p>对于存储为256M的NAND FLASH，需要28条地址线，来表示这个地址值，根据原理图可以，只用8根地址线，所以需要4个周期的地址，为了兼容更大容量的NAND FLASH，要发出5个周期的地址：（如下图所示）</p><p><img src="/image/d33a0a9998f2792809115551a64706c8.png" alt="d33a0a9998f2792809115551a64706c8.png"></p><p><img src="/image/8e2ccf915757eee6d476d74390c8a486.png" alt="8e2ccf915757eee6d476d74390c8a486.png"></p><p><img src="/image/a4e9577f5d4e4bde439169397cf0543e.png" alt="a4e9577f5d4e4bde439169397cf0543e.png"></p><p>因为现在是0地址，所以五个地址都是C0</p><p>2). 读数据</p><p><img src="/image/38396d514bbadd73fcf35b6675312557.png" alt="38396d514bbadd73fcf35b6675312557.png"></p><p><strong>第002节_NandFlash时序及初始化</strong></p><hr><p><img src="/image/b497bd21815bb8296a0d5243ad82311a.png" alt="b497bd21815bb8296a0d5243ad82311a.png"></p><p>一般一个块&#x3D;64个页</p><p>NAND FLASH控制器的时序，是为了让NAND FLASH外设工作起来，假如外接不同的 NAND FLASH外设，那么它的操作时序可能就会不同，所以NAND FLASH控制器发出 的时序图，就是不一样的，所以我们根据NAND FLASH外设要求的时序来设置NAND FLASH控制器，</p><p><img src="/image/800px-Chapter16_lesson2_001.png" alt="800px-Chapter16_lesson2_001.png"></p><p>NAND FLASH时序图，如下所示：</p><p><img src="/image/800px-Chapter16_lesson2_002.png" alt="800px-Chapter16_lesson2_002.png"></p><p><img src="/image/800px-Chapter16_lesson2_003.png" alt="800px-Chapter16_lesson2_003.png"></p><p><img src="/image/800px-Chapter16_lesson2_004.png" alt="800px-Chapter16_lesson2_004.png"></p><p>我们在汇编语言中已经设置HCLK为100MHZ，一个周期T &#x3D; 1000&#x2F;100 &#x3D; 10ns</p><ul><li>①表示我们在发出CLE&#x2F;ALE信号之后再过多长时间才能发出写使能，即TACLS的值。<ul><li>在4.1这个表中我们可以看到这个时间就是tCLS-tWP，</li><li>在时间参数表中又可以发现它们的差值为0，即TALCS&#x3D;0 同时tALS也为12，说明CLE,CE,ALE这三个可以同时发出</li><li>查看NFCONF寄存器说明，应将其中的bit12,bit13应写为0；</li></ul></li><li>②表示写使能信号WE的持续时间，即TWRPH0的值<ul><li>查看4.1表发现就是tWP的时间</li><li>看时间参数表中得为12ns</li><li>查看NFCONF寄存器说明，根据公式得:10*(m+1)&gt;&#x3D;12，m&gt;&#x3D;1，取m&#x3D;1，即TWRPH0&#x3D;1，配置寄存器的bit8,bit9,bit10为1</li></ul></li><li>③表示WE信号释放后过多久CLE&#x2F;ALE信号释放<ul><li>在4.1这个表中我们发现这个时间就是tCLH或者tALH</li><li>看时间参数表中得为5ns</li><li>查看NFCONF寄存器说明，根据公式得:10*(n+1)&gt;&#x3D;5，m&gt;&#x3D;0，取m&#x3D;0，即TWRPH1&#x3D;1，配置寄存器的bit4,bit5,bit6为0</li></ul></li></ul><p><img src="/image/800px-Chapter16_lesson2_005.png" alt="800px-Chapter16_lesson2_005.png"></p><p>所以NFCONF寄存器设置如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span>  TACLS   0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>  TWRPH0  1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>  TWRPH1  0</span><br><span class="hljs-comment">/*设置NAND FLASH的时序*/</span><br>NFCONF = (TACLS&lt;&lt;<span class="hljs-number">12</span>) | (TWRPH0&lt;&lt;<span class="hljs-number">8</span>) | (TWRPH1&lt;&lt;<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p>在s3c2440_soc.h中设置NFCMD、NFADDR、NFDATA、NFSTAT的__REG为__REG_BYTE</p><p>到此设置NAND FLASH的时序已经设置完了，我们接着来使能，使能NFCONT。</p><p><img src="/image/800px-Chapter16_lesson2_006.png" alt="800px-Chapter16_lesson2_006.png"></p><p>MODE [0]: 设置为1，使能NAND FLASH。</p><p>Reg_nCE [1]: 设置为1，禁止片选。因为我们现在还没有使用。为防止错误的操作。</p><p>InitECC [4]: 初始化ECC的编码器，后边要使用，我们设置为1，来初始化。</p><p>所以NFCONF寄存器设置如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/*使能NAND FLASH控制器,初始化ECC，禁止片选*/</span><br>NFCONT = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p><strong>第003节_NandFlash的芯片id读取</strong></p><hr><p>上节课我们讲解了NAND FLASH的初始化，这节课我们来讲解读取NAND FLASH的ID, 我们可以参考NAND FLASHh的芯片手册，如下图所示：（NAND FLASH读操作时序图）</p><p><img src="/image/800px-Chapter16_lesson3_001.png" alt="800px-Chapter16_lesson3_001.png"></p><p>我们一般先操作片选使能，只有片选使能之后才能进行后边的操作，片选是能代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">nand_select</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>        <span class="hljs-comment">/*使能片选*/</span><br>        <span class="hljs-variable constant_">NFCONT</span> &amp;=~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>有使能片选，一定有禁止片选，禁止片选的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">nand_deselect</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>        <span class="hljs-comment">/*禁止片选*/</span><br>        <span class="hljs-variable constant_">NFCONT</span> |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>读ID的操作时序图，如下所示</p><p><img src="/image/800px-Chapter16_lesson3_002.png" alt="800px-Chapter16_lesson3_002.png"></p><p>我们按照从左往右的时间点，来分析，片选信号像一个总开关，只有使能了片选信号，后续的操作才会有意义，我们使能片选信号之后，片选引脚nCE后续一直为低电平，在前面的命令时序图中知道tCLS和tWP最小的时间参数都是12us，就表明CLE和nWE这两个信号可以同时发出，就表示要命令了，对于写什么命令，就要看数据总线上要发送的命令了，当CLE从高电平变为低电平后，表示上次的写操作已经结束了。</p><p>对于上面复杂的时序，我们可以使用2440上的NAND FLASH控制器简化操作，只需要往NFCMMD寄存器写入要传输的命令就可以了，NAND FLASH控制器默认把上面复杂的时序发出来。</p><p>发命令后，后面就需要发送地址了，当nWE和ALE有效的时候，表示写地址，上图中，要写入的地址是0x00，当ALE从高电平变为低电平的时候，表示写地址结束，我们可以简化为:往NFADDR寄存器中写值就可以了，比如：NFADDR&#x3D;0x00。</p><p>下面我们写代码：发命令的函数，和发地址的函数代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nand_cmd</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> cmd)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> i;<br>        NFCCMD = cmd;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++);    <span class="hljs-comment">//延时</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nand_addr_byte</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> addr)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> i;<br>        NFADDR = addr;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++);    <span class="hljs-comment">//延时</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就可以读取数据了，数据可以直接通过读取NFDATA寄存器里面数据来获得数据，根据时序图，是读5个字节的数据，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-title">nand_data</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">return</span> NFDATA;        <span class="hljs-comment">//NFDATA的数据一次是一个字节的</span><br>&#125;<br></code></pre></td></tr></table></figure><p>读芯片ID之前先打开片选， 读取芯片ID函数，代码如下：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">void</span> <span class="hljs-title function_">nand_chip_id</span>(<span class="hljs-params">void</span>)<br>&#123;<br>        <span class="hljs-variable">unsigned</span> <span class="hljs-variable">char</span> <span class="hljs-variable">buf</span>[<span class="hljs-number">5</span>]<span class="hljs-operator">=</span>&#123;<span class="hljs-number">0</span>&#125;;<br>        <br>        <span class="hljs-title function_">nand_select</span>();<br>        <span class="hljs-title function_">nand_cmd</span>(<span class="hljs-number">0x90</span>);<br>        <span class="hljs-title function_">nand_addr_byte</span>(<span class="hljs-number">0x00</span>);<br><br>        <span class="hljs-variable">buf</span>[<span class="hljs-number">0</span>] <span class="hljs-operator">=</span> <span class="hljs-title function_">nand_data</span>();<br>        <span class="hljs-variable">buf</span>[<span class="hljs-number">1</span>] <span class="hljs-operator">=</span> <span class="hljs-title function_">nand_data</span>();   <br>        <span class="hljs-variable">buf</span>[<span class="hljs-number">2</span>] <span class="hljs-operator">=</span> <span class="hljs-title function_">nand_data</span>();<br>        <span class="hljs-variable">buf</span>[<span class="hljs-number">3</span>] <span class="hljs-operator">=</span> <span class="hljs-title function_">nand_data</span>();<br>        <span class="hljs-variable">buf</span>[<span class="hljs-number">4</span>] <span class="hljs-operator">=</span> <span class="hljs-title function_">nand_data</span>();   <br>        <span class="hljs-title function_">nand_deselect</span>();  <br>        <br>        <span class="hljs-comment">/* 打印数据 */</span><br>        <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;maker   id  = 0x%x<span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span>&quot;</span>,<span class="hljs-variable">buf</span>[<span class="hljs-number">0</span>]);<br>        <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;device  id  = 0x%x<span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span>&quot;</span>,<span class="hljs-variable">buf</span>[<span class="hljs-number">1</span>]);      <br>        <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;3rd byte    = 0x%x<span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span>&quot;</span>,<span class="hljs-variable">buf</span>[<span class="hljs-number">2</span>]);              <br>        <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;4th byte    = 0x%x<span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span>&quot;</span>,<span class="hljs-variable">buf</span>[<span class="hljs-number">3</span>]);                      <br>        <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;page  size  = %d kb<span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span>&quot;</span>,<span class="hljs-number">1</span>  <span class="hljs-operator">&lt;&lt;</span>  (<span class="hljs-variable">buf</span>[<span class="hljs-number">3</span>] <span class="hljs-operator">&amp;</span> <span class="hljs-number">0x03</span>));   <br>        <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;block size  = %d kb<span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span>&quot;</span>,<span class="hljs-number">64</span> <span class="hljs-operator">&lt;&lt;</span> ((<span class="hljs-variable">buf</span>[<span class="hljs-number">3</span>] <span class="hljs-operator">&gt;&gt;</span> <span class="hljs-number">4</span>) <span class="hljs-operator">&amp;</span> <span class="hljs-number">0x03</span>));   <br>        <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;5th byte    = 0x%x<span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span>&quot;</span>,<span class="hljs-variable">buf</span>[<span class="hljs-number">4</span>]);<br>&#125;<br><br><span class="hljs-comment">//64 &lt;&lt; ((buf[3] &gt;&gt; 4) &amp; 0x03)：取buf[3]的bit5,bit6；</span><br><span class="hljs-comment">//64 &lt;&lt; 0x0001：即(0100 0000)&lt;&lt; 1 = 128</span><br></code></pre></td></tr></table></figure><p>下面我们再写一个打印菜单的函数，在菜单中调用读取芯片ID的函数，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">oid <span class="hljs-title">nand_flash_test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">char</span> c;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        &#123;<br>                <span class="hljs-comment">/* 打印菜单, 供我们选择测试内容 */</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[s] Scan nand flash\n\r&quot;</span>);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[e] Erase nand flash\n\r&quot;</span>);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[w] Write nand flash\n\r&quot;</span>);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[r] Read nand flash\n\r&quot;</span>);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[q] quit\n\r&quot;</span>);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter selection: &quot;</span>);<br>                c = <span class="hljs-built_in">getchar</span>();<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n\r&quot;</span>, c);<br>                <span class="hljs-comment">/* 测试内容:          </span><br><span class="hljs-comment">                 * 1. 识别nand flash          </span><br><span class="hljs-comment">                 * 2. 擦除nand flash某个扇区          </span><br><span class="hljs-comment">                 * 3. 编写某个地址          </span><br><span class="hljs-comment">                 * 4. 读某个地址          </span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">switch</span> (c)                 <br>                &#123;<br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;q&#x27;</span>:<br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Q&#x27;</span>:<br>                                <span class="hljs-keyword">return</span>;<br>                                <span class="hljs-keyword">break</span>;<br>                                <br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;S&#x27;</span>:<br>                                <span class="hljs-built_in">nand_chip_id</span>();<br>                                <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;e&#x27;</span>:<br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;E&#x27;</span>:<br>                                <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;w&#x27;</span>:<br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;W&#x27;</span>:<br>                                <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;r&#x27;</span>:<br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;R&#x27;</span>:<br>                                <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-keyword">default</span>:<br>                                <span class="hljs-keyword">break</span>;<br>                &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在主函数中调用nand flash的初始化函数，和nand flash的测试函数。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scss">int <span class="hljs-selector-tag">main</span>(void)<br>&#123;<br>        <span class="hljs-built_in">led_init</span>();<br>        <span class="hljs-comment">//interrupt_init();  /* 初始化中断控制器 */</span><br>        <span class="hljs-built_in">key_eint_init</span>();   <span class="hljs-comment">/* 初始化按键, 设为中断源 */</span><br>        <span class="hljs-comment">//timer_init();</span><br>        <br>        <span class="hljs-built_in">puts</span>(&quot;\n\rg_A = &quot;);<br>        <span class="hljs-built_in">printHex</span>(g_A);<br>        <span class="hljs-built_in">puts</span>(&quot;\n\r&quot;);<br>        <span class="hljs-comment">//nor_flash_test();</span><br>        <span class="hljs-built_in">nand_init</span>();<br>        <span class="hljs-built_in">nand_flash_test</span>();<br>        <br>        return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第005节_NandFlash的擦除与烧写</strong></p><hr><p>在上节 我们实现了芯片ID的读取，可是那个程序已经超过了4k，我们想把它烧到开发板的话，必需把它烧写到NOR FLASH上去，这节我们来讲解NAND FLASH数据的读取，并且实现超过4k的程序从NAND FLASH启动。</p><p>下图为NAND FLASH内部结构图，从图中可以可以知道，一个page含有2k 字节的页数据，和64字节的oob区，后面会介绍页数据和oob区有什么关系。</p><p><img src="/image/800px-Chapter16_lesson4_001.png" alt="800px-Chapter16_lesson4_001.png"></p><p>下图的表格，来说明NAND FLASH内部结构，前面2K(0<del>2047)表示页数据，后边64字节(2048</del>2111)表示oob(Out Of Bank)。</p><p><img src="/image/Chapter16_lesson4_002.png" alt="Chapter16_lesson4_002.png"></p><p><strong>问：CPU想读取，第2048个数据，它是哪以一个？</strong></p><p>答：是Page1的第0个字节。CPU使用某个地址访问数据的时候，是在页数据空间来寻址的，根</p><p>本就看不到oob区。</p><p>我们知道NAND FLASH 和 NOR FLASH相比有个缺点，NAND FLASH读或写一页数据的时候，可能会发生位反转，里面可能有一位是错误的，为了解决这个问题，引入oob区， 它写页数据的时候，把数据写进页数据的同时会生成一个校验码，把这个校验码写进oob区里面，当读数据的时候，读出1页数据，读取1数据里面有可能有某一位发生错误，它继续读出原来的校验码，使用oob区里面的校验码，来修正页数据里面的数据。</p><p>从这里我们可以得出一个结论，oob区的存在是为了解决NAND FLASH的缺陷而存在的。</p><p>CPU: 只关心数据，不需要看到oob区的校验码(把数据读出来，然后进行校验再把正确的数据返回，就可以了)。CPU想使用某个addr来访问数据的时候，addr是在页数据区来寻址的，addr根本不会在oob区里面寻址。</p><p>为了形象在下面说一个幽默的对话来说明一下CPU和NAND FLASH的功能：</p><p>CPU大爷: 小nand啊，你的性能比不上小nor啊，听说你有位反转的毛病</p><p>Nand  : 是的，大爷，位反转是我天生的毛病，时有时无</p><p>CPU大爷: 靠，你说你价格便宜容量大，这不是害我嘛</p><p>Nand  : 没事，我有偏方，用OOB就可以解决这问题</p><p>CPU大爷: 得得得，你那偏方是什么也别告诉我，我只管能读写正确的数据</p><p>Nand  : 是的，大爷，我这OOB偏方也就我自个私下使用。您就像使用nor一样使唤我就可以了</p><p>下面我们开始写程序，想去读NAND FLASH应该怎样操作,下面是nand flash的。</p><p><img src="/image/800px-Chapter16_lesson4_003.png" alt="800px-Chapter16_lesson4_003.png"></p><p>下图为读NAND FLASH的时序操作：</p><p><img src="/image/800px-Chapter16_lesson4_004.png" alt="800px-Chapter16_lesson4_004.png"></p><p>读NAND FLASH步骤：(从程序的角度来说)，我们需要先发出00命令再发出5个周期的地址(由地址周期表得应为两个col列地址，三个row行地址)，再发出30命令，然后就可以读数据了。比如：我想访问某个地址的数据，需要确定在哪一行page(row)，在哪一列col(0~2047)。从NAND FLASH的地址周期中可以看出来，先发出2个col(列地址)，再发出3个(Row)行地址。 下面是程序的编写：</p><p><img src="/image/800px-Chapter16_lesson4_005.png" alt="800px-Chapter16_lesson4_005.png"></p><p>wait_ready函数等待NAND FLASHh空闲，从上图可以看出当NFSTAT寄存器[0]的值为1时NAND FLASH是空闲的，我们可以通过该位来判断NAND FLASH是否繁忙。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">wait_ready</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>        <span class="hljs-keyword">while</span> (!(<span class="hljs-variable constant_">NFSTAT</span> &amp; <span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>nand_read函数为NAND FLASH的读函数，代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void nand<span class="hljs-constructor">_read(<span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">addr</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">buf</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">len</span>)</span><br>&#123;<br>        <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> page = addr<span class="hljs-operator"> / </span><span class="hljs-number">2048</span>;<br>        <span class="hljs-built_in">int</span> col  = addr &amp; (<span class="hljs-number">2048</span> - <span class="hljs-number">1</span>);<br>        <br>        nand<span class="hljs-constructor">_select()</span>;<br><br>        <span class="hljs-keyword">while</span> (i &lt; len)<br>        &#123;<br>                <span class="hljs-comment">/* 发出00h命令 */</span><br>                nand<span class="hljs-constructor">_cmd(00)</span>;<br><br>                <span class="hljs-comment">/* 发出地址 */</span><br>                <span class="hljs-comment">/* col addr */</span> <br>                nand<span class="hljs-constructor">_addr_byte(<span class="hljs-params">col</span> &amp; 0xff)</span>;        <span class="hljs-comment">//看地址周期表可得怎么发地址</span><br>                nand<span class="hljs-constructor">_addr_byte((<span class="hljs-params">col</span>&gt;&gt;8)</span> &amp; <span class="hljs-number">0xff</span>);<br><br>                <span class="hljs-comment">/* row/page addr */</span><br>                nand<span class="hljs-constructor">_addr_byte(<span class="hljs-params">page</span> &amp; 0xff)</span>;<br>                nand<span class="hljs-constructor">_addr_byte((<span class="hljs-params">page</span>&gt;&gt;8)</span> &amp; <span class="hljs-number">0xff</span>);<br>                nand<span class="hljs-constructor">_addr_byte((<span class="hljs-params">page</span>&gt;&gt;16)</span> &amp; <span class="hljs-number">0xff</span>);<br><br>                <span class="hljs-comment">/* 发出30h命令 */</span><br>                nand<span class="hljs-constructor">_cmd(0x30)</span>;<br><br>                <span class="hljs-comment">/* 等待就绪 */</span><br>                wait<span class="hljs-constructor">_ready()</span>;<br><br>                <span class="hljs-comment">/* 读数据 */</span><br>                <span class="hljs-keyword">for</span> (; (col &lt; <span class="hljs-number">2048</span>)<span class="hljs-operator"> &amp;&amp; </span>(i &lt; len); col++)<br>                &#123;<br>                        buf<span class="hljs-literal">[<span class="hljs-identifier">i</span><span class="hljs-operator">++</span>]</span> = nand<span class="hljs-constructor">_data()</span>;                   <br>                &#125;<br>                <span class="hljs-keyword">if</span> (i<span class="hljs-operator"> == </span>len)        <span class="hljs-comment">//len：读多少字节的数据</span><br>                        break;<br><br>                col = <span class="hljs-number">0</span>;<br>                page++;<br>        &#125;<br>        <br>        nand<span class="hljs-constructor">_deselect()</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>在init.c文件中，加上如下代码，用来判断所使用的FLASH是NOR FLASH还是NAND FLASH。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isBootFromNorFlash</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *p = (<span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *)<span class="hljs-number">0</span>;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> val = *p;<br><br>        *p = <span class="hljs-number">0x12345678</span>;<br>        <span class="hljs-keyword">if</span> (*p == <span class="hljs-number">0x12345678</span>)<br>        &#123;<br>                <span class="hljs-comment">/* 写成功, 对应nand启动 */</span><br>                *p = val;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在init.c文件中的copy2sdram函数里面加上如下代码，用来支持NAND FLASH启动，当isBootFromNorFlash函数的返回值为1时，是从NOR FLASH启动，当isBootFromNorFlash函数的返回值为0是，是从NAND FLASH启动。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">    <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">BootFromNorFlash()</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (dest &lt; <span class="hljs-keyword">end</span>)<br>        &#123;<br>            *dest++ = *src++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        nand<span class="hljs-constructor">_init()</span>;<br>        nand<span class="hljs-constructor">_read(<span class="hljs-params">src</span>, <span class="hljs-params">dest</span>, <span class="hljs-params">len</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第005节_NandFlash的擦除与烧写</strong></p><hr><p>我们本节需要做的事情：</p><ol><li>实现nand_erase</li><li>实现nand_write</li><li>实现测试菜单</li></ol><p>下面我们逐个来实现他们：</p><p>本节讲的NAND FLASH的烧写和擦除还是比较简单的，它只涉及到页数据区，不涉及到oob区，擦出的时候是以块为单位。下图为擦除的时序图：</p><p><img src="/image/800px-Chapter16_lesson5_001.png" alt="800px-Chapter16_lesson5_001.png"></p><p>我们就根据擦除的时序图发出对应的命令和地址，NAND FLASH是以块为单位进行擦除的，假如我们传入len的值为1，但是它仍然会擦出一个块（128k字节），我们根据芯片手册，来操作NAND FLASH的擦出操作，函数功能：从addr地址开始，擦除len长度的数据。代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">nand_erase</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">int</span> page = addr / <span class="hljs-number">2048</span>;<br><br>        <span class="hljs-keyword">if</span> (addr &amp; (<span class="hljs-number">0x1FFFF</span>))    <span class="hljs-comment">//如果不是整的128K</span><br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;nand_erase err, addr is not block align\n\r&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (len &amp; (<span class="hljs-number">0x1FFFF</span>))<br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;nand_erase err, len is not block align\n\r&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <br>        <span class="hljs-built_in">nand_select</span>();<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        &#123;<br>                page = addr / <span class="hljs-number">2048</span>;<br>                <br>                <span class="hljs-built_in">nand_cmd</span>(<span class="hljs-number">0x60</span>);<br>                <br>                <span class="hljs-comment">/* row/page addr */</span><br>                <span class="hljs-built_in">nand_addr_byte</span>(page &amp; <span class="hljs-number">0xff</span>);<br>                <span class="hljs-built_in">nand_addr_byte</span>((page&gt;&gt;<span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>);<br>                <span class="hljs-built_in">nand_addr_byte</span>((page&gt;&gt;<span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xff</span>);<br><br>                <span class="hljs-built_in">nand_cmd</span>(<span class="hljs-number">0xD0</span>);<br><br>                <span class="hljs-built_in">wait_ready</span>();<br><br>                len -= (<span class="hljs-number">128</span>*<span class="hljs-number">1024</span>);    <span class="hljs-comment">//擦除完成，len-128k</span><br>                <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>)<br>                        <span class="hljs-keyword">break</span>;<br>                addr += (<span class="hljs-number">128</span>*<span class="hljs-number">1024</span>);    <span class="hljs-comment">//擦除完一个块，发现没有擦完，指向下一个块</span><br>        &#125;<br><br>        <span class="hljs-built_in">nand_deselect</span>();  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>操作NAND FLASH之前要，选中芯片，然后就可以根据芯片手册来操作NAND FLASH的擦除操作了，操作完之后，要取消片选。</p><p>往NAND FLASH写数据时，只需要把要写的数据复制给NFDATA寄存器即可。代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void nand<span class="hljs-constructor">_w_data(<span class="hljs-params">unsigned</span> <span class="hljs-params">char</span> <span class="hljs-params">val</span>)</span><br>&#123;<br>        NFDATA = <span class="hljs-keyword">val</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>下图为烧写的时序图：</p><p><img src="/image/800px-Chapter16_lesson5_002.png" alt="800px-Chapter16_lesson5_002.png"></p><p>从上图中的NAND FLASH烧写时序图可以知道对于NAND FLASH的烧写，先发出0x80命令，再发出地址周期，然后发出要烧写的数据，最后发出0x10，就开始内部烧写，然后等待烧写成功。（我们写数据的时候是逐页写的，开始要烧写的数据地址可能不是该页的起始地址）。操作之前需要选中片选，操作完之后取消片选，代码如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/* 把buf中len长度的数据写到地址addr */</span><br>void nand<span class="hljs-constructor">_write(<span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">addr</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">buf</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">len</span>)</span><br>&#123;<br>        <span class="hljs-built_in">int</span> page = addr<span class="hljs-operator"> / </span><span class="hljs-number">2048</span>;<br>        <span class="hljs-built_in">int</span> col  = addr &amp; (<span class="hljs-number">2048</span> - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br><br>        nand<span class="hljs-constructor">_select()</span>;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        &#123;<br>                nand<span class="hljs-constructor">_cmd(0x80)</span>;<br><br>                <span class="hljs-comment">/* 发出地址 */</span><br>                <span class="hljs-comment">/* col addr */</span><br>                nand<span class="hljs-constructor">_addr_byte(<span class="hljs-params">col</span> &amp; 0xff)</span>;<br>                nand<span class="hljs-constructor">_addr_byte((<span class="hljs-params">col</span>&gt;&gt;8)</span> &amp; <span class="hljs-number">0xff</span>);<br>                <br>                <span class="hljs-comment">/* row/page addr */</span><br>                nand<span class="hljs-constructor">_addr_byte(<span class="hljs-params">page</span> &amp; 0xff)</span>;<br>                nand<span class="hljs-constructor">_addr_byte((<span class="hljs-params">page</span>&gt;&gt;8)</span> &amp; <span class="hljs-number">0xff</span>);<br>                nand<span class="hljs-constructor">_addr_byte((<span class="hljs-params">page</span>&gt;&gt;16)</span> &amp; <span class="hljs-number">0xff</span>);<br><br>                <span class="hljs-comment">/* 发出数据 */</span><br>                <span class="hljs-keyword">for</span> (; (col &lt; <span class="hljs-number">2048</span>)<span class="hljs-operator"> &amp;&amp; </span>(i &lt; len); )<br>                &#123;<br>                        nand<span class="hljs-constructor">_w_data(<span class="hljs-params">buf</span>[<span class="hljs-params">i</span><span class="hljs-operator">++</span>])</span>;<br>                &#125;<br>                nand<span class="hljs-constructor">_cmd(0x10)</span>;<br>                wait<span class="hljs-constructor">_ready()</span>;<br><br>                <span class="hljs-keyword">if</span> (i<span class="hljs-operator"> == </span>len)<br>                        break;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                        <span class="hljs-comment">/* 开始下一个循环page */</span><br>                        col = <span class="hljs-number">0</span>;<br>                        page++;<br>                &#125;<br>        &#125;<br>        nand<span class="hljs-constructor">_deselect()</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>我们封装擦除操作NAND FLASH函数的时候，每一次擦除的大小是一个块(128*1024)代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_erase_nand_flash</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> addr;<br>        <br>        <span class="hljs-comment">/* 获得地址 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the address of sector to erase: &quot;</span>);<br>        addr = <span class="hljs-built_in">get_uint</span>();<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;erasing ...\n\r&quot;</span>);<br>        <span class="hljs-built_in">nand_erase</span>(addr, <span class="hljs-number">128</span>*<span class="hljs-number">1024</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们封装读取操作NAND FLASH函数，我们实现NAND FLASH每次的读取，每次读取64字节数据。把从地址addr读取得到的64字节数据存放到buf缓冲区中，然后通过串口显示出来，代码如下图所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_read_nand_flash</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> addr;<br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *p;<br>        <span class="hljs-type">int</span> i, j;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str[<span class="hljs-number">16</span>];<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>];<br>        <br>        <span class="hljs-comment">/* 获得地址 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the address to read: &quot;</span>);<br>        addr = <span class="hljs-built_in">get_uint</span>();<br><br>        <span class="hljs-built_in">nand_read</span>(addr, buf, <span class="hljs-number">64</span>);<br>        p = (<span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)buf;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Data : \n\r&quot;</span>);<br>        <span class="hljs-comment">/* 长度固定为64 */</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>        &#123;<br>                <span class="hljs-comment">/* 每行打印16个数据 */</span><br>                <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">16</span>; j++)<br>                &#123;<br>                        <span class="hljs-comment">/* 先打印数值 */</span><br>                        c = *p++;<br>                        str[j] = c;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02x &quot;</span>, c);<br>                &#125;<br><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   ; &quot;</span>);<br><br>                <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">16</span>; j++)<br>                &#123;<br>                        <span class="hljs-comment">/* 后打印字符 */</span><br>                        <span class="hljs-keyword">if</span> (str[j] &lt; <span class="hljs-number">0x20</span> || str[j] &gt; <span class="hljs-number">0x7e</span>)  <span class="hljs-comment">/* 不可视字符 */</span><br>                                <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;.&#x27;</span>);<br>                        <span class="hljs-keyword">else</span><br>                                <span class="hljs-built_in">putchar</span>(str[j]);<br>                &#125;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n\r&quot;</span>);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>NAND FLASH的烧写封装函数代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_write_nand_flash</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> addr;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br>        <span class="hljs-type">int</span> i, j;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> val;<br>        <br>        <span class="hljs-comment">/* 获得地址 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the address of sector to write: &quot;</span>);<br>        addr = <span class="hljs-built_in">get_uint</span>();<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the string to write: &quot;</span>);<br>        <span class="hljs-built_in">gets</span>(str);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;writing ...\n\r&quot;</span>);<br>        <span class="hljs-built_in">nand_write</span>(addr, str, <span class="hljs-built_in">strlen</span>(str)+<span class="hljs-number">1</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>NAND FLASH的测试菜单函数代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nand_flash_test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">char</span> c;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        &#123;<br>                <span class="hljs-comment">/* 打印菜单, 供我们选择测试内容 */</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[s] Scan nand flash\n\r&quot;</span>);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[e] Erase nand flash\n\r&quot;</span>);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[w] Write nand flash\n\r&quot;</span>);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[r] Read nand flash\n\r&quot;</span>);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[q] quit\n\r&quot;</span>);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter selection: &quot;</span>);<br><br>                c = <span class="hljs-built_in">getchar</span>();<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n\r&quot;</span>, c);<br><br>                <span class="hljs-comment">/* 测试内容:          </span><br><span class="hljs-comment">                 * 1. 识别nand flash          </span><br><span class="hljs-comment">                 * 2. 擦除nand flash某个扇区          </span><br><span class="hljs-comment">                 * 3. 编写某个地址          </span><br><span class="hljs-comment">                 * 4. 读某个地址          </span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">switch</span> (c)                 <br>                &#123;<br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;q&#x27;</span>:<br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Q&#x27;</span>:<br>                                <span class="hljs-keyword">return</span>;<br>                                <span class="hljs-keyword">break</span>;<br>                                <br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;S&#x27;</span>:<br>                                <span class="hljs-built_in">nand_chip_id</span>();<br>                                <span class="hljs-keyword">break</span>;<br><br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;e&#x27;</span>:<br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;E&#x27;</span>:<br>                                <span class="hljs-built_in">do_erase_nand_flash</span>();<br>                                <span class="hljs-keyword">break</span>;<br><br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;w&#x27;</span>:<br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;W&#x27;</span>:<br>                                <span class="hljs-built_in">do_write_nand_flash</span>();<br>                                <span class="hljs-keyword">break</span>;<br><br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;r&#x27;</span>:<br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;R&#x27;</span>:<br>                                <span class="hljs-built_in">do_read_nand_flash</span>();<br>                                <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-keyword">default</span>:<br>                                <span class="hljs-keyword">break</span>;<br>                &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>问题</strong></p><hr><p>一、对于存储为256M的NAND FLASH，需要28条地址线，来表示这个地址值，根据原理图可以，只用8根地址线，所以需要4个周期的地址。4个周期怎么算的？</p><p>二、为什么读操作下“因为现在是0地址，所以五个地址都是C0”</p><p>三、为什么要在s3c2440_soc.h中设置NFCMD、NFADDR、NFDATA、NFSTAT的__REG为__REG_BYTE(按字节形式)，可以从芯片手册的寄存器控制中找到吗</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第014课 异常与中断</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AC%AC014%E8%AF%BE_%E5%BC%82%E5%B8%B8%E4%B8%8E%E4%B8%AD%E6%96%AD/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AC%AC014%E8%AF%BE_%E5%BC%82%E5%B8%B8%E4%B8%8E%E4%B8%AD%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<p><strong>001节</strong></p><p><strong>ARM系统的中断处理方式</strong></p><p><img src="/image/4ec45ef1f3e481bcc262bd3bc6a4d0e5.png" alt="4ec45ef1f3e481bcc262bd3bc6a4d0e5.png"></p><p>对比我们的arm系统：有CPU，有中断控制器。</p><p>中断控制器可以发信号给CPU告诉它发生了那些紧急情况，中断源有按键、定时器、有其它的（比如网络数据）。这些信号都可以发送信号给中断控制器，再由中断控制器发送信号给CPU表明有这些中断产生了，这些成为中断(属于一种异常)。</p><p>还有什么可以中断CPU运行？</p><p>指令不对，数据访问有问题，reset信号，这些都可以中断CPU，这些称为异常。</p><hr><p><strong>arm对异常(中断)处理过程：</strong></p><p>1.初始化:</p><ul><li>设置中断源，让它可以产生中断</li><li>设置中断控制器(可以屏蔽某个中断，优先级)</li><li>设置CPU总开关，(使能中断)</li></ul><p>2.执行其他程序:正常程序。</p><p>3.产生中断：按下按键—&gt;中断控制器—&gt;CPU。</p><p>4.cpu每执行完一条指令都会检查有无中断&#x2F;异常产生</p><p>5.发现有中断&#x2F;异常产生，开始处理：</p><p>a CPU对于不同的异常，会强制跳去不同的地址。(硬件决定)</p><pre><code class="hljs">- 这地址上，只是一条跳转指令，用来跳去执行某个函数\(地址\)，这个就是异常向量。- 如下是异常向量表,对于不同的异常都有一条跳转指令。</code></pre><p>b  执行跳转指令，执行函数</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">.globl</span> _start<br><span class="hljs-symbol">_start:</span> <span class="hljs-keyword">b</span>    reset<br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, _undefined_instruction    <span class="hljs-comment">//异常向量</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, _software_interrupt       <span class="hljs-comment">//异常向量</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, _prefetch_abort<br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, _data_abort<br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, _not_used<br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, _irq <span class="hljs-comment">//发生中断时，CPU跳到这个地址执行该指令 **假设地址为0x18**</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, _fiq<br><span class="hljs-comment">//我们先在0x18这里放 ldr pc ,__irq,于是cpu最终会跳去执行__irq代码</span><br><span class="hljs-comment">//irq代码:保护现场，调用处理函数，恢复现场</span><br></code></pre></td></tr></table></figure><p>6.这些函数做什么事情?</p><p>a 保存现场(各种寄存器)</p><p>b 处理异常(中断):</p><pre><code class="hljs">- 分辨中断源- 再调用不同的处理函数</code></pre><p>c 恢复现场</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第015课 NOR Flash</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AC%AC015%E8%AF%BE_NOR_Flash/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AC%AC015%E8%AF%BE_NOR_Flash/</url>
    
    <content type="html"><![CDATA[<p><strong>目录</strong></p><hr><ol><li><p>第001节_Nor Flash原理及硬件操作</p><ul><li>Flash介绍</li><li>Nor Flash的操作</li><li>Nor Flash的两种规范</li><li>Nor Flash写数据</li></ul></li><li><p>第002节_Nor Flash编程_识别</p></li><li><p>第003节_Nor Flash编程_擦写读</p></li></ol><p><strong>第001节_Nor Flash原理及硬件操作</strong></p><hr><p>Nor Flash的连接线有地址线，数据线，片选信号读写信号等，Nor Flash的接口属于内存类接口，Nor Flash可以向内存一样读，但是不能像内存一样写，需要做一些特殊的操作才能进行写操作，读只需像内存一样读很简单。</p><p>Nor Flash原理图如图：</p><p><img src="/image/Chapter15_lesson1_001.png" alt="Chapter15_lesson1_001.png"></p><p>Flash介绍</p><hr><p>常用的Flash类型有Nor Flash和NAND Flash两种。</p><p>Nor Flash由Intel公司在1988年发明，以替代当时在市场上占据主要地位的EPROM和E2PROM</p><p>NAND Flash由Toshiba公司在1989年发明。两者的主要差别如下表：</p><p><img src="/image/2708b2aa132e2a74066e2aa8efd08907.png" alt="2708b2aa132e2a74066e2aa8efd08907.png"></p><p>Nor Flash支持XIP，即代码可以直接在Nor Flash上执行，无需复制到内存中。这是由于NorF lash的接口与RAM完全相同，可以随机访问任意地址的数据。Nor Flash进行读操作的效率非常高，但是擦除和写操作的效率很低，另外，Nor Flash的容量一般比较小。NAND Flash进行擦除和写操作的效率更高，并且容量更大。一般而言，Nor Flash用于存储程序，NAND Flash用于存储数据。基于NAND Flash的设备通常也要搭配Nor Flash以存储程字。</p><p>Flash存储器件由擦除单元（也称为块）组成，当要写某个块时，需要确保这个块己经 被擦除。Nor Flash的块大小范围为64kB、128kB：NAND Flash的块大小范围为8kB，64kB，擦&#x2F;写一个Nor Flash块需4s，而擦／写一个NAND Flash块仅需2ms。Nor Flash的块太大，不仅增加了擦写时间，对于给定的写操作，Nor Flash也需要更多的擦除操作——特别是小文件，比如一个文件只有IkB，但是为了保存它却需要擦除人小为64kB—128kB的Nor Flash块。</p><p>Nor Flash的接口与RAM完全相同，可以随意访问任意地址的数据。而NAND Flash的 接口仅仅包含几个I&#x2F;O引脚，需要串行地访问。NAND Flash一般以512字节为单位进行读写。这使得Nor Flash适合于运行程序，而NAND Flash更适合于存储数据。</p><p>容量相同的情况下，NAND Flash的体积更小，对于空间有严格要求的系统，NAND Flash可以节省更多空间。市场上Nor Flash的容量通常为IMB<del>4MB(也有32MB的Nor Flash)，NAND Flash的容量为8MB</del>512MB。容量的差别也使得Nor Flash多用于存储程序，NAND Flash多用于存储数据。</p><p>对于Flash存储器件的可靠性需要考虑3点：位反转、坏块和可擦除次数。所有Flash器件都遭遇位反转的问题：由于Flash固有的电器特性，在读写数据过程中，偶然会产生一位或几位数据错误（这种概率很低），而NAND Flash出现的概率远大于Nor Flash，当位反转发生在关键的代码、数据上时，有可能导致系统崩溃。当仅仅是报告位反转，重新读取即可：如果确实发生了位反转，则必须有相应的错误检测&#x2F;恢复措施。在NAND Flash上发生位反转的概率史高，推荐使用EDC&#x2F;ECC进行错误检测和恢复。NAND Flash上面会有坏块随机分布在使用前需要将坏块扫描出来，确保不再使用它们，否则会使产品含有严重的故障。NAND Flash每块的可擦除次数通常在100000次左右，是Nor Flash的10倍。另外，因为NAND Flash的块大小通常是NorF lash的1&#x2F;8，所以NAND Flash的寿命远远超过Nor Flash。</p><p>嵌入式Linux对Nor、NAND Flash的软件支持都很成熟。在Nor Flash上常用jffs2文 件系统，而在NAND Flash常用yaffs文件系统。在更底层，有MTD驱动程序实现对它们的读、写、擦除操仵，它也实现了EDC&#x2F;ECC校验。</p><p>Nor Flash的操作</p><hr><p>下面我们使用u-boot来体验Nor Flash的操作(开发板设置Nor启动，进入u-boot)。</p><p>使用OpenJTAG烧写UBOOT到Nor Flash</p><p>那么我们怎么用u-boot来操作呢？</p><p>Nor Flash手册里会有一个命令的表格，如图：</p><p><img src="/image/fbf4560f71d5c5379f6e350ff8441167.png" alt="fbf4560f71d5c5379f6e350ff8441167.png"></p><p>Word是指使用的nor位宽为16，Byte指使用的nor位宽为8，可以从原理图上看出，我们的是16位的(数据位)，所以我们用的写操作是word那一行</p><p>下面简单的举一些例子：</p><p>复位(reset)：往任何一个地址写入F0。</p><p>读ID(ReadSiliconID)：很多的Nor Flash可以配置成位宽16bit(Word)，位宽8bit(Byte)。对于我们使用的jz2440开发板使用是位宽16bit，怎样读ID呢？</p><p>根据前面得图可知，往Nor Flash的555地址写AA，再往2AA的地址写入55，再往555的地址写入90，然后就可以读ADI地址，就可以读到DDI数据了。</p><p><strong>实例1�</strong>�</p><p>读数据：</p><p>当我们现在u-boot之后，我们退出菜单模式，按q进入命令行。</p><p>在u-boot上执行：md.b0</p><p>结果(和我们烧进去的数据完全一样)：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00000000</span>:<span class="hljs-number">170000</span>ea14f09fe514f09fe514f09fe5................<br><span class="hljs-attribute">00000010</span>:<span class="hljs-number">14</span>f09fe514f09fe514f09fe514f09fe5................<br><span class="hljs-attribute">00000020</span>:<span class="hljs-number">6001</span>f833c001f8332002f8337002f833`..<span class="hljs-number">3</span>...<span class="hljs-number">3</span>..<span class="hljs-number">3</span>...<span class="hljs-number">3</span><br><span class="hljs-attribute">00000030</span>:e002f8330004f8332004f833efbeadde...<span class="hljs-number">3</span>...<span class="hljs-number">3</span>..<span class="hljs-number">3</span>....<br></code></pre></td></tr></table></figure><p>可以得出结论：u-boot可以像读内存一样来读nor flash</p><p><strong>实例2</strong></p><p>读ID(参考Nor手册MX29LV800BBTC)<img src="/image/20da9acc7f43e2d9651848996745b12a.png" alt="20da9acc7f43e2d9651848996745b12a.png"></p><ul><li>往地址555H写入AAH(解锁)</li></ul><p> </p><p>          &#x2F;&#x2F;这里的555H是在nor基地址为0的情况下，若不为0需要写入的地址是基地址加上555H </p><ul><li>往地址2AAH写入55H(解锁)</li><li>往地址555H写入90H（命令）</li><li>读0地址得到厂家ID(得到C2H)</li><li>读1地址得到设备ID(22DAH或225BH)</li><li>退出读ID状态：给任意地址写F0H就可以了。</li></ul><p>下图为2440和Nor Flash的简易连接图：</p><p><img src="/image/700px-Chapter15_lesson1_003.jpg" alt="700px-Chapter15_lesson1_003.jpg"></p><p>2440的A1接到Nor的A0所以2440发出的地址是，Nor Flash收到的地址左移一位。比如：2440发出(555H&lt;&lt;1)地址，Nor Flash才能收到555H这个地址。</p><p>下面对在Nor Flash的操作，2440的操作，U-BOOT上的操作进行比较，如下表：</p><p><img src="/image/8917b93067e2129d11f26ae419701fdf.png" alt="8917b93067e2129d11f26ae419701fdf.png"></p><p>1). 当执行过</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">md</span>.w  <span class="hljs-number">0</span>  <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>结果(输出厂家ID)：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00000000</span>:<span class="hljs-number">00</span>c2..(<span class="hljs-number">00</span>c2就是厂家ID)<br></code></pre></td></tr></table></figure><p>2). 当执行过</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">md</span>.w  <span class="hljs-number">2</span>  <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>结果(输出设备ID)：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-number">00000002</span>:<span class="hljs-number">2249</span>I<span class="hljs-string">&quot;(2249就是设备ID)</span><br></code></pre></td></tr></table></figure><p>3).当执行</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mw</span>.w  <span class="hljs-number">0</span>  f0<br></code></pre></td></tr></table></figure><p>就退出读ID的状态，</p><p>执行：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">md</span>.b0<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00000000</span>:<span class="hljs-number">17</span>.（读到的就是Nor Flash地址·<span class="hljs-number">0</span>的数据）<br></code></pre></td></tr></table></figure><p>Nor Flash的两种规范</p><hr><p>通常内核里面要识别一个 Nor Flash 有两种方法：</p><p>一种是 jedec 探测，就是在内核里面事先定义一个数组，该数组里面放有不同厂家各个芯片的一些参数，探测的时候将 flash 的 ID 和数组里面的 ID 一一比较，如果发现相同的，就使用该数组的参数。 jedec 探测的优点就是简单，缺点是如果内核要支持的 flash 种类很多，这个数组就会很庞大。内核里面用 jedec 探测一个芯片时，是先通过发命令来获取 flash 的 ID，然后和数组比较，但是 flash.c 中连 ID 都是自己通过宏配置的。</p><p>一种是 CFI(common flash interface)探测，就是直接发各种命令来读取芯片的信息，比如 ID、容量等，芯片本身就包含了电压有多大，容量有有多少等信息。</p><p>下面对在Nor Flash上操作，2440上操作，U-BOOT上操作cfi 探测（读取芯片信息）进行比较参考芯片手册。</p><p>进入CFI模式：往55H地址写入98H</p><p><img src="/image/a3e6fe8bd91b3329b365ecab7497d33b.png" alt="a3e6fe8bd91b3329b365ecab7497d33b.png"></p><p>Nor Flash写数据</p><hr><p>我们在Nor Flash的10000的地址读数据，</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">md</span>.w  <span class="hljs-number">100000</span>  <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure"><span class="hljs-number">00100000</span><span class="hljs-symbol">:ffff..</span><br></code></pre></td></tr></table></figure><p>在Nor flash的10000的地址写数据下0x1234，</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mw</span>.w <span class="hljs-number">100000</span>   <span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><p>然后在这个地址读数据，</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">md</span>.w  <span class="hljs-number">100000</span>  <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">00100000</span>:<span class="hljs-built_in">ffff</span>(这个地址上的数据没有被修改，写操作无效)。<br></code></pre></td></tr></table></figure><p>怎样把数据写进Nor Flash进去呢？</p><p>写数据之前必须保证，要写的地址是擦除的，即全为f。</p><p>下面是Nor Flash的写操作，如下表：</p><p><img src="/image/cadb135ff3ad644288eae215e2a58987.png" alt="cadb135ff3ad644288eae215e2a58987.png"></p><p>1). U-BOOT执行完上述指令后，0x1234，就被写到0x100000地址处，</p><p>执行：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">md</span>.w <span class="hljs-number">100000</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>结果(1234被写进去)：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00100000</span>:<span class="hljs-number">1234</span>   <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>从这里可以看出来U-BOOT的操作不是很复杂。</p><p>2). 我们再次往0x100000地址处，写入0x5678,执行如下命令：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mw</span>.w  aaa  aa<br><span class="hljs-attribute">mw</span>.w  <span class="hljs-number">554</span>  <span class="hljs-number">55</span><br><span class="hljs-attribute">mw</span>.w  aaa  a0<br><span class="hljs-attribute">mw</span>.w  <span class="hljs-number">100000</span>  <span class="hljs-number">5678</span><br></code></pre></td></tr></table></figure><p>查看0x100000地址处的数据</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">md</span>.w  <span class="hljs-number">100000</span>  <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00100000</span>:<span class="hljs-number">12300</span>.<br></code></pre></td></tr></table></figure><p>0x100000地址处的数据不是0x5678，写操作失败，失败的原因是，原来的数据已经是0x1234不是全0xffff，再次写操作失败，(Nor Flash只有先擦出，才能烧写)。</p><p>先擦除(参考Nor Flash芯片手册)</p><p><img src="/image/2168704400a6fa73598ba6bc82fed76c.png" alt="2168704400a6fa73598ba6bc82fed76c.png"></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">Nor Flash操作      u-boot操作<br><span class="hljs-number">555H</span> <span class="hljs-number">AAH</span>      mw<span class="hljs-number">.</span>w   <span class="hljs-keyword">aaa</span>    aa<br><span class="hljs-number">2AAH</span> <span class="hljs-number">55H</span>      mw<span class="hljs-number">.</span>w   <span class="hljs-number">554</span>    <span class="hljs-number">55</span><br><span class="hljs-number">555H</span> <span class="hljs-number">80H</span>      mw<span class="hljs-number">.</span>w   <span class="hljs-keyword">aaa</span>   <span class="hljs-number">80</span><br><span class="hljs-number">555H</span> <span class="hljs-number">AAH</span>      mw<span class="hljs-number">.</span>w   <span class="hljs-keyword">aaa</span>    aa<br><span class="hljs-number">2AAH</span> <span class="hljs-number">55H</span>      mw<span class="hljs-number">.</span>w   <span class="hljs-number">554</span>    <span class="hljs-number">55</span><br>SA  <span class="hljs-number">30H</span> //往扇区地址写入<span class="hljs-number">30</span>   mw<span class="hljs-number">.</span>w  <span class="hljs-number">100000</span>  <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><p>执行完上述指令后测试</p><p>执行：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">md</span>.w  <span class="hljs-number">100000</span>  <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure"><span class="hljs-number">00100000</span><span class="hljs-symbol">:ffff..</span><br></code></pre></td></tr></table></figure><p>已被擦除，这个时候再次烧写就不会有问题了。</p><p>再烧写</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mw</span>.w  aaa   aa<br><span class="hljs-attribute">mw</span>.w  <span class="hljs-number">554</span>   <span class="hljs-number">55</span><br><span class="hljs-attribute">mw</span>.w  aaa   a0<br><span class="hljs-attribute">mw</span>.w  <span class="hljs-number">100000</span>  <span class="hljs-number">5678</span><br></code></pre></td></tr></table></figure><p>测试烧写结果 执行：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">md</span>.w  <span class="hljs-number">100000</span>  <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00100000</span>:<span class="hljs-number">5678</span>  xV<br></code></pre></td></tr></table></figure><p>数据被烧写进去，烧写成功。</p><p>总结：我们烧写时，如果上面的数据，不是0ffff,没有被擦除过，我们就要先擦出，擦除完后，才可以烧写，擦除烧写的命令可以从芯片手册里面获得。</p><p><strong>第002节_Nor Flash编程_识别</strong></p><hr><p><strong>本节实例的目的：识别nor flash�</strong>�</p><p><strong>Nor Flash的测试</strong></p><p>nor_flash_test函数通过switch语句，分别处理识别NOR Flash，擦除NOR Flash某个扇区，编写某个地址，读某个地址。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* Nor_flash.c */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nor_flash_test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> c;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">/* 打印菜单, 供我们选择测试内容 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[s] Scan nor flash\n\r&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[e] Erase nor flash\n\r&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[w] Write nor flash\n\r&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[r] Read nor flash\n\r&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[q] quit\n\r&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter selection: &quot;</span>);<br><br>        c = <span class="hljs-built_in">getchar</span>();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n\r&quot;</span>, c);<br><br>        <span class="hljs-comment">/* 测试内容:</span><br><span class="hljs-comment">         * 1. 识别nor flash</span><br><span class="hljs-comment">         * 2. 擦除nor flash某个扇区</span><br><span class="hljs-comment">         * 3. 编写某个地址</span><br><span class="hljs-comment">         * 4. 读某个地址</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">switch</span> (c)         <br>        &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;q&#x27;</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Q&#x27;</span>:<br>                <span class="hljs-keyword">return</span>;<br>                <span class="hljs-keyword">break</span>;<br>                <br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;S&#x27;</span>:<br>                <span class="hljs-built_in">do_scan_nor_flash</span>();<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;e&#x27;</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;E&#x27;</span>:<br>                <span class="hljs-built_in">do_erase_nor_flash</span>();<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;w&#x27;</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;W&#x27;</span>:<br>                <span class="hljs-built_in">do_write_nor_flash</span>();<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;r&#x27;</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;R&#x27;</span>:<br>                <span class="hljs-built_in">do_read_nor_flash</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>写入函数</strong></p><p>nor_write_word函数实现往NOR Flash某个地址发送指令，</p><p>offset是基于NOR的角度看到，在jz2440中,NOR基地址为0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 比如:   55H 98</span><br><span class="hljs-comment"> * 本意是: 往(0基地址base + (0x55偏移量offset)&lt;&lt;1)写入0x98数据val</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nor_write_word</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> base, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *p = (<span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *)(base + (offset &lt;&lt; <span class="hljs-number">1</span>));<br>    *p = val;    <span class="hljs-comment">//val是int,而p是short,所以只用到val的最低两个字节</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不想老重复入固定的base，进行封装一下</p><p>发送命令函数 nor_cmd函数代码如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/* offset是基于NOR的角度看到 */</span><br>void nor<span class="hljs-constructor">_cmd(<span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">offset</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">cmd</span>)</span><br>&#123;<br>    nor<span class="hljs-constructor">_write_word(NOR_FLASH_BASE, <span class="hljs-params">offset</span>, <span class="hljs-params">cmd</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>读取函数</strong></p><p>nor_read_word函数是从NOR Flash 读取两个字节（本开发板位宽16bit），读取数据的地址，是基于2440，所以读取NOR Flash某个地址上的数据时，需要把NOR Flash对应的地址左移一位(地址乘以2)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">nor_read_word</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> base, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> offset)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *p = (<span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *)(base + (offset &lt;&lt; <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">return</span> *p;<br>&#125;<br></code></pre></td></tr></table></figure><p>不想老重复入固定的base，进行封装一下</p><p>向nor_dat函数中写入NOR Flash某个地址，返回该NOR Flash地址上的数据。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">unsigned <span class="hljs-built_in">int</span> nor<span class="hljs-constructor">_dat(<span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">offset</span>)</span><br>&#123;<br>    return nor<span class="hljs-constructor">_read_word(NOR_FLASH_BASE, <span class="hljs-params">offset</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>进入NOR FLASH的CFI模式，读取各类信息</strong></p><p>do_scan_nor_flash函数代码如下，该函数的功能：进入CFI模式读取NOR Flash中的厂家ID，设备ID,容量等信息。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-number">50</span><span class="hljs-comment">/* 进入NOR FLASH的CFI模式</span><br><span class="hljs-comment">51 * 读取各类信息</span><br><span class="hljs-comment">52 */</span><br><span class="hljs-number">53</span>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_scan_nor_flash</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function">54   </span>&#123;<br><span class="hljs-number">55</span>           <span class="hljs-type">char</span> str[<span class="hljs-number">4</span>];<br><span class="hljs-number">56</span>           <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size;<br><span class="hljs-number">57</span>           <span class="hljs-type">int</span> regions, i;<br><span class="hljs-number">58</span>           <span class="hljs-type">int</span> region_info_base;<br><span class="hljs-number">59</span>           <span class="hljs-type">int</span> block_addr, blocks, block_size, j;<br><span class="hljs-number">60</span>           <span class="hljs-type">int</span> cnt;<br><span class="hljs-number">61</span><br><span class="hljs-number">62</span>           <span class="hljs-type">int</span> vendor, device;<br><span class="hljs-number">63</span>   <br><span class="hljs-number">64</span>           <span class="hljs-comment">/* 打印厂家ID、设备ID */</span><br><span class="hljs-number">65</span>           <span class="hljs-built_in">nor_cmd</span>(<span class="hljs-number">0x555</span>, <span class="hljs-number">0xaa</span>);     <span class="hljs-comment">/* 解锁 */</span><br><span class="hljs-number">66</span>           <span class="hljs-built_in">nor_cmd</span>(<span class="hljs-number">0x2aa</span>, <span class="hljs-number">0x55</span>);<br><span class="hljs-number">67</span>           <span class="hljs-built_in">nor_cmd</span>(<span class="hljs-number">0x555</span>, <span class="hljs-number">0x90</span>);     <span class="hljs-comment">/* read id */</span><br><span class="hljs-number">68</span>           vendor = <span class="hljs-built_in">nor_dat</span>(<span class="hljs-number">0</span>);<br><span class="hljs-number">69</span>           device = <span class="hljs-built_in">nor_dat</span>(<span class="hljs-number">1</span>);<br><span class="hljs-number">70</span>           <span class="hljs-built_in">nor_cmd</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0xf0</span>);         <span class="hljs-comment">/* reset */</span><br><span class="hljs-number">71</span>   <br><span class="hljs-number">72</span>           <span class="hljs-built_in">nor_cmd</span>(<span class="hljs-number">0x55</span>, <span class="hljs-number">0x98</span>);      <span class="hljs-comment">/* 进入cfi模式 */</span>    <br><span class="hljs-number">73</span><br><span class="hljs-number">74</span>           str[<span class="hljs-number">0</span>] = <span class="hljs-built_in">nor_dat</span>(<span class="hljs-number">0x10</span>);<br><span class="hljs-number">75</span>           str[<span class="hljs-number">1</span>] = <span class="hljs-built_in">nor_dat</span>(<span class="hljs-number">0x11</span>);<br><span class="hljs-number">76</span>           str[<span class="hljs-number">2</span>] = <span class="hljs-built_in">nor_dat</span>(<span class="hljs-number">0x12</span>);<br><span class="hljs-number">77</span>           str[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><span class="hljs-number">78</span>           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;str = %s&quot;</span>, str);<br><span class="hljs-number">79</span><br><span class="hljs-number">80</span>           <span class="hljs-comment">/* 打印容量 */</span><br><span class="hljs-number">81</span>           size = <span class="hljs-number">1</span>&lt;&lt;(<span class="hljs-built_in">nor_dat</span>(<span class="hljs-number">0x27</span>));<br><span class="hljs-number">82</span>           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;v=0x%x,d=0x%x,s=0x%x,%dM&quot;</span>,vendor,device,size,size/(<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>));<br><span class="hljs-number">83</span><br><span class="hljs-number">84</span>           <span class="hljs-comment">/* 打印各个扇区的起始地址 */</span><br><span class="hljs-number">85</span>           <span class="hljs-comment">/* 名词解释:</span><br><span class="hljs-comment">86                * Erase block region : 里面含有1个或多个block, 它们的大小一样87                * 一个nor flash含有1个或多个region</span><br><span class="hljs-comment">88                * 一个region含有1个或多个block(扇区)</span><br><span class="hljs-comment">89</span><br><span class="hljs-comment">90                * Erase block region information:</span><br><span class="hljs-comment">91                *    前2字节+1    : 表示该region有多少个block </span><br><span class="hljs-comment">92                *   后2字节*256   : 表示block的大小93               */</span><br><span class="hljs-number">94</span><br><span class="hljs-number">95</span>           regions = <span class="hljs-built_in">nor_dat</span>(<span class="hljs-number">0x2c</span>);        <span class="hljs-comment">//确认有多少regions</span><br><span class="hljs-number">96</span>           region_info_base = <span class="hljs-number">0x2d</span>;<br><span class="hljs-number">97</span>           block_addr = <span class="hljs-number">0</span>;<br><span class="hljs-number">98</span>           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Block/Sector start Address:&quot;</span>);<br><span class="hljs-number">99</span>           cnt = <span class="hljs-number">0</span>;<br><span class="hljs-number">100</span>          <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; regions; i++)<br><span class="hljs-number">101</span>          &#123;<br><span class="hljs-number">102</span>             blocks = <span class="hljs-number">1</span> + <span class="hljs-built_in">nor_dat</span>(region_info_base)+(<span class="hljs-built_in">nor_dat</span>(region_info_base+<span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-number">8</span>);<br><span class="hljs-number">103</span>             block_size = <span class="hljs-number">256</span>*(<span class="hljs-built_in">nor_dat</span>(region_info_base+<span class="hljs-number">2</span>)+(<span class="hljs-built_in">nor_dat</span>(region_info_base+<span class="hljs-number">3</span>)&lt;&lt;<span class="hljs-number">8</span>));<br><span class="hljs-number">104</span>             region_info_base += <span class="hljs-number">4</span>;<br><span class="hljs-number">105</span><br><span class="hljs-number">106</span>             <span class="hljs-comment">//printf(&quot;…………&quot;);</span><br><span class="hljs-number">107</span><br><span class="hljs-number">108</span>                  <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; blocks; j++)<br><span class="hljs-number">109</span>                  &#123;<br><span class="hljs-number">110</span>                          <span class="hljs-comment">/* 打印每个block的起始地址 */</span><br><span class="hljs-number">111</span>                           <br><span class="hljs-number">112</span>                          <span class="hljs-built_in">printHex</span>(block_addr);<br><span class="hljs-number">113</span>                          <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br><span class="hljs-number">114</span>                          cnt++;    <br><span class="hljs-number">115</span>                          block_addr += block_size;    <br>                                        <span class="hljs-comment">//打印完一个后,block_addr指向下一个block</span><br><span class="hljs-number">116</span>                          <span class="hljs-keyword">if</span> (cnt % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>)    <span class="hljs-comment">//打印五个后就换行</span><br><span class="hljs-number">117</span>                          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n\r&quot;</span>);<br><span class="hljs-number">118</span>          &#125;<br><span class="hljs-number">119</span>          &#125;<br><span class="hljs-number">120</span>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n\r&quot;</span>);<br><br><span class="hljs-number">121</span>      <span class="hljs-comment">/* 退出CFI模式 */</span><br><span class="hljs-number">122</span>      <span class="hljs-built_in">nor_cmd</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0xf0</span>);<br><span class="hljs-number">123</span>  &#125;<br></code></pre></td></tr></table></figure><p>第65，66行 这两步是解锁，解锁之后就进入读ID状态，就可以读取厂家和设备ID了。</p><p>第68行 是把读取到的厂家ID的值，复制给vendor变量。</p><p>第69行 是把读取到的设备ID的值，复制给device变量。</p><p>第70行 退出读ID状态: 给任意地址写F0H。</p><p>第72行,往地址0x55地址写入数据0x98,是进入cfi模式。</p><p>第74，75，76行是读取NOR Flash地址0x10,0x11,x012中的字符，赋值给字符串str。</p><p>第81行，根据芯片手册可知道，读取NOR Flash地址0x27处的数据，得到的是NOR Flash容量大小2的幂数，所以把1左移读取到的数据，就可得到NOR Flash的容量。</p><p>第95行读取NOR Flash地址0x2c地址中的数据，可以得到NOR Flash中有多少region。</p><p>第102行根据Erase block region information:的信息可以知道读取[2E,2D]这两个字节的地址+1，可以得到一个region有多少block(参考芯片手册)。代码中的region_info_base变量的值是0x2d,0x2d是前两个字节中的低字节，0x2e是前两个字节中的高字节，所以需要左移8位，然后加上1就得到了一个region有多少block.。</p><p>第103行参考芯片手册，读取[30,2F]这两个字节地址，然后乘上256就可以得到一个块的大小。</p><p>第104行，地址加4，读取下一个region有多少block和每个block的大小。</p><p>第112,115行，由于NOR Flash的基地址是0，所以第一个block的首地址是0，下一个block的首地址，就是上一个block的首地址加上block的大小。</p><p>第112行往0地址写入0xf0,退出CFI模式。</p><p><strong>Nor Flash的测试</strong></p><p>nor_flash_test函数通过switch语句，分别处理识别NOR Flash，擦除NOR Flash某个扇区，编写某个地址，读某个地址。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">232</span>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nor_flash_test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function">233  </span>&#123;<br><span class="hljs-number">234</span>          <span class="hljs-type">char</span> c;<br><span class="hljs-number">235</span><br><span class="hljs-number">236</span>          <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br><span class="hljs-number">237</span>          &#123;<br><span class="hljs-number">238</span>                  <span class="hljs-comment">/* 打印菜单, 供我们选择测试内容 */</span><br><span class="hljs-number">239</span>                  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[s] Scan nor flash\n\r&quot;</span>);<br><span class="hljs-number">240</span>                  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[e] Erase nor flash\n\r&quot;</span>);<br><span class="hljs-number">241</span>                  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[w] Write nor flash\n\r&quot;</span>);<br><span class="hljs-number">242</span>                  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[r] Read nor flash\n\r&quot;</span>);<br><span class="hljs-number">243</span>                  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[q] quit\n\r&quot;</span>);<br><span class="hljs-number">244</span>                  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter selection: &quot;</span>);<br><span class="hljs-number">245</span><br><span class="hljs-number">246</span>                  c = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-number">247</span>                  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, c);<br><span class="hljs-number">248</span><br><span class="hljs-number">249</span>                  <span class="hljs-comment">/* 测试内容:</span><br><span class="hljs-comment">250                       * 1. 识别nor flash</span><br><span class="hljs-comment">251                       * 2. 擦除nor flash某个扇区</span><br><span class="hljs-comment">252                       * 3. 编写某个地址</span><br><span class="hljs-comment">253                       * 4. 读某个地址</span><br><span class="hljs-comment">254                       */</span><br><span class="hljs-number">255</span>                  <span class="hljs-keyword">switch</span> (c)                 <br><span class="hljs-number">256</span>                  &#123;<br><span class="hljs-number">257</span>                          <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;q&#x27;</span>:<br><span class="hljs-number">258</span>                          <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Q&#x27;</span>:<br><span class="hljs-number">259</span>                                  <span class="hljs-keyword">return</span>;<br><span class="hljs-number">260</span>                                  <span class="hljs-keyword">break</span>;<br><span class="hljs-number">261</span>                          <br><span class="hljs-number">262</span>                          <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<br><span class="hljs-number">263</span>                          <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;S&#x27;</span>:<br><span class="hljs-number">264</span>                                  <span class="hljs-built_in">do_scan_nor_flash</span>();<br><span class="hljs-number">265</span>                                  <span class="hljs-keyword">break</span>;<br><span class="hljs-number">266</span><br><span class="hljs-number">267</span>                          <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;e&#x27;</span>:<br><span class="hljs-number">268</span>                          <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;E&#x27;</span>:<br><span class="hljs-number">269</span>                                  <span class="hljs-built_in">do_erase_nor_flash</span>();<br><span class="hljs-number">270</span>                                  <span class="hljs-keyword">break</span>;<br><span class="hljs-number">271</span><br><span class="hljs-number">272</span>                          <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;w&#x27;</span>:<br><span class="hljs-number">273</span>                          <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;W&#x27;</span>:<br><span class="hljs-number">274</span>                                  <span class="hljs-built_in">do_write_nor_flash</span>();<br><span class="hljs-number">275</span>                                  <span class="hljs-keyword">break</span>;<br><span class="hljs-number">276</span><br><span class="hljs-number">277</span>                          <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;r&#x27;</span>:<br><span class="hljs-number">278</span>                          <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;R&#x27;</span>:<br><span class="hljs-number">279</span>                                  <span class="hljs-built_in">do_read_nor_flash</span>();<br><span class="hljs-number">280</span>                                  <span class="hljs-keyword">break</span>;<br><span class="hljs-number">281</span>                          <span class="hljs-keyword">default</span>:<br><span class="hljs-number">282</span>                                  <span class="hljs-keyword">break</span>;<br><span class="hljs-number">283</span>                  &#125;<br><span class="hljs-number">284</span>          &#125;<br><span class="hljs-number">285</span>  &#125;<br></code></pre></td></tr></table></figure><p><strong>主函数</strong></p><p>main函数代码如下所示。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-number">12</span> int <span class="hljs-selector-tag">main</span>(void)<br><span class="hljs-number">13</span>   &#123;<br><span class="hljs-number">14</span>           <span class="hljs-built_in">led_init</span>();<br><span class="hljs-number">15</span>           <span class="hljs-comment">//interrupt_init();  /* 初始化中断控制器 */</span><br><span class="hljs-number">16</span>           <span class="hljs-built_in">key_eint_init</span>();   <span class="hljs-comment">/* 初始化按键, 设为中断源 */</span><br><span class="hljs-number">17</span>           <span class="hljs-comment">//timer_init();</span><br><span class="hljs-number">18</span>   <br><span class="hljs-number">19</span>           <span class="hljs-built_in">puts</span>(&quot;\n\rg_A = &quot;);<br><span class="hljs-number">20</span>           <span class="hljs-built_in">printHex</span>(g_A);<br><span class="hljs-number">21</span>           <span class="hljs-built_in">puts</span>(&quot;\n\r&quot;);<br><span class="hljs-number">22</span><br><span class="hljs-number">23</span>           <span class="hljs-built_in">nor_flash_test</span>();<br><span class="hljs-number">24</span>   <br><span class="hljs-number">25</span>           return <span class="hljs-number">0</span>;<br><span class="hljs-number">26</span>   &#125;<br></code></pre></td></tr></table></figure><p>出现两个错误</p><p>一：多次操作后会崩溃，把timer中断去掉，否则: 测试NOR Flash时进入CFI等模式时, 如果发生了中断，cpu必定读NOR Flash，那么读不到正确的指令，导致程序崩溃。</p><p>二：打印厂家ID,设备ID出错</p><p>查询汇编文件，发现在nor_write_word中，我们本意一次性把val的最低两字节写入p,</p><p>而实际上它是一个一个字节操作的</p><p>必应搜索后得到建议“设置你的 -march ”</p><p>查询uboot得到应在编译链接时加上 -march&#x3D;armv4 ,表示使用armv4的指令集</p><p>即：编译程序时加上:-march&#x3D;armv4，否则</p><p>volatile unsigned short *p &#x3D; xxx</p><p>*p &#x3D; val; 会被拆分为2个strb操作</p><p><strong>第003节_Nor Flash编程_擦写读</strong></p><hr><p>本实例的目的：擦除nor flash某个扇区，编写某个地址，读某个地址。</p><p><strong>等待烧写</strong></p><p>等待烧写完成 : 读数据, Q6无变化时表示结束 (参考芯片手册)，</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">35 </span>void wait_ready(unsigned <span class="hljs-keyword">int</span> addr)<br><span class="hljs-number">36</span>   &#123;<br><span class="hljs-number">37</span>           unsigned <span class="hljs-keyword">int</span> <span class="hljs-keyword">val</span>;<br><span class="hljs-number">38</span>           unsigned <span class="hljs-keyword">int</span> pre;<br><span class="hljs-number">39</span><br><span class="hljs-number">40</span>           pre = nor_dat(addr&gt;&gt;<span class="hljs-number">1</span>);<br><span class="hljs-number">41</span>           <span class="hljs-keyword">val</span> = nor_dat(addr&gt;&gt;<span class="hljs-number">1</span>);<br><span class="hljs-number">42</span>           <span class="hljs-keyword">while</span> ((<span class="hljs-keyword">val</span> &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">6</span>)) != (pre &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">6</span>)))<br><span class="hljs-number">43</span>           &#123;<br><span class="hljs-number">44</span>                   pre = <span class="hljs-keyword">val</span>;<br><span class="hljs-number">45</span>                   <span class="hljs-keyword">val</span> = nor_dat(addr&gt;&gt;<span class="hljs-number">1</span>);         <br><span class="hljs-number">46</span>           &#125;<br><span class="hljs-number">47</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>擦除NOR Flash 某个扇区</strong></p><p>do_erase_nor_flash函数的代码如下。参考芯片手册，就可以知道擦除某个扇区，还是相对比较简单的。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-number">125</span>        void <span class="hljs-keyword">do</span><span class="hljs-constructor">_erase_nor_flash(<span class="hljs-params">void</span>)</span><br><span class="hljs-number">126</span>  &#123;<br><span class="hljs-number">127</span>          unsigned <span class="hljs-built_in">int</span> addr;<br><span class="hljs-number">128</span>  <br><span class="hljs-number">129</span>                  <span class="hljs-comment">/* 获得地址 */</span><br><span class="hljs-number">130</span>          printf(<span class="hljs-string">&quot;Enter the address of sector to erase: &quot;</span>);<br><span class="hljs-number">131</span>          addr = get<span class="hljs-constructor">_uint()</span>;<br><span class="hljs-number">132</span><br><span class="hljs-number">133</span>          printf(<span class="hljs-string">&quot;erasing ...&quot;</span>);<br><span class="hljs-number">134</span>          nor<span class="hljs-constructor">_cmd(0x555, 0xaa)</span>;      <span class="hljs-comment">/* 解锁 */</span><br><span class="hljs-number">135</span>          nor<span class="hljs-constructor">_cmd(0x2aa, 0x55)</span>;<br><span class="hljs-number">136</span>          nor<span class="hljs-constructor">_cmd(0x555, 0x80)</span>;      <span class="hljs-comment">/* erase sector */</span><br><span class="hljs-number">137</span>  <br><span class="hljs-number">138</span>          nor<span class="hljs-constructor">_cmd(0x555, 0xaa)</span>;      <span class="hljs-comment">/* 解锁 */</span><br><span class="hljs-number">139</span>          nor<span class="hljs-constructor">_cmd(0x2aa, 0x55)</span>;<br><span class="hljs-number">140</span>          nor<span class="hljs-constructor">_cmd(<span class="hljs-params">addr</span>&gt;&gt;1, 0x30)</span>;    <span class="hljs-comment">/* 发出扇区地址 */</span><br><span class="hljs-number">141</span>          wait<span class="hljs-constructor">_ready(<span class="hljs-params">addr</span>)</span>;<br><span class="hljs-number">142</span>  &#125;<br></code></pre></td></tr></table></figure><p>第131行，get_uint函数用于获取输入的地址。</p><p>第134,135这两行是解锁。</p><p>第136行是erase sector。</p><p>第138,139行是再次解锁。</p><p>第140行是对发出的扇区地址。</p><p>第 141行等待擦除完成。</p><p><strong>写NOR Flash</strong></p><p>do_write_nor_flash的代码如下所示，开发板上的NOR Flash的位宽是16bit,所以可以把要写的数据构造出16bit然后在写进NOR Flash中。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-number">144</span>        void do_write_nor_flash(void)<br><span class="hljs-number">145</span>  &#123;<br><span class="hljs-number">146</span>          unsigned int <span class="hljs-keyword">addr;</span><br><span class="hljs-keyword"></span><span class="hljs-number">147</span>          unsigned char str[<span class="hljs-number">100</span>];<br><span class="hljs-number">148</span>          int i, <span class="hljs-keyword">j;</span><br><span class="hljs-keyword"></span><span class="hljs-number">149</span>                  unsigned int val;<br><span class="hljs-number">150</span>  <br><span class="hljs-number">151</span>          <span class="hljs-comment">/* 获得地址 */</span><br><span class="hljs-number">152</span>          printf(<span class="hljs-string">&quot;Enter the address of sector to write: &quot;</span>);<br><span class="hljs-number">153</span>          <span class="hljs-keyword">addr </span>= get_uint();<br><span class="hljs-number">154</span><br><span class="hljs-number">155</span>          printf(<span class="hljs-string">&quot;Enter the string to write: &quot;</span>);<br><span class="hljs-number">156</span>          gets(str);<br><span class="hljs-number">157</span><br><span class="hljs-number">158</span>          printf(<span class="hljs-string">&quot;writing ...\n\r&quot;</span>);<br><span class="hljs-number">159</span><br><span class="hljs-number">160</span>          <span class="hljs-comment">/* str[0],str[1]==&gt;16bit </span><br><span class="hljs-comment">161           * str[2],str[3]==&gt;16bit </span><br><span class="hljs-comment">162           */</span><br><span class="hljs-number">163</span>          i = <span class="hljs-number">0</span>;<br><span class="hljs-number">164</span>          <span class="hljs-keyword">j </span>= <span class="hljs-number">1</span>;<br><span class="hljs-number">165</span>          while (str[i] &amp;&amp; str[<span class="hljs-keyword">j])</span><br><span class="hljs-keyword"></span><span class="hljs-number">166</span>          &#123;<br><span class="hljs-number">167</span>                  val = str[i] + (str[<span class="hljs-keyword">j]&lt;&lt;8);</span><br><span class="hljs-keyword"></span><span class="hljs-number">168</span>          <br><span class="hljs-number">169</span>                  <span class="hljs-comment">/* 烧写 */</span><br><span class="hljs-number">170</span>                  <span class="hljs-keyword">nor_cmd(0x555, </span><span class="hljs-number">0xaa</span>)<span class="hljs-comment">;  /* 解锁 */</span><br><span class="hljs-number">171</span>                  <span class="hljs-keyword">nor_cmd(0x2aa, </span><span class="hljs-number">0x55</span>);<br><span class="hljs-number">172</span>                  <span class="hljs-keyword">nor_cmd(0x555, </span><span class="hljs-number">0xa0</span>)<span class="hljs-comment">;  /* program */</span><br><span class="hljs-number">173</span>                  <span class="hljs-keyword">nor_cmd(addr&gt;&gt;1, </span>val);<br><span class="hljs-number">174</span>                  <span class="hljs-comment">/* 等待烧写完成 : 读数据, Q6无变化时表示结束 */</span><br><span class="hljs-number">175</span>                  <span class="hljs-keyword">wait_ready(addr);</span><br><span class="hljs-keyword"></span><span class="hljs-number">176</span><br><span class="hljs-number">177</span>                  i += <span class="hljs-number">2</span>;<br><span class="hljs-number">178</span>                  <span class="hljs-keyword">j </span>+= <span class="hljs-number">2</span>;<br><span class="hljs-number">179</span>                  <span class="hljs-keyword">addr </span>+= <span class="hljs-number">2</span>;<br><span class="hljs-number">180</span>          &#125;<br><span class="hljs-number">181</span><br><span class="hljs-number">182</span>          val = str[i];<br><span class="hljs-number">183</span>          <span class="hljs-comment">/* 烧写 */</span><br><span class="hljs-number">184</span>          <span class="hljs-keyword">nor_cmd(0x555, </span><span class="hljs-number">0xaa</span>)<span class="hljs-comment">;  /* 解锁 */</span><br><span class="hljs-number">185</span>          <span class="hljs-keyword">nor_cmd(0x2aa, </span><span class="hljs-number">0x55</span>);<br><span class="hljs-number">186</span>          <span class="hljs-keyword">nor_cmd(0x555, </span><span class="hljs-number">0xa0</span>)<span class="hljs-comment">;  /* program */</span><br><span class="hljs-number">187</span>          <span class="hljs-keyword">nor_cmd(addr&gt;&gt;1, </span>val);<br><span class="hljs-number">188</span>          <span class="hljs-comment">/* 等待烧写完成 : 读数据, Q6无变化时表示结束 */</span><br><span class="hljs-number">189</span>          <span class="hljs-keyword">wait_ready(addr);</span><br><span class="hljs-keyword"></span><span class="hljs-number">190</span>  &#125;<br></code></pre></td></tr></table></figure><p>第153行把通过get_uint获得的地址赋值给addr变量，</p><p>第156行通过gets函数获得输入的字符串。</p><p>第168行两个8位的数据，组合成一个16位的数据赋值给变量val。</p><p><strong>读NOR Flash</strong></p><p>do_read_nor_flash函数代码如下，由于NOR Flash是内存类接口，可以像内存一样读取。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">191</span>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_read_nor_flash</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function">192  </span>&#123;<br><span class="hljs-number">193</span>          <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> addr;<br><span class="hljs-number">194</span>          <span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *p;<br><span class="hljs-number">195</span>          <span class="hljs-type">int</span> i, j;<br><span class="hljs-number">196</span>          <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c;<br><span class="hljs-number">197</span>          <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str[<span class="hljs-number">16</span>];<br><span class="hljs-number">198</span>  <br><span class="hljs-number">199</span>          <span class="hljs-comment">/* 获得地址 */</span><br><span class="hljs-number">200</span>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the address to read: &quot;</span>);<br><span class="hljs-number">201</span>          addr = <span class="hljs-built_in">get_uint</span>();    <span class="hljs-comment">//得到一个unsignt的地址</span><br><span class="hljs-number">202</span><br><span class="hljs-number">203</span>          p = (<span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)addr;<br><span class="hljs-number">204</span><br><span class="hljs-number">205</span>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Data :  \n\r&quot;</span>);<br><span class="hljs-number">206</span>          <span class="hljs-comment">/* 长度固定为64 */</span><br><span class="hljs-number">207</span>          <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br><span class="hljs-number">208</span>          &#123;<br><span class="hljs-number">209</span>                  <span class="hljs-comment">/* 每行打印16个数据 */</span><br><span class="hljs-number">210</span>                  <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">16</span>; j++)<br><span class="hljs-number">211</span>                  &#123;<br><span class="hljs-number">212</span>                          <span class="hljs-comment">/* 先打印数值 */</span><br><span class="hljs-number">213</span>                          c = *p++;<br><span class="hljs-number">214</span>                          str[j] = c;<br><span class="hljs-number">215</span>                          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02x &quot;</span>, c);<br><span class="hljs-number">216</span>                  &#125;<br><span class="hljs-number">217</span><br><span class="hljs-number">218</span>                  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   ; &quot;</span>);<br><span class="hljs-number">219</span><br><span class="hljs-number">220</span>                  <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">16</span>; j++)<br><span class="hljs-number">221</span>                  &#123;<br><span class="hljs-number">222</span>                          <span class="hljs-comment">/* 后打印字符 */</span><br><span class="hljs-number">223</span>                          <span class="hljs-keyword">if</span> (str[j] &lt; <span class="hljs-number">0x20</span> || str[j] &gt; <span class="hljs-number">0x7e</span>) <span class="hljs-comment">/* 不可视字符 */</span><br><span class="hljs-number">224</span>                                  <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;.&#x27;</span>);<br><span class="hljs-number">225</span>                          <span class="hljs-keyword">else</span><br><span class="hljs-number">226</span>                                  <span class="hljs-built_in">putchar</span>(str[j]);<br><span class="hljs-number">227</span>                  &#125;<br><span class="hljs-number">228</span>                  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n\r&quot;</span>);<br><span class="hljs-number">229</span>  &#125;<br></code></pre></td></tr></table></figure><p>第201行中的get_uint函数，从串口中获得输入的地址。</p><p>第203行，强制类型转化。</p><p>第207行~216行是对NOR Flash内容的读取，输出的内容为16进制的数据，由于NOR Flash是内存类接口，可以像内存一样读取。</p><p>第220行~227输出NOR Flash的内容为字符型数据，其中的第223行用来判断，输出的字符是否为不可视字符，要是为不可视字符输出点’.’,要是可视字符输出字符。</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第013课 代码重定位</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AC%AC013%E8%AF%BE_%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AC%AC013%E8%AF%BE_%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<p><strong>概念引入</strong></p><p><img src="/image/663815b0a100a777e18cb5fd64a712a4.png" alt="663815b0a100a777e18cb5fd64a712a4.png"></p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>001</p><p>002：修改Makefile中的链接命令来使g_char位于0x30000000，使烧写于Nor的bin中的全局变量也可被修改</p><p>003：002的修改导致bin文件过大，使用链接脚本将位于0x30000000的data段与位于</p><p>0的代码段拼接到一起(这些复杂的功能使用链接命令时已经无法实现，所以要使用链接脚本)</p><p>004：003中的链接脚本不通用，我们写一个通用的链接脚本</p><p>005：在004的基础上打印一个初值为0的全局变量g_A</p><p>006：005输出的变量g_A数值错误，应该清除值为0的全局变量所在的bss段</p><p>007：改进start.S和修改链接脚本，让bss向四对齐</p><p>008：将整个程序重定位到SDRAM中，引入绝对地址位置无关码</p><p>009：将几个函数使用C语言实现</p><p>010：将参数也用C语言获得</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p><strong>Nand与重定位</strong></p><p>把程序烧到SDRAM、Nor上可直接运行，但CPU无法直接从Nand中取代码执行，那为什么还能使用Nand启动？</p><p>        1.一上电，片内内存SRAM会把Nand上的前4K复制过去</p><p>        2.CPU从0运行(0对应的是SRAM的地址)</p><p>                如果程序大于4K，前4K的代码需要把整个程序读出来放到SDRAM，重新确认程序的地址，即重定位</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p><strong>Nor与重定位</strong></p><p>Nor可以像内存一样的读，但不能像内存一样的写</p><p>            比如执行</p><p>mov r0,#0     </p><p>LDR R1,[R0]            &#x2F;* 有效：读 *&#x2F;</p><p>STR R1,[R0]            &#x2F;* 无效：写 *&#x2F;</p><p>因为NorFlash相当于硬盘，其中包含着重要的数据，想写数据需要执行一些特殊的操作</p><p>在Nor上设置一个想改动的全局&#x2F;静态变量，发现无法更改     </p><p>                                          &#x2F;* 局部变量包含在栈中，栈指向SRAM，可读可写 *&#x2F;</p><p>                                           &#x2F;* 全局&#x2F;静态变量包含在bin中，烧在NorFlash上 ，无法直接修改 *&#x2F;</p><p>这时就需要重定位放到SDRAM中</p><p><img src="/image/dc9d7a288f3299c7880f1a492ded178e.png" alt="dc9d7a288f3299c7880f1a492ded178e.png"></p><p>引入段和重定位的概念</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p><strong>002</strong></p><p>Nor启动</p><p>设置全局变量：char g_char</p><p>全局变量不可写，尝试将变量放在可读可写的SDRAM中，即让数据段从0x30000000(SDRAM初始地址)开始</p><p>&#x2F;* 指定数据段地址为0x30000000 *&#x2F;</p><p>arm-linux-ld -Ttext 0 -Tdata 0x30000000 start.o led.o init.o mian.o</p><p>烧写后发现bin文件大小为30000001(30000000+1)</p><p><img src="/image/55bcd74fb3dd5b76d3677c71801e8f29.png" alt="55bcd74fb3dd5b76d3677c71801e8f29.png"></p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p><strong>003</strong></p><p>解决这个巨大的间隔</p><p><img src="/image/80454717bcb90ac8e1b96f2d89d47c40.png" alt="80454717bcb90ac8e1b96f2d89d47c40.png"></p><p>使用链接脚本把本来该位于0x30000000的数据段和代码段拼在一起(这些复杂的功能使用链接命令时已经无法实现，所以要使用链接脚本)</p><p>&#x2F;* Makefile *&#x2F;</p><p>arm-linux-ld -T sdram.lds start.o led.o init.o mian.o</p><p>&#x2F;* 链接脚本sdram.lds *&#x2F; </p><p>&#x2F;* 将0x30000000地址与0x800地址链(连)接 *&#x2F;</p><p>SECTIONS {</p><p>   .text   0  : { *(.text) }</p><p>   .rodata  : { *(.rodata) }</p><p>   .data 0x30000000 : AT(0x800) { *(.data) }        &#x2F;&#x2F;0x800即data段的原开始处</p><p>   .bss  : { *(.bss) *(.COMMON) }                   &#x2F;&#x2F;括号里的</p><p>}</p><p>&#x2F;* start.S *&#x2F;</p><p>&#x2F;* 使用链接脚本后，main是去0x30000000取值，所以我们应该 </p><p> * 重定位data段,把0x800里的值(g_char)写入(复制)0x30000000 </p><p> *&#x2F;</p><p>    mov r1, #0x800</p><p>    ldr r0, [r1]</p><p>    mov r1, #0x30000000</p><p>    str r0, [r1]</p><p>这个方法并不通用，需要写更加通用的代码</p><p>重定位后原0x800是否还有数据？要没有数据那怎么复制到0x30000000？[x] </p><p>答：有</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p><strong>004</strong></p><p>&#x2F;* sdram.lds *&#x2F;</p><p>&#x2F;* 将0x30000000地址与0x800地址链接 *&#x2F;</p><p>SECTIONS {</p><p>   .text   0  : { *(.text) }</p><p>   .rodata  : { *(.rodata) }</p><p>   .data 0x30000000 : AT(0x800) </p><p>    {</p><p>        data_load_addr &#x3D; LOADADDR (.data);    &#x2F;* 返回()内段的绝对加载地址，在此处为0x800 *&#x2F;</p><p>        data_start &#x3D; . ;        &#x2F;* data_start &#x3D; 0x30000000 *&#x2F;</p><p>        *(.data)</p><p>        data_end &#x3D; . ;          &#x2F;* data_end - data_start &#x3D; data段长度 *&#x2F; </p><p>    }  </p><p>   .bss  : { *(.bss) *(.COMMON) }</p><p>}</p><p>&#x2F;* start.S *&#x2F;</p><p>&#x2F;* 重定位data段,把0x800里的值写入(复制)0x30000000 *&#x2F;</p><p>    ldr r1, &#x3D;data_load_addr    &#x2F;* data段在bin文件中的地址,加载地址 *&#x2F;</p><p>    ldr r2, &#x3D;data_start        &#x2F;* data段在重定位地址,运行地址 *&#x2F;</p><p>    ldr r3, &#x3D;data_end          &#x2F;* data段结束地址 *&#x2F;</p><p>cpy:</p><p>    ldrb r4, [r1]</p><p>    strb r4, [r2]</p><p>    add r1, r1, #1</p><p>    add r2, r2, #1</p><p>    cmp r2, r3</p><p>        bne cpy                                        &#x2F;* r2与r3不等,继续拷贝 *&#x2F;</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>003节</p><p><strong>链接脚本的解析：</strong></p><p><img src="/image/5427f5b31be59b1f6d0a6eb2e09b08fd.png" alt="5427f5b31be59b1f6d0a6eb2e09b08fd.png"></p><p>这些地址的意思：</p><p>&#x2F;* Makefile *&#x2F;</p><p>arm-linux-ld -T sdram.lds start.o led.o init.o mian.o</p><p>在Makefile中使用链接脚本链接了.o文件，生成一个elf文件，这个elf文件中就有地址信息</p><p>1.链接得elf文件，含有地址信息(加载地址Load Addr)</p><p>        某个段使用AT命令的时候就直接指定了加载地址，若不使用则加载地址等于运行地址start</p><p>2.地址如何使用：使用加载器(对于裸板，是JTAG调试工具；对于APP，加载器也是APP)</p><p>   把elf读入到内存(读到加载地址Load Addr)</p><p>3.运行</p><p>4.若Load Addr !&#x3D; Runtime Addr，程序本身要重定位</p><p>核心：程序运行时，应位于runtime Addr&#x2F;reload Addr&#x2F;链接地址</p><p>bin文件：</p><p>1.elf文件生成bin文件</p><p>2.硬件机制启动</p><p>3.若bin所在位置 !&#x3D; Runtime Addr，程序本身要重定位</p><p><img src="/image/c2dfad83930208aad8a4d1e11be029f1.png" alt="c2dfad83930208aad8a4d1e11be029f1.png"></p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p><strong>005</strong></p><p>&#x2F;* uart.c *&#x2F;</p><p>&#x2F;* 取出每一位的值,再转成字符打印出来 *&#x2F;</p><p>void printHex(unsigned int val)</p><p>{</p><p>    int i;</p><p>    unsigned char arr[8];</p><p>    &#x2F;* 先取出每一位的值 *&#x2F;</p><p>    for (i &#x3D; 0; i &lt; 8; i++)</p><p>    {</p><p>        arr[i] &#x3D; val &amp; 0xf;</p><p>        val &gt;&gt;&#x3D; 4;   &#x2F;* arr[0] &#x3D; 2, arr[1] &#x3D; 1, arr[2] &#x3D; 0xF *&#x2F;</p><p>    }</p><p>    &#x2F;* 打印 *&#x2F;</p><p>    puts(“0x”);</p><p>    for (i &#x3D; 7; i &gt;&#x3D;0; i--)</p><p>    {</p><p>        if (arr[i] &gt;&#x3D; 0 &amp;&amp; arr[i] &lt;&#x3D; 9)</p><p>            putchar(arr[i] + ‘0’);</p><p>        else if(arr[i] &gt;&#x3D; 0xA &amp;&amp; arr[i] &lt;&#x3D; 0xF)</p><p>            putchar(arr[i] - 0xA + ‘A’);</p><p>    }</p><p>}</p><p>&#x2F;* main.c *&#x2F;</p><p>#include “s3c2440_soc.h”</p><p>#include “uart.h”</p><p>#include “init.h”</p><p>char g_Char &#x3D; ‘A’;</p><p>char g_Char3 &#x3D; ‘a’;</p><p>const char g_Char2 &#x3D; ‘B’;</p><p>int g_A &#x3D; 0;        &#x2F;&#x2F;简单打印这个初始值为0的数，并不清除bss段</p><p>int g_B;</p><p>&#x2F;* 简单打印初始值为0的g_char,并不清除bss段 *&#x2F;</p><p>int main(void)</p><p>{</p><p>    uart0_init();</p><p>    puts(“\n\rg_A &#x3D; “);</p><p>    printHex(g_A);</p><p>    puts(“\n\r”);</p><p>    while (1)</p><p>    {</p><p>        putchar(g_Char);</p><p>        g_Char++;</p><p>        putchar(g_Char3);</p><p>        g_Char3++;</p><p>        delay(1000000);</p><p>    }</p><p>    return 0;</p><p>}</p><p>发现打印的g_char值是不确定的，因为初值为0和无初始值的全局变量放在BSS段上，BSS段上的变量都是无初始值的，都需要在BSS段清0时获取初始值</p><p>之所以有bss段，是因为存储这么多0到目标文件是没有必要的，为了节省空间，在生成目标文件的时候，就把没有初始值（实际就是0）的数据段里的变量都放到BSS段里，这样目标文件就不需要这么大的体积。当目标文件被载入时，加载器负责把BSS段清零</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p><strong>006</strong></p><p>&#x2F;* sdram.lds *&#x2F;</p><p>&#x2F;* 将0x30000000地址与0x800地址链接 *&#x2F;</p><p>SECTIONS {</p><p>   .text   0  : { *(.text) }</p><p>   .rodata  : { *(.rodata) }</p><p>   .data 0x30000000 : AT(0x800)</p><p>    {</p><p>        data_load_addr &#x3D; LOADADDR (.data);    &#x2F;*返回()内段的绝对加载地址 *&#x2F;</p><p>        data_start &#x3D; . ;        &#x2F;* data_star &#x3D; 0x30000000 *&#x2F;</p><p>        *(.data)</p><p>        data_end &#x3D; . ;          &#x2F;* data_end - data_start &#x3D; data段长度 *&#x2F;</p><p>    }  </p><p>   bss_start &#x3D; .;            &#x2F;&#x2F;在里在外没关系，“.”当前地址</p><p>   .bss  : { *(.bss) *(.COMMON) }</p><p>   bss_end &#x3D; .;</p><p>}</p><p>&#x2F;* start.S *&#x2F;</p><p>    &#x2F;* 重定位data段,把0x800里的值写入(复制)0x30000000 *&#x2F;</p><p>    ldr r1, &#x3D;data_load_addr    &#x2F;* data段在bin文件中的地址,加载地址 *&#x2F;</p><p>    ldr r2, &#x3D;data_start        &#x2F;* data段在重定位地址,运行地址 *&#x2F;</p><p>    ldr r3, &#x3D;data_end          &#x2F;* data段结束地址 *&#x2F;</p><p>cpy:</p><p>    ldrb r4, [r1]</p><p>    strb r4, [r2]</p><p>    add r1, r1, #1</p><p>    add r2, r2, #1</p><p>    cmp r2, r3</p><p>        bne cpy                                        &#x2F;* r2与r3不等,继续拷贝 *&#x2F;</p><p>    &#x2F;* 清除BSS段 *&#x2F;</p><p>    ldr r1, &#x3D;bss_start</p><p>    ldr r2, &#x3D;bss_end</p><p>    mov r3, #0</p><p>clean:</p><p>    strb r3, [r1]</p><p>    add r1, r1, #1</p><p>    cmp r1, r2</p><p>    ble clean</p><p>从这里可以看出即使程序里有一百万个全局变量，这些全局变量的初始值为0，我也不需要在bin，elf文件中保存这些0，只要在运行程序的时候把这段空间清0就可以</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>004节</p><p><strong>链接脚本的改进</strong></p><p>ldrb执行过程：CPU把ldrb这条命令发给内存控制器，内存控制器到SDRAM中读到四个字节的数据，然后跳出一个返回给CPU(SDRAM 32bit    Nor 16bit)</p><p>strb执行过程：CPU把地址和数据发给内存控制器，内存控制器把32位的数据发给SDRAM，同时发出数据屏蔽信号DQM，比如CPU只写一个字节，CPU就会发出三个屏蔽信号，屏蔽掉三个不需要写的字节(SDRAM 32bit    Nor 16bit)</p><p>ldrb    strb，以字节为单位访问Nor和SDRAM，访问Nor16次，访问SDRAM16次</p><p>ldr       str ,   以四个字节为单位访问Nor和SDRAM，访问Nor8次，访问SDRAM4次(因为Nor位宽为16位，读一次访问两次)</p><p><strong>007</strong></p><p>cpy:</p><p>    ldr r4, [r1]</p><p>    str r4, [r2]</p><p>    add r1, r1, #4</p><p>    add r2, r2, #4</p><p>    cmp r2, r3</p><p>    ble cpy</p><p>    &#x2F;* 清除BSS段 *&#x2F;</p><p>    ldr r1, &#x3D;bss_start</p><p>    ldr r2, &#x3D;bss_end</p><p>    mov r3, #0</p><p>clean:</p><p>    str r3, [r1]</p><p>    add r1, r1, #4</p><p>    cmp r1, r2</p><p>    ble clean</p><p>发现BSS段意外将数据段中的全局变量也清零了，进入反汇编看到</p><p><img src="/image/b0dfb11a54e2262fc80bc32d920d2092.png" alt="b0dfb11a54e2262fc80bc32d920d2092.png"></p><p>30000002不是4的整数倍，所以并不是4字节对齐的</p><p>str：无论存入地址为多少都是以4个字节为单位存入，也就是说无论存入地址是0x30000000或0x30000001或0x300000002或0x30000003，存入都是以0x30000000开始，在这个地方就将0x30000000也存入了0，而这个地址就是全局变量的地址。所以输出为0的原因是bss的开始地址是0x30000002，并不是向4取整的，而str是以4字节的方式存入r3的值，所以在清零bss段时将全局变量一起清0了。</p><p>ldr：读取以4个字节为单位循环读取。假设存入0xfe，当从0x30000001开始读取时，从低地址-&gt;高地址（00-00-00-fe）(0x30000001-0x30000002-0x30000003-0x30000000)，所以r2就成了0xfe000000；当从0x30000002读取时从低地址-&gt;高地址（00-00-fe-00）(0x30000002-0x30000003-0x30000000-0x30000001)，所以r2就成了0x00fe0000</p><p>那么只要修改链接脚本，让bss段向4取整就解决了这个问题</p><p>&#x2F;* sdram.lds *&#x2F;</p><p>&#x2F;* 将0x30000000地址与0x800地址链接 *&#x2F;</p><p>SECTIONS {</p><p>   .text   0  : { *(.text) }</p><p>   .rodata  : { *(.rodata) }</p><p>   .data 0x30000000 : AT(0x800)</p><p>    {</p><p>        data_load_addr &#x3D; LOADADDR (.data);    &#x2F;*返回()内段的绝对加载地址 *&#x2F;</p><p>   . &#x3D; ALIGN(4);                  &#x2F;* 以防意外 *&#x2F;</p><p>        data_start &#x3D; . ;        &#x2F;* data_star &#x3D; 0x30000000 *&#x2F;</p><p>        *(.data)</p><p>        data_end &#x3D; . ;          &#x2F;* data_end - data_start &#x3D; data段长度 *&#x2F;</p><p>    }  </p><p>    . &#x3D; ALIGN(4);                &#x2F;* 让当前地址等于向四对齐 *&#x2F;</p><p>    bss_start &#x3D; .;</p><p>    .bss  : { *(.bss) *(.COMMON) }</p><p>    bss_end &#x3D; .;</p><p>}</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>005节</p><p>重定位：把可执行程序从一个位置复制到另一个位置的过程</p><p>将整个程序重定位到SDRAM所需要的技术细节：（在Nor启动时，将所有程序复制到SDRAM中）</p><p>1.要从FLASH中把程序复制到它的运行地址-----&gt;在链接脚本中指定Runtime Addr为SDRAM地址</p><p>2.重定位之前的代码，与地址无关-----&gt;用位置无关码写程序(有部分程序将整个程序复制到SDRAM中，为什么它可以运行，因为位置无关)</p><p><strong>008</strong></p><p>&#x2F;* sdram.lds *&#x2F;</p><p>&#x2F;* 由uboot.lds所借鉴 *&#x2F;</p><p>SECTIONS</p><p>{</p><p>    . &#x3D; 0x30000000;                  &#x2F;* 表示整个程序应该摆在这个位置 *&#x2F;</p><p>    . &#x3D; ALIGN(4);                    &#x2F;* 对齐所有文件的data段 *&#x2F;</p><p>    .text      :</p><p>    {</p><p>      *(.text)</p><p>    }</p><p>    . &#x3D; ALIGN(4);                    &#x2F;* 对齐所有文件的rodata段 *&#x2F;</p><p>    .rodata : { *(.rodata) }</p><p>    . &#x3D; ALIGN(4);                    &#x2F;* 对齐所有文件的data段 *&#x2F;</p><p>    .data : { *(.data) }</p><p>    . &#x3D; ALIGN(4);                    &#x2F;* 对齐所有文件的bss段，COMMON段 *&#x2F;</p><p>    __bss_start &#x3D; .;</p><p>    .bss : { *(.bss) *(.COMMON) }    &#x2F;* COMMON：无初值的段 *&#x2F;</p><p>    _end &#x3D; .;</p><p>}</p><p>&#x2F;* start.S *&#x2F;</p><p>&#x2F;* 重定位text,rodata,data段整个程序,假设程序小于4K *&#x2F;</p><p>    mov r1, #0                &#x2F;* data段在bin文件中的地址,加载地址 *&#x2F;</p><p>    ldr r2, &#x3D;_start            &#x2F;* 第一条指令运行时得地址 *&#x2F;</p><p>    ldr r3, &#x3D;__bss_start          &#x2F;* data段的结束地址，即bss段的起始地址 *&#x2F;</p><p>cpy:</p><p>    ldrb r4, [r1]</p><p>    strb r4, [r2]</p><p>    add r1, r1, #1</p><p>    add r2, r2, #1</p><p>    cmp r2, r3</p><p>        bne cpy                                        &#x2F;* r2与r3不等,继续拷贝 *&#x2F;</p><p>    &#x2F;* 清除BSS段 *&#x2F;</p><p>    ldr r1, &#x3D;__bss_start</p><p>    ldr r2, &#x3D;_end</p><p>    mov r3, #0</p><p>clean:</p><p>    str r3, [r1]</p><p>    add r1, r1, #4</p><p>    cmp r1, r2</p><p>    ble clean</p><p>    &#x2F;&#x2F;bl main              &#x2F;* 使用BL命令相对跳转，程序仍在Nor&#x2F;Sdram执行 *&#x2F;</p><p>    ldr pc, &#x3D;main          &#x2F;* 绝对跳转，跳到SDRAM *&#x2F;</p><p>008程序启动分析：</p><p>bl sdram_init()</p><p><img src="/image/9dd2c3fcf53d1ee445971f76f00073e9.png" alt="9dd2c3fcf53d1ee445971f76f00073e9.png"></p><p>bl命令并不是跳到0x30000478这个地址，而是跳到当前pc+offset(offset：链接器计算的偏移地址)的位置，在反汇编中写出了这个值只是为了方便你分析代码，所以虽然程序指定了运行时地址，但即使放到0地址也可以运行，因为它跳转的时候是用的偏移地址，与运行时地址无关</p><p>重点：反汇编文件里，B&#x2F;BL   0x3xxxxxx，这个值只是方便查看，不是跳到这个地址</p><p>bl main</p><p>重定位完毕，程序继续执行下一条指令bl main，而此时0x5c4和0x300005c4都有main函数，但这个地方使用的是bl命令，所用的pc依旧是当前的pc值，所以它仍然继续在Nor中运行</p><p>为什么要写位置无关码的程序？</p><p>因为为了让我们的程序在SDRAM里运行，我们使用了重定位，但这就要求我们必须做到在重定位之前的代码必须是位置无关码，这样才能正常运行。（连接脚本指定我们程序的运行地址为0x30000000，为什么我们的在nor flash上的代码从0地址开始运行也能工作？这就说明我们这部分代码必须是建立在位置无关码的基础上的，</p><p>            对于位置有关码来说：最终执行时的运行地址和编译链接时给定的链接地址必须相同，               否则一定会出错。</p><p>0地址处运行和0x30000000处运行达到同样效果，需要我们保证，在重定位之前，也就是复制操作没有完成之前的代码，必须是位置无关的）。</p><p>怎么写位置无关码的程序?(程序在任何地址都能运行，不需要把它放到运行时地址)</p><p>使用位置无关码！不能使用绝对地址！通过看反汇编来判断是否使用绝对地址</p><p>a.使用相对跳转命令B&#x2F;BL</p><p>b.重定位之前不可使用绝对地址：不可访问全局变量&#x2F;静态变量(因为重定位之前只有一个地址)</p><p>                           不可访问有初始值的数组，不是位置无关码(因为这些初始值放在rodata里,使用绝对地址来访问)</p><p>c.重定位后可以使用绝对地址，使用ldr pc, &#x3D;xxx来跳转到Runtime Addr</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p><strong>006节</strong></p><p><strong>009使用C语言实现重定位</strong></p><p>&#x2F;* start.S *&#x2F;</p><p>    &#x2F;* 重定位text, rodata, data段整个程序 *&#x2F;</p><p>    mov r0, #0</p><p>    ldr r1, &#x3D;_start         &#x2F;* 源：第1条指令运行时的地址 *&#x2F;</p><p>    ldr r2, &#x3D;__bss_start    &#x2F;* 目的：bss段的起始地址 *&#x2F;</p><p>    sub r2, r2, r1          &#x2F;* 长度 *&#x2F;</p><p>    bl copy2sdram  &#x2F;* src, dest, len    源， 目的， 长度 *&#x2F;</p><p>    &#x2F;* 清除BSS段 *&#x2F;</p><p>    ldr r0, &#x3D;__bss_start</p><p>    ldr r1, &#x3D;_end</p><p>    bl clean_bss  &#x2F;* startADDR, endADDR *&#x2F;</p><p>    &#x2F;&#x2F;bl main  &#x2F;* 使用BL命令相对跳转, 程序仍然在NOR&#x2F;sram执行 *&#x2F;</p><p>    ldr pc, &#x3D;main  &#x2F;* 绝对跳转, 跳到SDRAM *&#x2F;</p><p>&#x2F;* Init.c *&#x2F;</p><p>void copy2sdram(volatile unsigned int *src, volatile unsigned int *dest, unsigned int len)  &#x2F;* src, dest, len *&#x2F;</p><p>{</p><p>    unsigned int i &#x3D; 0;</p><p>    while (i &lt; len)</p><p>    {</p><p>        *dest++ &#x3D; *src++;            &#x2F;* 从源地址取数据存到目的地址*&#x2F;</p><p>        i +&#x3D; 4;</p><p>    }</p><p>}</p><p>                                   &#x2F;* start, end *&#x2F;</p><p>void clean_bss(volatile unsigned int *start, volatile unsigned int *end)  </p><p>{</p><p>    while (start &lt;&#x3D; end)</p><p>    {</p><p>        *start++ &#x3D; 0;</p><p>    }</p><p>}</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>直接在C中获取参数</p><p>&#x2F;* start.S *&#x2F;</p><p>    bl sdram_init</p><p>    &#x2F;* 重定位text, rodata, data段整个程序</p><p>     * 不传参数</p><p>     *&#x2F;</p><p>    bl copy2sdram</p><p>    &#x2F;* 清除BSS段 </p><p>     * 不传参数</p><p>     *&#x2F;</p><p>    bl clean_bss</p><p>    &#x2F;&#x2F;bl main  &#x2F;* 使用BL命令相对跳转, 程序仍然在NOR&#x2F;sram执行 *&#x2F;</p><p>    ldr pc, &#x3D;main  &#x2F;* 绝对跳转, 跳到SDRAM *&#x2F;</p><p>&#x2F;* sdram.lds *&#x2F;</p><p>SECTIONS</p><p>{</p><p>    . &#x3D; 0x30000000;</p><p>    __code_start &#x3D; .;    &#x2F;&#x2F;动态获得当前地址</p><p>    . &#x3D; ALIGN(4);</p><p>    .text      :</p><p>    {</p><p>      *(.text)</p><p>    }</p><p>    . &#x3D; ALIGN(4);</p><p>    .rodata : { *(.rodata) }</p><p>    . &#x3D; ALIGN(4);</p><p>    .data : { *(.data) }</p><p>    . &#x3D; ALIGN(4);</p><p>    __bss_start &#x3D; .;</p><p>    .bss : { *(.bss) *(.COMMON) }</p><p>    _end &#x3D; .;</p><p>}</p><p>&#x2F;* Init.c *&#x2F;</p><p>void copy2sdram(void)</p><p>{</p><p>    &#x2F;* 要从lds文件中获得 __code_start, __bss_start</p><p>     * 然后从0地址把数据复制到__cod e_start</p><p>     *&#x2F;</p><p>    extern int __code_start, __bss_start;        &#x2F;* 声明为外部变量 *&#x2F;</p><p>    volatile unsigned int *dest &#x3D; (volatile unsigned int *)&amp;__code_start;</p><p>    volatile unsigned int *end &#x3D; (volatile unsigned int *)&amp;__bss_start;</p><p>    volatile unsigned int *src &#x3D; (volatile unsigned int *)0;</p><p>    while (dest &lt; end)</p><p>    {</p><p>        *dest++ &#x3D; *src++;</p><p>    }</p><p>}</p><p>void clean_bss(void)</p><p>{</p><p>    &#x2F;* 要从lds文件中获得 __bss_start, _end</p><p>     *&#x2F;</p><p>    extern int _end, __bss_start;</p><p>    volatile unsigned int *start &#x3D; (volatile unsigned int *)&amp;__bss_start;</p><p>    volatile unsigned int *end &#x3D; (volatile unsigned int *)&amp;_end;</p><p>    while (start &lt;&#x3D; end)</p><p>    {</p><p>        *start++ &#x3D; 0;</p><p>    }</p><p>}</p><p>C函数怎么使用lds文件中的变量abc（上方的__bss_start, _end等）?</p><p>a. 在C函数中声明改变量为extern类型, 类型并不重要，比如:</p><p>    extern int abc;</p><p>    </p><p>b. 使用时, 要取址, 比如:            但在汇编程序中可以直接使用</p><p>     int *p &#x3D; &amp;abc;  &#x2F;&#x2F; p的值即为lds文件中abc的值</p><p>原因：编译程序时，有一个symbol table(符号表)</p><p>    <img src="/image/6ada227de5b43829698292fc406db1bb.png" alt="6ada227de5b43829698292fc406db1bb.png"></p><p>结论：1.C程序不保存lds文件中的变量</p><p>          2.借助Symbol table保存lds的变量，使用时加上”&amp;”得到它的值</p><p>                对于g_i，使用&amp;g_i得到Addr</p><p>                为了保持代码一致，对于lds的a1，使用&amp;a1得到值</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第010课 ARM芯片时钟体系</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AC%AC010%E8%AF%BE_ARM%E8%8A%AF%E7%89%87%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AC%AC010%E8%AF%BE_ARM%E8%8A%AF%E7%89%87%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<p>三个时钟：CPU---&gt;FCLK            AHB BUS---&gt;HCLK           APB BUS---&gt;PCLK</p><p><img src="/image/899a1c23d6e8d0ac0562ee35b1f33c2c.png" alt="899a1c23d6e8d0ac0562ee35b1f33c2c.png"></p><p>2440有两个PLL,MPLL生产时钟给CPU用，UPLL生产时钟给USB用</p><p><img src="/image/fe294072f24590a34b865beafdd98567.png" alt="fe294072f24590a34b865beafdd98567.png"></p><p>编程：通过控制MPLL、HDIVN、PDIVN来找到合适的FCLK、HCLK、PCLK</p><p><img src="/image/1b70cdb4ed09e91940fec6d2a2167b1c.png" alt="1b70cdb4ed09e91940fec6d2a2167b1c.png"></p><p>上电后FCLK已经起振，但CPU要等待复位引脚松开才运行</p><p>1.复位芯片等待电源稳定才输出高电平</p><p>2.根据OM[3：2]的值，FLCK&#x3D;晶振 </p><p>3.PLL锁存OM[3：2]的值，同时CPU开始运行(复位引脚被拉高)</p><p>4.可以设置PLL，一旦设置PLL，在LockTime中FCLK没有起振，CPU停止运行</p><p>5.LockTime锁定时间中，CPU停止运行，PLL工作</p><p>6.LockTime结束，PLL设置完成，FCLK&#x3D;PLL输出的新时钟，CPU运行</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p><img src="/image/7cb8af50f893166e20e3ae2222fa5ae0.png" alt="7cb8af50f893166e20e3ae2222fa5ae0.png"></p><ol><li>芯片手册得知 HDIVN、PDIVN可以通过CLKDIVN控制</li></ol><p><img src="/image/6e2a08a6a59ffd32554d094add050a96.png" alt="6e2a08a6a59ffd32554d094add050a96.png"></p><ol><li>FCLK可以由MPLLCON控制</li></ol><p><img src="/image/a514d69bb8f475bc8d954fe0436008cc.png" alt="a514d69bb8f475bc8d954fe0436008cc.png"></p><p><img src="/image/ee193af24cd4e5c048aaf1c87e8af1b0.png" alt="ee193af24cd4e5c048aaf1c87e8af1b0.png"></p><ol><li>注意事项，HDIVN≠0，设置CPU为异步模式</li></ol><p><img src="/image/46db4bf7e7b8a213650debe5c561bc80.png" alt="46db4bf7e7b8a213650debe5c561bc80.png"></p><ol><li>为了保险，重新设置下LOCKTIME</li></ol><p><img src="/image/ef4f3026a9ef258f5519bf21b5b4ca9d.png" alt="ef4f3026a9ef258f5519bf21b5b4ca9d.png"></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">.text</span><br><span class="hljs-symbol">.global</span> _start<br><span class="hljs-symbol">_start:</span><br>    <span class="hljs-comment">/* 1.关闭看门狗 */</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-number">=0x53000000</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r1</span>, <span class="hljs-number">=0</span><br>    <span class="hljs-keyword">str</span> <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r0</span>]<br><br>    <span class="hljs-comment">/* 2.设置时钟 */</span><br>    <span class="hljs-comment">/* 2.1 设置LOCKTIME(0x4C000000)=0xFFFFFFFF */</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-number">=0x4C000000</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r1</span>, <span class="hljs-number">=0xFFFFFFFF</span><br>    <span class="hljs-keyword">str</span> <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r0</span>]<br><br>    <span class="hljs-comment">/* 2.2 设置CLKDIVN(0x4C000014) = 0x5 FCLK : HCLK : PCLK = 400m : 100m : 50m*/</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-number">=0x4C000014</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r1</span>, <span class="hljs-number">=0x5</span><br>    <span class="hljs-keyword">str</span> <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r0</span>]<br><br>    <span class="hljs-comment">/* 2.3 设置CPU处于异步模式 */</span><br>    <span class="hljs-keyword">mrc</span> <span class="hljs-built_in">p15</span>,<span class="hljs-number">0</span>,<span class="hljs-built_in">r0</span>,<span class="hljs-built_in">c1</span>,<span class="hljs-built_in">c0</span>,<span class="hljs-number">0</span><br>    <span class="hljs-keyword">orr</span> <span class="hljs-built_in">r0</span>,<span class="hljs-built_in">r0</span>,<span class="hljs-number">#0xc0000000</span> <span class="hljs-comment">/* #R1_nF:OR:R1_iA */</span><br>    mcr <span class="hljs-built_in">p15</span>,<span class="hljs-number">0</span>,<span class="hljs-built_in">r0</span>,<span class="hljs-built_in">c1</span>,<span class="hljs-built_in">c0</span>,<span class="hljs-number">0</span><br><br>    <span class="hljs-comment">/* 2.4 设置MPLLCON(0x4C000004)=(92&lt;&lt;12)   | (1 &lt;&lt; 4) | (1 &lt;&lt; 0)</span><br><span class="hljs-comment">     *       m = MDIV + 8 = 100</span><br><span class="hljs-comment">     *       p = PDIV + 2 = 3</span><br><span class="hljs-comment">     *       s = SDIV = 1    </span><br><span class="hljs-comment">     *        Mpll = (2 * m * Fin) / (p * 2 ^ s)</span><br><span class="hljs-comment">     *            = (2 * 100 * 12) / (3 * 2 ^ 1) = 400MHZ</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-number">=0x4C000004</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r1</span>, =(<span class="hljs-number">92</span>&lt;&lt;<span class="hljs-number">12</span>) <span class="hljs-title">| (1 &lt;&lt; 4) |</span> (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">str</span> <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r0</span>]<br><br>    <span class="hljs-comment">/* 3.设置栈</span><br><span class="hljs-comment">     *   自动分辨NOR启动或者NAND启动</span><br><span class="hljs-comment">     *   向0地址写入0，在读出来,如果写入则是NAND,否则是NOR</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-number">=0</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r0</span>] <span class="hljs-comment">/* 读出原来的值备份 */</span><br>    <span class="hljs-keyword">str</span> <span class="hljs-built_in">r0</span>, [<span class="hljs-built_in">r0</span>] <span class="hljs-comment">/* 向0地址写入0 */</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r2</span>, [<span class="hljs-built_in">r0</span>] <span class="hljs-comment">/* 再次读出来 */</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">r1</span>, <span class="hljs-built_in">r2</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">=0x40000000</span> + <span class="hljs-number">4096</span> <span class="hljs-comment">/* nor启动 */</span><br>    <span class="hljs-keyword">moveq</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">#4096</span>               <span class="hljs-comment">/* nand启动 */</span><br>    <span class="hljs-keyword">streq</span> <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r0</span>]               <span class="hljs-comment">/* 恢复原来的值 */</span><br>    <span class="hljs-keyword">bl</span> main<br><br><span class="hljs-symbol">halt:</span><br>    <span class="hljs-keyword">b</span> halt<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第012课 SDRAM的设置</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AC%AC012%E8%AF%BE_SDRAM%E7%9A%84%E8%AE%BE%E7%BD%AE/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AC%AC012%E8%AF%BE_SDRAM%E7%9A%84%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>2440接了24M的SDRAM，需要设置下内存控制器才能用起来</p><p>SDRAM的存储结构：</p><p><img src="/image/dae62d1fdc319f2ac2167dc185c4caa7.png" alt="dae62d1fdc319f2ac2167dc185c4caa7.png"></p><p>每个格保存16位数据，访问指定格子：发出片选信号选中整个芯片--&gt;发出Bank地址(选择哪一块)--&gt;发出行地址--&gt;发出列地址</p><p>所有信号都由内存控制器发出</p><p><img src="/image/15565f1909098b3b52be45a50d948c07.png" alt="15565f1909098b3b52be45a50d948c07.png"></p><p>设置相关寄存器：</p><p>1.BWSCON &#x3D; 0x2200 0000<img src="/image/597b9f1d13d4a7e77cb0215708b69391.png" alt="597b9f1d13d4a7e77cb0215708b69391.png"></p><p>只接了片选6，所以DW7，WS7，ST7都不用管，但最终设置时需要设置为与BANK6一样的数据</p><p>DW6：我们使用两个16位芯片组成一个32位芯片，设为10</p><p>WS6：假设该内存芯片的读写速度非常慢，当CPU发出读写命令之后，内存控制器开始驱动引脚，在这些时间之内还是没准备好数据，这时内存芯片就可向2440&#x2F;内存控制器发出一个nWAIT信号，请求多点时间；我们这里用不到</p><p>ST6：nBE[3:0]读写某个字节时决定是否操作byte</p><p>         nWBE[3:0]写某个字节时决定是否真正写入</p><p>        该内存是32位的，内存控制器读到的也是32位的数据，它会挑出你需要的字节，所以不需要ByteEnable来屏蔽某个byte</p><p>        故设为0</p><p>2.BANKCON6 &#x3D; 0x18001</p><p><img src="/image/7339344d703256b62499b90713ec6f82.png" alt="7339344d703256b62499b90713ec6f82.png"></p><p><img src="/image/f8b60a0ab968680ab8698b2bd9b44dd6.png" alt="f8b60a0ab968680ab8698b2bd9b44dd6.png"></p><p>MT用来确认接的是什么，SDRAM设为11</p><p><img src="/image/1512529429d4993a111d17909a657cae.png" alt="1512529429d4993a111d17909a657cae.png"></p><p>            SCAN：所选芯片列地址为几位？</p><p><img src="/image/bfa48d2079cd25642b952d2917bc894b.png" alt="bfa48d2079cd25642b952d2917bc894b.png"></p><p>            Trcd：先发行地址再发列地址，它们之间有个delay，这个delay可以在芯片手册中查                  到；保险起见选个最大的20ns</p><p>            若2440HCLK &#x3D; 100MHZ，T &#x3D; 10ns，则Trcd &#x3D; 2 clocks &#x3D; 00</p><p><img src="/image/fbbe816a4a3b78c9316d96d6ba57258a.png" alt="fbbe816a4a3b78c9316d96d6ba57258a.png"></p><p>3.刷新寄存器：SDRAM中你需要不断地刷新它，不然数据会丢失</p><p><img src="/image/6afe43beccfe1f7128c0c82b5c5cbf5d.png" alt="6afe43beccfe1f7128c0c82b5c5cbf5d.png"></p><p>Trp：在芯片手册中搜索，得出最小值18，最大值20；HCLK是100MHZ，周期为10ns，故可以设置为2clocks &#x3D; 00</p><p>Tsrc：在芯片手册中搜索，得不出值，得到Trc&#x3D;Tsrc+Trp;</p><p>          搜索Tsrc取最大值70；70ns &#x3D; Tsrc + 20； Tsrc &#x3D; 50ns；设置01</p><p>4.BANKSIZE &#x3D; 0xb1</p><p><img src="/image/ec2cf2a259c484c50f8b61801086e0b7.png" alt="ec2cf2a259c484c50f8b61801086e0b7.png"></p><p>5.MRSRB6 &#x3D; 0x20</p><p><img src="/image/7aff4e2089351b0c7e9554d17498bded.png" alt="7aff4e2089351b0c7e9554d17498bded.png"></p><p>CL：查询芯片手册，可以是2或3<img src="/image/ff72d9096e10366884193da920b7014c.png" alt="ff72d9096e10366884193da920b7014c.png"></p><p><img src="/image/55c28c57846b923a164b465cff6b05f3.png" alt="55c28c57846b923a164b465cff6b05f3.png"></p><p>把MRSR中的CL设置成3，它就会向SDRAM发出指令信号来设置MR，使得里面的CL等于3</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第009课_gcc和arm-linux-gcc和Makefile</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AC%AC009%E8%AF%BE_gcc%E5%92%8Carm-linux-gcc%E5%92%8CMakefile/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AC%AC009%E8%AF%BE_gcc%E5%92%8Carm-linux-gcc%E5%92%8CMakefile/</url>
    
    <content type="html"><![CDATA[<p>gcc的使用方法：</p><p>gcc  [选项]   文件名</p><p>gcc常用选项：</p><p>  -v：查看gcc编译器的版本，显示gcc执行时的详细过程</p><p>  -o &lt;file&gt;                Place the output into &lt;file&gt;</p><p>                           指定输出文件名为file，这个名称不能跟源文件名同名</p><p>  -E                       Preprocess only; do not compile, assemble or link</p><p>                           只预处理，不会编译、汇编、链接</p><p>  -S                       Compile only; do not assemble or link</p><p>                           只编译，不会汇编、链接</p><p>  -c                       Compile and assemble, but do not link</p><p>                           编译和汇编，不会链接    </p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>gcc  -v：查看gcc编译器的版本</p><p>方式1：</p><p>gcc hello.c  输出一个a.out，然后.&#x2F;a.out来执行该应用程序。</p><p>gcc -o hello hello.c  输出hello，然后.&#x2F;hello来执行该应用程 序。</p><p>方式2：</p><p>gcc -E -o hello.i hello.c</p><p>gcc -S -o hello.s hello.i</p><p>gcc -c -o hello.o hello.s</p><p>gcc -o hello hello.o</p><p>.o:object file(OBJ文件)</p><p>小结：</p><p>1）输入文件的后缀名和选项共同决定gcc到底执行那些操作。</p><p>2）在编译过程中，除非使用了-E、-S、-c选项(或者编译出错阻止了完整的编译过程)</p><p>   否则最后的步骤都是链接。</p><p>   <img src="/image/2f55eb4d7fbbf169e61984ff99e3e10d.png" alt="2f55eb4d7fbbf169e61984ff99e3e10d.png"></p><p>方式3：(简化方式需掌握 )</p><p>gcc -c -o hello.o hello.c</p><p>gcc -o hello hello.o</p><p>gcc会对.c文件默认进行预处理操作，-c再来指明了编译、汇编，从而得到.o文件</p><p>再通过gcc -o hello hello.o将.o文件进行链接，得到可执行应用程序。</p><p>链接就是将汇编生成的OBJ文件、系统库的OBJ文件、库文件链接起来，</p><p>最终生成可以在特定平台运行的可执行程序。</p><p>       crt1.o、crti.o、crtbegin.o、crtend.o、crtn.o是gcc加入的系统标准启动文件，</p><p>       对于一般应用程序，这些启动是必需的。</p><p>       -lc：链接libc库文件，其中libc库文件中就实现了printf等函数。</p><p>        -nostdlib：卜连杰系统标准启动文件和标准库文件，只把指定的文件传递给连接器</p><p>        gcc -v -nostdlib -o hello hello.o会提示因为没有链接系统标准启动文件和标准库文件，而链接失败。(-v显示编译过程)</p><p>       这个-nostdlib选项常用于裸机&#x2F;bootloader、linux内核等程序，因为它们不需要启动文件、标准库文件。</p><p>一般应用程序才需要系统标准启动文件和标准库文件。</p><p>因为裸机&#x2F;bootloader、linux内核等程序不需要启动文件、标准库文件。</p><p>动态链接使用动态链接库进行链接，生成的程序在执行的时候需要加载所需的动态库才能运行。</p><p>动态链接生成的程序体积较小，但是必须依赖所需的动态库，否则无法执行。</p><p>静态链接使用静态库进行链接，生成的程序包含程序运行所需要的全部库，可以直接运行，</p><p>不过静态链接生成的程序体积较大。</p><p>gcc -c -o hello.o hello.c</p><p>gcc -o hello_shared  hello.o                            (默认使用动态链接库进行链接)</p><p>gcc -static -o hello_static hello.o                    (使用静态库进行链接)</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第008课_第1个ARM裸板程序及引申(部分免费)</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AC%AC008%E8%AF%BE_%E7%AC%AC1%E4%B8%AAARM%E8%A3%B8%E6%9D%BF%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%BC%95%E7%94%B3(%E9%83%A8%E5%88%86%E5%85%8D%E8%B4%B9)/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/%E7%AC%AC008%E8%AF%BE_%E7%AC%AC1%E4%B8%AAARM%E8%A3%B8%E6%9D%BF%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%BC%95%E7%94%B3(%E9%83%A8%E5%88%86%E5%85%8D%E8%B4%B9)/</url>
    
    <content type="html"><![CDATA[<p><strong>目录</strong></p><hr><ol><li>第001节_辅线1_硬件知识_LED原理图</li><li>第002节_辅线1_GPIO操作与简单流程</li><li>第003节_编写第1个程序点亮LED</li><li>第004节_汇编与机器码_P</li><li>第005节_编程知识_进制_P</li><li>第006节_编程知识_字节序_位操作_P</li><li>第007节_编写C程序控制LED_P</li><li>第008节_几条汇编指令_bl_add_sub_ldm_stm_P</li><li>第009节_解析C程序的内部机制_P</li><li>第010节_完善LED程序_编写按键程序_P</li></ol><p><strong>第001节_辅线1_硬件知识_LED原理图</strong></p><hr><p>点亮LED：</p><ol><li>看原理图确定控制LED的引脚</li><li>看主芯片手册确定如何设置&#x2F;控制引脚</li><li>写程序</li><li>将编辑好的程序上传到Linux编译得到bin文件</li><li>将bin文件传回pc烧写进开发板</li></ol><p> </p><p><strong>第002节_辅线1_硬件知识_S3C2440启动流程与GPIO操作</strong></p><hr><p>操作简述</p><hr><p>（一）进入原理图,找到LED模块</p><p><img src="/image/afbb7e32c925c2cb8e2528ea19bb12de.png" alt="afbb7e32c925c2cb8e2528ea19bb12de.png"></p><p>由原理图得引脚nLED4输入低电平，LED点亮；输入高电平，LED熄灭</p><p>找到nLED4在芯片上对应的引脚,即GPF6</p><p><img src="/image/a55c31fba8ba316159aa1b784725ca15.png" alt="a55c31fba8ba316159aa1b784725ca15.png"></p><p>（二）进入S3C2440的芯片手册查看如何设置该引脚</p><p><img src="/image/e25564c070d4b0e81314058c63f88180.png" alt="e25564c070d4b0e81314058c63f88180.png"></p><p>看出可以需要先通过GPFCON寄存器将GPF6设置成输出状态，再通过GPFDAT输出电平</p><p><img src="/image/c8157723579ef7fd425ff3808f46188b.png" alt="c8157723579ef7fd425ff3808f46188b.png"></p><p>配置成输出端口：即设置[13:12]为[0:1]就能设置成输出状态</p><p><img src="/image/4ed0f77e32d934be2856e6ed5fc10f5c.png" alt="4ed0f77e32d934be2856e6ed5fc10f5c.png"></p><p>输出低电平：由描述得将对应的位配置成1就是高电平，配置成0就是低电平</p><p><img src="/image/8654c9053310a38c61132cd50aaef940.png" alt="8654c9053310a38c61132cd50aaef940.png"></p><p>通过寄存器配置工具得到：配置输出端口：将0x1000写入到地址0x56000050(GPFCON)</p><p>                                         输出低电平：将0写入地址0x56000054</p><p>（三）编写程序</p><p>见003节</p><p>（四）打开MobaXterm_Personal，输入虚拟机的ip和登陆用户及密码，需要在打开虚拟机的情况下进行,进行远程登录虚拟机</p><p>打开FileZilla,把虚拟机和pc连接(需要ping通)，将led_on.S文件发送到虚拟机中编译连接（通过Makefile），然后将得到的bin文件发送回PC，再使用eop烧写bin文件(在NAND启动下烧写)，烧写完毕后拔掉排针，重新即可验证现象</p><p>S3C2440启动流程</p><hr><p>启动过程：大多数ARM芯片从0地址启动</p><ul><li>NOR启动（程序烧到NOR Flash）：NOR Flash(可读不可写)基地址为0，即CPU看到的0地址在NOR Flash上</li></ul><p>                (设置NOR启动的时候，0地址对应NOR Flash，SRAM(片内RAM)为0x4000 0000)</p><p>                代码烧入NOR Flash中，CPU读出NOR上第一个指令 (前四字节)执行</p><p>                CPU继续读出其他指令执行</p><ul><li>Nand启动（程序烧到NAND Flash）：片内内存4kRAM基地址为0(可写)，即CPU看到的0地址在4KRAM上</li></ul><p>                (设置Nand启动的时候，0地址为SRAM，NOR Flash不可访问)</p><p>                 硬件把Nand前4k内容复制到片内内存(SRAM)</p><p>                 然后CPU从0地址取出第一条指令执行</p><p>ldr sp, &#x3D;4096  &#x2F;* nand启动 *&#x2F;</p><p>ldr sp, &#x3D;0x40000000+4096  &#x2F;* nor启动 *&#x2F;</p><p>把栈设置在4K内存的顶部，所以nand为1024*4，nor为0x40000000+1024*4</p><p><img src="/image/adef0acd332ae66fd8934508895e2030.png" alt="adef0acd332ae66fd8934508895e2030.png"></p><p><strong>第003节_编写第1个程序点亮LED</strong></p><hr><p>S3C2440中存在着CPU和GPIO控制器，它们之间都存在着寄存器。CPU中的寄存器可以直接访问，而GPIO控制器中的寄存器访问需要地址</p><p>若想控制GPIO则需要配置对应的GPIO配置寄存器和GPIO数据寄存器，就需要向其中写值，利用寄存器工具确定写入何值，然后将数据写入对应的地址</p><p>通过汇编代码达到功能：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">/* start.S */</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 点亮LED:gpf4</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-symbol">.text</span>    <span class="hljs-comment">//表明是代码段</span><br><span class="hljs-symbol">.global</span> _start<br><br><span class="hljs-symbol">_start:</span><br><br><span class="hljs-comment">/* 配置GPF4为输出引脚</span><br><span class="hljs-comment"> * 把0x100写到地址0X56000050</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r1</span>, <span class="hljs-number">=0x56000050</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-number">=0x100</span>    <span class="hljs-comment">/* mov r0,#0x100 */</span><br>    <span class="hljs-keyword">str</span> <span class="hljs-built_in">r0</span>, [<span class="hljs-built_in">r1</span>]<br><span class="hljs-comment">/* 设置GPF4输出高电平</span><br><span class="hljs-comment"> * 把0写到地址0X56000054</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r1</span>, <span class="hljs-number">=0x56000054</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-number">=0</span>    <span class="hljs-comment">/* mov r0,#0 */</span><br>    <span class="hljs-keyword">str</span> <span class="hljs-built_in">r0</span>, [<span class="hljs-built_in">r1</span>]<br><br><span class="hljs-comment">/* 死循环</span><br><span class="hljs-comment"> * 因为烧入的只有十几字节，但十几字节后的内容是不确定的</span><br><span class="hljs-comment"> */</span><br><span class="hljs-symbol">halt:</span><br>    <span class="hljs-keyword">b</span> halt<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">/* Makefile */</span><br><span class="hljs-attribute">all</span>:<br>    arm-linux-gcc -c -o led_on<span class="hljs-selector-class">.o</span> led_on<span class="hljs-selector-class">.S</span>                    <span class="hljs-comment">//编译</span><br>    arm-linux-ld -Ttext <span class="hljs-number">0</span> led_on<span class="hljs-selector-class">.o</span> -o led_on<span class="hljs-selector-class">.elf</span>             <span class="hljs-comment">//连接</span><br>    arm-linux-objcopy -O binary -S led_on<span class="hljs-selector-class">.elf</span> led_on<span class="hljs-selector-class">.bin</span>     <span class="hljs-comment">//得到bin文件</span><br>    arm-linux-objdump -D led_on<span class="hljs-selector-class">.elf</span> &gt; led_on<span class="hljs-selector-class">.dis</span>             <span class="hljs-comment">//得到反汇编文件</span><br>clean:<br>    rm *<span class="hljs-selector-class">.bin</span> *<span class="hljs-selector-class">.o</span> *.elf<br></code></pre></td></tr></table></figure><p><strong>第004节_汇编与机器码</strong></p><hr><p>（一）反汇编dis文件详解</p><p><img src="/image/d1dd1d14f04a8c36f2704d258c556b3c.png" alt="d1dd1d14f04a8c36f2704d258c556b3c.png"></p><ol><li>line001：读取内存地址为[pc+20]上的数据，写入r1中。[0+8+20]&#x3D;[28]即0x1c地址上读值</li></ol><p> </p><p>-pc值&#x3D;当前指令+8。因为CPU是以流水线形式执行的，当前执行地址A的指令，已经在对地址A+4的指令进行译码，已经在读取A+8的指令</p><ol><li>line002：r0 &#x3D; 0x100</li><li>line003：把r0即0x100写入r1对应的内存0x56000050（到此达到效果：将0x100写入0x56000050即GPFCON寄存器）</li><li>line004：r1 &#x3D; [pc + 12] &#x3D; [0xc + 8 +12] &#x3D; [32] &#x3D; [0x20]，去0x20地址读取值0x56000054存放到r1里面</li><li>line005：r0 &#x3D; 0x0</li><li>line006：把r0即0x0写入r1对应的内存0x56000054（到此达到效果：将0x0写入0x56000054，即GPFDAT寄存器）</li></ol><p>故在cpu角度，这些寄存器就是内存</p><p>通过反汇编文件可以看到编译器将我们所写汇编文件中的伪指令转换成真正的汇编码</p><p>%!(EXTRA markdown.ResourceType&#x3D;, string&#x3D;, string&#x3D;)</p><p><img src="/image/982989c2ef5f3bfb731087384343d792.png" alt="982989c2ef5f3bfb731087384343d792.png"></p><p><img src="/image/03b320988018e5da53095d5248f95a67.png" alt="03b320988018e5da53095d5248f95a67.png"></p><p>对于真正的汇编码保持不变</p><p>%!(EXTRA markdown.ResourceType&#x3D;, string&#x3D;, string&#x3D;)</p><p><img src="/image/a217007b15a867300d469d580fe9722d.png" alt="a217007b15a867300d469d580fe9722d.png"></p><p>（二）观察bin文件</p><p>编译器把程序转换成汇编码后，再将汇编码转换成机器码存为bin文件，bin文件中包含所有反汇编文件中的</p><p><img src="/image/bfed22c44aa7d93c2b50fa7fb16aabca.png" alt="bfed22c44aa7d93c2b50fa7fb16aabca.png"></p><p>可看出bin文件内容是和反汇编文件中机器码一一对应的</p><p>（三）解析bin文件中ARM指令</p><p>如果我们想通过直接修改机器码来改变结果，我们需要得到mov指令对应的机器码格式，可在ARM架构手册ARM Architecture Reference Manual.pdf中找到</p><p><img src="/image/75ad70c6483ec404d7ab7f9116ee0c70.png" alt="75ad70c6483ec404d7ab7f9116ee0c70.png"></p><p>例：”e3a00c01     mov    r0, #256    ; “中：</p><p>0x100对应e3a00c01中的c01，即为1100 0000 0001</p><p>将immed_8循环右移24位后得到1 0000 0000，即为立即数0x100</p><p><strong>第005节_编程知识_进制_P</strong></p><hr><p>（一） 如何快速转换二进制&#x2F;八进制&#x2F;十六进制</p><p>-八进制：每一位八进制数对应3位二进制数，每一位八进制数据代表3个二进制数据，即3bit</p><p>-十六进制：每一位十六进制数对应4位二进制数，每一位十六进制数据代表4个二进制数据，即4bit</p><p>（二）数据如何在C语言中表示</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int a <span class="hljs-operator">=</span> <span class="hljs-number">96</span><span class="hljs-comment">;</span><br>int a <span class="hljs-operator">=</span> <span class="hljs-number">0140</span><span class="hljs-comment">;</span><br>int a <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x60<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>（三）为何引入这些进制</p><p>-二进制：与晶体管一一对应，晶体管只有两个状态0和1</p><p>-八进制：用1位表示3bit，即3位二进制；1位取值范围：0-7</p><p>-十六进制：用1位表示4bit，即4位二进制；1位取值范围：0-15</p><p><strong>第006节_编程知识_字节序_位操作_P</strong></p><hr><p>（一）大小端模式（大字节序小字节序）</p><p>地址的高地位：有一段连续的地址：0x00、0x01、0x02、0x03，很简单，值小的就低，大的就高，那就是0x00是低地址，往右递增。</p><p>小端模式：数据的低字节存放到内存的低地址中，高字节存到高地址中。并且小端模式下优先将数据填充到内存的低地址中。（适合计算机理解）</p><p>   地址：0x00 | 0x01 | 0x02 | 0x03       内存地址从左到右由低到高</p><p>   数据：0x78 | 0x56 | 0x34 | 0x12       数据字节从左到右由低到高</p><p>大端模式：数据的低字节存放到内存的高地址中，高字节存到低地址中，且数据优先填充到高地址上。（适合人类理解）</p><p>   地址：0x00 | 0x01 | 0x02 | 0x03       内存地址从左到右由低到高</p><p>   数据：0x12 | 0x34 | 0x56 | 0x78       数据字节从左到右由高到低</p><p>一个地址存放一个字节</p><p><img src="/image/086eca011369e97830f7aff2a0baf846.png" alt="086eca011369e97830f7aff2a0baf846.png"></p><p>（二）置位操作，清位操作</p><ol><li>置位：int a &#x3D; 0x123，把bit7,8置位(7,8位置1)</li></ol><p>int b &#x3D; a | ( 1 &lt;&lt; 7 ) | ( 1 &lt;&lt; 8 ) &#x3D; 0x1a3</p><ol><li>清位：int a&#x3D;0x123，把bit7,8清除(7,8位置0)</li></ol><p>int b&#x3D;(a &amp; <del>(1 &lt;&lt; 7)) &amp; (</del>(1 &lt;&lt; 8))&#x3D;0x23</p><p><strong>第007节_编写C程序控制LED_P</strong></p><hr><p>（一）如何在C语言中定义寄存器地址</p><p>ARM芯片寄存器大多是32位小端，即4个字节。同时一个地址对应一个字节，也可直接看出地址相差4字节</p><p><img src="/image/0fe2e5f61e71be991bb0d27c69a1339e.png" alt="0fe2e5f61e71be991bb0d27c69a1339e.png"></p><p>-此为32位地址应该用int来表示</p><p>-对于int 变量，它的最高位是用来表示符号位，但对于寄存器，它的最高位依然是用来控制硬件的（无论实际上用不用得到），所以用unsigned int</p><p>-c语言中不能直接使用地址，必须转换为指针，所以为unsigned int *</p><p>故若想定义一个地址例如GPFCON进行操作，即为unsigned int *pGPFCON &#x3D; (unsigned int *)0x56000050</p><p>（二）编写C程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* main.c */</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *pGPFCON = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *)<span class="hljs-number">0x56000050</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *pGPFDAT = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *)<span class="hljs-number">0x56000054</span>;<br>    <span class="hljs-comment">/* 配置GPF4为输出引脚 */</span><br>    *pGPFCON = <span class="hljs-number">0x100</span>;<br>    <br>    <span class="hljs-comment">/* 设置GPF4输出0 */</span><br>    *pGPFDAT = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>再写出汇编程序调用C程序</p><p>（三）编写汇编程序</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* start.S */</span><br><br>.text<br>.global _start<br><br>_start:<br><br>    <span class="hljs-regexp">/* 设置内存: sp 栈 */</span><br>    ldr sp, =<span class="hljs-number">4096</span>  <span class="hljs-regexp">/* nand启动 */</span><br><span class="hljs-regexp">//</span>    ldr sp, =<span class="hljs-number">0</span>x40000000+<span class="hljs-number">4096</span>  <span class="hljs-regexp">/* nor启动 */</span><br><br>    <span class="hljs-regexp">/* 调用main */</span><br>    bl main    <span class="hljs-regexp">//</span>跳转执行main函数，并且保存返回地址到lr里<br><br>halt:<br>    b halt<br></code></pre></td></tr></table></figure><p>局部变量保存在栈中，栈是一块内存，需要自己设置(不设置指针就找不到地方指向，出现错误Segmentation fault (core dumped))，设置ldr sp, &#x3D;4096，将栈设置到NAND或NOR内存中</p><p>问题：为什么写简单程序的时候不需要设置栈？</p><p>答：这个地方设置栈是因为需要找到这个两个地址，通过设置nand,nor作为0地址可以定位到真实存在的寄存器地址来修改[ ] </p><p>修改Makefile</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-attribute">all</span>:<br>    arm-linux-gcc -c -o led<span class="hljs-selector-class">.o</span> led<span class="hljs-selector-class">.c</span><br>    arm-linux-gcc -c -o start<span class="hljs-selector-class">.o</span> start<span class="hljs-selector-class">.S</span>        <span class="hljs-comment">//分别编译</span><br>    arm-linux-ld -Ttext <span class="hljs-number">0</span> start<span class="hljs-selector-class">.o</span> led<span class="hljs-selector-class">.o</span> -o led<span class="hljs-selector-class">.elf</span><br>    arm-linux-objcopy -O binary -S led<span class="hljs-selector-class">.elf</span> led<span class="hljs-selector-class">.bin</span><br>    arm-linux-objdump -D led<span class="hljs-selector-class">.elf</span> &gt; led<span class="hljs-selector-class">.dis</span><br>clean:<br>    rm *<span class="hljs-selector-class">.bin</span> *<span class="hljs-selector-class">.o</span> *<span class="hljs-selector-class">.elf</span> *.dis<br></code></pre></td></tr></table></figure><p>**第008节_**<strong>简单的汇编指令</strong></p><hr><p><a href="evernote:///view/18988257/s16/5400fbfa-6f31-4e6c-91c9-4eac4b8860e9/5400fbfa-6f31-4e6c-91c9-4eac4b8860e9/">简单的汇编指令</a></p><p><strong>第009节_解析C程序的内部机制_P</strong></p><hr><p>（一）程序都做了什么</p><p>start.S做了什么：设置栈，调用main，并把返回地址保存到lr中</p><p>main.c做了什么：定义两个局部变量，设置变量，return0</p><p>（二）为什么要设置栈？</p><p>汇编语言是底层语言，它没有栈，它也不需要编写很复杂很庞大的程序，即使没有内存（SDRAM），它也能在cpu的片内内存运行以完成一些裸机硬件程序；但是C语言是高级语言，它能够编写复杂庞大的程序，所以它需要函数间的多层调用，它需要用到指针的灵活赋值等等，但是这些都有依赖于栈<a href="https://blog.csdn.net/daleiwang/article/details/50579776">https://blog.csdn.net/daleiwang/article/details/50579776</a></p><p>（三）如何设置栈？</p><p>ldr sp, &#x3D;4096 ，实际就是让SP指针指向这样的地址，但是这个地址是内存中的地址，而不是cpu片内地址，内存资源相对cpu资源来说充裕多了，所以SP可以有很大的增长空间，这也是C语言可以写复杂程序的前提。而且要保证这块内存可读可写， 并且跟程序不冲突，在此程序中栈从上往下增长，不会破坏到程序所运行的内存。</p><p>理论知识</p><hr><p>ATPCS：</p><p><img src="/image/Image.png" alt="Image.png"></p><p>CPU里有各种寄存器：</p><ol><li>R15程序计数器（Program Counter，PC）用来指出下一条指令在主存储器中的地址。</li></ol><p>-在程序执行之前，首先必须将程序的首地址，即程序第一条指令所在主存单元的地址(存储地址)送入PC，因此PC的内容即是从主存提取的第一条指令的地址。</p><p>-当执行指令时，CPU能自动递增PC的内容，使其始终保存将要执行的下一条指令的主存地址，为取下一条指令做好准备。</p><p>（在ARM里，CPU里程序的执行方式是以流水线的方式执行的：当前执行地址A的指令已经在对地址A+4的指令进行译码，已经在读取地址A+8的指令，A+8即PC的值)</p><p>-当遇到转移指令时，下一条指令的地址将由转移指令的地址码字段来指定，即当把一个地址写入PC时，程序会跳到那个地址。</p><ol><li><p>R14(LInk Register)：用来保存返回地址，执行函数调用时，执行函数后需要跳回原来的位置，这个地址就保存在这里</p></li><li><p>R13(sp数据栈指针)：栈：就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量，函数参数等</p></li></ol><p>解析反汇编文件</p><hr><p><img src="/image/886e9e2879540e11dce65274cd0056df.png" alt="886e9e2879540e11dce65274cd0056df.png"></p><ol><li>line6：一上电，从零地址开始执行</li><li>line7：sp指向4096即0x1000</li><li>line8：跳转到line13从0x0c开始执行，同时让lr等于它的返回地址（line11）即lr&#x3D;8</li><li>line14：ip &#x3D; sp &#x3D; 4096</li><li>line15：把fp,ip,lr,pc四个寄存器保存在sp对应的内存里（入栈）；pc&#x3D;当前指令地址+8<img src="/image/db7de45848251b0c4eb6045b766d2d8d.png" alt="db7de45848251b0c4eb6045b766d2d8d.png"></li><li>line16：fp &#x3D; ip - 4 &#x3D; 4092</li><li>line17：sp &#x3D; sp - 8 &#x3D; 4080 - 8 &#x3D; 4072</li><li>line18：r3 &#x3D; 0x56000000</li><li>line19：r3 &#x3D; r3 + 0x50 &#x3D; 0x56000050</li><li>line20：r3存入[fp - 16] &#x3D; [4092 - 16] &#x3D; [4076]，保存的就是局部变量pGPFCON</li><li>line21：r3 &#x3D; 0x56000000</li><li>line22：r3 &#x3D; r3 + 0x54 &#x3D; 0x56000054</li><li>line23：r3存入[fp - 20] &#x3D; [4092 - 20] &#x3D; [4072]，保存的就是局部变量pGPFCON</li><li>line24：r2 &#x3D; [fp - 16] &#x3D; [4076] &#x3D; 0x56000050 &#x3D; GPFCON</li><li>line25：r3(0x100)存入[0x56000050]，对应C语言：*pGPFCON &#x3D; 0x100;</li><li>line26：r2 &#x3D; [fp - 20] &#x3D; [4072] &#x3D; 0x56000054 &#x3D; GPFDAT</li><li>line27：r3(0x0)存入[0x56000054]，对应C语言:*pGPFDAT &#x3D; 0;</li><li>line28&#x2F;line29：r3 &#x3D; 0；r0 &#x3D; r3</li></ol><p>-调用者和被调用者通过r0~r3来传递参数，所以C语言中return的0应该保存到r0里</p><ol><li>line30：sp &#x3D; [fp - 12] &#x3D; [4092 - 12] &#x3D; 4080</li><li>line31：从栈4080的位置中恢复寄存器；</li></ol><p>-fp &#x3D; [4080] &#x3D; 原来保存的fp</p><p>-sp &#x3D; [4084] &#x3D; 4096</p><p>-pc &#x3D; [4088] &#x3D; 8；跳回0x8的地址，即main返回</p><p>验证汇编程序与C程序如何传参</p><hr><p>C语言与汇编语言调用规则：</p><p>调用者如何传参数给被调用者(子函数)：通过r0-r3寄存器传递一个值（由ATPCS指定）</p><p>.S：mov r0, #4</p><p>      bl led_on</p><p>.c：int led_on(int which)</p><p>被调用者如何传参数给调用者：通过r0-r3寄存器传递一个值(return的0保存在了r0中)</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">/* start.S */</span><br><br><span class="hljs-symbol">.text</span><br><span class="hljs-symbol">.global</span> _start<br><br><span class="hljs-symbol">_start:</span><br><br>    <span class="hljs-comment">/* 设置内存: sp 栈 */</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">=4096</span>  <span class="hljs-comment">/* nand启动 */</span><br><span class="hljs-comment">//    ldr sp, =0x40000000+4096  /* nor启动 */</span><br><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">r0</span>, <span class="hljs-number">#4</span><br>    <span class="hljs-keyword">bl</span> led_on<br><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-number">=100000</span><br>    <span class="hljs-keyword">bl</span> delay<br><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">r0</span>, <span class="hljs-number">#5</span><br>    <span class="hljs-keyword">bl</span> led_on<br><br><span class="hljs-symbol">halt:</span><br>    <span class="hljs-keyword">b</span> halt<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* led.c */</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">delay</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> d)</span>        <span class="hljs-comment">//volatitle：void delay(volatile int d)，避免编译器优化，确保有效</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (d--);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">led_on</span><span class="hljs-params">(<span class="hljs-type">int</span> which)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *pGPFCON = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *)<span class="hljs-number">0x56000050</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *pGPFDAT = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *)<span class="hljs-number">0x56000054</span>;<br><br>    <span class="hljs-keyword">if</span> (which == <span class="hljs-number">4</span>)<br>    &#123;<br>        <span class="hljs-comment">/* 配置GPF4为输出引脚 */</span><br>        *pGPFCON = <span class="hljs-number">0x100</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (which == <span class="hljs-number">5</span>)<br>    &#123;<br>        <span class="hljs-comment">/* 配置GPF5为输出引脚 */</span><br>        *pGPFCON = <span class="hljs-number">0x400</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>反汇编：</p><p><img src="/image/f009c20e6f80161dfb43239ed359f92e.png" alt="f009c20e6f80161dfb43239ed359f92e.png"></p><ol><li>line8：r0 &#x3D; 4</li><li>line9：跳到&lt;led_on&gt;执行</li><li>line10：r0 &#x3D; [pc + 12] &#x3D; 0x000186a0 &#x3D; 100000</li><li>line11：跳到&lt;delay&gt;执行</li><li>line12：r0 &#x3D; 5</li><li>line13：跳到&lt;led_on执行&gt;</li></ol><p><strong>第010节_完善LED程序_编写按键程序_P</strong></p><hr><p>从原理图可以看到平时EINT0为拉高状态，按键按下后被拉低，即按下输入0，抬起输入1</p><p>&#x2F;* start.S *&#x2F;</p><p>.text</p><p>.global _start</p><p>_start:</p><p>    &#x2F;* 关闭看门狗 </p><p>     * 它是系统里保证系统正常运行的一个机制，时间到达后会重启整个系统，避免系统卡死</p><p>     *&#x2F;</p><p>    ldr r0, &#x3D;0x53000000</p><p>    ldr r1, &#x3D;0</p><p>    str r1, [r0]</p><p>    &#x2F;* 设置内存: sp 栈 *&#x2F;</p><p>    &#x2F;* 自动分辨是nor&#x2F;nand启动</p><p>     * 写0到0地址, 再读出来</p><p>     * 如果得到0, 表示0地址上的内容被修改了, 它对应ram, 这就是nand启动</p><p>     * 否则就是nor启动</p><p>     *&#x2F;</p><p>    mov r1, #0</p><p>    ldr r0, [r1] &#x2F;* 读出原来的值备份 *&#x2F;</p><p>    str r1, [r1] &#x2F;* 0-&gt;[0] *&#x2F;</p><p>    ldr r2, [r1] &#x2F;* r2&#x3D;[0] *&#x2F;</p><p>    cmp r1, r2   &#x2F;* r1&#x3D;&#x3D;r2? 如果相等表示是NAND启动 *&#x2F;</p><p>    ldr sp, &#x3D;0x40000000+4096 &#x2F;* 先假设是nor启动 *&#x2F;</p><p>    moveq sp, #4096  &#x2F;* nand启动 *&#x2F;</p><p>    streq r0, [r1]   &#x2F;* 恢复原来的值 *&#x2F;</p><p>    </p><p>    bl main</p><p>halt:</p><p>    b halt</p><p>&#x2F;* main.c *&#x2F;</p><p>#include “s3c2440_soc.h”</p><p>void delay( volatile int d )</p><p>{</p><p>    while ( d-- );</p><p>}</p><p>int main( void )</p><p>{</p><p>    int val1, val2;</p><p>    </p><p>    &#x2F;* 设置GPFCON让GPF4&#x2F;5&#x2F;6配置为输出引脚 *&#x2F;</p><p>    GPFCON &amp;&#x3D; ~ ( ( 3&lt;&lt;8 ) | ( 3&lt;&lt;10 ) | ( 3&lt;&lt;12 ) );    &#x2F;&#x2F;清零</p><p>    GPFCON |&#x3D;   ( ( 1&lt;&lt;8 ) | ( 1&lt;&lt;10 ) | ( 1&lt;&lt;12 ) );</p><p>    &#x2F;* 配置3个按键引脚为输入引脚:</p><p>     * GPF0(S2),GPF2(S3),GPG3(S4)</p><p>     *&#x2F;</p><p>    GPFCON &amp;&#x3D; ~ ( ( 3 &lt;&lt; 0 ) | ( 3 &lt;&lt; 4 ) );  &#x2F;* gpf0,2 *&#x2F;</p><p>    GPGCON &amp;&#x3D; ~ ( ( 3 &lt;&lt; 6 ) );  &#x2F;* gpg3 *&#x2F;</p><p>    &#x2F;* 循环点亮 *&#x2F;</p><p>    while (1){</p><p>        val1 &#x3D; GPFDAT;</p><p>        val2 &#x3D; GPGDAT;</p><p>        if ( val1 &amp; ( 1 &lt;&lt; 0 ) ) {    &#x2F;* s2 --&gt; gpf6 *&#x2F;</p><p>            &#x2F;* 松开 *&#x2F;</p><p>            GPFDAT |&#x3D; ( 1 &lt;&lt; 6 );</p><p>        }</p><p>        else {</p><p>            &#x2F;* 按下 *&#x2F;</p><p>            GPFDAT &amp;&#x3D; ~ ( 1 &lt;&lt; 6 );</p><p>        }</p><p>        if ( val1 &amp; ( 1 &lt;&lt; 2 ) ) {    &#x2F;* s3 --&gt; gpf5 *&#x2F;</p><p>            &#x2F;* 松开 *&#x2F;</p><p>            GPFDAT |&#x3D; ( 1 &lt;&lt; 5 );</p><p>        }</p><p>        else {</p><p>            &#x2F;* 按下 *&#x2F;</p><p>            GPFDAT &amp;&#x3D; ~ ( 1 &lt;&lt; 5 );</p><p>        }</p><p>        if (val2 &amp; ( 1 &lt;&lt; 3 ) ) {    &#x2F;* s4 --&gt; gpf4 *&#x2F;</p><p>            &#x2F;* 松开 *&#x2F;</p><p>            GPFDAT |&#x3D; ( 1 &lt;&lt; 4 );</p><p>        }</p><p>        else {</p><p>            &#x2F;* 按下 *&#x2F;</p><p>            GPFDAT &amp;&#x3D; ~(1&lt;&lt;4);</p><p>        }</p><p>    }</p><p>    return 0;</p><p>}</p><p><strong>&#x2F;* s3c2440_soc.h *&#x2F; (用define编写的头文件)</strong></p><p>#ifndef  __S3C2440_SOC_H</p><p>#define  __S3C2440_SOC_H</p><p>#define     __REG(x)                    (*(volatile unsigned int *)(x))</p><p>#define     GPECON                   __REG(0x56000040)  &#x2F;&#x2F;Port E control                                   </p><p>#define     GPEDAT                   __REG(0x56000044)  &#x2F;&#x2F;Port E data</p><p>val1 &amp; (1&lt;&lt;2)意思是，val1对应地址的第2位(GPFDAT的第二位)与1相与</p><p>（1&lt;&lt;2）指1当前在bit0上，左移2位后在bit2上</p><p>C语言对寄存器写值：(赋值&#x3D;先把赋值的哪几位清零，然后再把需要赋值的数左移到那几位)</p><ol><li>若给定一个整型数a，设置a的bit3为1，保证其他位不变</li></ol><p>a |&#x3D; (1&lt;&lt;3);</p><ol><li>给定一个整型数a，清除a的bit15~bit23，保证其他位不变</li></ol><p>a &amp;&#x3D; ~(0x1ff&lt;&lt;15);</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vi编辑器的使用</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/vi%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/vi%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>vi编辑器的配置</strong></p><hr><p>cd &#x2F;etc&#x2F;vim</p><p>cp vimrc ~&#x2F;.vimrc</p><p>cd ~</p><p>gedit .vimrc</p><p>在.vimrc中加入如下内容：</p><p>“关闭兼容功能</p><p>set nocompatible</p><p>“显示行号</p><p>set number</p><p>“编辑时 backspace 键设置为2个空格</p><p>set backspace&#x3D;2</p><p>“编辑时 tab 键设置为4个空格</p><p>set tabstop&#x3D;4</p><p>“设置自动对齐为4个空格</p><p>set shiftwidth&#x3D;4</p><p>“搜索时不区分大小写</p><p>set ignorecase</p><p>“搜索时高亮显示</p><p>set hlsearch</p><p><strong>vi编辑器的模式</strong></p><hr><p>三种模式:</p><p>1）一般模式（光标移动、复制、粘贴、删除）</p><p>2）编辑模式（编辑文本）</p><p>3）命令行模式（查找和替换）</p><p><img src="/image/vi%E7%BC%96%E8%BE%91%E5%99%A8.png" alt="vi编辑器.png"></p><p>注意：</p><p>1）当不知道处于何种模式时，按ESC键返回到一般模式。</p><p>2）wq(write quit)    i(insert)</p><p><strong>vi编辑器的基本操作</strong></p><hr><p>1.打开文件、新建文件、保存文件：</p><p><span style="background-color: #ffaaaa">vi</span> 文件名：打开文件</p><p>在编辑完成时，需按esc返回一般模式：</p><p>1）输入<span style="background-color: #ffaaaa">:w</span>则保存文件，如果已经保存文件，输入<span style="background-color: #ffaaaa">:q</span>则退出文件</p><p>2）直接输入<span style="background-color: #ffaaaa">:wq</span>保存并退出。文件存在，:wq保存并退出文件；文件不存在，:wq就可以新建并保存文件</p><p>3）如果不想保存被修改的内容，则<span style="background-color: #ffaaaa">:q!</span>强制退出。</p><p>2.进入编辑模式</p><p><span style="background-color: #ffaaaa">i</span>(在光标前开始插入文本)</p><p><span style="background-color: #ffaaaa">a</span>(在光标后开始插入文本)</p><p><span style="background-color: #ffaaaa">o</span>(在当前行之下新开一行，并到行首)</p><p>3.光标移动</p><p>在一般模式下，hjkl这四个按键就可以移动光标</p><p><span style="background-color: #ffaaaa">h(左)j(下)k(上)l(右)</span></p><p>←↓↑→</p><p>4.快速的定位到某一行：</p><p>定位到文件头：<span style="background-color: #ffaaaa">ngg</span>光标移至第n行的行首（n为数字），</p><p>            如1gg就跳到第一行的行首，就是文件头</p><p>            如2gg就跳到第二行的行首</p><p>定位到文件尾：<span style="background-color: #ffaaaa">G</span></p><p>            注意：ngg和G是在一般模式</p><p>在某一行快速定位到某一列：</p><p><span style="background-color: #ffaaaa">0<span style="background-color: #ffaaaa">(</span></span>数字零)光标移至当前行行首</p><p><span style="background-color: #ffaaaa">$</span>光标移至当前行行末</p><p><span style="background-color: #ffaaaa">fx</span>搜索当前行中下一个出现字母x的地方</p><p>注意：0、$、fx是在一般模式</p><p>5.vi的难点：</p><p>1）vi操作之前，先判断一下当前是哪一种模式，再看光标所在位置。</p><p>当你不知道处于何种模式时，使用esc键返回到一般模式。</p><p>再看光标，难点在于移动光标，可以做到快速切换到某一行某一列。</p><p>6.文本复制、粘贴、删除、撤销</p><p><span style="background-color: #ffaaaa">yy</span>复制当前行(y:yank(复制))   </p><p><span style="background-color: #ffaaaa">nyy</span>复制当前行及其后的n-1行(n是数字)</p><p>        使用<span style="background-color: #ffaaaa">P</span>键来粘贴(p:paste)</p><p><span style="background-color: #ffaaaa">dd</span>  删除光标所在行(d:delete)</p><p><span style="background-color: #ffaaaa">ndd</span> 删除当前行及其后的n-1行(n是数字)</p><p>        按<span style="background-color: #ffaaaa">u</span>键来撤销上一步操作</p><p><span style="background-color: #ffaaaa">x</span>删除光标所在位置的字符</p><p>替换 　　「r」：替换光标所在处的字符。 ,按一下”r”然后输入要即可.</p><p>注意：</p><p>yy&#x2F;nyy&#x2F;dd&#x2F;ndd&#x2F;x&#x2F;u都是在一般模式。</p><p>7.查找和替换</p><p><span style="background-color: #ffaaaa">&#x2F;</span>pattern 从光标开始处向文件尾搜索pattern，后按下n或N</p><p>注意：</p><p><span style="background-color: #ffaaaa">        n</span>在同一个方向重复上一次搜索命令</p><p><span style="background-color: #ffaaaa">        N</span>在反方向重复上一次搜索命令</p><p>        n(N)来源于next</p><p>注意：在&#x2F;pattern之前先跳到第一行则进行全文件搜索。</p><span style="background-color: #ffaaaa"></span><p><span style="background-color: #ffaaaa">:%s&#x2F;p1&#x2F;p2&#x2F;g</span>将文件中所有的p1均用p2替换</p><p><span style="background-color: #ffaaaa">:%s&#x2F;p1&#x2F;p2&#x2F;g</span>c替换时需要确认</p><p><span style="background-color: #ffaaaa">s</span>:substitute替换</p><p><span style="background-color: #ffaaaa">g</span>:global全局</p><p><span style="background-color: #ffaaaa">c</span>:confirm确认</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nor和Nand启动</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/Nor%E5%92%8CNand%E5%90%AF%E5%8A%A8/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/Nor%E5%92%8CNand%E5%90%AF%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<p>1) 保存寄存器：CPU 运行的时候，用到了一些寄存器，对于这些寄存器的值，如果你不保存而直接跳转到子函数中去执行，那么很可能就被其破坏了，因为其函数执行也要用到这些寄存器。因此，在函数调用之前，应该将这些寄存器等现场，暂时保持起来(入栈 push)，等调用函数执行完毕返回后(出栈 pop)，再恢复现场，从而让CPU继续正确执行。(比如保存lr等寄存器，若main中也调用了其他函数，那么main函数保存在lr中的返回地址会被子函数返回地址所覆盖，所以需要保存lr等寄存器)</p><p>2) 传递参数：汇编代码调用 C 函数时，需传递参数。</p><p>3) 保存临时变量:包括函数的非静态局部变量以及编译器自动生成的其他临时变量，此函数中使用到了两个局部变量，就需要用到栈</p><p> </p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Makefile</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/Makefile/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/Makefile/</url>
    
    <content type="html"><![CDATA[<p>001_Makefile的引入及规则</p><p>使用keil, mdk, avr等工具开发程序时点点鼠标就可以编译了，</p><p>它的内部机制是什么？它怎么组织管理程序？怎么决定编译哪一个文件？</p><p>怎么使用makefile:</p><p>                        make [目标]                         若无目标则默认第一个目标</p><p>gcc -o test a.c b.c  </p><p>&#x2F;&#x2F; 简单,</p><p>&#x2F;&#x2F; 但是会对所有文件都处理一次,</p><p>&#x2F;&#x2F; 文件多时如果只修改其中一个文件会导致效率低</p><p>Makefile的核心---规则 :</p><p>目标 : 依赖1 依赖2 …</p><p>[TAB]命令</p><p>规则执行条件：</p><p>当”目标文件”不存在,或某个依赖文件比目标文件”新”，则: 执行”命令”</p><p>002_Makefile的语法</p><p>a. 通配符: %.o</p><p>   $@ 表示目标</p><p>   $&lt;  表示第1个依赖文件</p><p>   $^  表示所有依赖文件</p><p>(a.o:a.c                        (%.o:%.c</p><p>    gcc -c -o a.o a.c)           gcc -c -o $@ $&lt;) </p><p>b. 假想目标: .PHONY</p><p>clean:</p><p>    rm *.o test    若目录有同名的文件clean时，无法执行make clean操作,加入</p><p>.PHONY clean    就不会去判断名为clean的文件是否存在</p><p>c. 即时变量、延时变量, export</p><p>简单变量(即时变量) :</p><p>A :&#x3D; xxx   # A的值即刻确定，在定义时即确定</p><p>B &#x3D; xxx    # B的值使用到时才确定</p><p>:&#x3D;   # 即时变量</p><p>&#x3D;    # 延时变量</p><p>?&#x3D;   # 延时变量, 如果是第1次定义才起效, 如果在前面该变量已定义则忽略这句</p><p>+&#x3D;   # 附加, 它是即时变量还是延时变量取决于前面的定义</p><p>参考文档:</p><p>a. 百度搜 “gnu make 于凤昌”</p><p>b. 官方文档: <a href="http://www.gnu.org/software/make/manual/">http://www.gnu.org/software/make/manual/</a></p><p>如果想深入, 可以学习这视频:</p><p>第3期视频项目1, 第1课第4节_数码相框_编写通用的Makefile_P</p><p>003_Makefile函数</p><p>test&#x3D;$(var)，引用值</p><p>a. $(foreach var,list,text)        # 在list中的每一个变量执行text公式</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">A =a b c<br>B =<span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> F,<span class="hljs-variable">$(A)</span>,<span class="hljs-variable">$(f)</span>.o)</span>                          B=a.o b.o c.o<br></code></pre></td></tr></table></figure><p>b. $(filter pattern…,text)      # 在text中取出符合patten格式的值</p><p>   $(filter-out pattern…,text)  # 在text中取出不符合patten格式的值</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mel">C = a b c d/<br>D=$(<span class="hljs-keyword">filter</span>%/,$(C))                                   D=d/                        E = $(<span class="hljs-keyword">filter</span>-out %/, $(C))                            E=a b c<br></code></pre></td></tr></table></figure><p>c. $(wildcard pattern)            </p><p>                                    # pattern定义了文件名的格式,</p><p>                                    # wildcard取出其中真实存在的文件</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">目录下：<span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.c</span> <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.c</span> c<span class="hljs-selector-class">.c</span><br><br>files = $(wildcard *.c)                               files=<span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.c</span> c<span class="hljs-selector-class">.c</span>  <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.c</span><br><span class="hljs-attribute">all</span>:<br>    @echo files=$(files)<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">目录下：<span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.c</span> <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.c</span> c<span class="hljs-selector-class">.c</span><br>files2=<span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.c</span> <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.c</span> c<span class="hljs-selector-class">.c</span> d<span class="hljs-selector-class">.c</span> e<span class="hljs-selector-class">.c</span><br>files3= $(wildcard $(files2))                               files2=<span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.c</span> c<span class="hljs-selector-class">.c</span>  <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.c</span><br><span class="hljs-attribute">all</span>:<br>    @echo files2=$(files3)<br></code></pre></td></tr></table></figure><p>d. $(patsubst pattern,replacement,$(var))  </p><p>                                           # 从列表中取出每一个值</p><p>                                           # 如果符合pattern</p><p>                                           # 则替换为replacement</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">files<span class="hljs-number">2</span><span class="hljs-operator">=</span>a.<span class="hljs-keyword">c</span> b.<span class="hljs-keyword">c</span> <span class="hljs-keyword">c</span>.<span class="hljs-keyword">c</span> d.<span class="hljs-keyword">c</span> e.<span class="hljs-keyword">c</span> abc<br>dep_files <span class="hljs-operator">=</span> $(patsubst <span class="hljs-variable">%.c</span><span class="hljs-punctuation">,</span><span class="hljs-variable">%.d</span><span class="hljs-punctuation">,</span>$(files<span class="hljs-number">2</span>))<br><span class="hljs-symbol">all:</span><br>    <span class="hljs-title">@echo</span> dep_files <span class="hljs-operator">=</span> $(dep_files)             dep_files <span class="hljs-operator">=</span>a.d b.d <span class="hljs-keyword">c</span>.d d.d e.d abc<br></code></pre></td></tr></table></figure><p>004_Makefile实例</p><p>a. 改进: 支持头文件依赖</p><p><a href="http://blog.csdn.net/qq1452008/article/details/50855810">http://blog.csdn.net/qq1452008/article/details/50855810</a></p><p>gcc -M c.c &#x2F;&#x2F; 打印出依赖</p><p>gcc -M -MF c.d c.c  &#x2F;&#x2F; 把依赖写入文件c.d</p><p>gcc -c -o c.o c.c -MD -MF c.d  &#x2F;&#x2F; 编译c.o, 把依赖写入文件c.d</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mel">%.o:%.c<br>    gcc -c -o $@ $&lt; -MD -MF .$@.d <br></code></pre></td></tr></table></figure><p>b. 添加CFLAGS</p><p>CFLAGS编译参数</p><p>c. 分析裸板Makefile</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objs = a.o b.o c.o<br><br>dep_files := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %,.%.d, <span class="hljs-variable">$(objs)</span>)</span>        //把所有文件加上一个前缀.和后缀.d<br>dep_files := <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(dep_files)</span>)</span>           //判断是否存在，存在就把它包含进来<br><br>CFLAGS = -Werror -Iinclude                      //CFLAGS = -Werror把警告都变成错误<br>                        //<span class="hljs-comment">#include &quot;a.h&quot;在当前目录下搜索该文件</span><br>                        //-Iinclude 在文件目录下自行创建一个<span class="hljs-keyword">include</span>文件夹，将可改成<span class="hljs-comment">#include &lt;a.h&gt;在include目录下和gcc目录下寻找该文件</span><br><span class="hljs-section">test: <span class="hljs-variable">$(objs)</span></span><br>    gcc -o test <span class="hljs-variable">$^</span><br><br><span class="hljs-keyword">ifneq</span> (<span class="hljs-variable">$(dep_files)</span>,)                            //如果这个变量不等于空<br><span class="hljs-keyword">include</span> <span class="hljs-variable">$(dep_files)</span>                             //就包含进来<br><span class="hljs-keyword">endif</span>                                            <br><br>%.o : %.c<br>    gcc <span class="hljs-variable">$(CFLAGS)</span> -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span> -MD -MF .<span class="hljs-variable">$@</span>.d<br><span class="hljs-section">clean:</span><br>    rm *.o test<br><span class="hljs-section">distclean:</span><br>    rm <span class="hljs-variable">$(dep_files)</span><br>    <br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean    </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux入门命令</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/linux%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/linux%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p><strong>目录</strong></p><hr><ol><li>002节_shell命令解析器功能说明_P</li><li>003-007节_简单的Linux命令</li></ol><p><strong>002节_shell命令解析器功能说明_P</strong></p><hr><p>例:ls &#x2F;bin&#x2F;pwd</p><p>在shell中输入字符串并回车:</p><ol><li>shell根据第1个字符串ls找同名的应用程序</li></ol><ul><li><p>指定了路径，去路径下找</p></li><li><p>没有指定路径，去环境变量PATH所指定的目录中找</p></li></ul><ol start="2"><li>再把&#x2F;bin&#x2F;pwd作为参数传给应用程序，然后执行命令&#x2F;程序</li></ol><ul><li>成功，执行</li><li>失败，输出command not found</li></ul><p>command not found的原因:</p><ol><li>PATH所确定的目录中无此程序</li></ol><ul><li>添加环境变量</li></ul><ol start="2"><li>它不是可执行的程序</li></ol><ul><li>增加权限</li></ul><p>设置PATH环境变量添加我们的目录:</p><p>export PATH&#x3D;$PATH:&#x2F;my&#x2F;dir</p><p>课外知识点：</p><ul><li>shell程序：系统的用户界面，接受用户输入的命令并把它送入内核去执行，即一个命令解释器。</li><li>环境变量：在操作系统中用来指定操作系统运行环境的一些参数，具有特定的名字，包含了一个或多个应用程序所用到的信息。<ul><li>path环境变量：是告诉系统，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到哪些目录下去寻找。</li></ul></li><li>命令：可执行程序。</li></ul><p><strong>003-007节_简单的Linux命令</strong></p><hr><p>linux命令提示符：表示当前终端的状态</p><p><img src="/image/1.png" alt="1.png"></p><p>linux命令的格式：命令 [选项]  [参数]</p><ul><li>命令肯定存在</li><li>选项和参数可有可无。选项和参数取决于你使用该命令实现的具体目的。</li><li>选项是以”-“来指明的。  </li><li>命令、选项、参数之间是以空格来隔开的，一个或多个空格都视为1个空格。</li></ul><p>  如：ls -l &#x2F;home与ls   -l     &#x2F;home的目的是一样的。</p><ul><li>完成linux命令输入后，按下enter键，即可执行该命令。</li></ul><p>基础命令</p><hr><p><span style="background-color: #ffaaaa">pwd</span>(print working directory)：打印当前所在的路径</p><p><span style="background-color: #ffaaaa">cd</span>**(**change directory)：切换路径</p><p>    cd  ~切换到当前用户的家目录</p><p>    cd .  切换到当前路径</p><p>    cd .. 切换到上一级路径</p><p>    cd ..&#x2F;.. 切换到上上级路径(其中：在linux中路径分隔符为斜杠&#x2F;)</p><p>    cd -  切换到上一次的路径</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">linux目录结构<br>/           <span class="hljs-params">------------------</span>根目录/<br>|<span class="hljs-params">------bin</span>  <span class="hljs-params">------------------/bin</span><br>|<span class="hljs-params">------home</span> <span class="hljs-params">------------------/home</span><br>    |<span class="hljs-params">------book</span> <span class="hljs-params">------------------/home/book</span><br>    |<span class="hljs-params">------Guest</span> <span class="hljs-params">------------------/home/Guest</span><br>|<span class="hljs-params">------usr</span>  <span class="hljs-params">------------------/usr</span><br>    |<span class="hljs-params">------lib</span> <span class="hljs-params">------------------/usr/lib</span><br>    |<span class="hljs-params">------bin</span> <span class="hljs-params">------------------/usr/bin</span><br>举例：<br>绝对路径：如<span class="hljs-string">/home/book</span>  <br>相对路径：一般以.和<span class="hljs-string">..</span>来构成<br>1)当前路径为<span class="hljs-string">/bin</span>，然后输入<span class="hljs-string">./pwd</span>，就是执行了<span class="hljs-string">/bin/pwd</span><br>2)当前路径为<span class="hljs-string">/home/book/100ask</span>，然后<span class="hljs-keyword">cd</span> <span class="hljs-string">../Videos/</span>就到达<span class="hljs-string">/home/book/Videos</span>，或<span class="hljs-keyword">cd</span> <span class="hljs-string">../..</span>就到达<span class="hljs-string">/home</span><br></code></pre></td></tr></table></figure><p>注意事项：</p><ol><li>你切换的路径必须保证存在，可以使用ls命令来查看某一个路径下面的所有内容。</li><li>一定要记得多使用tab键。</li></ol><p><span style="background-color: #ffaaaa">ls</span>(list)：列出目录内容                                                                                                            </p><p>   命令   [选项]  [参数]</p><ul><li>ls：直接ls，则显示当前所在目录的内容</li><li>ls  目录名：</li></ul><p>如：ls &#x2F;home,则指定显示&#x2F;home的内容</p><p>如：ls ~    ,则指定显示&#x2F;home&#x2F;book的内容</p><ul><li>ls  选项或：ls 选项 目录名</li></ul><p>-l(long),显示目录下文件的更详细的信息(文件权限、文件最后修改时间、文件大小)</p><p>-a(all),显示了隐藏文件</p><p>-h(human-able),将文件大小以K(KB)、M(MB)、G(GB)来表示</p><p>目录的操作</p><hr><p><span style="background-color: #ffaaaa">mkdir</span>(make directory)：创建目录</p><p>    命令  [选项]  [参数]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">举例：<br>1)<span class="hljs-built_in">mkdir</span>   目录名<br><span class="hljs-built_in">mkdir</span> dir0   创建了dir0这个目录<br>2)<span class="hljs-built_in">mkdir</span> -p  父目录/子目录<br><span class="hljs-built_in">mkdir</span> -p  dir1/dir2<br></code></pre></td></tr></table></figure><p>-p(parents)</p><p>连续创建多级目录(父目录和子目录)，如果父目录不存在，则需要加入-p参数。</p><p><span style="background-color: #ffaaaa">rmdir</span> ：删除目录</p><p>举例：</p><p>1)rmdir  目录名</p><p>注意：rmdir不能删除非空目录(非空目录:该目录下面有子目录或者文件)</p><p>文件的操作</p><hr><p><span style="background-color: #ffaaaa">touch</span>：新建文件</p><p>    touch   文件名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">举例：<br><span class="hljs-built_in">touch</span> file1    在当前目录新建名为file1的文件<br></code></pre></td></tr></table></figure><p>注意：</p><ol><li>同一目录无法创建同名的文件</li><li>linux的文件名是区分大小写的，如file1和File1是不同文件。</li></ol><p>  </p><p><span style="background-color: #ffaaaa">mv</span>(move)：修改文件(目录)名、移动路径</p><p>    mv  旧文件名   新文件名    &#x3D;&#x3D;&#x3D;&#x3D;&gt;修改文件名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">    如：<span class="hljs-built_in">mv</span> file1 filea将当前目录的文件file1改名为filea<br></code></pre></td></tr></table></figure><p>    mv  旧目录名   新目录名    &#x3D;&#x3D;&#x3D;&#x3D;&gt;修改目录名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">    如：<span class="hljs-built_in">mv</span> dir1 dira将当前目录下的目录dir1改为dira<br></code></pre></td></tr></table></figure><p>    mv  文件名     目录名      &#x3D;&#x3D;&#x3D;&#x3D;&gt;移动路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">    如：<span class="hljs-built_in">mv</span> filea dira将当前目录下filea移动到dira子目录<br>    如：<span class="hljs-built_in">mv</span> filea  ~  将当前目录下filea移动家目录<br>    如：<span class="hljs-built_in">mv</span> ~/filea  ..将家目录下的fila移动到上一个路径<br></code></pre></td></tr></table></figure><p><span style="background-color: #ffaaaa">cp</span>(copy)：复制文件(目录)</p><p>cp  源文件名   目标文件名</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">举例：<br>    <span class="hljs-meta">cp</span> File1  file2将当前目录下的文件File1拷贝成file2<br></code></pre></td></tr></table></figure><p>cp  源文件名   目标目录名</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">举例：<br>    <span class="hljs-meta">cp</span> file2 dira/将当前目录下的文件file2拷贝到dira子目录<br></code></pre></td></tr></table></figure><p>cp  源目录名   目标目录名    </p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">举例：<br>    <span class="hljs-meta">cp</span> -r dira dirb复制dira目录下的所有内容到dirb<br></code></pre></td></tr></table></figure><p>    其中,-r参数是递归复制</p><p>    </p><p>    cp -i file2 dira如果dira目录下面有同名的file2，加入-i参数就会</p><p>    要求你确认是否覆盖同名的文件</p><p><span style="background-color: #ffaaaa">rm</span>(remove)：删除文件(目录)</p><p>    rm   [选项]   [文件名 | 目录名]</p><p>常用选项:</p><p>    -i(interactive(交互))，删除文件(目录)之前，要求你确认是否同意删除</p><p>    -r(recursive(递归))，递归删除指定目录下的子目录和文件</p><p>    -f(force(强制))，强制删除    </p><p>举例：</p><p>    rm File1       删除当前目录下的文件File1</p><p>    rm -i file2    删除文件file2，删除前要求你确认是否同意删除，其中y表明同意删除，n表示取消删除</p><p>    rm -r dira     删除目录dira</p><p>    rm -ir dirb    删除目录dirb，删除前要求你确认是否同意删除，其中y表明同意删除，n表示取消删除  </p><p>注意：删除文件(目录)前，确定该文件(目录)是否可以被删除。</p><p>文件的查看和编辑</p><hr><p>1)<span style="background-color: #ffaaaa">cat</span>  查看文件内容</p><p>    cat  文件名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">举例：<br>    <span class="hljs-built_in">cat</span> file1          将file1的内容打印到标准输出中(默认标准标准输出指向终端)<br>    <span class="hljs-built_in">cat</span> file1 file2    将file1和file2的内容串联并依次全部打印到标准输出中<br>    <span class="hljs-built_in">cat</span> -n file1       显示内容并在内容前显示行号。<br></code></pre></td></tr></table></figure><p>2)<span style="background-color: #ffaaaa">gedit</span>图形应用程序的编辑器</p><p>3)<span style="background-color: #ffaaaa">vi</span> 编辑器</p><p>清除屏幕</p><hr><p><span style="background-color: #ffaaaa">clear</span>：刷新屏幕，保留历史命令操作记录</p><p>说明：此命令本质上只是让终端向后翻一页，</p><p>当向上滚动鼠标时，还是可以看到之前命令的操作记录</p><p><span style="background-color: #ffaaaa">reset</span>：重新初始化屏幕，清除历史命令操作记录</p><p>帮助信息</p><hr><p><span style="background-color: #ffaaaa">man、info、--help</span></p><p>1)man使用的最多                                                                                                                    &#x2F;&#x2F;ls 常用选项为-l、-a、-h，可以通过man   ls来查看这些选项的含义。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stata">举例：<br>    <span class="hljs-keyword">man</span>   <span class="hljs-keyword">man</span>  查看<span class="hljs-keyword">man</span>手册的说明<br>    <span class="hljs-keyword">man</span>  <span class="hljs-keyword">ls</span>    当没有指定使用那一页，默认使用第1页<br>    <span class="hljs-keyword">man</span> 1 <span class="hljs-keyword">ls</span><br>    <span class="hljs-keyword">man</span> 1 gcc  gcc是一个应用程序，在linux中一般使用gcc编译器来编译c/c++语言的程序<br>    <span class="hljs-keyword">open</span>/write/<span class="hljs-keyword">read</span>/<span class="hljs-keyword">close</span>等等都是系统调用<br>    <span class="hljs-keyword">man</span> 2 <span class="hljs-keyword">open</span>   查看系统调用<span class="hljs-keyword">open</span>的<span class="hljs-keyword">man</span>手册说明<br></code></pre></td></tr></table></figure><p><img src="/image/2.png" alt="2.png"></p><p>注意：man手册共9册，当搜索内容同时在几个手册包含时需要指定哪本手册，默认第一册。</p><p>2)<span style="background-color: #ffaaaa">info</span></p><p>如info ls</p><p>3)<span style="background-color: #ffaaaa">--help</span></p><p>如ls --help</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux进阶命令</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/linux%E8%BF%9B%E9%98%B6%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/linux%E8%BF%9B%E9%98%B6%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p><span style="background-color: #ffaaaa">find</span></p><p>目的：查找符合条件的文件</p><p>格式：  find    目录名    选项    查找条件</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gradle">举例：<br><span class="hljs-number">1</span>）<span class="hljs-keyword">find</span> <span class="hljs-regexp">/work/</span><span class="hljs-number">001</span>_linux_basic<span class="hljs-regexp">/dira/</span>  -name <span class="hljs-string">&quot;test1.txt&quot;</span><br>说明:<br>    a)<span class="hljs-regexp">/work/</span><span class="hljs-number">001</span>_linux_basic<span class="hljs-regexp">/dira/</span>指明了查找的路径<br>    b)-name表明以名字来查找文件<br>    c)<span class="hljs-string">&quot;test1.txt&quot;</span>，就指明查找名为test1.txt的文件<br>同理：<br>    <span class="hljs-keyword">find</span> <span class="hljs-regexp">/work/</span><span class="hljs-number">001</span>_linux_basic<span class="hljs-regexp">/dira/</span>  -name <span class="hljs-string">&quot;*.txt&quot;</span>    <br>    查找指定目录下面所以以.txt结尾的文件，其中*是通配符，代表所有的。<br>    <span class="hljs-keyword">find</span> <span class="hljs-regexp">/work/</span><span class="hljs-number">001</span>_linux_basic  -name <span class="hljs-string">&quot;dira&quot;</span>    <br>    查找指定目录下面是否存在dira这个目录，dira是目录名。<br></code></pre></td></tr></table></figure><p>注意：</p><p>1）如果没有指定查找目录，则为当前目录。</p><p>    find .  -name “*.txt”   其中.代表当前路径</p><p>    find    -name “*.txt”</p><p>    都是一样的功能</p><p>2）find还有一些高级的用法，如查找最近几天(几个小时)之内(之前)有变动的文件</p><p>find &#x2F;home -mtime -2  查找&#x2F;home目录下两天内有变动的文件    </p><p>    </p><p><span style="background-color: #ffaaaa">grep</span></p><p>目的：使用grep命令来查找文件中符合条件的字符串</p><p>格式：grep  [选项]     [查找模式]  [文件名]</p><p>grep -rn “字符串”  文件名</p><p><span style="background-color: #ffaaaa">r</span>(recursive)：递归查找</p><p><span style="background-color: #ffaaaa">n</span>(number)：显示目标位置的行号</p><p>字符串:要查找的字符串</p><p>文件名:要查找的目标文件，如果是*则表示查找当前目录下的所有文件和目录    </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vim">举例：<br>将dira目录的test1.txt和dirb目录的test1.txt都含有如下内容：<br>aaa<br>AAAAAA<br><span class="hljs-keyword">abc</span><br>abcabcabc<br>cbacbacba<br>match_pattern<br>nand-&gt;erase<br><br><span class="hljs-keyword">grep</span> -n <span class="hljs-string">&quot;abc&quot;</span> test1.txt   在test1.txt中查找字符串<span class="hljs-keyword">abc</span><br><span class="hljs-keyword">grep</span> -rn <span class="hljs-string">&quot;abc&quot;</span> *          在当前目录递归查找字符串<span class="hljs-keyword">abc</span><br></code></pre></td></tr></table></figure><p>    </p><p>注意：</p><p>1）可以加入-w全字匹配。比如查找abc，遇到abcabc则不识别</p><p><span style="background-color: #ffaaaa">file</span>(linux下一切皆文件)</p><p>目的：识别文件类型</p><p>格式： file   文件名</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle">举例：<br><span class="hljs-keyword">file</span> ~/.bashrc        为ASCII 编码的text类型<br><span class="hljs-keyword">file</span> ~/.vimrc         为UTF-<span class="hljs-number">8</span> Unicode 编码的text类型<br><span class="hljs-keyword">file</span> ~<span class="hljs-regexp">/Pictures/</span>*     如图形文件JPEG<span class="hljs-regexp">/PNG/</span>BMP格式<br><span class="hljs-keyword">file</span> ~<span class="hljs-regexp">/100ask/</span>        为directory表明这是一个目录<br><span class="hljs-keyword">file</span> <span class="hljs-regexp">/bin/</span>pwd         出现 ELF <span class="hljs-number">64</span>-bit LSB executable，即为ELF格式的可执行文件<br><span class="hljs-keyword">file</span> <span class="hljs-regexp">/dev/</span>*           出现character special(字符设备文件)、 block special(块设备文件)等<br></code></pre></td></tr></table></figure><p><span style="background-color: #ffaaaa">which</span>和<span style="background-color: #ffaaaa">whereis</span></p><p>目的：查找命令或应用程序的所在位置</p><p>格式：which  命令名&#x2F;应用程序名</p><p>在终端上执行pwd实际上是去执行了&#x2F;bin&#x2F;pwd</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">举例：<br>    which pwd 定位到<span class="hljs-regexp">/bin/</span>pwd<br>    which gcc 定位到<span class="hljs-regexp">/usr/</span>bin/gcc<br>    whereis  pwd查找到可执行程序的位置<span class="hljs-regexp">/bin/</span>pwd和手册页的位置<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/man/m</span>an1/pwd.<span class="hljs-number">1</span>.gz<br></code></pre></td></tr></table></figure><p>压缩</p><p>1.压缩的概念</p><p>1）压缩的目的：</p><p>    在网络传递文件时，可以先将文件压缩，然后传递压缩后的文件，从而减少网络带宽。</p><p>    接受者接受文件后，解压即可。</p><p>2）压缩的类型:</p><p>   有损压缩、无损压缩。</p><p>   a)有损压缩：</p><p>    如mp4视频文件，即使压缩过程中，减少了很多帧的数据，</p><p>    对观看者而言，也没有影响。当然mp3音乐文件也是有损压缩。</p><p>   b)无损压缩：</p><p>    如普通文件的压缩，为了保证信息的正确传递，</p><p>    不希望文件经过压缩或解压后，出现问题。</p><p>2.linux下常用的压缩命令</p><p>单个文件的压缩(解压)使用gzip 和bzip2</p><p>多个文件和目录使用tar   </p><p><span style="background-color: #ffaaaa">gzip</span>的常用选项</p><p>-l(list)    列出压缩文件的内容</p><p>-k(keep)    在压缩或解压时，保留输入文件。</p><p>-d(decompress)    将压缩文件进行解压缩</p><p>1）查看</p><p>    gzip  -l 压缩文件名</p><p>    比如：gzip -l pwd.1.gz</p><p>2）解压</p><p>    gzip -kd  压缩文件名</p><p>    比如：gzip -kd pwd.1.gz</p><p>    该压缩文件是以.gz结尾的单个文件</p><p>3）压缩</p><p>    gzip -k  源文件名</p><p>    比如：gzip -k mypwd.1</p><p>    得到了一个.gz结尾的压缩文件</p><p>注意：</p><p>1）如果gzip不加任何选项，此时为压缩，压缩完该文件会生成后缀为.gz的压缩文件，并删除原有的文件，所以说，推荐使用gzip -k  来压缩源文件。</p><p>2）相同的文件内容，如果文件名不同，压缩后的大小也不同，因为文件名也占字节。</p><p>3）gzip只能压缩单个文件，不能压缩目录。</p><p>提示：</p><p>man pwd会解压&#x2F;usr&#x2F;share&#x2F;man&#x2F;man1&#x2F;pwd.1.gz这个文件，</p><p>然后读取该文件中固定的格式的一些信息，然后显示到终端中。</p><p><span style="background-color: #ffaaaa">bzip2</span>来压缩单个文件</p><p>bzip2的常用选项</p><p>-k(keep)    在压缩或解压时，保留输入文件。</p><p>-d(decompress)    将压缩文件进行解压缩</p><p>1）压缩</p><p>    bzip2  -k  源文件名</p><p>    比如：bzip2 -k mypwd.1</p><p>    得到一个.bz2后缀的压缩文件</p><p>2）解压</p><p>    bzip2  -kd  压缩文件名</p><p>    bzip2 -kd mypwd.1.bz2    </p><p>注意：</p><p>1）如果bzip2不加任何选项，此时为压缩，压缩完该文件会生成后缀为.bz2的压缩文件，并删除原有的文件，所以说，推荐使用bzip2 -k  来压缩源文件。</p><p>2）bzip2只能压缩单个文件，不能压缩目录。</p><p>单个文件的压缩使用gzip或bzip2，</p><p>压缩有两个参数：1）压缩时间  2）压缩比</p><p>一般情况下，小文件使用gzip来压缩，大文件使用bzip2来压缩。</p><p>mypwd.1源大小是1477字节，</p><p>    gzip压缩后mypwd.1.gz是877字节，</p><p>    bzip2压缩后mypwd.1.bz2是939字节。</p><p>myls.1源文件大小7664字节，</p><p>    gzip压缩后myls.1.gz是3144字节，</p><p>    bzip2压缩后myls.1.bz2是3070字节。    </p><p><span style="background-color: #ffaaaa">tar</span> 对多个目录、文件进行打包和压缩</p><p>常用选项</p><p>-c(create) ：表示创建用来生成文件包</p><p>-x：表示提取，从文件包中提取文件</p><p>-t：可以查看压缩的文件。</p><p>-z：使用gzip方式进行处理，它与”c“结合就表示压缩，与”x“结合就表示解压缩。</p><p>-j：使用bzip2方式进行处理，它与”c“结合就表示压缩，与”x“结合就表示解压缩。</p><p>-v(verbose)：详细报告tar处理的信息</p><p>-f(file)：表示文件，后面接着一个文件名。</p><p>-C  &lt;指定目录&gt;    解压到指定目录</p><p>1.tar打包、gzip压缩</p><p>1）压缩</p><p>    tar -czvf   压缩文件名   目录名</p><p>    如：tar czvf dira.tar.gz  dira                                                        &#x2F;&#x2F;注意：tar  -czvf与tar  czvf是一样的效果，所以说，后面统一取消-。</p><p>2）查看</p><p>    tar tvf   压缩文件名</p><p>    如：tar tvf dira.tar.gz</p><p>3）解压</p><p>    tar xzvf 压缩文件名</p><p>    tar xzvf 压缩文件名  -C  指定目录</p><p>    如：tar xzvf dira.tar.gz   解压到当前目录</p><p>    如：tar xzvf dira.tar.gz   -C  &#x2F;home&#x2F;book   解压到&#x2F;home&#x2F;book</p><p>    </p><p>2.tar打包、bzip2压缩</p><p>1）压缩</p><p>    tar cjvf   压缩文件名   目录名</p><p>    如：tar cjvf dira.tar.bz2  dira</p><p>2）查看</p><p>    tar tvf   压缩文件名</p><p>    如：tar tvf dira.tar.bz2</p><p>3）解压</p><p>    tar xjvf 压缩文件名</p><p>    tar xjvf 压缩文件名  -C  指定目录</p><p>    如：tar xjvf dira.tar.bz2   解压到当前目录</p><p>    如：tar xjvf dira.tar.bz2 -C  &#x2F;home&#x2F;book  解压到&#x2F;home&#x2F;book</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言指针复习</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>复习一下C语言中的指针</p><p>在64位机器中用八个字节表示指针，在在32位机器中用四个字节表示指针</p><p>&#x2F;* 第一步 : 所有变量都保存在内存中，我们打印一下变量的存储地址 *&#x2F;</p><p>&#x2F;* 第二步：所有变量都可以保存某些值,接着赋值并打印 *&#x2F;    </p><p>&#x2F;* 第三步：使用指针：1)取值  2)移动指针 *&#x2F;    </p><p><img src="/image/c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E5%A4%8D%E4%B9%A0.jpg" alt="c语言指针复习.jpg"></p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>&amp;变量,目的：获得变量在内存中的地址</p><p>      返回: 变量在内存中的起始地址</p><p>结论：指针变量所存储的内容是所指向的变量在内存中的起始地址。</p><p>小端模式：低字节--&gt;低地址        高字节--&gt;高地址</p><p>0x12345678所以ia的地址由高到低保存为12,34,56,78</p><p>    高--&gt;低</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>指针对连续空间进行操作时：</p><p>1）取值   </p><p>2）移动指针</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>指针加数值的问题</p><p>抽象T *t; t是一个指针变量，里面装的是一个地址值。</p><p>          经过t&#x3D;t+n(数值),t的值增加了n*sizeof(T)个字节，</p><p>        </p><p>char *pc;pc&#x3D;pc+1; sizeof(char)&#x3D;1字节,经过pc&#x3D;pc+1之后，pc加了1个字节  </p><p>int *pi;pi&#x3D;pi+1;  sizeof(int)&#x3D;4字节,经过pi&#x3D;pi+1之后，pc加了4个字节      </p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;    </p><p>char ca[3]&#x3D;{‘A’,’B’,’C’};</p><p>char *pc &#x3D; ca;</p><p>      pc是指向字符数组的字符指针,pc就是数组首元素的地址,pc&#x3D;&amp;a[0]</p><p>char *pc&#x3D;”abc”;</p><p>      pc是指向字符串的字符指针,pc就是字符串”abc”的首字符’a’的地址</p><p>    </p><p>    </p><p>    </p><p>    </p><p>    </p><p>    </p><p>    </p><p>    </p><p>    </p><p>    </p><p>    </p><p>    </p><p>    </p><p>    </p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(待修改)硬件知识_内存接口概念__不同位宽设备的连接_时序图工作实例</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/(%E5%BE%85%E4%BF%AE%E6%94%B9)%E7%A1%AC%E4%BB%B6%E7%9F%A5%E8%AF%86_%E5%86%85%E5%AD%98%E6%8E%A5%E5%8F%A3%E6%A6%82%E5%BF%B5-%E4%B8%8D%E5%90%8C%E4%BD%8D%E5%AE%BD%E8%AE%BE%E5%A4%87%E7%9A%84%E8%BF%9E%E6%8E%A5_%E6%97%B6%E5%BA%8F%E5%9B%BE%E5%B7%A5%E4%BD%9C%E5%AE%9E%E4%BE%8B/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/(%E5%BE%85%E4%BF%AE%E6%94%B9)%E7%A1%AC%E4%BB%B6%E7%9F%A5%E8%AF%86_%E5%86%85%E5%AD%98%E6%8E%A5%E5%8F%A3%E6%A6%82%E5%BF%B5-%E4%B8%8D%E5%90%8C%E4%BD%8D%E5%AE%BD%E8%AE%BE%E5%A4%87%E7%9A%84%E8%BF%9E%E6%8E%A5_%E6%97%B6%E5%BA%8F%E5%9B%BE%E5%B7%A5%E4%BD%9C%E5%AE%9E%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<p>对于CPU来说，只需要把数据发给寄存器(数据并不输出到外部电路，只到寄存器中)，再由控制器(内部的控制器决定这些数据起什么作用)发出对应波形</p><p>        1.GPIO&#x2F;门电路接口(通过控制器决定CPU发来的地址起什么作用)</p><p>        2.协议类接口：UART,IIC等(通过控制器决定CPU发来的地址起什么作用)</p><p>        4.NandFlash控制器：外接NandFlash(NandFLash不参与CPU统一编制)</p><p>        3.内存接口：内存类设备(Nor、网卡、SDRAM) </p><p>                            CPU可以直接把地址传递给这些设备(地址线、数据线都直接连接到芯片上)</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>SDRAM、DM9000、NOR公用地址总线、数据总线，它们如何才能互不干扰？</p><p>    它们都有一个片选引脚CSchip select，谁来通过地址选择哪个芯片？是内存控制器</p><p>    CPU把地址发给内存控制器，内存控制器跟据不同的地址决定发出哪个片选信号</p><p>地址和片选信号的关系</p><p><img src="/image/e85803c6efa27ee9327c9b644609033c.png" alt="e85803c6efa27ee9327c9b644609033c.png"></p><p>例如：0&lt;&#x3D;addr&lt;&#x3D;0x0800,0000，使nGCS0输出低电平，片选Nor</p><p>        </p><p>1、2、3它们的地址都是CPU统一编排的，都属于CPU统一编制，而NandFlash不属于CPU统一编排</p><p>如何让访问内存时Nand不干扰？Nand也有片选信号，由Nand控制器发出，只有CPU访问到Nand控制器的某个寄存器时，才会发出片选信号访问NandFlash</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p><img src="/image/3e7d5249bee8d4d2f430459a83d89755.png" alt="3e7d5249bee8d4d2f430459a83d89755.png"></p><p>每一个片选信号可选择的地址范围空间是128M&#x3D;227，至少需要A0,A1,…..A26共27条地址线</p><p>32位的CPU把32位的addr发给内存控制器，但因为内存控制器能力有限只利用到了其中的27条</p><p>从这向上介绍了CPU与内存设备之间连接的线有地址线，数据线，片选线，</p><p>如何确定CPU是从内存设备中读还是写?</p><p>引入nOR,nOW，使能来决定Only Read,Only Write</p><p>如何分辨数据是由CPU写给内存设备，还是由CPU从内存设备读出？</p><p>需有引脚确认数据的传输方向</p><p>        在网卡中：使用两条引脚分别表示读或者写</p><p><img src="/image/c62901bfe83f82dafe729ad4e4859d9f.png" alt="c62901bfe83f82dafe729ad4e4859d9f.png"></p><p>        CPU可以使LnOE变为低电平表示使用这个引脚读数据</p><p>        使LnWE变为低电平表示要将数据写给网卡芯片</p><p>        在NorFlash中：使用两条引脚分别表示读或者写</p><p><img src="/image/6aa71301e9e56153f0d875066245619e.png" alt="6aa71301e9e56153f0d875066245619e.png"></p><p>        CPU可以使LnOE变为低电平表示使用这个引脚读数据</p><p>        使LnWE变为低电平表示要将数据写给NorFlash</p><p>        在SDRAM中：使用一条引脚表示读或写</p><p><img src="/image/087d110e4b9740968fa83f7c5436b450.png" alt="087d110e4b9740968fa83f7c5436b450.png"></p><p>        当LnWE是低电平的时候表示CPU要将数据写给SDRAM</p><p>        为高电平时表示CPU要从SDRAM中读数据</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p><img src="/image/02318db71e6a55e20901609fa0d93775.png" alt="02318db71e6a55e20901609fa0d93775.png"></p><p><img src="/image/16aa956fd18bfde9f12f631d448d7e57.png" alt="16aa956fd18bfde9f12f631d448d7e57.png"></p><p><img src="/image/e22139f880830a6a030e9a625a31798a.png" alt="e22139f880830a6a030e9a625a31798a.png"></p><p>上面图中，为什么NorFlash，SDRAM都不是A0接A0，网卡更是只用到了一条地址线，为什么？</p><p>查看芯片手册的举例</p><p><img src="/image/7a9fdd67e1e2707b8627305eb8ad9670.png" alt="7a9fdd67e1e2707b8627305eb8ad9670.png"></p><p><img src="/image/41be7372d72c0edb52d0e0533186d99b.png" alt="41be7372d72c0edb52d0e0533186d99b.png"></p><p>图中可以看出</p><p>当你使用两个8bit的ROM拼起来变成16位芯片的时候，CPU的A1就要接到A0</p><p>当你使用四个8bit的ROM拼起来变成32位芯片的时候，CPU的A2就要接到A0</p><p>得知外接芯片的位宽有变化，地址线的接发也有变化</p><p><strong>举例一：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">假设CPU执行：            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">R0</span>,<span class="hljs-number">#3</span><br>                        <span class="hljs-keyword">LDRB</span> <span class="hljs-built_in">R1</span>,[<span class="hljs-built_in">R0</span>]<br>去地址<span class="hljs-number">3</span>读取一个字节<br></code></pre></td></tr></table></figure><p><img src="/image/ab4e832099bc0bb3f37e66a35647f7eb.png" alt="ab4e832099bc0bb3f37e66a35647f7eb.png"></p><p>在16bit ROM中，取出的是第一个16bit的数据</p><p>在32bit ROM中，取出的是第0个32bit的数据</p><p>但我们需要的是一个8bit的数据，如何从16&#x2F;32bit数据中挑出这8bit的数据？</p><p>使用内存控制器挑出16bit中第A0个数据给CPU，从32bit中第A1A0个数据给CPU</p><p><img src="/image/2153866fc498b9fc1a90c1c55a53c637.png" alt="2153866fc498b9fc1a90c1c55a53c637.png"></p><p>结果：内存控制器发出的地址线有一部分接到了芯片上，这些接上的引脚用来确定读取芯片的哪一个单元，把这个单元的数据返回给内存控制器，而内存控制器使用那些没有接的引脚来确定从这些单元中取出哪一个字节返回给CPU</p><p>                    比如：A0是给内存控制器使用的，用来选择这16位数据中的低八位还是高八位</p><p>                        <img src="/image/6666943883922af52bee5a37fbdf3905.png" alt="6666943883922af52bee5a37fbdf3905.png"></p><p><strong>举例二：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">假设CPU执行：            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">R0</span>,<span class="hljs-number">#4</span><br>                        <span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R1</span>,[<span class="hljs-built_in">R0</span>]<br>去地址<span class="hljs-number">4</span>读取四个字节，即读取<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>这四个字节<br></code></pre></td></tr></table></figure><p><img src="/image/f278b1dc119f0655900c693c2a86239a.png" alt="f278b1dc119f0655900c693c2a86239a.png"></p><p>内存控制器的作用：1.CPU把地址发送给内存控制器，内存控制器根据地址选择不同的模块（ROM），然后把数据发给模块&#x2F;或者取出数据给CPU</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>怎么根据电路图确定芯片访问地址？</p><p>1.根据片选信号确定基址</p><p>2.根据芯片所接地址线确定范围</p><p><img src="/image/355aa45588c8f8c220221dc220f189dc.png" alt="355aa45588c8f8c220221dc220f189dc.png"></p><p>Nor：CPU发出的A1-A20接上芯片上，A0是给内存控制器用来选择16位数据中的低八位和高八位的，所以用到A0-A20共21条线</p><p>最多支持NorF0lash是2M空间</p><p>网卡只接A2,16位数据只需要一个A0选择，我们不关心A1</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>2440 Read时序图(查看各个引脚如何协同工作)：1先发出地址信号，2才发出片选信号，3再发出读信号，过了一会，4数据才有效</p><p>将数据读走，5然后释放读信号，6释放片选信号</p><p><img src="/image/5d1de58defba2376f590697434d07322.png" alt="5d1de58defba2376f590697434d07322.png"></p><p>这些时间值要根据所接芯片的性能设置，以NorFLash举例</p><p>Nor时序图</p><p><img src="/image/5a1dd584fa24fc0e53498fc34f8aa296.png" alt="5a1dd584fa24fc0e53498fc34f8aa296.png"></p><p>Taa：收到addr后多长时间Data才有效，Max&#x3D;70ns保证芯片接收到地址信号70ns之后有数据可供访问，但不能保证70ns之内访问的数据是正确的</p><p>Tce：收到片选信号后多长时间Data才有效，Max&#x3D;70ns保证芯片接收到片选信号70ns之后有数据可供访问，但不能保证70ns之内访问的数据是正确的</p><p>Toe：收到OE信号后多长时间Data才有效，Max&#x3D;30ns：2440发出读信号，保证在30ns之后有数据可供使用，但不能保证30ns之内数据是可靠的</p><p>Toh：数据保持时间，为0</p><p>Tdf：即使片选信号已经释放，此时并没有选定该芯片，但在Tdf时间内也不能访问其他芯片，因为此时数据还不稳定</p><p>Trc：读周期时间，Min&#x3D;70ns，NandFlash每读一次至少花费70ns时间</p><p>需要设置这些时间可以满足2440,为了简单让地址信号，片选信号，读信号同时发出，然后保持Tacc大于等于70ns，就可以满足芯片时序</p><p>查找芯片手册寻找如何设置Tacc，因为NorFlash接的是片选线0，所以选用BANKCON</p><p><img src="/image/064865ee0117734946963d5cc60591ca.png" alt="064865ee0117734946963d5cc60591ca.png"></p><p>可以看到默认Tacc值为111，一上电时是用晶振运行的</p><p>            HCLK为12MHZ，Tacc&#x3D;14 * HCLK</p><p>            则默认值为：(1000&#x2F;12) * 14&#x3D; 116ns</p><p>可以看出上电后，它使用最保险的参数</p><p>            假设HCLK&#x3D;100M，T&#x3D;1000&#x2F;100 &#x3D; 10ns</p><p>            Tacc需要&gt;&#x3D; 70ns，BANKCON[10:8] &#x3D; 0b101</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>对于NandFlash我们需要设置BWSCON 和 BANKCON0两个寄存器，检查发现BWSCON采用默认值即可</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPU的工作模式_状态和寄存器</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/CPU%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F_%E7%8A%B6%E6%80%81%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/CPU%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F_%E7%8A%B6%E6%80%81%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>002节</strong></p><p><strong>7种Mode:</strong></p><ul><li>usr&#x2F;sys 正常&#x2F;兴奋模式</li><li>undefined(und) 未定义指令模式</li><li>Supervisor(svc) 管理模式</li><li>Abort(abt) 中止模式<ul><li>指令预取中止：CPU读指令时，它执行当前指令时已经在解析第二条指令，同时也在读取第三条指令，第三条指令的读取即预取，有可能出错</li><li>数据访问中止：比如访问某个地址时出错了</li></ul></li><li>IRQ(irq) 中断模式</li><li>FIQ(fiq) 快中断模式</li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima">五种异常模式：<span class="hljs-literal">und</span>，svc，abt，irq，fiq<br>六种特权模式(Privileged mode)：sys，<span class="hljs-literal">und</span>，svc，abt，irq，fiq<br>    除了用户模式以外，其他<span class="hljs-number">6</span>种都是特权模式<br>    特权模式中，可以编程操作CPSR直接进入其他模式；在用户模式下，不可以切换成特权模式<br></code></pre></td></tr></table></figure><p><strong>2种State:</strong></p><ul><li>ARM state</li><li>Thumb state</li></ul><p><strong>寄存器：</strong></p><ul><li>通用寄存器</li><li>备份寄存器(banked register)</li><li>当前程序状态寄存器(Current Program Status Register);CPSR</li><li>CPSR的备份寄存器:SPSR(Save Program Status Register)</li></ul><hr><p>发生某种异常时，会进入某种异常模式，在这种异常模式下更容易处理这些异常</p><p>在各种异常模式下，它们拥有的其实就是寄存器的差别</p><p><img src="/image/f693c816f656497d8840275d2ba74ec3.png" alt="f693c816f656497d8840275d2ba74ec3.png"></p><p>这个图是有关各个模式下能访问寄存器的，再讲这个图之前我们先引入 2种state</p><p>CPU有两种state:</p><p>a. ARM state:使用ARM指令集，每个指令4byte</p><p>b. Thumb state:使用的是Thumb指令集，每个指令2byte</p><p>比如同样是:</p><p>mov R0, R1 编译后</p><p>对于ARM指令集要占据4个字节：机器码</p><p>对于Thumb指令集占据2个字节：机器码</p><p>引入Thumb减少存储空间</p><p>ARM指令集与Thumb指令集的区别：</p><p>Thumb 指令可以看作是 ARM 指令压缩形式的子集,是针对代码密度的问题而提出的,它具有 16 位的代码密度但是它不如ARM指令的效率高 .</p><p>Thumb 不是一个完整的体系结构,不能指望处理只执行Thumb 指令而不支持 ARM 指令集.</p><p>因此,Thumb 指令只需要支持通用功能,必要时可以借助于完善的 ARM 指令集,比如,所有异常自动进入 ARM 状态.在编写 Thumb 指令时,先要使用伪指令 CODE16 声明,而且在 ARM 指令中要使用 BX指令跳转到 Thumb 指令,以切换处理器状态.编写 ARM 指令时,则可使用伪指令 CODE32声明.</p><p>下节课会演示使用Thumb指令集编译，看是否生成的bin文件会变小很多</p><p>在每种模式下都有R0 ~ R15</p><p>在这张图注意到有些寄存器画有灰色的三角形，表示访问该模式下访问的专属寄存器 比如</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R8</span><br></code></pre></td></tr></table></figure><p>在System 模式下访问的是R0 ~ R8,在所有模式下访问R0都是同一个寄存器</p><p>但是在FIQ模式下，访问R8是访问的FIQ模式专属的R8寄存器，不是同一个物理上的寄存器</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">R0</span>, <span class="hljs-built_in">R8</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">R0</span>, R8_fiq<br></code></pre></td></tr></table></figure><p>在这五种异常模式中每个模式都有自己专属的R13 R14寄存器，R13用作SP(栈) R14用作LR(返回地址) LR是用来保存发生异常时的指令地址</p><p>为什么快中断(FIQ模式)有那么多专属寄存器，这些寄存器称为备份寄存器</p><p>回顾一下中断的处理过程</p><p>a. 保存现场(保存被中断模式的寄存器)</p><p>就比如说我们的程序正在系统模式&#x2F;用户模式下运行，当你发生中断时，需要把R0 ~ R14这些寄存器全部保存下来，让后处理异常，最后恢复这些寄存器</p><p>但如果是快中断，那么我就不需要保存 系统&#x2F;用户模式下的R8 ~ R12这几个寄存器，在FIQ模式下有自己专属的R8 ~ R12寄存器，省略保存寄存器的时间，加快处理速度</p><p>但是在Linux中并不会使用FIQ模式</p><p>b. 处理</p><p>c. 恢复现场</p><p>CPSR：当前程序状态寄存器，这是一个特别重要的寄存器</p><p>SPSR保存的程序状态寄存器</p><p>它们格式如下：</p><p><img src="/image/c315e75974db39349489c5211b268ccd.png" alt="c315e75974db39349489c5211b268ccd.png"></p><p>首先 M4 ~ M0 表示当前CPU处于哪一种模式(Mode)；</p><p>我们可以读取这5位来判断CPU处于哪一种模式，也可以修改这些模式位，让它进入某种模式；</p><p>当然若你当前处于用户模式下，是没有权限修改这些位的；</p><p>M4 ~ M0对应什么值，会有说明：</p><p><img src="/image/50a0730e0d3c716809ecc6d351809fbf.png" alt="50a0730e0d3c716809ecc6d351809fbf.png"></p><p>查看其他位</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">Bit5 </span>State <span class="hljs-keyword">bits表示CPU工作与Thumb </span>State还是ARM State用的指令集是什么<br><span class="hljs-keyword">Bit6 </span>FIQ <span class="hljs-keyword">disable当bit6等于1时，FIQ是不工作的</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">Bit7 </span>IRQ <span class="hljs-keyword">disable当bit5等于1时，禁止所有的IRQ中断，这个位是IRQ的总开关</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">Bit8 </span>~ <span class="hljs-keyword">Bit27是保留位</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">Bite28 </span>~ <span class="hljs-keyword">Bit31是状态位，</span><br></code></pre></td></tr></table></figure><p>什么是状态位，比如说执行一条指令cmp R0, R1</p><p>如果R0 等于 R1 那么zero位将等于1，即这条指令影响 Z 位，如果R0 &#x3D;&#x3D; R1，则Z &#x3D; 1</p><p>beq xxx 这条跳转指令会判断Bit30是否为1，是1的话则跳转，不是1的话则不会跳转：即Z 位，如果 Z 位等于1 则跳转，这些指令是借助状态位实现的</p><p>SPSR(保存的程序状态寄存器)： 表示发生异常时这个寄存器会用来保存被中断的模式下它的CPSR</p><p>比如我的程序在系统模式下运行 CPSR是某个值，当发生中断时会进入irq模式，irq模式下有一个它专属的CPSR_irq寄存器，这个CPSR_irq就保存着被中断模式的系统模式下的CPSR</p><p>我们来看看发生异常时CPU是如何协同工作的：</p><p>进入异常的处理流程(硬件)：</p><p><img src="/image/2668da5cb375777e2ef323e66720bdf7.png" alt="2668da5cb375777e2ef323e66720bdf7.png"></p><p>翻译一下：</p><p>发生异常时，我们的CPU会做什么事情</p><p>a. 把下一条指令的地址保存在LR寄存器里(某种异常模式的LR寄存器等于被中断的下一条指令的地址)，它有可能是PC + 4有可能是PC + 8,到底是那种取决于不同的情况</p><p>b. 把CPSR保存在SPSR里面(某一种异常模式下SPSR里面的值等于CPSR)</p><p>c. 修改CPSR的模式为进入异常模式(修改CPSR的M4 ~ M0进入异常模式)</p><p>d. 跳到向量表</p><p>退出异常怎么做？</p><p><img src="/image/ea57846e8a843997a6ab0f0bc93b3105.png" alt="ea57846e8a843997a6ab0f0bc93b3105.png"></p><p>a. 让LR减去某个值，让后赋值给PC(PC &#x3D; 某个异常LR寄存器减去 offset)</p><p>减去什么值呢？</p><p>也就是说我们怎么返回去继续执行原来的程序，根据下面这个表来取值</p><p>Table 2-2</p><p><img src="/image/1da882ad2d1b6a4435c7d7b1842bdfaa.png" alt="1da882ad2d1b6a4435c7d7b1842bdfaa.png"></p><p>如果发生的是SWI可以把 R14_svc复制给PC</p><p>如果发生的是IRQ可以把R14_irq的值减去4赋值给PC</p><p>b. 把CPSR的值恢复(CPSR值等于某一个异常模式下的SPSR)</p><p>c. 清中断（如果发生的是中断的话，对于其他异常不用设置）</p><p>003节（一点不重要）</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">all: led.o uart.o init.o main.o start.o<br>    <span class="hljs-comment">#arm-linux-ld -Ttext 0 -Tdata 0x30000000  start.o led.o uart.o init.o main.o -o sdram.elf</span><br>    arm-linux-ld -T sdram.lds start.o led.o uart.o init.o main.o -o sdram.elf<br>    arm-linux-objcopy -O binary -S sdram.elf sdram.bin<br>    arm-linux-objdump -D sdram.elf &gt; sdram.dis<br>clean:<br>    rm *<span class="hljs-string">.bin</span> *<span class="hljs-string">.o</span> *<span class="hljs-string">.elf</span> *<span class="hljs-string">.dis</span><br>%<span class="hljs-string">.o</span> : %<span class="hljs-string">.c</span><br>    arm-linux-gcc -mthumb -c -o $@ $&lt;    <span class="hljs-string">//</span>对于所有的C文件，加上这个就可以用thumb指令集来编译<br>%<span class="hljs-string">.o</span> : %<span class="hljs-string">.S</span><br>    arm-linux-gcc -c -o $@ $&lt;<br></code></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">/* start.S */</span><br><br><span class="hljs-symbol">.text</span><br><span class="hljs-symbol">.global</span> _start<br><span class="hljs-symbol">.code</span> <span class="hljs-number">32</span>        <span class="hljs-comment">//表示后续的指令使用thumb指令集</span><br><span class="hljs-symbol">_start:</span><br><br>    <span class="hljs-comment">/* 关闭看门狗 */</span><br><br>    <span class="hljs-comment">/* 设置MPLL, FCLK : HCLK : PCLK = 400m : 100m : 50m */</span><br><br>    <span class="hljs-comment">/* CLKDIVN(0x4C000014) = 0X5, tFCLK:tHCLK:tPCLK = 1:4:8  */</span><br><br>    <span class="hljs-comment">/* 设置CPU工作于异步模式 */</span><br><br>    <span class="hljs-comment">/* 设置MPLLCON(0x4C000004) = (92&lt;&lt;12)|(1&lt;&lt;4)|(1&lt;&lt;0)</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-comment">/* 设置内存: sp 栈 */</span><br><br>    <span class="hljs-comment">/* 怎么从ARM State切换到Thumb State? */</span><br>    <span class="hljs-keyword">adr</span> <span class="hljs-built_in">r0</span>, thumb_func<br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">r0</span>, <span class="hljs-number">#1</span>  <span class="hljs-comment">/* bit0=1时, bx就会切换CPU State到thumb state */</span><br>    <span class="hljs-keyword">bx</span> <span class="hljs-built_in">r0</span><br>    <br><span class="hljs-symbol">.code</span> <span class="hljs-number">16</span>    <br><span class="hljs-symbol">thumb_func:</span>    <br>    <span class="hljs-keyword">bl</span> sdram_init<br>    <span class="hljs-comment">//bl sdram_init2     /* 用到有初始值的数组, 不是位置无关码 */</span><br><br>    <span class="hljs-comment">/* 重定位text, rodata, data段整个程序 */</span><br>    <span class="hljs-keyword">bl</span> copy2sdram<br><br>    <span class="hljs-comment">/* 清除BSS段 */</span><br>    <span class="hljs-keyword">bl</span> clean_bss<br><br>    <span class="hljs-comment">//bl main  /* 使用BL命令相对跳转, 程序仍然在NOR/sram执行 */</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-symbol">=main</span>  <span class="hljs-comment">/* 绝对跳转, 跳到SDRAM */</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">pc</span>, <span class="hljs-built_in">r0</span><br><br><span class="hljs-symbol">halt:</span><br>    <span class="hljs-keyword">b</span> halt<br></code></pre></td></tr></table></figure><span style="background-color: #ffaaaa"></span><span style="background-color: #ffaaaa"></span><p><strong>第004节_und异常模示程序示例</strong></p><hr><p>写一个程序故意让其发生未定义异常，让后处理这个异常</p><p>查看uboot中源码uboot\u-boot-1.1.6\cpu\arm920t</p><p>打开start.S找到一场向量表</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-comment">/*code: 28 -- 72*/</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;config.h&gt;</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;version.h&gt;</span></span><br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Jump vector table as in table 3.1 in [1]</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> GSTATUS2   (0x560000B4)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> GSTATUS3   (0x560000B8)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> GSTATUS4   (0x560000BC)</span><br>    <br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> REFRESH(0x48000024)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> MISCCR (0x56000080)</span><br>    <br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> LOCKTIME  0x4C000000     <span class="hljs-comment">/* R/W, PLL lock time count register */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> MPLLCON           0x4C000004  <span class="hljs-comment">/* R/W, MPLL configuration register */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> UPLLCON           0x4C000008  <span class="hljs-comment">/* R/W, UPLL configuration register */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> CLKCON            0x4C00000C  <span class="hljs-comment">/* R/W, Clock generator control reg. */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> CLKSLOW           0x4C000010  <span class="hljs-comment">/* R/W, Slow clock control register */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> CLKDIVN           0x4C000014  <span class="hljs-comment">/* R/W, Clock divider control */</span></span><br>    <br>    <span class="hljs-comment">/******下面这些就是异常向量表*****/</span><br>    .globl <span class="hljs-variable">_start</span><br>    <span class="hljs-variable">_start</span>:     b   reset<br>        ldr      pc, <span class="hljs-variable">_undefined_instruction</span><br>        ldr      pc, <span class="hljs-variable">_software_interrupt</span><br>        ldr      pc, <span class="hljs-variable">_prefetch_abort</span><br>        ldr      pc, <span class="hljs-variable">_data_abort</span><br>        ldr      pc, <span class="hljs-variable">_not_used</span><br>        ldr      pc, <span class="hljs-variable">_irq</span><br>        ldr      pc, <span class="hljs-variable">_fiq</span><br>    <br>    <span class="hljs-variable">_undefined_instruction</span>:     .word undefined_instruction<br>    <span class="hljs-variable">_software_interrupt</span>:        .word software_interrupt<br>    <span class="hljs-variable">_prefetch_abort</span>:    .word prefetch_abort<br>    <span class="hljs-variable">_data_abort</span>:                .word data_abort<br>    <span class="hljs-variable">_not_used</span>:          .word not_used<br>    <span class="hljs-variable">_irq</span>:                       .word irq<br>    <span class="hljs-variable">_fiq</span>:                       .word fiq<br>    <br>        .balignl <span class="hljs-number">16</span>,<span class="hljs-number">0</span>xdeadbeef<br></code></pre></td></tr></table></figure><p>可以在手册中找到异常向量表</p><p><img src="/image/375020a76d4189cc942a9d90be8971eb.png" alt="375020a76d4189cc942a9d90be8971eb.png"></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">/* start.S */</span><br>    <span class="hljs-meta">.text</span><br>    <span class="hljs-meta">.global</span> _start<br>    <br>    _start:<br>        <span class="hljs-keyword">b</span> reset  <span class="hljs-comment">/* vector 0 : reset */</span> <span class="hljs-comment">//一上电复位，是从0地址开始执行，跳到reset处</span><br>        <span class="hljs-keyword">b</span> do_und <span class="hljs-comment">/* vector 4 : und */</span> <br>            <span class="hljs-comment">//如果发生未定义指令异常，就会跳到0x04地址未定义指令异常处，执行do_und程序</span><br>    <br>    <span class="hljs-comment">/* 假设一上电从0地址开始执行，reset，做一系列初始化之后    </span><br><span class="hljs-comment">     * 故意加入一条未定义指令:            </span><br><span class="hljs-comment">        und_code:         </span><br><span class="hljs-comment">            .word 0xdeadc0de  /* 未定义指令 */</span><br>        当CPU发现无法执行此条指令时，就会发生未定义指令异常，就会执行do_und<br>        即<span class="hljs-keyword">bl</span> print2，<br>     */<br>    do_und:<br>        <span class="hljs-comment">/* 执行到这里之前:          </span><br><span class="hljs-comment">         * 1. lr_und保存有被中断模式中的下一条即将执行的指令的地址          </span><br><span class="hljs-comment">         * 2. SPSR_und保存有被中断模式的CPSR          </span><br><span class="hljs-comment">         * 3. CPSR中的M4-M0被设置为11011, 进入到und模式          </span><br><span class="hljs-comment">         * 4. 跳到0x4的地方执行程序           </span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-comment">/* 需要从新设置sp栈，指向某一块没有使用的地址</span><br><span class="hljs-comment">         * 为什么要设置栈，因为这个栈是und模式里的栈，从来没有人设置它 </span><br><span class="hljs-comment">         * sp_und未设置, 先设置它 </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">=0x34000000</span><br>        <br>        <span class="hljs-comment">/* 保存现场：</span><br><span class="hljs-comment">         * 在und异常处理函数中有可能会修改r0-r12, 所以先保存</span><br><span class="hljs-comment">         * 发生异常时，当前被中断的地址会保存在lr寄存器中 先减后存</span><br><span class="hljs-comment">         * lr是异常处理完后的返回地址, 也要保存 </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">stmdb</span> <span class="hljs-built_in">sp</span>!, &#123;<span class="hljs-built_in">r0</span>-<span class="hljs-built_in">r12</span>, <span class="hljs-built_in">lr</span>&#125;<br><br>        <span class="hljs-comment">/* 处理und异常：</span><br><span class="hljs-comment">         * 传递两个参数给它，我们放入r0和r1里 </span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">mrs</span> <span class="hljs-built_in">r0</span>, <span class="hljs-keyword">cpsr</span>    <span class="hljs-comment">//把cpsr的值读入r0</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r1</span>, <span class="hljs-symbol">=und_string</span>    <span class="hljs-comment">//把下面的字符串地址赋值给r1</span><br>        <span class="hljs-keyword">bl</span> printException<br><br>        <span class="hljs-comment">/* 恢复现场：</span><br><span class="hljs-comment">         * 这些寄存器保存在栈中，把他们读取出来就可以了</span><br><span class="hljs-comment">         * 先读后加</span><br><span class="hljs-comment">         * 把r0 ~ r12的值从栈中都取出来，并且把原来保存的lr值，赋值到pc中去</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">ldmia</span> <span class="hljs-built_in">sp</span>!, &#123;<span class="hljs-built_in">r0</span>-<span class="hljs-built_in">r12</span>, <span class="hljs-built_in">pc</span>&#125;^  <span class="hljs-comment">/* ^会把spsr的值恢复到cpsr里 */</span><br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 如何定义字符串und_string，可以百度搜索 arm-linux-gcc 汇编 定义字符串</span><br><span class="hljs-comment">         * 参考官方的说明文档：http://web.mit.edu/gnu/doc/html/as_7.html</span><br><span class="hljs-comment">          .string &quot;str&quot;：Copy the characters in str to the object file. You may specify more than one string to copy, separated by commas. Unless otherwise specified for a particular machine, the assembler marks the end of each string with a 0 byte. You can use any of the escape sequences described in section Strings.</span><br><span class="hljs-comment">          上面是说我们使用.str会自动加上结束符</span><br><span class="hljs-comment">         */</span>        <br>    und_string:<br>        .string <span class="hljs-string">&quot;undefined instruction exception&quot;</span><br>    <br>    reset:<br>        <span class="hljs-comment">/* 关闭看门狗 */</span><br>    <br>        <span class="hljs-comment">/* 设置MPLL, FCLK : HCLK : PCLK = 400m : 100m : 50m */</span><br>        <span class="hljs-comment">/* LOCKTIME(0x4C000000) = 0xFFFFFFFF */</span><br>    <br>        <span class="hljs-comment">/* CLKDIVN(0x4C000014) = 0X5, tFCLK:tHCLK:tPCLK = 1:4:8  */</span><br>    <br>        <span class="hljs-comment">/* 设置CPU工作于异步模式 */</span><br><br>        <span class="hljs-comment">/* 设置MPLLCON(0x4C000004) = (92&lt;&lt;12)|(1&lt;&lt;4)|(1&lt;&lt;0)           </span><br><span class="hljs-comment">         *  FCLK = 2*m*Fin/(p*2^s) = 2*100*12/(3*2^1)=400M          </span><br><span class="hljs-comment">         */</span><br>    <br>        <span class="hljs-comment">/* 一旦设置PLL, 就会锁定lock time直到PLL输出稳定          </span><br><span class="hljs-comment">         * 然后CPU工作于新的频率FCLK          </span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-comment">/* 设置内存: sp 栈 */</span><br>        <span class="hljs-comment">/* 分别是nor/nand启动          </span><br><span class="hljs-comment">         * 写0到0地址, 再读出来          </span><br><span class="hljs-comment">         * 如果得到0, 表示0地址上的内容被修改了, 它对应ram, 这就是nand启动          </span><br><span class="hljs-comment">         * 否则就是nor启动          </span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-comment">/* 重定位text, rodata, data段整个程序 */</span><br>    <br>        <span class="hljs-comment">/* 清除BSS段 */</span><br>   <br>        <span class="hljs-keyword">bl</span> uart0_init<br>    <br>        <span class="hljs-keyword">bl</span> print1<br>        <span class="hljs-comment">/* 故意加入一条未定义指令 */</span><br>    und_code:<br>        <span class="hljs-meta">.word</span> <span class="hljs-number">0xdeadc0de</span>  <span class="hljs-comment">/* 未定义指令 */</span><br>        <span class="hljs-keyword">bl</span> print2<br>    <br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, <span class="hljs-symbol">=main</span>  <span class="hljs-comment">/* 绝对跳转, 跳到SDRAM */</span><br>    <br>    halt:<br>        <span class="hljs-keyword">b</span> halt<br></code></pre></td></tr></table></figure><p>如何处理这个异常？</p><p>直接print打印一句话，新建exception.c文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* exception.c */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;uart.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printException</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cpsr, <span class="hljs-type">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Exception! cpsr = &quot;</span>);<br>    <span class="hljs-built_in">printHex</span>(cpsr);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot; &quot;</span>);<br>    <span class="hljs-built_in">puts</span>(str);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n\r&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>修改makefile添加文件</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">    all: start.o led.o uart.o init.o main.o exception.o<br>        <span class="hljs-comment">#arm-linux-ld -Ttext 0 -Tdata 0x30000000  start.o led.o uart.o init.o main.o -o sdram.elf</span><br>        arm-linux-ld -T sdram.lds $^ -o sdram.elf<br>        <span class="hljs-comment">#用$ ^来包含所有的依赖</span><br>        arm-linux-objcopy -O binary -S sdram.elf sdram.bin<br>        arm-linux-objdump -D sdram.elf &gt; sdram.dis<br>    clean:<br>        rm *<span class="hljs-string">.bin</span> *<span class="hljs-string">.o</span> *<span class="hljs-string">.elf</span> *<span class="hljs-string">.dis</span><br>        <br>    %<span class="hljs-string">.o</span> : %<span class="hljs-string">.c</span><br>        arm-linux-gcc -c -o $@ $&lt;<br>    <br>    %<span class="hljs-string">.o</span> : %<span class="hljs-string">.S</span><br>        arm-linux-gcc -c -o $@ $&lt;<br>        *<span class="hljs-string">.dis</span><br></code></pre></td></tr></table></figure><p>编译成功烧写</p><p>但没有输出我们想要的字符串</p><p>这里通过printf演示如何调试程序</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk">sdram:<br>        bl print1 <span class="hljs-regexp">//</span>添加print1<br>        <span class="hljs-regexp">/* 故意加入一条未定义指令 */</span><br>    und_code:<br>        .word <span class="hljs-number">0</span>xdeadc0de  <span class="hljs-regexp">/* 未定义指令 */</span><br>        bl print2 <span class="hljs-regexp">//</span>添加print2,实现这两个函数，来打印<br>    <br>        <span class="hljs-regexp">//</span>bl main  <span class="hljs-regexp">/* 使用BL命令相对跳转, 程序仍然在NOR/</span>sram执行 */<br>        ldr pc, =main  <span class="hljs-regexp">/* 绝对跳转, 跳到SDRAM */</span><br>    <br>    halt:<br>        b halt<br></code></pre></td></tr></table></figure><p>实现print1 print2这两个打印函数，在uart.c这个文件里</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">void</span> <span class="hljs-title function_">print1</span>(<span class="hljs-params">void</span>)<br>    &#123;<br>        <span class="hljs-title function_">puts</span>(<span class="hljs-string">&quot;abc<span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span>&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-variable">void</span> <span class="hljs-title function_">print2</span>(<span class="hljs-params">void</span>)<br>    &#123;<br>        <span class="hljs-title function_">puts</span>(<span class="hljs-string">&quot;123<span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span>&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>上传代码烧写，发现print1、print2并未执行成功</p><p>发现在start.S并未初始化 uart0_init()，删除main.c中的uart0_init()初始化函数</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, <span class="hljs-symbol">=sdram</span>    <br>    sdram:<br>        <span class="hljs-keyword">bl</span> uart0_init<br>    <br>        <span class="hljs-keyword">bl</span> print1<br>        <span class="hljs-comment">/* 故意加入一条未定义指令 */</span><br>    und_code:<br>        <span class="hljs-meta">.word</span> <span class="hljs-number">0xdeadc0de</span>  <span class="hljs-comment">/* 未定义指令 */</span><br>        <span class="hljs-keyword">bl</span> print2<br>    <br>        <span class="hljs-comment">//bl main  /* 使用BL命令相对跳转, 程序仍然在NOR/sram执行 */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, <span class="hljs-symbol">=main</span>  <span class="hljs-comment">/* 绝对跳转, 跳到SDRAM */</span><br>    <br>    halt:<br>        <span class="hljs-keyword">b</span> halt<br></code></pre></td></tr></table></figure><p>打印了未定义指令异常CPSR地址,打印了字符串，最后执行main函数</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">.<span class="hljs-type">word</span> <span class="hljs-number">0xdeadc0de</span>  <span class="hljs-comment">/* 也是一条定义指令 只要指令地址对不上上表就是未定义指令*/</span><br></code></pre></td></tr></table></figure><p>程序改进</p><p>源程序</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs awk">.text<br>.global _start<br><br>_start:<br>        b reset  <span class="hljs-regexp">/* vector 0 : reset */</span><br>    <span class="hljs-regexp">/*使用b命令跳转  相对跳转*/</span><br>        b do_und <span class="hljs-regexp">/* vector 4 : und */</span><br><br>do_und:<br><br>        <span class="hljs-regexp">/* sp_und未设置, 先设置它 */</span><br><br>        <span class="hljs-regexp">/* 保存现场 */</span><br>        <br>        <span class="hljs-regexp">/* 处理und异常 */</span><br><br>        /* 这里又使用了bl指令跳转，如果是nand启动，且这个函数在<span class="hljs-number">4</span>k之外，这个函数必定出错 <br>         * 为了保险，我们需要跳转到sdram中执行这个函数（在这条指令之前就跳转到sdram去执行）<br>         */<br>        bl printException<br>        <br>        <span class="hljs-regexp">/* 恢复现场 */</span><br>        <br>    und_string:<br>        .string <span class="hljs-string">&quot;undefined instruction exception&quot;</span><br>    <br>reset:<br></code></pre></td></tr></table></figure><p>去sdram执行do_und这个代码段，改进后如下：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">.text</span><br>    <span class="hljs-meta">.global</span> _start<br>    <br>    _start:<br>        <span class="hljs-keyword">b</span> reset  <span class="hljs-comment">/* vector 0 : reset */</span><br>    <span class="hljs-comment">/*跳转到sdram执行这个函数，那么这个函数一定在sdram中我们需要指定让他去前面这块内存去读这个值，担心如果这个文件很大，超过4K造成nand就没法去读这个文件</span><br><span class="hljs-comment">     */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, und_addr <span class="hljs-comment">/* vector 4 : und */</span><br><br>    <span class="hljs-comment">/*为什么不直接用ldr pc, =do_und</span><br><span class="hljs-comment">     *使用伪指令时，他并不是直接把do_und的地址传给pc,而是到一个编译器确定的地址读取数据，而这个地址存放着do_und的地址，且这个地址通常会放在汇编文件的最后面，若start.S很小则没关系，若start.S超过4k，编译器就有可能去4k之外的地方取值，若板子是NAND启动的话，在4k之外就取不到值。</span><br><span class="hljs-comment">     *所以我们最好指定它去前面这块内存来读值</span><br><span class="hljs-comment">     */</span>   <br>    <span class="hljs-comment">/* .word就是在当前地址，即und_addr处放一个值do_und</span><br><span class="hljs-comment">     * 主要是为了占领一个位置，不让这个地址放到CPU的片内srom以外了，不然就找不到他了。</span><br><span class="hljs-comment">     */</span> <br>    und_addr:<br>        <span class="hljs-meta">.word</span> do_und<br>    <br>    do_und:<br>        <span class="hljs-comment">/* sp_und未设置, 先设置它 */</span><br>    <br>        <span class="hljs-comment">/* 保存现场 */</span><br>        <span class="hljs-comment">/* 处理und异常 */</span><br>        <br>        <span class="hljs-comment">/* 恢复现场 */</span><br>        <span class="hljs-keyword">ldmia</span> <span class="hljs-built_in">sp</span>!, &#123;<span class="hljs-built_in">r0</span>-<span class="hljs-built_in">r12</span>, <span class="hljs-built_in">pc</span>&#125;^  <span class="hljs-comment">/* ^会把spsr的值恢复到cpsr里 */</span><br>        <br>    und_string:<br>        .string <span class="hljs-string">&quot;undefined instruction exception&quot;</span><br>    <span class="hljs-comment">/* 如果你的程序长度稍有变化，就不能保证运行 </span><br><span class="hljs-comment">     * 加上 .align 4才能保证后面的程序以4字节对齐，保证程序运行 </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">.align</span> <span class="hljs-number">4</span><br>    <br>    reset:<br>        <span class="hljs-comment">/* 关闭看门狗 */</span><br><br>        <span class="hljs-comment">/* 设置MPLL, FCLK : HCLK : PCLK = 400m : 100m : 50m */</span><br><br>        <span class="hljs-comment">/* CLKDIVN(0x4C000014) = 0X5, tFCLK:tHCLK:tPCLK = 1:4:8  */</span><br><br>        <span class="hljs-comment">/* 设置CPU工作于异步模式 */</span><br>  <br>        <span class="hljs-comment">/* 设置MPLLCON(0x4C000004) = (92&lt;&lt;12)|(1&lt;&lt;4)|(1&lt;&lt;0)           </span><br><span class="hljs-comment">         *  FCLK = 2*m*Fin/(p*2^s) = 2*100*12/(3*2^1)=400M          </span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-comment">/* 一旦设置PLL, 就会锁定lock time直到PLL输出稳定          </span><br><span class="hljs-comment">         * 然后CPU工作于新的频率FCLK          </span><br><span class="hljs-comment">         */</span><br>    <br>        <span class="hljs-comment">/* 设置内存: sp 栈 */</span><br>        <span class="hljs-comment">/* 分辨是nor/nand启动          </span><br><span class="hljs-comment">         * 写0到0地址, 再读出来          </span><br><span class="hljs-comment">         * 如果得到0, 表示0地址上的内容被修改了, 它对应ram, 这就是nand启动          </span><br><span class="hljs-comment">         * 否则就是nor启动           </span><br><span class="hljs-comment">         */</span><br>    <br>        <span class="hljs-comment">/* 重定位text, rodata, data段整个程序 */</span><br>    <br>        <span class="hljs-comment">/* 清除BSS段 */</span><br><br>        <span class="hljs-comment">/* 把sdram表示的值(sdram的(链接)地址)赋值给pc，使pc直接就跳转到SDRAM中执行sdram */</span><br>        <span class="hljs-comment">/* 重定位完后就应该跳到SDRAM中执行，因为uart0_init,print1两个函数有可能在4k之外 */</span>   <br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, <span class="hljs-symbol">=sdram</span><br>    sdram:<br>        <span class="hljs-keyword">bl</span> uart0_init<br>    <br>        <span class="hljs-keyword">bl</span> print1<br><br>        <span class="hljs-comment">/* 故意加入一条未定义指令 */</span><br>    <br>        <span class="hljs-comment">//bl main  /* 使用BL命令相对跳转, 程序仍然在NOR/sram执行 */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, <span class="hljs-symbol">=main</span>  <span class="hljs-comment">/* 绝对跳转, 跳到SDRAM */</span><br>    <br>    halt:<br>        <span class="hljs-keyword">b</span> halt<br></code></pre></td></tr></table></figure><p>编译指定-Ttext0x30000000时，ldr pc, &#x3D;sdram 即是把sdram的链接地址0x30000010赋给PC，实现程序跳转到SDRAM中运行。</p><p>问题一：Makefile中没有用到-Ttext 0x30000000，那么它是怎么知道指定的起始&#x2F;链接地址？</p><p>答：通过lds链接脚本确定</p><p>若此处有不明白之处，参考笔记“链接地址，存储地址的理解”</p><p>看一下整个程序的执行过程</p><p><img src="/image/4c83b7f226192bc431db62da91d180c9.png" alt="4c83b7f226192bc431db62da91d180c9.png"></p><p><strong>swi异常程序示例</strong></p><hr><p>这节我们再来演示swi的处理流程</p><p>swi软件中断:software interrupt</p><p>在前面的视频中我们讲过ARMCPU有7种模式，除了用户模式以外，其他6种都是特权模式，这些特权模式都可以通过直接修改CPSR进入其他模式(usr用户模式不能修改CPSR进入其他模式)</p><p>Linux应用程序一般运行于usr用户模式</p><p>APP运行于user mode，(受限模式，不可访问硬件)</p><p>APP想访问硬件，必须切换模式，怎么切换？</p><p>发生异常</p><ul><li>中断(中断是一种异常,但可遇不可求)</li><li>und</li><li>swi + 某个值val(使用软中断切换模式)(可以使用这个值分辨为什么执行这条指令)</li></ul><p>现在start.S把要做的事情列出来</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">/*<span class="hljs-number">1</span> <br>    /* 复位之后, cpu处于svc模式  <br>     * 现在, 切换到usr模式  <br>     * 设置栈sp_usr  <br>     * 跳转执行 <br>     */<br><br><span class="hljs-regexp">/*2 故意引入一条swi指令*/</span><br><br><span class="hljs-regexp">/*3 需在_start这里放一条swi指令*/</span><br></code></pre></td></tr></table></figure><p>查看异常向量表swi异常的向量地址是0x8</p><p><img src="/image/cb46877f626bca675c1d305c342e0023.png" alt="cb46877f626bca675c1d305c342e0023.png"></p><p>我们先切换到usr模式下</p><p><img src="/image/136bfc8c086cfdbfbaf9f6163e1568f0.png" alt="136bfc8c086cfdbfbaf9f6163e1568f0.png"></p><p><img src="/image/d7d4629fc1fa3da8105353615902a2f3.png" alt="d7d4629fc1fa3da8105353615902a2f3.png"></p><p>usr模式下的 M0 ~ M4是10000</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">/*5 先进入usr模式*/</span><br><span class="hljs-keyword">mrs</span> <span class="hljs-built_in">r0</span>, <span class="hljs-keyword">cpsr</span>      <span class="hljs-comment">/* 读出cpsr 读到r0 */</span><br>/使用bic命令 bitclean 把低<span class="hljs-number">4</span>位清零/<br><span class="hljs-keyword">bic</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">r0</span>, <span class="hljs-number">#0xf</span>  <span class="hljs-comment">/* 修改M4-M0为0b10000, 进入usr模式 */</span><br><span class="hljs-keyword">msr</span> cpsr, <span class="hljs-built_in">r0</span><br><br><span class="hljs-comment">/*6 设置栈*/</span><br><span class="hljs-comment">/* 设置 sp_usr */</span><br><span class="hljs-keyword">ldr</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">=0x33f00000</span><br></code></pre></td></tr></table></figure><p>编译运行</p><p>发现可以处理und指令</p><p>添加 swi异常，仿照未定义指令做</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">.text</span><br><span class="hljs-symbol">.global</span> _start<br><br><span class="hljs-symbol">_start:</span><br>        <span class="hljs-keyword">b</span> reset          <span class="hljs-comment">/* vector 0 : reset */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, und_addr <span class="hljs-comment">/* vector 4 : und */</span><span class="hljs-comment">/*1 添加swi指令*/</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, swi_addr <span class="hljs-comment">/* vector 8 : swi */</span><br><br><span class="hljs-symbol">und_addr:</span><br>        <span class="hljs-meta">.word</span> do_und<br><br><span class="hljs-comment">/*2 仿照und未定义添加指令*/</span><br><span class="hljs-symbol">swi_addr:</span><br>        <span class="hljs-meta">.word</span> do_swi<br><br><span class="hljs-symbol">do_und:</span><br>        <span class="hljs-comment">/* 省略 */</span><br><br><span class="hljs-comment">/*3 复制do_und修改为swi */</span><br><span class="hljs-symbol">do_swi:</span><br>        <span class="hljs-comment">/* 执行到这里之前:  </span><br><span class="hljs-comment">         * 3.1. lr_svc保存有被中断模式中的下一条即将执行的指令的地址  </span><br><span class="hljs-comment">         * 3.2. SPSR_svc保存有被中断模式的CPSR  </span><br><span class="hljs-comment">         * 3.3. CPSR中的M4-M0被设置为10011, 进入到svc模式  </span><br><span class="hljs-comment">         * 3.4. 跳到0x08的地方执行程序   </span><br><span class="hljs-comment">         */</span> <br><br>        <span class="hljs-comment">/* 3.5 sp_svc未设置, 先设置它 */</span><br>        <span class="hljs-comment">/* 这种栈可以随便设置，只要指向没有使用的内存就好 */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">=0x33e00000</span><br><br>        <span class="hljs-comment">/* 3.6 在swi异常处理函数中有可能会修改r0-r12, 所以先保存 */</span><br>        <span class="hljs-comment">/* 3.7 lr是异常处理完后的返回地址, 也要保存 */</span><br>        <span class="hljs-keyword">stmdb</span> <span class="hljs-built_in">sp</span>!, &#123;<span class="hljs-built_in">r0</span>-<span class="hljs-built_in">r12</span>, <span class="hljs-built_in">lr</span>&#125;  <br>        <br>        <span class="hljs-comment">/* 3.8 保存现场 */</span><br>        <span class="hljs-comment">/* 3.9 处理swi异常 只是打印 */</span><br>        <span class="hljs-keyword">mrs</span> <span class="hljs-built_in">r0</span>, <span class="hljs-keyword">cpsr</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r1</span>, <span class="hljs-symbol">=swi_string</span><br>        <span class="hljs-keyword">bl</span> printException<br>        <br>        <span class="hljs-comment">/*3.10  恢复现场 */</span><br>        <span class="hljs-keyword">ldmia</span> <span class="hljs-built_in">sp</span>!, &#123;<span class="hljs-built_in">r0</span>-<span class="hljs-built_in">r12</span>, <span class="hljs-built_in">pc</span>&#125;^  <span class="hljs-comment">/* ^会把spsr的值恢复到cpsr里 */</span><br><br><span class="hljs-comment">/*swi处理函数*/</span>       <br><span class="hljs-symbol">swi_string:</span><br>        .string <span class="hljs-string">&quot;swi exception&quot;</span><br></code></pre></td></tr></table></figure><p>上传代码实验，烧写，发现没有执行</p><p>程序问题出现在</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">.<span class="hljs-built_in">string</span> <span class="hljs-string">&quot;swi exception&quot;</span><br></code></pre></td></tr></table></figure><p>这句话，为什么加上这句话程序就无法执行，查看一下反汇编：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-number">30000064</span> &lt;swi_string&gt;: <span class="hljs-comment">//这里地址是64</span><br><span class="hljs-number">30000064</span>:  <span class="hljs-number">20697773</span>     <span class="hljs-keyword">rsbcs</span>    <span class="hljs-built_in">r7</span>, <span class="hljs-built_in">r9</span>, <span class="hljs-built_in">r3</span>, rror <span class="hljs-built_in">r7</span><br><span class="hljs-number">30000068</span>:  <span class="hljs-number">65637865</span>     strvsb   <span class="hljs-built_in">r7</span>, [<span class="hljs-built_in">r3</span>, #-<span class="hljs-number">2149</span>]!<br><span class="hljs-number">3000007</span>c:    <span class="hljs-number">6</span>f697470  <span class="hljs-keyword">swivs</span>    <span class="hljs-number">0x00697470</span><br><span class="hljs-number">30000070</span>:  <span class="hljs-number">0000006</span>e      <span class="hljs-keyword">andeq</span>    <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">lr</span>, <span class="hljs-keyword">rrx</span><br><br><span class="hljs-number">30000082</span> &lt;reset&gt;: <span class="hljs-comment">//我们使用的是ARM指令集，应该是4字节对齐，发现这里并不是，问题就在这里</span><br><span class="hljs-number">30000082</span>:  e3a00453         <span class="hljs-keyword">mov</span>      <span class="hljs-built_in">r0</span>, <span class="hljs-number">#1392508928</span>  <span class="hljs-comment">; 0x53000000</span><br><span class="hljs-number">30000086</span>:  e3a01000         <span class="hljs-keyword">mov</span>      <span class="hljs-built_in">r1</span>, <span class="hljs-number">#0</span>   <span class="hljs-comment">; 0x0</span><br><span class="hljs-number">3000008</span>a:  e5801000         <span class="hljs-keyword">str</span>      <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r0</span>]<br><span class="hljs-number">3000008</span>e:  e3a00313         <span class="hljs-keyword">mov</span>      <span class="hljs-built_in">r0</span>, <span class="hljs-number">#1275068416</span>  <span class="hljs-comment">; 0x4c000000</span><br><span class="hljs-number">30000092</span>:  e3e01000         <span class="hljs-keyword">mvn</span>      <span class="hljs-built_in">r1</span>, <span class="hljs-number">#0</span>   <span class="hljs-comment">; 0x0</span><br></code></pre></td></tr></table></figure><p>因为这个字符串长度有问题</p><p>前面und_string 那里的字符串长度刚刚好</p><p>添加4字节对齐：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">und_string:</span><br>    .string<span class="hljs-string">&quot;undefined instruction exception&quot;</span><br><br><span class="hljs-comment">/* 以4字节对齐</span><br><span class="hljs-comment"> * 放在可能影响对齐的字符串后面</span><br><span class="hljs-comment"> */</span><br><span class="hljs-symbol">.align</span> <span class="hljs-number">4</span><br><br><span class="hljs-symbol">do_swi:</span><br>        <span class="hljs-comment">/* 执行到这里之前:  </span><br><span class="hljs-comment">         * 3.1. lr_svc保存有被中断模式中的下一条即将执行的指令的地址  </span><br><span class="hljs-comment">         * 3.2. SPSR_svc保存有被中断模式的CPSR  </span><br><span class="hljs-comment">         * 3.3. CPSR中的M4-M0被设置为10011, 进入到svc模式  </span><br><span class="hljs-comment">         * 3.4. 跳到0x08的地方执行程序   </span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-comment">/* 3.5 sp_svc未设置, 先设置它 */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">=0x33e00000</span><br><br>        <span class="hljs-comment">/* 3.6 在swi异常处理函数中有可能会修改r0-r12, 所以先保存 */</span><br>        <span class="hljs-comment">/* 3.7 lr是异常处理完后的返回地址, 也要保存 */</span><br>        <span class="hljs-keyword">stmdb</span> <span class="hljs-built_in">sp</span>!, &#123;<span class="hljs-built_in">r0</span>-<span class="hljs-built_in">r12</span>, <span class="hljs-built_in">lr</span>&#125;  <br>        <br>        <span class="hljs-comment">/* 3.8 保存现场 */</span><br>        <span class="hljs-comment">/* 3.9 处理swi异常 只是打印 */</span><br>        <span class="hljs-keyword">mrs</span> <span class="hljs-built_in">r0</span>, <span class="hljs-keyword">cpsr</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r1</span>, <span class="hljs-symbol">=swi_string</span><br>        <span class="hljs-keyword">bl</span> printException<br>        <br>        <span class="hljs-comment">/*3.10  恢复现场 */</span><br>        <span class="hljs-keyword">ldmia</span> <span class="hljs-built_in">sp</span>!, &#123;<span class="hljs-built_in">r0</span>-<span class="hljs-built_in">r12</span>, <span class="hljs-built_in">pc</span>&#125;^  <span class="hljs-comment">/* ^会把spsr的值恢复到cpsr里 */</span><br><br><span class="hljs-comment">/*****</span><br><span class="hljs-comment">swi处理函数</span><br><span class="hljs-comment">*/</span>        <br><span class="hljs-symbol">swi_string:</span><br>        .string <span class="hljs-string">&quot;swi exception&quot;</span><br><br><span class="hljs-symbol">.align</span> <span class="hljs-number">4</span><br><span class="hljs-comment">/**************</span><br><span class="hljs-comment">放在可能影响对齐的字符串后面</span><br><span class="hljs-comment">表明下面的标号要放在4字节对齐的地方</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-symbol">reset:</span><br></code></pre></td></tr></table></figure><p>上传代码编译运行查看反汇编：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-number">30000068</span> &lt;swi_string&gt;:<br><span class="hljs-number">30000068</span>:  <span class="hljs-number">20697773</span>     <span class="hljs-keyword">rsbcs</span>    <span class="hljs-built_in">r7</span>, <span class="hljs-built_in">r9</span>, <span class="hljs-built_in">r3</span>, <span class="hljs-keyword">ror</span> <span class="hljs-built_in">r7</span><br><span class="hljs-number">3000006</span>c:    <span class="hljs-number">65637865</span>     strvsb   <span class="hljs-built_in">r7</span>, [<span class="hljs-built_in">r3</span>, #-<span class="hljs-number">2149</span>]!<br><span class="hljs-number">30000070</span>:  <span class="hljs-number">6</span>f697470  <span class="hljs-keyword">swivs</span>    <span class="hljs-number">0x00697470</span><br><span class="hljs-number">30000074</span>:  <span class="hljs-number">0000006</span>e      <span class="hljs-keyword">andeq</span>    <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">lr</span>, <span class="hljs-keyword">rrx</span><br>        ...<br><br><span class="hljs-number">30000080</span> &lt;reset&gt;: <span class="hljs-comment">//现在reset放在4自己对齐的地方30000080:  e3a00453         mov      r0, #1392508928  ; 0x53000000</span><br><span class="hljs-number">30000084</span>:  e3a01000         <span class="hljs-keyword">mov</span>      <span class="hljs-built_in">r1</span>, <span class="hljs-number">#0</span>   <span class="hljs-comment">; 0x0</span><br><span class="hljs-number">30000088</span>:  e5801000         <span class="hljs-keyword">str</span>      <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r0</span>]<br><span class="hljs-number">3000008</span>c:    e3a00313         <span class="hljs-keyword">mov</span>      <span class="hljs-built_in">r0</span>, <span class="hljs-number">#1275068416</span>  <span class="hljs-comment">; 0x4c000000</span><br><span class="hljs-number">30000090</span>:  e3e01000         <span class="hljs-keyword">mvn</span>      <span class="hljs-built_in">r1</span>, <span class="hljs-number">#0</span>   <span class="hljs-comment">; 0x0</span><br><span class="hljs-number">30000094</span>:  e5801000         <span class="hljs-keyword">str</span>      <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r0</span>]<br><span class="hljs-number">30000098</span>:  e59f0084         <span class="hljs-keyword">ldr</span>      <span class="hljs-built_in">r0</span>, [<span class="hljs-built_in">pc</span>, <span class="hljs-number">#132</span>]       <span class="hljs-comment">; </span><br><span class="hljs-number">30000124</span> &lt;<span class="hljs-meta">.text</span>+<span class="hljs-number">0x124</span>&gt;<br><span class="hljs-number">3000009</span>c:    e3a01005         <span class="hljs-keyword">mov</span>      <span class="hljs-built_in">r1</span>, <span class="hljs-number">#5</span>   <span class="hljs-comment">; 0x5</span><br><span class="hljs-number">300000</span>a0:    e5801000         <span class="hljs-keyword">str</span>      <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r0</span>]<br><span class="hljs-number">300000</span><span class="hljs-built_in">a4</span>:    ee110f10         <span class="hljs-keyword">mrc</span>      <span class="hljs-number">15</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">r0</span>, cr1, cr0, &#123;<span class="hljs-number">0</span>&#125;<br><span class="hljs-number">300000</span>a8:    e3700103         <span class="hljs-keyword">orr</span>      <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">r0</span>, #-<span class="hljs-number">1073741824</span>     <span class="hljs-comment">; 0xc0000000</span><br><span class="hljs-number">300000</span>ac:    ee010f10         mcr      <span class="hljs-number">15</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">r0</span>, cr1, cr0, &#123;<span class="hljs-number">0</span>&#125;<br><span class="hljs-number">300000</span>b0:    e59f0070         <span class="hljs-keyword">ldr</span>      <span class="hljs-built_in">r0</span>, [<span class="hljs-built_in">pc</span>, <span class="hljs-number">#112</span>]       <span class="hljs-comment">; </span><br><span class="hljs-number">30000128</span> &lt;<span class="hljs-meta">.text</span>+<span class="hljs-number">0x128</span>&gt;<br><span class="hljs-number">300000</span>b4:    e59f1070         <span class="hljs-keyword">ldr</span>      <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">pc</span>, <span class="hljs-number">#112</span>]       <span class="hljs-comment">; </span><br><span class="hljs-number">3000012</span>c &lt;<span class="hljs-meta">.text</span>+<span class="hljs-number">0x12c</span>&gt;<br><span class="hljs-number">300000</span>b8:    e5801000         <span class="hljs-keyword">str</span>      <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r0</span>]<br><span class="hljs-number">300000</span>bc:    e3a01000         <span class="hljs-keyword">mov</span>      <span class="hljs-built_in">r1</span>, <span class="hljs-number">#0</span>   <span class="hljs-comment">; 0x0</span><br><span class="hljs-number">300000</span><span class="hljs-built_in">c0</span>:    e5910000         <span class="hljs-keyword">ldr</span>      <span class="hljs-built_in">r0</span>, [<span class="hljs-built_in">r1</span>]<br></code></pre></td></tr></table></figure><p>下载烧写，程序执行完全没有问题</p><p>程序备份修改代码</p><p>swi可以根据应用程序传入的val来判断为什么调用swi指令，试下我们的异常处理函数能不能把这个val值读出来</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">do_swi:</span><br>        <span class="hljs-comment">/* 执行到这里之前:  </span><br><span class="hljs-comment">         * 1. lr_svc保存有被中断模式中的下一条即将执行的指令的地址  </span><br><span class="hljs-comment">         * 2. SPSR_svc保存有被中断模式的CPSR  </span><br><span class="hljs-comment">         * 3. CPSR中的M4-M0被设置为10011, 进入到svc模式  </span><br><span class="hljs-comment">         * 4. 跳到0x08的地方执行程序   </span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-comment">/* sp_svc未设置, 先设置它 */</span><br>        <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">=0x33e00000</span><br><br>        <span class="hljs-comment">/* 保存现场 */</span><br>        <span class="hljs-comment">/* 在swi异常处理函数中有可能会修改r0-r12, 所以先保存 */</span><br>        <span class="hljs-comment">/* lr是异常处理完后的返回地址, 也要保存 */</span><br>        <span class="hljs-keyword">stmdb</span> <span class="hljs-built_in">sp</span>!, &#123;<span class="hljs-built_in">r0</span>-<span class="hljs-built_in">r12</span>, <span class="hljs-built_in">lr</span>&#125;  <br><br><span class="hljs-comment">/* 2</span><br><span class="hljs-comment"> * 我们要把lr拿出来保存，因为bl printException会破坏存储了sw 0x123的下一条指令ldr pc,=main的地址的lr。使用mov rX， lr保存寄存器lr，且这个函数 bl printException 可能会修改某些寄存器，但是又会恢复这些寄存器，根据ATPCS规则得知他会保存r4 ~ r11这些寄存器。如果用到的话就把他保存起来，执行完C函数后把它释放掉，我们把lr保存在r4寄存器里，r4寄存器就不会被C函数printException破坏</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">r4</span>, <span class="hljs-built_in">lr</span><br>        <br>    <span class="hljs-comment">/* 处理swi异常 */</span><br>    <span class="hljs-keyword">mrs</span> <span class="hljs-built_in">r0</span>, <span class="hljs-keyword">cpsr</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r1</span>, <span class="hljs-symbol">=swi_string</span><br>    <span class="hljs-keyword">bl</span> printException<br>        <br><span class="hljs-comment">/* 1</span><br><span class="hljs-comment"> * 此时跳转到printSWIVal，我们如何才能知道swi的值呢？</span><br><span class="hljs-comment">我们得读出swi 0x123这条指令的内存地址，而执行完swi 0x123指令以后，会发生一次异常，异常模式里的lr寄存器会保存下一条指令的地址，那么把lr寄存器的地址减去4就是swi 0x123这条指令的地址</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/* 3</span><br><span class="hljs-comment"> * 把r4的寄存器值(ldr pc,=main指令的地址)-4赋给r0，传递给打印函数，然后打印val</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-keyword">sub</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">r4</span>, <span class="hljs-number">#4</span><br>    <span class="hljs-keyword">bl</span> printSWIVal<br>        <br>    <span class="hljs-comment">/* 恢复现场 */</span><br>    <span class="hljs-keyword">ldmia</span> <span class="hljs-built_in">sp</span>!, &#123;<span class="hljs-built_in">r0</span>-<span class="hljs-built_in">r12</span>, <span class="hljs-built_in">pc</span>&#125;^  <span class="hljs-comment">/* ^会把spsr的值恢复到cpsr里 */</span><br>        <br><span class="hljs-symbol">swi_string:</span><br>    .string <span class="hljs-string">&quot;swi exception&quot;</span><br><br><span class="hljs-comment">/* uart.c */</span>添加printSWIVal打印函数<br><br><span class="hljs-comment">/* 打印出val，即发生异常的内存地址(除高八位) */</span><br><span class="hljs-symbol">void</span> printSWIVal(unsigned int *pSWI)<br>&#123;<br>        puts(<span class="hljs-string">&quot;SWI val = &quot;</span>)<span class="hljs-comment">;</span><br>        printHEx(*pSWI &amp; ~<span class="hljs-number">0xff000000</span>)<span class="hljs-comment">; //高8位忽略掉  </span><br>        puts(<span class="hljs-string">&quot;\n\r&quot;</span>)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>编译实验运行没有问题</p><p><img src="/image/700px-Chapter14_lesson5_002.png" alt="700px-Chapter14_lesson5_002.png"></p><p><strong>_按键中断程序示例_概述与初始</strong></p><hr><p><strong>中断的处理流程：</strong> </p><ol><li>中断初始化：</li></ol><p>a. 我们需要设置中断源，让它能够发出中断信号</p><p>b. 设置中断控制器，让它能发出中断给CPU</p><p>c. 设置CPU，CPSR有I位，是总开关</p><p>（我们需要这样设置，中断源才能发送给CPU）</p><ol><li>处理完要清中断（相比异常，多了清理中断的操作 ）</li><li>处理时，要分辨中断源，对于不同的中断源要执行不同的处理函数</li></ol><p>下面开始写代码</p><p>打开start.S 先做初始化工作，先做第 3 设置CPU，CPSR有I位，是总开关</p><p>我们需要把CPSR寄存器 bit7给清零，这是中断的总开关，如果bit7设置为1，CPU无法响应任何中断</p><p><img src="/image/136bfc8c086cfdbfbaf9f6163e1568f0.png" alt="136bfc8c086cfdbfbaf9f6163e1568f0.png"></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs armasm">    <span class="hljs-comment">/* 清除BSS段 */</span><br>    <span class="hljs-keyword">bl</span> clean_bss<br><br>    <span class="hljs-comment">/* 复位之后, cpu处于svc模式  </span><br><span class="hljs-comment">     * 现在, 切换到usr模式  </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">mrs</span> <span class="hljs-built_in">r0</span>, <span class="hljs-keyword">cpsr</span>         <span class="hljs-comment">/* 读出cpsr */</span><br>    <span class="hljs-keyword">bic</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">r0</span>, <span class="hljs-number">#0xf</span>     <span class="hljs-comment">/* 修改M4-M0为0b10000, 进入usr模式 */</span><br><br><span class="hljs-comment">/*1 把bit7这一位清零 */</span><br>    <span class="hljs-keyword">bic</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">r0</span>, #(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">7</span>)  <span class="hljs-comment">/* 清除I位, 使能中断 */</span><br>    <span class="hljs-keyword">msr</span> cpsr, <span class="hljs-built_in">r0</span><br><br>    <span class="hljs-comment">/* 设置 sp_usr */</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">=0x33f00000</span><br><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, <span class="hljs-symbol">=sdram</span><br><span class="hljs-symbol">sdram:</span><br>    <span class="hljs-keyword">bl</span> uart0_init<br><br>    <span class="hljs-keyword">bl</span> print1<br>    <span class="hljs-comment">/* 故意加入一条未定义指令 */</span><br><span class="hljs-symbol">und_code:</span><br>    <span class="hljs-meta">.word</span> <span class="hljs-number">0xdeadc0de</span>  <span class="hljs-comment">/* 未定义指令 */</span><br>    <span class="hljs-keyword">bl</span> print2<br><br>    <span class="hljs-keyword">swi</span> <span class="hljs-number">0x123</span>  <span class="hljs-comment">/* 执行此命令, 触发SWI异常, 进入0x8执行 */</span><br><br><span class="hljs-comment">/*2 调用两个中断 */</span><br>    <span class="hljs-keyword">bl</span> interrupt_init <span class="hljs-comment">/* 初始化中断控制器 */</span><br>    <span class="hljs-keyword">bl</span> key_eint_init <span class="hljs-comment">/* 初始化按键，设为中断源 */</span><br><br><span class="hljs-comment">/* 需要初始化上面这两个函数 */</span><br>    <span class="hljs-comment">//bl main  /* 使用BL命令相对跳转, 程序仍然在NOR/sram执行 */</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, <span class="hljs-symbol">=main</span>  <span class="hljs-comment">/* 绝对跳转, 跳到SDRAM */</span><br><br><span class="hljs-symbol">halt:</span><br>    <span class="hljs-keyword">b</span> halt<br></code></pre></td></tr></table></figure><p>添加一个 interrupt.c文件，这个程序稍微有些复杂，我们先画个流程图</p><p> <img src="/image/Chapter14_lesson6_002.png" alt="Chapter14_lesson6_002.png"></p><p>我们想达到按下按键灯亮松开按键灯灭，把下面四个按键全部配置为外部中断按键</p><p><img src="/image/12ded688d46c48aa3521c1ae0464616d.png" alt="12ded688d46c48aa3521c1ae0464616d.png"></p><p>打开芯片手册找到第九章 IO ports，直接搜索“’EINT0号中断和EINT2号中断”’，找配置寄存器 GPFCON</p><p><img src="/image/d15ed2551d92ee42a203de78e0d0d88a.png" alt="d15ed2551d92ee42a203de78e0d0d88a.png"></p><p>为了简单操作</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* 初始化按键, 设为中断源 */</span><br>void key_eint_init(void)<br>&#123;<br><span class="hljs-regexp">/*1 配置GPIO为中断引脚 */</span><br><span class="hljs-regexp">//</span>先把eint0和eint2这两个引脚清零<br>GPFCON &amp;= ~((<span class="hljs-number">3</span>&lt;&lt;<span class="hljs-number">0</span>) | (<span class="hljs-number">3</span>&lt;&lt;<span class="hljs-number">4</span>));<br>GPFCON |= ((<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-number">0</span>) | (<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-number">4</span>));   <span class="hljs-regexp">/* S2,S3被配置为中断引脚 */</span><br></code></pre></td></tr></table></figure><p>通过电路图得知 S4 S5按键为EINT11号中断引脚和EINT19号中断引脚</p><p><img src="/image/b0a4affe35fb0524909151ffa32b8682.png" alt="b0a4affe35fb0524909151ffa32b8682.png"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GPGCON</span> &amp;= ~((<span class="hljs-number">3</span>&lt;&lt;<span class="hljs-number">6</span>) | (<span class="hljs-number">3</span>&lt;&lt;<span class="hljs-number">22</span>));<br><span class="hljs-attribute">GPGCON</span> |= ((<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-number">6</span>) | (<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-number">22</span>));   /* S4,S5被配置为中断引脚 */<br></code></pre></td></tr></table></figure><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">/*2 设置中断触发方式: (按下松开，从低电源变为高电源，或者从低电源变为高电源双边沿触发)</span><br><span class="hljs-comment">设置EINT0 EINT2为双边沿触发 */</span><br><br>EXTI<span class="hljs-symbol">NT0</span> |= <span class="hljs-comment">(7&lt;&lt;0)</span> | <span class="hljs-comment">(7&lt;&lt;8)</span>;     <span class="hljs-comment">/* S2,S3 */</span><br></code></pre></td></tr></table></figure><p><img src="/image/54019a20aabe6d0f047bae6f14a2ebdb.png" alt="54019a20aabe6d0f047bae6f14a2ebdb.png"></p><p>设置EINT11为双边沿触发</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">EXTI<span class="hljs-symbol">NT1</span> |= <span class="hljs-comment">(7&lt;&lt;12)</span>;             <span class="hljs-comment">/* S4 */</span><br></code></pre></td></tr></table></figure><p>设置EINT19为双边沿触发</p><p><img src="/image/f17a90c67b39bc8cdfefdcd1c14f0889.png" alt="f17a90c67b39bc8cdfefdcd1c14f0889.png"></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">EXTI<span class="hljs-symbol">NT2</span> |= <span class="hljs-comment">(7&lt;&lt;12)</span>;             <span class="hljs-comment">/* S5 */</span><br></code></pre></td></tr></table></figure><p><img src="/image/c6153354099cc21cde644195a3fded8a.png" alt="c6153354099cc21cde644195a3fded8a.png"></p><p>外部中断屏蔽寄存器EINTMASK：设置为1的话就禁止向外部发出中断信号，只有EINTMASK相应的位设置为0外部中断才能给中断控制器发信号</p><p>我们需要设置这个寄存器</p><p><img src="/image/2d8c3b4b89685e7cd77a809b36555d05.png" alt="2d8c3b4b89685e7cd77a809b36555d05.png"></p><p>把EINT11设置为0 把EINT19设置为0对于EINT0 和EINT2显示为保留，默认时使能的，可以直接发送给中断控制器，无需设置</p><p><img src="/image/700px-Chapter14_lesson6_0011.png" alt="700px-Chapter14_lesson6_0011.png"></p><p>设置EINTMASK使能eint11,19</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">EINTMASK</span> &amp;= ~((<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">11</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">19</span>));<br></code></pre></td></tr></table></figure><p>EINTPEND：当发生中断时可以读这个寄存器确认是产生了哪个EINT(eint4~23)(并且要清除它)</p><p>清除中断时, 写EINTPEND的相应位为0</p><p><img src="/image/de4721414cc408358081c71fc2d2c48c.png" alt="de4721414cc408358081c71fc2d2c48c.png"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* 初始化按键, 设为中断源 */</span><br>void key_eint_init(void)<br>&#123;<br>    <span class="hljs-regexp">/* 配置GPIO为中断引脚 */</span><br>    GPFCON &amp;= ~((<span class="hljs-number">3</span>&lt;&lt;<span class="hljs-number">0</span>) | (<span class="hljs-number">3</span>&lt;&lt;<span class="hljs-number">4</span>));<br>    GPFCON |= ((<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-number">0</span>) | (<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-number">4</span>));   <span class="hljs-regexp">/* S2,S3被配置为中断引脚 */</span><br><br>    GPGCON &amp;= ~((<span class="hljs-number">3</span>&lt;&lt;<span class="hljs-number">6</span>) | (<span class="hljs-number">3</span>&lt;&lt;<span class="hljs-number">11</span>));<br>    GPGCON |= ((<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-number">6</span>) | (<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-number">11</span>));   <span class="hljs-regexp">/* S4,S5被配置为中断引脚 */</span><br><br>    <span class="hljs-regexp">/* 设置中断触发方式: 双边沿触发 */</span><br>    EXTINT0 |= (<span class="hljs-number">7</span>&lt;&lt;<span class="hljs-number">0</span>) | (<span class="hljs-number">7</span>&lt;&lt;<span class="hljs-number">8</span>);     <span class="hljs-regexp">/* S2,S3 */</span><br>    EXTINT1 |= (<span class="hljs-number">7</span>&lt;&lt;<span class="hljs-number">12</span>);             <span class="hljs-regexp">/* S4 */</span><br>    EXTINT2 |= (<span class="hljs-number">7</span>&lt;&lt;<span class="hljs-number">12</span>);             <span class="hljs-regexp">/* S5 */</span><br><br>    <span class="hljs-regexp">/* 设置EINTMASK使能eint11,19 */</span><br>    EINTMASK &amp;= ~((<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">11</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">19</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来需要阅读’第14章 Interrupt Controller章节设置中断控制器我们只需要按照下面这张流程图Figure 14-1设置就可以了</p><p><img src="/image/1a42bfaa519db705869ef805e4faff6c.png" alt="1a42bfaa519db705869ef805e4faff6c.png"></p><p>我们来看一下外部中断属于哪一种,需不需要设置SUBSRCPND</p><p>打开芯片手册，从上往下读</p><p><img src="/image/b436fdac06f773f584b03539726ecb3b.png" alt="b436fdac06f773f584b03539726ecb3b.png"></p><p>由上图可得 EINT4_7 EINT8_23合用一条中断线ARB1</p><p>也就是可以直接到达SRCPND不需要设置SUBSRCPND和SUBMASK这两个寄存器</p><p>我们只需要设置</p><ul><li>SRCPND不同的中断类型不可以直接到达这里执行</li><li>MASK 屏蔽寄存器</li><li>INTPND 等待处理，我们可以读这个寄存器，确定是那个中断产生了</li></ul><p><img src="/image/700px-Chapter14_lesson6_0014.png" alt="700px-Chapter14_lesson6_0014.png"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">/<span class="hljs-emphasis">* SRCPND 用来显示哪个中断产生了, 需要清除对应位，我们只需要关心  </span><br><span class="hljs-emphasis"> *</span> bit0对应eint0  <br> <span class="hljs-emphasis">* bit2对应eint2  </span><br><span class="hljs-emphasis"> *</span> bit5对应eint8<span class="hljs-emphasis">_23(表明bit5等于1的时候 eint8_</span>23中的某一个已经产生，我们需要继续分辨  <br> <span class="hljs-emphasis">* 读EINTPEND分辨是哪个EINT产生)  </span><br><span class="hljs-emphasis"> *</span>/<br></code></pre></td></tr></table></figure><p>INTMOD寄存器 默认值为IRQ模式即可，不需要设置</p><p><img src="/image/388eb1ae56a0e00eb08fe1b280c3508c.png" alt="388eb1ae56a0e00eb08fe1b280c3508c.png"></p><p>INTMASK寄存器，需要设置为0</p><p><img src="/image/9dba24c50318ce93233af097feefd2ef.png" alt="9dba24c50318ce93233af097feefd2ef.png"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">/<span class="hljs-emphasis">* INTMSK 用来屏蔽中断, 1对应masked屏蔽中断，我们需要设置相应位设置为0  </span><br><span class="hljs-emphasis"> *</span> bit0-eint0  <br> <span class="hljs-emphasis">* bit2-eint2  </span><br><span class="hljs-emphasis"> *</span> bit5-eint8<span class="hljs-emphasis">_23  </span><br><span class="hljs-emphasis"> */</span><br></code></pre></td></tr></table></figure><p>同时可能有多个中断产生，这么多个中断经过优先级以后，只会有一个通知CPU，是哪一个中断优先级最高，可以读INTPAD就能知道当前处理的唯一 一 个中断是哪一个</p><p><img src="/image/fb8f2cb4442897d291455a375fa81c19.png" alt="fb8f2cb4442897d291455a375fa81c19.png"></p><p>1 表示这个中断已经产生，需要配置相应的位</p><p>INTPND 用来显示当前优先级最高的、正在发生的中断, 需要清除对应位</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">/<span class="hljs-emphasis">* INTPND 用来显示当前优先级最高的、正在发生的中断, 需要清除对应位</span><br><span class="hljs-emphasis"> *</span>bit0-eint0<br> <span class="hljs-emphasis">*bit2-eint2</span><br><span class="hljs-emphasis"> *</span>bit5-eint8<span class="hljs-emphasis">_23</span><br><span class="hljs-emphasis"> */</span><br></code></pre></td></tr></table></figure><p>INTOFFSET是用来显示INTPND寄存器中是哪一位被设置成1，即正在等待处理</p><p><img src="/image/f260fa33f4e83980af9cda33254d29b7.png" alt="f260fa33f4e83980af9cda33254d29b7.png"></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment">/* INTOFFSET是用来显示INTPND寄存器中是哪一位被设置成1，即正在等待处理 */</span><br>INTPAD中<span class="hljs-keyword">bit0等于1的话INTOFFSET就等于0</span><br><span class="hljs-keyword"></span>INTPAD中<span class="hljs-keyword">bit1等于1的话INTOFFSET值就等于1</span><br><span class="hljs-keyword"></span><br>可以读INTPND，也可以读INTOFFSET确定哪个中断正在等待处理，读INTOFFSET比较方便，且不用清零<br></code></pre></td></tr></table></figure><p>SRCPND我们用不到</p><p><img src="/image/2e61a1315da6391919e514c23451ff9f.png" alt="2e61a1315da6391919e514c23451ff9f.png"></p><p>某一位等于1时INT_UART0它的来源可能有多个，这是串口0的中断，串口0的中断产生时有可能是接收到了数据(INT_RXD0),有可能是发送了数据(INT_TXD0),也有可能是产生了错误，那么到底是哪一个呢？</p><p>需要去读取SUBSRCPND下一级的源寄存器</p><p>我们只需要设置INTMSK这个寄存器</p><p>SRCPND和INTPND只有发生中断才需要设置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* 初始化中断控制器 */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">interrupt_init</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>        <span class="hljs-comment">/* 1是屏蔽我们需要清零，外部中断0 外部中断2 外部中8_23里面还有外部中断11到19 */</span><br>        <span class="hljs-variable constant_">INTMSK</span> &amp;= ~((<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">2</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>修改start.S</p><p>删除</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">bl</span> interrupt_init  <span class="hljs-comment">/* 初始化中断控制器 */</span><br><span class="hljs-keyword">bl</span> key_eint_init  <span class="hljs-comment">/* 初始化按键, 设为中断源 */</span><br></code></pre></td></tr></table></figure><p>能使用C语言就使用C语言，在main.c文件中添加调用C函数：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs wren">int <span class="hljs-title function_">main</span>(<span class="hljs-params">void</span>)<br>&#123;<br>    <span class="hljs-title function_">interrupt_init</span>();  <span class="hljs-comment">/* 初始化中断控制器 */</span><br>    <span class="hljs-title function_">key_eint_init</span>();   <span class="hljs-comment">/* 初始化按键, 设为中断源 */</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span>/        <br>    <span class="hljs-title function_">puts</span>(<span class="hljs-string">&quot;<span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span>g_A = &quot;</span>);<br>    <span class="hljs-title function_">printHex</span>(<span class="hljs-variable">g_A</span>);<br>    <span class="hljs-title function_">puts</span>(<span class="hljs-string">&quot;<span class="hljs-char escape_">\n</span><span class="hljs-char escape_">\r</span>&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>_按键中断程序示例_完善</strong></p><hr><p>首先main.c中 我们初始化中断控制器 初始化中断源</p><p>假设按键按下就会产生中断，CPU就会跳到start.S 执行</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><p>具体跳到哪里执行，我们需要看看中断向量表在哪里</p><p><img src="/image/e952bd32aa16202b20c092df04a3fd51.png" alt="e952bd32aa16202b20c092df04a3fd51.png"></p><p>IRQ模式的话跳到0x00000018地方</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">_start:</span><br>    <span class="hljs-keyword">b</span> reset                  <span class="hljs-comment">/* vector 0 : reset */</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, und_addr         <span class="hljs-comment">/* vector 4 : und */</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, swi_addr         <span class="hljs-comment">/* vector 8 : swi */</span><br><span class="hljs-comment">/* b halt：一旦发生异常就卡死 */</span><br>    <span class="hljs-keyword">b</span> halt                   <span class="hljs-comment">/* vector 0x0c : prefetch aboot */</span><br>    <span class="hljs-keyword">b</span> halt                   <span class="hljs-comment">/* vector 0x10 : data abort */</span><br>    <span class="hljs-keyword">b</span> halt                   <span class="hljs-comment">/* vector 0x14 : reserved */</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, irq_addr         <span class="hljs-comment">/* vector 0x18 : irq */</span><br>    <span class="hljs-keyword">b</span> halt                   <span class="hljs-comment">/* vector 0x1c : fiq */</span><br><br><span class="hljs-comment">/*3/</span><br><span class="hljs-comment">do_irq: </span><br><span class="hljs-comment">    /* 执行到这里之前:  </span><br><span class="hljs-comment">     * 1. lr_irq保存有被中断模式中的下一条即将执行的指令的地址  </span><br><span class="hljs-comment">     * 2. SPSR_irq保存有被中断模式的CPSR  </span><br><span class="hljs-comment">     * 3. CPSR中的M4-M0被设置为10010, 进入到irq模式  </span><br><span class="hljs-comment">     * 4. 跳到0x18的地方执行程序   </span><br><span class="hljs-comment">     */</span><br><br><span class="hljs-comment">/*4 分配不冲突的没有使用的内存就可以了*/</span><br>    <span class="hljs-comment">/* sp_irq未设置, 先设置它 */</span><br>     <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">=0x33d00000</span><br><br><span class="hljs-comment">/*5*/</span><br>     <span class="hljs-comment">/* 保存现场 */</span><br><br><span class="hljs-comment">/*7 发生中断时irq返回值是R14-4 为什么要减去4:硬件结构让你怎么做就怎么做 */</span><br>     <span class="hljs-comment">/* 在irq异常处理函数中有可能会修改r0-r12, 所以先保存 */</span><br>     <span class="hljs-comment">/* lr-4是异常处理完后的返回地址, 也要保存，在Table2-2查看 */</span><br>     <span class="hljs-keyword">sub</span> <span class="hljs-built_in">lr</span>, <span class="hljs-built_in">lr</span>, <span class="hljs-number">#4</span><br>     <span class="hljs-keyword">stmdb</span> <span class="hljs-built_in">sp</span>!, &#123;<span class="hljs-built_in">r0</span>-<span class="hljs-built_in">r12</span>, <span class="hljs-built_in">lr</span>&#125;  <br>        <br>    <span class="hljs-comment">/* 处理irq异常 */</span><br><span class="hljs-comment">/*6 在这C函数里分辨中断源，处理中断 */</span><br>    <span class="hljs-keyword">bl</span> handle_irq_c<br><br><span class="hljs-comment">/*8*/</span>     <br>    <span class="hljs-comment">/* 恢复现场 */</span><br>    <span class="hljs-keyword">ldmia</span> <span class="hljs-built_in">sp</span>!, &#123;<span class="hljs-built_in">r0</span>-<span class="hljs-built_in">r12</span>, <span class="hljs-built_in">pc</span>&#125;^  <span class="hljs-comment">/* ^会把spsr_irq的值恢复到cpsr里 */</span><br></code></pre></td></tr></table></figure><p>接下来我们在interrupt.c中写出 handle_irq_c处理函数 这个是处理中断的C函数</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_irq_c</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*1 分辨中断源 */</span><br>    <span class="hljs-comment">/* 读INTOFFSET在芯片手册里找到这个寄存器，它里面的值表示INTPND中哪一位被设置成1 */</span><br>    <span class="hljs-type">int</span> bit = INTOFFSET;<br><br>    <span class="hljs-comment">/*2 调用对应的处理函数 */</span><br>    <span class="hljs-keyword">if</span> (bit == <span class="hljs-number">0</span> || bit == <span class="hljs-number">2</span> || bit == <span class="hljs-number">5</span>)  <span class="hljs-comment">/* 对应eint0,2,eint8_23 */</span><br>    &#123;<br>        <span class="hljs-comment">/*我们会调用一个按键处理函数*/</span><br>        <span class="hljs-built_in">key_eint_irq</span>(bit); <span class="hljs-comment">/* 处理中断, 清中断源EINTPEND */</span><br>    &#125;<br><br>    <span class="hljs-comment">/*3 清中断 : 从Figure14-1图中的源头开始清  </span><br><span class="hljs-comment">     *先清除掉中断源里面的某些寄存器  </span><br><span class="hljs-comment">     *再清 SRCPND  </span><br><span class="hljs-comment">     *再清 INTPND </span><br><span class="hljs-comment">     */</span><br>    SRCPND = (<span class="hljs-number">1</span>&lt;&lt;bit);<br>    INTPND = (<span class="hljs-number">1</span>&lt;&lt;bit);     <br>&#125;<br></code></pre></td></tr></table></figure><p>读EINTPEND分辨哪个EINT产生(eint4~23)清除中断时, 写EINTPEND的相应位</p><p><img src="/image/f5bccdad305d5f4d352fce62e0d4604c.png" alt="f5bccdad305d5f4d352fce62e0d4604c.png"></p><p>我们使用s2来控制哪盏灯？</p><ul><li>之前我们写过按键控制led灯的程序，它使用的是s2控制gpf6</li><li>也就是s2控制led4 D12</li></ul><p><img src="/image/9ba631e79479724f79bdee3c818e6596.png" alt="9ba631e79479724f79bdee3c818e6596.png"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs awk">void key_eint_irq(int irq)<br>&#123;<br>    <span class="hljs-regexp">/*4 清的时候我先把这个值读出来，清的时候我再把他写进去 */</span><br>    unsigned int val = EINTPEND;<br>    unsigned int val1 = GPFDAT;<br>    unsigned int val2 = GPGDAT;  <br>    <span class="hljs-keyword">if</span> (irq == <span class="hljs-number">0</span>)     <span class="hljs-regexp">/*1 外部中断eint0对应s2按键  */</span><br>    &#123;  <br>    <span class="hljs-regexp">/*1.2 如何知道是按下还是松开，我们需要读值*/</span><br>        <span class="hljs-keyword">if</span> (val1 &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>)) <span class="hljs-regexp">/* s2 --&gt; gpf6 */</span><br>        &#123;<br>            <span class="hljs-regexp">/*1.3 松开 */</span><br>            GPFDAT |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">6</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-regexp">/*1.4 按下 */</span><br>            GPFDAT &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">6</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (irq == <span class="hljs-number">2</span>) <span class="hljs-regexp">/*2 eint2对应s3 控制 D11  LED2 */</span><br>    &#123;<br>            <span class="hljs-keyword">if</span> (val1 &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">2</span>)) <span class="hljs-regexp">/* s3 --&gt; gpf5 */</span><br>            &#123;<br>                <span class="hljs-regexp">/* 松开 */</span><br>                GPFDAT |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>);<br>            &#125;<br>           <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-regexp">/* 按下 */</span><br>                GPFDAT &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>);<br>            &#125;<br>    &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (irq == <span class="hljs-number">5</span>) <span class="hljs-regexp">/*3 eint8_23, eint11对应s4 控制 D10 LED1, eint19对应s5 控制所有LED */</span><br>        &#123;<br></code></pre></td></tr></table></figure><p>irq &#x3D; 5表明发生的事8-23的中断，到底是发生哪一种中断，我们需要读取 EINTPND来判断是哪个中断产生</p><p><img src="/image/f8afce629a651780016780a4e69e8104.png" alt="f8afce629a651780016780a4e69e8104.png"></p><p>如果bit19等于1的话表明外部中断EINT19产生了，如果bit11等于1表用外部中断11产生，这里我们需要判断</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs awk">        <span class="hljs-keyword">if</span> (val &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">11</span>)) <span class="hljs-regexp">/* 表明外部中断eint11产生 */</span><br>        &#123;    <br>            <span class="hljs-keyword">if</span> (val2 &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">3</span>)) <span class="hljs-regexp">/* s4 --&gt; gpf4 */</span><br>            &#123;<br>                <span class="hljs-regexp">/* 松开 */</span><br>                GPFDAT |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-regexp">/* 按下 */</span><br>                GPFDAT &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>);<br>            &#125;<br>        &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">19</span>)) <span class="hljs-regexp">/* 表用外部中断eint19 */</span><br>    &#123;<br>            <span class="hljs-keyword">if</span> (val2 &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">11</span>))<br>            &#123;<br>                <span class="hljs-regexp">/* 松开 */</span><br>                <span class="hljs-regexp">/* 熄灭所有LED 输出高电平 */</span><br>                GPFDAT |= ((<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">6</span>));<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-regexp">/* 按下: 点亮所有LED */</span><br>                GPFDAT &amp;= ~((<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">6</span>));<br>            &#125;<br>    &#125;<br>&#125;<br><span class="hljs-regexp">/*5 再把值写进去就达到了清除的效果 */</span><br>EINTPEND = val;<br>&#125;<br></code></pre></td></tr></table></figure><p>包含头文件，上传代码测试</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;S3c2440_soc.h&quot;</span></span><br></code></pre></td></tr></table></figure><p>编译通过，开发板上电测试正常工作 回顾中断处理流程</p><p>我们start.s 一上电从 _start: 运行 做一些初始化工作</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><code class="hljs awk">reset:<br>    <span class="hljs-regexp">/* 关闭看门狗 */</span><br><br>    <span class="hljs-regexp">/* 设置MPLL, FCLK : HCLK : PCLK = 400m : 100m : 50m */</span><br>    <span class="hljs-regexp">/* LOCKTIME(0x4C000000) = 0xFFFFFFFF */</span><br><br>    <span class="hljs-regexp">/* CLKDIVN(0x4C000014) = 0X5, tFCLK:tHCLK:tPCLK = 1:4:8  */</span><br><br>    <span class="hljs-regexp">/* 设置CPU工作于异步模式 */</span><br><br>    /* 设置MPLLCON(<span class="hljs-number">0</span>x4C000004) = (<span class="hljs-number">92</span>&lt;&lt;<span class="hljs-number">12</span>)|(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>)|(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>)   <br>     *  m = MDIV+<span class="hljs-number">8</span> = <span class="hljs-number">92</span>+<span class="hljs-number">8</span>=<span class="hljs-number">100</span>  <br>     *  p = PDIV+<span class="hljs-number">2</span> = <span class="hljs-number">1</span>+<span class="hljs-number">2</span> = <span class="hljs-number">3</span>  <br>     *  s = SDIV = <span class="hljs-number">1</span>  <br>     *  FCLK = <span class="hljs-number">2</span>*m*Fin<span class="hljs-regexp">/(p*2^s) = 2*100*12/</span>(<span class="hljs-number">3</span>*<span class="hljs-number">2</span>^<span class="hljs-number">1</span>)=<span class="hljs-number">400</span>M  <br>     */<br><br>    /* 一旦设置PLL, 就会锁定lock time直到PLL输出稳定  <br>     * 然后CPU工作于新的频率FCLK  <br>     */<br><br>    <span class="hljs-regexp">/* 设置内存: sp 栈 */</span><br>    <span class="hljs-regexp">/* 分辨是nor/</span>nand启动  <br>     * 写<span class="hljs-number">0</span>到<span class="hljs-number">0</span>地址, 再读出来  <br>     * 如果得到<span class="hljs-number">0</span>, 表示<span class="hljs-number">0</span>地址上的内容被修改了, 它对应ram, 这就是nand启动  <br>     * 否则就是nor启动  <br>     */<br><br>    bl sdram_init<br>    <span class="hljs-regexp">//</span>bl sdram_init2  <span class="hljs-regexp">/* 用到有初始值的数组, 不是位置无关码 */</span><br><br>    <span class="hljs-regexp">/* 重定位text, rodata, data段整个程序 */</span><br>    bl copy2sdram<br><br>    <span class="hljs-regexp">/* 清除BSS段 */</span><br>    bl clean_bss<br><br>    /* 复位之后, cpu处于svc模式  <br>     * 现在, 切换到usr模式  <br>     */<br>    mrs r0, cpsr         <span class="hljs-regexp">/* 读出cpsr */</span><br>    bic r0, r0, <span class="hljs-comment">#0xf     /* 修改M4-M0为0b10000, 进入usr模式 */</span><br>    bic r0, r0, <span class="hljs-comment">#(1&lt;&lt;7)  /* 清除I位, 使能中断 */</span><br>    msr cpsr, r0<br><br>    <span class="hljs-regexp">/* 设置 sp_usr */</span><br>    ldr sp, =<span class="hljs-number">0</span>x33f00000<br><br>    ldr pc, =sdramsdram:<br>    bl uart0_init<br><br>    bl print1<br>    <span class="hljs-regexp">/* 故意加入一条未定义指令 */u</span>nd_code:<br>    .word <span class="hljs-number">0</span>xdeadc0de  <span class="hljs-regexp">/* 未定义指令 */</span><br>    bl print2<br><br>    swi <span class="hljs-number">0</span>x123  <span class="hljs-regexp">/* 执行此命令, 触发SWI异常, 进入0x8执行 */</span><br><br>    <span class="hljs-regexp">//</span>bl main  <span class="hljs-regexp">/* 使用BL命令相对跳转, 程序仍然在NOR/</span>sram执行 */<br>    ldr pc, =main  <span class="hljs-regexp">/* 绝对跳转, 跳到SDRAM */</span><br><br>halt:<br>    b halt<br><br><span class="hljs-regexp">//</span>然后设置CPSR开中断<br><span class="hljs-regexp">//</span>然后跳到mian函数，做一些中断初始化<br><br>int main(void)<br>&#123;<br>    led_init();<br>    interrupt_init();  <span class="hljs-regexp">/* 初始化中断控制器 */</span><br>    key_eint_init();   <span class="hljs-regexp">/* 初始化按键, 设为中断源 */</span><br>        <br>    puts(<span class="hljs-string">&quot;\n\rg_A = &quot;</span>);<br>    printHex(g_A);<br>    puts(<span class="hljs-string">&quot;\n\r&quot;</span>);<span class="hljs-regexp">/*让后在main函数里一直循环输出串口*/</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        putchar(g_Char);<br>        g_Char++;<br><br>        putchar(g_Char3);<br>        g_Char3++;<br>        delay(<span class="hljs-number">1000000</span>);<br>        &#125;<br><br><span class="hljs-regexp">//</span>这个时候按下按键就会产生中断，让后进入start.s<br><span class="hljs-regexp">//</span>跳到<span class="hljs-number">0</span>x18 irq模式<br><br>    ldr pc, irq_addr <span class="hljs-regexp">/* vector 0x18 : irq */</span><br><br>它是一条读内存的执行，从irq_addr这里读地址赋给pc<br><br>irq_addr:<br>    .word do_irq<br><br>就跳到sdram执行do_irq函数<br>do_irq:<br>    /* 执行到这里之前:  <br>     * <span class="hljs-number">1</span>. lr_irq保存有被中断模式中的下一条即将执行的指令的地址  <br>     * <span class="hljs-number">2</span>. SPSR_irq保存有被中断模式的CPSR  <br>     * <span class="hljs-number">3</span>. CPSR中的M4-M0被设置为<span class="hljs-number">10010</span>, 进入到irq模式  <br>     * <span class="hljs-number">4</span>. 跳到<span class="hljs-number">0</span>x18的地方执行程序   <br>     */<br><br>    <span class="hljs-regexp">/* sp_irq未设置, 先设置它 */</span><br>    ldr sp, =<span class="hljs-number">0</span>x33d00000<br><br>    <span class="hljs-regexp">/* 保存现场 */</span><br>    <span class="hljs-regexp">/* 在irq异常处理函数中有可能会修改r0-r12, 所以先保存 */</span><br>    <span class="hljs-regexp">/* lr-4是异常处理完后的返回地址, 也要保存 */</span><br>    sub lr, lr, <span class="hljs-comment">#4</span><br>    stmdb sp!, &#123;r0-r12, lr&#125;  <br>        <br>    <span class="hljs-regexp">/* 处理irq异常 */</span><br>    bl handle_irq_c<br>        <br>    <span class="hljs-regexp">/* 恢复现场 */</span><br><br>它怎么处理<br>/* 读INTOFFSET分辨率哪个EINT产生(eint0，<span class="hljs-number">2</span>，<span class="hljs-number">8</span>~<span class="hljs-number">23</span>) <br> * 调用对应的处理函数<br> * 清除中断<br> */<br><br>void key_eint_irq(int irq)<br>&#123;<br>    unsigned int val = EINTPEND;<br>    unsigned int val1 = GPFDAT;<br>    unsigned int val2 = GPGDAT;<br>        <br>    <span class="hljs-keyword">if</span> (irq == <span class="hljs-number">0</span>) <span class="hljs-regexp">/* eint0 : s2 控制 D12 */</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (val1 &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>)) <span class="hljs-regexp">/* s2 --&gt; gpf6 */</span><br>        &#123;<br>            <span class="hljs-regexp">/* 松开 */</span><br>            GPFDAT |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">6</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-regexp">/* 按下 */</span><br>            GPFDAT &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">6</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (irq == <span class="hljs-number">2</span>) <span class="hljs-regexp">/* eint2 : s3 控制 D11 */</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (val1 &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">2</span>)) <span class="hljs-regexp">/* s3 --&gt; gpf5 */</span><br>        &#123;<br>            <span class="hljs-regexp">/* 松开 */</span><br>            GPFDAT |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-regexp">/* 按下 */</span><br>            GPFDAT &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (irq == <span class="hljs-number">5</span>) <span class="hljs-regexp">/* eint8_23, eint11--s4 控制 D10, eint19---s5 控制所有LED */</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (val &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">11</span>)) <span class="hljs-regexp">/* eint11 */</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (val2 &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">3</span>)) <span class="hljs-regexp">/* s4 --&gt; gpf4 */</span><br>            &#123;<br>                <span class="hljs-regexp">/* 松开 */</span><br>                GPFDAT |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-regexp">/* 按下 */</span><br>                GPFDAT &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>);<br>            &#125;<br>        &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">19</span>)) <span class="hljs-regexp">/* eint19 */</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (val2 &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">11</span>))<br>        &#123;<br>            <span class="hljs-regexp">/* 松开 */</span><br>            <span class="hljs-regexp">/* 熄灭所有LED */</span><br>            GPFDAT |= ((<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">6</span>));<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-regexp">/* 按下: 点亮所有LED */</span><br>            GPFDAT &amp;= ~((<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">6</span>));<br>        &#125;<br>    &#125;<br>&#125;<br><br>        EINTPEND = val;<br>&#125;<br>处理完之后清中断，从源头开始清<br></code></pre></td></tr></table></figure><p>这完全是按照中断流程操作的</p><p><strong>定时器中断程序示例</strong></p><hr><p>这节课我们来写一个定时器的中断服务程序 使用定时器来实现点灯计数 查考资料就是第10章PWM TIMER 可以参考书籍《嵌入式Linux应用程序开发完全手册》第10章</p><p>定时器内部控制逻辑图：</p><p><img src="/image/ccd4014ba91cc12d13baa12954f76d3b.png" alt="ccd4014ba91cc12d13baa12954f76d3b.png"></p><ol><li>这里面肯定有一个clk(时钟),每来一个clk(时钟)这个TCNTn减去1 </li><li>当TCNTn &#x3D;&#x3D; TCMPn时，不可以产生中断，可以让对应的PWM引脚反转，(比如说原来是高电平，发生之后电平转换成低电平) </li><li>TCNTn继续减1，当TCNTn &#x3D;&#x3D; 0时，可以产生中断，pwm引脚再次反转，TCMPn 和 TCNTn的初始值来自 TCMPBn,TCNTBn </li><li>TCNTn &#x3D;&#x3D; 0时，可设置成从TCMPBn,TCNTBn这两个寄存器中自动加载初始值</li></ol><p><strong>怎么使用定时器？</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 设置时钟<br><span class="hljs-bullet">2.</span> 设置初值<br><span class="hljs-bullet">3.</span> 加载初值，启动Timer<br><span class="hljs-bullet">4.</span> 设置为自动加载<br><span class="hljs-bullet">5.</span> 中断相关（选择在哪引出中断）<br></code></pre></td></tr></table></figure><p>由于2440没有引出pwm引脚，所以pwm功能无法使用，也就无法做pwm相关实验</p><p>所谓pwm是指可调制脉冲</p><p><img src="/image/800px-Chapter14_lesson8_002.png" alt="800px-Chapter14_lesson8_002.png"></p><p>T1高脉冲和T2低脉冲它的时间T1, T2可调整，可以输出不同频率不同占控比的波形，在控制电机时特别有用</p><p>我们这个程序只做一个实验：当TCNTn这个计数器到0的时候，就产生中断，在这个中断服务程序里我们点灯</p><p>写代码 打开我们的main函数</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">int <span class="hljs-selector-tag">main</span>(void)<br>&#123;<br>    <span class="hljs-built_in">led_init</span>();<br>    <span class="hljs-built_in">interrupt_init</span>();  <span class="hljs-comment">/* 初始化中断控制器 */</span><br>    <span class="hljs-built_in">key_eint_init</span>();   <span class="hljs-comment">/* 初始化按键, 设为中断源 */</span><br><span class="hljs-comment">//我们初始化了中断源，同样的，我们初始化timer</span><br><span class="hljs-comment">//初始化定时器</span><br>    <span class="hljs-built_in">timer_init</span>();<br></code></pre></td></tr></table></figure><p>我们需要实现定时器初始化函数</p><p>新建一个 timer.c，我们需要操作一堆寄存器，添加头文件 #include “s3c2440_soc.h”</p><p>写出void timer_init(void)</p><ol><li>设置TIMER0的时钟  &#x2F;* 选择使用TIMER0 *&#x2F;</li><li>设置TIMER0的初值</li><li>加载初值, 启动timer0</li><li>设置为自动加载并启动(值到0以后会自动加载)</li><li>设置中断(显然我们也需要提供一个中断处理函数void timer_irq(void)在这里面我们来点灯)</li></ol><p>打开芯片手册，我们想设置timer0的话</p><ol><li>首先设置8-Bit Prescaler(预分频器)</li><li>设置5.1 MUX(五选一，选择一个时钟分频)</li><li>设置TCMPB０和TCNTB0</li><li>设置TCONn寄存器用于控制</li></ol><p>Figure 10-1：</p><p><img src="/image/7ef44f90567be421d19d9aedcccbe60d.png" alt="7ef44f90567be421d19d9aedcccbe60d.png"></p><p>看手册上写如何初始化timer</p><p><img src="/image/f59da1b8a7583eb7787ba29dcd835abc.png" alt="f59da1b8a7583eb7787ba29dcd835abc.png"></p><ol><li>把初始值写到TCNTBn 和TCMPBn寄存器</li><li>设置手动更新位</li><li>设置启动位</li></ol><p>往下看到时钟配置寄存器</p><p><img src="/image/9597068d41a2ef047075a6c32ee915cf.png" alt="9597068d41a2ef047075a6c32ee915cf.png"></p><p>有个计算公式</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* Timer clk = PCLK /</span> &#123;(预分频数)prescaler value+<span class="hljs-number">1</span>&#125; / &#123;divider value(<span class="hljs-number">5.1</span>MUX值)&#125;            <br></code></pre></td></tr></table></figure><p>PCLK是50M</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">= 50000000/(99+1)/16</span><br><span class="hljs-section">= 31250</span><br> */<br></code></pre></td></tr></table></figure><p>也就是说我们得TCON是31250的话，从这个值一直减到0，才过去1秒</p><p>Prescaler0等于99</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">TCFG0</span> = <span class="hljs-number">99</span>;  /* Prescaler <span class="hljs-number">0</span> = <span class="hljs-number">99</span>, 用于timer0,<span class="hljs-number">1</span> */<br></code></pre></td></tr></table></figure><p>TCFG1 MUX多路复用器的意思，他有多路输入，我们可以通过MUX选择其中一路作为输出</p><p><img src="/image/40482a9f658b104b65e6d1f342e0f012.png" alt="40482a9f658b104b65e6d1f342e0f012.png"></p><p>根据上面mux的值，我们要把MUX0 设置成0011 只需要设置这4位即可，先清零 再或上 0011 就是3</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">TCFG1</span> &amp;= ~<span class="hljs-number">0</span>xf;<br><span class="hljs-attribute">TCFG1</span> |= <span class="hljs-number">3</span>;  /* MUX0 : <span class="hljs-number">1</span>/<span class="hljs-number">16</span> */<br></code></pre></td></tr></table></figure><p>再来看看初始值控制寄存器(我们没有用到TCMPB0，所以不设置)</p><p><img src="/image/800px-Chapter14_lesson8_007.png" alt="800px-Chapter14_lesson8_007.png"></p><p>一秒钟点灯太慢了 ，就让0.5秒</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">TCNTB0</span> <span class="hljs-operator">=</span> <span class="hljs-number">15625</span><span class="hljs-comment">;  /* 0.5s中断一次 */</span><br></code></pre></td></tr></table></figure><p>TCNTO0这个寄存器是用来观察里面的计数值的，不需要设置</p><p>现在可以设置TCON来设置这个寄存器了</p><p><img src="/image/68bd44a3aba8b01b941c4dbfbcceff31.png" alt="68bd44a3aba8b01b941c4dbfbcceff31.png"></p><p>现在需要设置Timer0</p><p><img src="/image/3520a06f8a00a3c2ddf62632127c2727.png" alt="3520a06f8a00a3c2ddf62632127c2727.png"></p><p>开始需要手工更新</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">TCON</span> |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>);   /* Update from TCNTB0 &amp; TCMPB0 */<br></code></pre></td></tr></table></figure><p>把这两个值放到TCNTB0 和 TCMPB0中</p><p><strong>注意：这一位必须清除才能写下一位</strong></p><p>设置为自动加载并启动，先清掉手动更新位，再或上bit0 bit3</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">TCON</span> &amp;= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>);<br><span class="hljs-attribute">TCON</span> |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">3</span>);  /* bit0: start, bit3: auto reload */<br></code></pre></td></tr></table></figure><p>设置中断，显然我们需要提供一个中断处理函数void timer_irq(void) 在Timer里没有看到中断相关的控制器，我们需要回到中断章节去看看中断控制器，看看有没有定时器相关的中断 我们没有看到更加细致的Timer0寄存器</p><p><img src="/image/3c7d29e2ea9cc627c32d02b8c60841e6.png" alt="3c7d29e2ea9cc627c32d02b8c60841e6.png"></p><p>当TCNTn&#x3D;TCMPn时，他不会产生中断，只有当TCNTn等于0的时候才可以产生中断，我们之前以为这个定时器可以产生两种中断，那么肯定有寄存器中断或者禁止两种寄存器其中之一，那现在只有一种中断的话，就相对简单些 设置中断的话，我们只需要设置中断控制器</p><p>设置interrupu.c中断控制器</p><ul><li><p>初始化中断控制器 void interrupt_init(void)，把对应位清零就行</p></li><li><p>把定时器相应的位清零就可以了，哪一位呢？</p></li></ul><p>INTPND的哪一位？ INT_TIMER0第10位即可</p><p><img src="/image/c93eb2d99b7bcbfb22f587851ff7decc.png" alt="c93eb2d99b7bcbfb22f587851ff7decc.png"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* void interrupt_init(void) */</span><br>INTMSK &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">10</span>);  <span class="hljs-regexp">/* enable timer0 int */</span><br></code></pre></td></tr></table></figure><p>当定时器减到0的时候就会产生中断，就会进到start.s这里一路执行do_irq</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs arduino">do_irq:<br>    <span class="hljs-comment">/* 执行到这里之前:  </span><br><span class="hljs-comment">     * 1. lr_irq保存有被中断模式中的下一条即将执行的指令的地址  </span><br><span class="hljs-comment">     * 2. SPSR_irq保存有被中断模式的CPSR  </span><br><span class="hljs-comment">     * 3. CPSR中的M4-M0被设置为10010, 进入到irq模式  </span><br><span class="hljs-comment">     * 4. 跳到0x18的地方执行程序   </span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-comment">/* sp_irq未设置, 先设置它 */</span><br><br>    <span class="hljs-comment">/* 保存现场 */</span><br>    <span class="hljs-comment">/* 在irq异常处理函数中有可能会修改r0-r12, 所以先保存 */</span><br>    <span class="hljs-comment">/* lr-4是异常处理完后的返回地址, 也要保存 */</span><br><br>    <span class="hljs-comment">/* 处理irq异常 */</span><br>    bl handle_irq_c<br>        <br>    <span class="hljs-comment">/* 恢复现场 */</span><br>    ldmia sp!, &#123;r0-r12, pc&#125;^  <span class="hljs-comment">/* ^会把spsr_irq的值恢复到cpsr里 */</span><br><br>然后进入irq处理函数中处理，处理这个<span class="hljs-function">irq</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_irq_c</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/* 分辨中断源 */</span><br>    <span class="hljs-type">int</span> bit = INTOFFSET;<br><br>    <span class="hljs-comment">/* 调用对应的处理函数 */</span><br><br>    <span class="hljs-keyword">if</span>(bit ==<span class="hljs-number">0</span> || bit == <span class="hljs-number">2</span> || bit == <span class="hljs-number">5</span>)<span class="hljs-comment">/*eint0,2,rint8_23*/</span><br>    &#123;<br>        <span class="hljs-built_in">key_eint_irq</span>(bit);<span class="hljs-comment">/*处理中断，清中断源EINTPEND*/</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bit == <span class="hljs-number">10</span>)<br><span class="hljs-comment">//如果等于10的话说明发生的是定时器中断，这时候就调用我们得timer_irq</span><br><span class="hljs-comment">//INTOFFSET中查找对应值</span><br>    &#123;<br>        <span class="hljs-built_in">timer_irq</span>();&#125;<br><br>        <span class="hljs-comment">/* 清中断 : 从源头开始清 */</span><br>        SRCPND = (<span class="hljs-number">1</span>&lt;&lt;bit);<br>        INTPND = (<span class="hljs-number">1</span>&lt;&lt;bit);     <br>    &#125;<br><br>回到timer.c文件中，在这个定时器处理函数中我们需要点灯<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">timer_irq</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/* 点灯计数 循环点灯*/</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> tmp;<br><br>    cnt++;<br><br>    tmp = ~cnt;<br>    tmp &amp;= <span class="hljs-number">7</span>;<br>    GPFDAT &amp;= ~(<span class="hljs-number">7</span>&lt;&lt;<span class="hljs-number">4</span>);<br>    GPFDAT |= (tmp&lt;&lt;<span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>代码写完我们实验一下，上传代码，在Makefile中添加timer.o，进行编译 编译后进行烧写 现象灯没有闪烁</p><p><strong>TCON有一个观察寄存器</strong></p><p>我们不断的打印这个值，看是否有变化</p><p><img src="/image/a48d57153707e8b932dc0ed286a12383.png" alt="a48d57153707e8b932dc0ed286a12383.png"></p><p>在main函数中不断打印</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">putchar</span>(g_Char3);<br>g_Char3++;<br><span class="hljs-built_in">delay</span>(<span class="hljs-number">1000000</span>);<br><span class="hljs-built_in">printHex</span>(TCNTO0);<br></code></pre></td></tr></table></figure><p>编译实验</p><p>打印结果全都是0，发现我们的定时器根本就没有启用，在timer.c文件void timer_init(void)函数里设置为自动加载并启动，先清掉手动更新位，再或上bit0 bit3</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">TCON</span> &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>);//我们没有设置取反<br><span class="hljs-attribute">TCON</span> |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">3</span>);  /* bit0: start, bit3: auto reload */<br></code></pre></td></tr></table></figure><p>再次实验</p><p>发现灯已经开始闪，就可以把调试信息去除了 对程序进行改进</p><p>在我们添加了定时器中断后，进入main函数中执行 timer_init();</p><p>需要修改interrupt.c 初始化函数 void interrupt_init(void) 还需要修改调用中断处理函数 void handle_irq_c(void) </p><p>每次添加一个中断我都需要修改handle_irq这个函数，这样太麻烦，我能不能保证这个interrupt.c文件不变，只需要在timer.c中引用即可，这里我们使用指针数组</p><p>在interrupt.c中定义函数指针数组</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs delphi">typedef void<span class="hljs-comment">(*irq_func)(int);   </span><br><span class="hljs-comment">    //使用irq_func代替void(*irq_func)(int irq)这句代码</span><br><span class="hljs-comment">    //irq_func的类型是void (*)</span>(int)    <br>    <span class="hljs-comment">//void(*irq_func)(int)    irq_func是一个函数指针，它的返回类型为空，它所指向的函数接收一个int型的参数</span><br></code></pre></td></tr></table></figure><p>定义一个数组，我们来看下这里有多少项，一共32位，我们想把每一个中断的处理函数都放在这个数组里面来，当发生中断时，我们可以得到这个中断号，然后我从数组里面调用对应的中断号就可以了</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">irq_func irq_array[<span class="hljs-number">32</span>];        <br>    <span class="hljs-regexp">//</span>定义<span class="hljs-number">32</span>个指针函数：<span class="hljs-keyword">void</span> (*irq_array[<span class="hljs-number">0</span>])(<span class="hljs-keyword">void</span>); <span class="hljs-keyword">void</span> (*irq_array[<span class="hljs-number">1</span>])(<span class="hljs-keyword">void</span>);<br></code></pre></td></tr></table></figure><p>那么我们得提供一个注册函数</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">void register_ir<span class="hljs-string">q (int irq, irq_func fp)</span><br>&#123;<br>    irq_array[irq] = fp;        <span class="hljs-regexp">//</span>把中断处理函数key_enit_irq和timer_inq放在数组里<br>    INTMASK &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; irq)；    //同时使能中断<br>&#125;<br></code></pre></td></tr></table></figure><p>以后我直接调用对应的处理函数</p><ol><li>在中断处理函数中根据中断号调用处理函数</li><li>在按键初始化函数，定时器初始化函数中通过register_irq注册中断</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs awk">void handle_irq_c(void)<br>&#123;<br>    <span class="hljs-regexp">/* 分辨中断源 */</span><br>    int bit = INTOFFSET;<br><br>    <span class="hljs-regexp">/* 调用对应的处理函数 */</span><br>    <span class="hljs-regexp">/* 根据得到的中断号，从这个数组里调用对应的函数 */</span><br>    irq_array[bit](bit);<br>        <br>    <span class="hljs-regexp">/* 清中断 : 从源头开始清 */</span><br>    SRCPND = (<span class="hljs-number">1</span>&lt;&lt;bit);<br>    INTPND = (<span class="hljs-number">1</span>&lt;&lt;bit);     <br>&#125;<br><br><span class="hljs-regexp">//</span>按键中断初始化函数需要注册<br><br>    <span class="hljs-regexp">/* 初始化按键, 设为中断源 */</span><br>    void key_eint_init(void)<br>    &#123;<br>        <span class="hljs-regexp">/* 配置GPIO为中断引脚 */</span><br>        GPFCON &amp;= ~((<span class="hljs-number">3</span>&lt;&lt;<span class="hljs-number">0</span>) | (<span class="hljs-number">3</span>&lt;&lt;<span class="hljs-number">4</span>));<br>        GPFCON |= ((<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-number">0</span>) | (<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-number">4</span>));   <span class="hljs-regexp">/* S2,S3被配置为中断引脚 */</span><br><br>        GPGCON &amp;= ~((<span class="hljs-number">3</span>&lt;&lt;<span class="hljs-number">6</span>) | (<span class="hljs-number">3</span>&lt;&lt;<span class="hljs-number">22</span>));<br>        GPGCON |= ((<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-number">6</span>) | (<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-number">22</span>));   <span class="hljs-regexp">/* S4,S5被配置为中断引脚 */</span><br>        <br>        <span class="hljs-regexp">/* 设置中断触发方式: 双边沿触发 */</span><br>        EXTINT0 |= (<span class="hljs-number">7</span>&lt;&lt;<span class="hljs-number">0</span>) | (<span class="hljs-number">7</span>&lt;&lt;<span class="hljs-number">8</span>);     <span class="hljs-regexp">/* S2,S3 */</span><br>        EXTINT1 |= (<span class="hljs-number">7</span>&lt;&lt;<span class="hljs-number">12</span>);             <span class="hljs-regexp">/* S4 */</span><br>        EXTINT2 |= (<span class="hljs-number">7</span>&lt;&lt;<span class="hljs-number">12</span>);             <span class="hljs-regexp">/* S5 */</span><br><br>        <span class="hljs-regexp">/* 设置EINTMASK使能eint11,19 */</span><br>        EINTMASK &amp;= ~((<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">11</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">19</span>));<br><br>        /* 注册中断 <br>         * 将该中断源对应的中断处理函数放入处理函数的数组，之后可以通过INTOFFSET的值来访问对应的处理函数<br>         * 同时使能该中断<br>         */<br>        register_irq(<span class="hljs-number">0</span>, key_eint_irq);    <span class="hljs-regexp">/* enit0 */</span><br>        register_irq(<span class="hljs-number">2</span>, key_eint_irq);    <span class="hljs-regexp">/* enit2 */</span><br>        register_irq(<span class="hljs-number">5</span>, key_eint_irq);    <span class="hljs-regexp">/* enit5 */</span><br>        &#125;<br></code></pre></td></tr></table></figure><p>在timer.c中也需要设置中断</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs awk">    void timer_init(void)<br>    &#123;<br>        <span class="hljs-regexp">/* 设置TIMER0的时钟 */</span><br>        <span class="hljs-regexp">/* Timer clk = PCLK /</span> &#123;prescaler value+<span class="hljs-number">1</span>&#125; / &#123;divider value&#125;<br>                     = <span class="hljs-number">50000000</span><span class="hljs-regexp">/(99+1)/</span><span class="hljs-number">16</span>              <br>                     = <span class="hljs-number">31250</span>  <br>         */<br>        TCFG0 = <span class="hljs-number">99</span>;  <span class="hljs-regexp">/* Prescaler 0 = 99, 用于timer0,1 */</span><br>        TCFG1 &amp;= ~<span class="hljs-number">0</span>xf;<br>        TCFG1 |= <span class="hljs-number">3</span>;  <span class="hljs-regexp">/* MUX0 : 1/</span><span class="hljs-number">16</span> */<br><br>        <span class="hljs-regexp">/* 设置TIMER0的初值 */</span><br>        TCNTB0 = <span class="hljs-number">15625</span>;  <span class="hljs-regexp">/* 0.5s中断一次 */</span><br><br>        <span class="hljs-regexp">/* 加载初值, 启动timer0 */</span><br>        TCON |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>);   <span class="hljs-regexp">/* Update from TCNTB0 &amp; TCMPB0 */</span><br><br>        <span class="hljs-regexp">/* 设置为自动加载并启动 */</span><br>         TCON &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>);<br>         TCON |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">3</span>);  <span class="hljs-regexp">/* bit0: start, bit3: auto reload */</span><br><br>       <span class="hljs-regexp">/* 注册中断 */</span><br>        register_irq(<span class="hljs-number">10</span>, timer_irq);<br>        &#125;<br></code></pre></td></tr></table></figure><p>把interrupt.c中按键的初始化放在最后面</p><p>我们来看看我们做了什么事情，</p><p>我们定义了一个指针数组</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">void</span>(*irq_func)(<span class="hljs-built_in">int</span>);<br></code></pre></td></tr></table></figure><p>这个指针数组里面放有各个指针的处理函数</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">irq_func irq_array[<span class="hljs-number">32</span>]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>当我们去初始化按键中断时，我们在初始化函数中给这按键注册中断函数</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">register_ir<span class="hljs-string">q(0, key_eint_irq)</span>;<br>register_ir<span class="hljs-string">q(2, key_eint_irq)</span>;<br>register_ir<span class="hljs-string">q(5, key_eint_irq)</span>;<br></code></pre></td></tr></table></figure><p>这个注册函数会把这个数组放在注册函数里面，同时使能中断</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs perl">void register_ir<span class="hljs-string">q(int irq, irq_func fp)</span><br>&#123;<br>    irq_array[irq] = fp;<br><br>    INTMSK &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;irq);<br>&#125;<br>//我们的timer.c中<br>timer_init();<br><span class="hljs-regexp">//</span>也会注册这个函数<br>    /* 设置中断 */<br>    register_ir<span class="hljs-string">q(10, timer_irq)</span>;<br></code></pre></td></tr></table></figure><p>把这个中断irq放在第10项里同时使能中断，以后我们只需要添加中断自己的初始化函数，和自己的中断函数，然后去注册中断，再也不需要修改interrupt.c里的内容函数 烧写执行*</p><p>查看定时器中断处理流程我们从start.s开始看， 一上电从 b reset运行做一列初始化</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">.text</span><br><span class="hljs-symbol">.global</span> _start<br><br><span class="hljs-symbol">_start:</span><br>    <span class="hljs-keyword">b</span> reset          <span class="hljs-comment">/* vector 0 : reset */</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, und_addr <span class="hljs-comment">/* vector 4 : und */</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, swi_addr <span class="hljs-comment">/* vector 8 : swi */</span><br>    <span class="hljs-keyword">b</span> halt                     <span class="hljs-comment">/* vector 0x0c : prefetch aboot */</span><br>    <span class="hljs-keyword">b</span> halt                     <span class="hljs-comment">/* vector 0x10 : data abort */</span><br>    <span class="hljs-keyword">b</span> halt                     <span class="hljs-comment">/* vector 0x14 : reserved */</span><br> <br>       <br><span class="hljs-symbol">reset:</span><br>    <span class="hljs-comment">/* 关闭看门狗 */</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-number">=0x53000000</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r1</span>, <span class="hljs-number">=0</span><br>    <span class="hljs-keyword">str</span> <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r0</span>]<br><br>    <span class="hljs-comment">/* 设置MPLL, FCLK : HCLK : PCLK = 400m : 100m : 50m */</span><br>    <span class="hljs-comment">/* LOCKTIME(0x4C000000) = 0xFFFFFFFF */</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-number">=0x4C000000</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r1</span>, <span class="hljs-number">=0xFFFFFFFF</span><br>    <span class="hljs-keyword">str</span> <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r0</span>]<br><br>    <span class="hljs-comment">/* CLKDIVN(0x4C000014) = 0X5, tFCLK:tHCLK:tPCLK = 1:4:8  */</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-number">=0x4C000014</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r1</span>, <span class="hljs-number">=0x5</span><br>    <span class="hljs-keyword">str</span> <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r0</span>]<br><br>    <span class="hljs-comment">/* 设置CPU工作于异步模式 */</span><br>    <span class="hljs-keyword">mrc</span> <span class="hljs-built_in">p15</span>,<span class="hljs-number">0</span>,<span class="hljs-built_in">r0</span>,<span class="hljs-built_in">c1</span>,<span class="hljs-built_in">c0</span>,<span class="hljs-number">0</span><br>    <span class="hljs-keyword">orr</span> <span class="hljs-built_in">r0</span>,<span class="hljs-built_in">r0</span>,<span class="hljs-number">#0xc0000000</span>   <span class="hljs-comment">//R1_nF:OR:R1_iA</span><br>    mcr <span class="hljs-built_in">p15</span>,<span class="hljs-number">0</span>,<span class="hljs-built_in">r0</span>,<span class="hljs-built_in">c1</span>,<span class="hljs-built_in">c0</span>,<span class="hljs-number">0</span><br><br>    <span class="hljs-comment">/* 设置MPLLCON(0x4C000004) = (92&lt;&lt;12)|(1&lt;&lt;4)|(1&lt;&lt;0)   </span><br><span class="hljs-comment">     *  m = MDIV+8 = 92+8=100  </span><br><span class="hljs-comment">     *  p = PDIV+2 = 1+2 = 3  </span><br><span class="hljs-comment">     *  s = SDIV = 1  </span><br><span class="hljs-comment">     *  FCLK = 2*m*Fin/(p*2^s) = 2*100*12/(3*2^1)=400M  </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, <span class="hljs-number">=0x4C000004</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r1</span>, =(<span class="hljs-number">92</span>&lt;&lt;<span class="hljs-number">12</span>)<span class="hljs-title">|(1&lt;&lt;4)|</span>(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">str</span> <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r0</span>]<br><br>    <span class="hljs-comment">/* 一旦设置PLL, 就会锁定lock time直到PLL输出稳定  </span><br><span class="hljs-comment">     * 然后CPU工作于新的频率FCLK  </span><br><span class="hljs-comment">     */</span><br>        <br><br>    <span class="hljs-comment">/* 设置内存: sp 栈 */</span><br>    <span class="hljs-comment">/* 分辨是nor/nand启动  </span><br><span class="hljs-comment">     * 写0到0地址, 再读出来  </span><br><span class="hljs-comment">     * 如果得到0, 表示0地址上的内容被修改了, 它对应ram, 这就是nand启动  </span><br><span class="hljs-comment">     * 否则就是nor启动  </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">r1</span>, <span class="hljs-number">#0</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r0</span>, [<span class="hljs-built_in">r1</span>] <span class="hljs-comment">/* 读出原来的值备份 */</span><br>    <span class="hljs-keyword">str</span> <span class="hljs-built_in">r1</span>, [<span class="hljs-built_in">r1</span>] <span class="hljs-comment">/* 0-&gt;[0] */</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">r2</span>, [<span class="hljs-built_in">r1</span>] <span class="hljs-comment">/* r2=[0] */</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">r1</span>, <span class="hljs-built_in">r2</span>   <span class="hljs-comment">/* r1==r2? 如果相等表示是NAND启动 */</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">=0x40000000</span>+<span class="hljs-number">4096</span> <span class="hljs-comment">/* 先假设是nor启动 */</span><br>    <span class="hljs-keyword">moveq</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">#4096</span>  <span class="hljs-comment">/* nand启动 */</span><br>    <span class="hljs-keyword">streq</span> <span class="hljs-built_in">r0</span>, [<span class="hljs-built_in">r1</span>]   <span class="hljs-comment">/* 恢复原来的值 */</span><br><br>    <span class="hljs-keyword">bl</span> sdram_init<br>    <span class="hljs-comment">//bl sdram_init2  /* 用到有初始值的数组, 不是位置无关码 */</span><br><br>    <span class="hljs-comment">/* 重定位text, rodata, data段整个程序 */</span><br>    <span class="hljs-keyword">bl</span> copy2sdram<br><br>    <span class="hljs-comment">/* 清除BSS段 */</span><br>    <span class="hljs-keyword">bl</span> clean_bss<br><br>    <span class="hljs-comment">/* 复位之后, cpu处于svc模式  * 现在, 切换到usr模式  */</span><br>    <span class="hljs-keyword">mrs</span> <span class="hljs-built_in">r0</span>, <span class="hljs-keyword">cpsr</span>         <span class="hljs-comment">/* 读出cpsr */</span><br>    <span class="hljs-keyword">bic</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">r0</span>, <span class="hljs-number">#0xf</span>     <span class="hljs-comment">/* 修改M4-M0为0b10000, 进入usr模式 */</span><br>    <span class="hljs-keyword">bic</span> <span class="hljs-built_in">r0</span>, <span class="hljs-built_in">r0</span>, #(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">7</span>)  <span class="hljs-comment">/* 清除I位, 使能中断 */</span><br>    <span class="hljs-keyword">msr</span> cpsr, <span class="hljs-built_in">r0</span><br><br>    <span class="hljs-comment">/* 设置 sp_usr */</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">=0x33f00000</span><br><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, <span class="hljs-symbol">=sdramsdram</span>:<br>    <span class="hljs-keyword">bl</span> uart0_init<br><br>    <span class="hljs-keyword">bl</span> print1<br>    <span class="hljs-comment">/* 故意加入一条未定义指令 */</span>und_code:<br>    <span class="hljs-meta">.word</span> <span class="hljs-number">0xdeadc0de</span>  <span class="hljs-comment">/* 未定义指令 */</span><br>    <span class="hljs-keyword">bl</span> print2<br><br>    <span class="hljs-keyword">swi</span> <span class="hljs-number">0x123</span>  <span class="hljs-comment">/* 执行此命令, 触发SWI异常, 进入0x8执行 */</span><br><br><span class="hljs-comment">/***最后执行main函数***/</span><br>    <span class="hljs-comment">//bl main  /* 使用BL命令相对跳转, 程序仍然在NOR/sram执行 */</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, <span class="hljs-symbol">=main</span>  <span class="hljs-comment">/* 绝对跳转, 跳到SDRAM */</span><br><br><span class="hljs-symbol">halt:</span><br>    <span class="hljs-keyword">b</span> halt<br></code></pre></td></tr></table></figure><p>进入main.c做一系列初始化</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss">int <span class="hljs-selector-tag">main</span>(void)<br>&#123;<br>    <span class="hljs-built_in">led_init</span>();<br>    <span class="hljs-comment">//interrupt_init();  /* 初始化中断控制器 */</span><br>    <span class="hljs-built_in">key_eint_init</span>();   <span class="hljs-comment">/* 初始化按键, 设为中断源 */</span><br>    <span class="hljs-built_in">timer_init</span>();<br>        <br>    <span class="hljs-built_in">puts</span>(&quot;\n\rg_A = &quot;);<br>    <span class="hljs-built_in">printHex</span>(g_A);<br>    <span class="hljs-built_in">puts</span>(&quot;\n\r&quot;);<br></code></pre></td></tr></table></figure><p>进入按键初始化程序 interrupt.c 初始化按键, 设为中断源</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs awk">int main(void)<br>&#123;<br>    led_init();<br>    <span class="hljs-regexp">//i</span>nterrupt_init();  <span class="hljs-regexp">/* 初始化中断控制器 */</span><br>    key_eint_init();   <span class="hljs-regexp">/* 初始化按键, 设为中断源 */</span><br>    timer_init();<br>        <br>    puts(<span class="hljs-string">&quot;\n\rg_A = &quot;</span>);<br>    printHex(g_A);<br>    puts(<span class="hljs-string">&quot;\n\r&quot;</span>);<br>进入按键初始化程序 interrupt.c 初始化按键, 设为中断源<br>void key_eint_init(void)&#123;<br>     <span class="hljs-regexp">/* 配置GPIO为中断引脚 */</span><br>    GPFCON &amp;= ~((<span class="hljs-number">3</span>&lt;&lt;<span class="hljs-number">0</span>) | (<span class="hljs-number">3</span>&lt;&lt;<span class="hljs-number">4</span>));<br>    GPFCON |= ((<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-number">0</span>) | (<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-number">4</span>));   <span class="hljs-regexp">/* S2,S3被配置为中断引脚 */</span><br>    GPGCON &amp;= ~((<span class="hljs-number">3</span>&lt;&lt;<span class="hljs-number">6</span>) | (<span class="hljs-number">3</span>&lt;&lt;<span class="hljs-number">22</span>));<br>    GPGCON |= ((<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-number">6</span>) | (<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-number">22</span>));   <span class="hljs-regexp">/* S4,S5被配置为中断引脚 */</span><br>        <br>    <span class="hljs-regexp">/* 设置中断触发方式: 双边沿触发 */</span><br>    EXTINT0 |= (<span class="hljs-number">7</span>&lt;&lt;<span class="hljs-number">0</span>) | (<span class="hljs-number">7</span>&lt;&lt;<span class="hljs-number">8</span>);     <span class="hljs-regexp">/* S2,S3 */</span><br>    EXTINT1 |= (<span class="hljs-number">7</span>&lt;&lt;<span class="hljs-number">12</span>);             <span class="hljs-regexp">/* S4 */</span><br>    EXTINT2 |= (<span class="hljs-number">7</span>&lt;&lt;<span class="hljs-number">12</span>);             <span class="hljs-regexp">/* S5 */</span><br>    <span class="hljs-regexp">/* 设置EINTMASK使能eint11,19 */</span><br>    EINTMASK &amp;= ~((<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">11</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">19</span>));<br><span class="hljs-regexp">/*注册中断控制器*/</span><br>    register_irq(<span class="hljs-number">0</span>, key_eint_irq);<br>    register_irq(<span class="hljs-number">2</span>, key_eint_irq);<br>    register_irq(<span class="hljs-number">5</span>, key_eint_irq);<br>&#125;<br><br>时钟初始化程序 &lt;code&gt;timer_init();&lt;/code&gt;<br><br>void timer_init(void)<br>&#123;<br>    <span class="hljs-regexp">/* 设置TIMER0的时钟 */</span><br>    <span class="hljs-regexp">/* Timer clk = PCLK /</span> &#123;prescaler value+<span class="hljs-number">1</span>&#125; / &#123;divider value&#125;               <br>                 = <span class="hljs-number">50000000</span><span class="hljs-regexp">/(99+1)/</span><span class="hljs-number">16</span>              <br>                 = <span class="hljs-number">31250</span>  <br>     */<br>    TCFG0 = <span class="hljs-number">99</span>;  <span class="hljs-regexp">/* Prescaler 0 = 99, 用于timer0,1 */</span><br>    TCFG1 &amp;= ~<span class="hljs-number">0</span>xf;<br>    TCFG1 |= <span class="hljs-number">3</span>;  <span class="hljs-regexp">/* MUX0 : 1/</span><span class="hljs-number">16</span> */<br>    <span class="hljs-regexp">/* 设置TIMER0的初值 */</span><br>    TCNTB0 = <span class="hljs-number">15625</span>;  <span class="hljs-regexp">/* 0.5s中断一次 */</span><br>    <span class="hljs-regexp">/* 加载初值, 启动timer0 */</span><br>    TCON |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>);   <span class="hljs-regexp">/* Update from TCNTB0 &amp; TCMPB0 */</span><br>    <span class="hljs-regexp">/* 设置为自动加载并启动 */</span><br>    TCON &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>);<br>    TCON |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>) | (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">3</span>);  <span class="hljs-regexp">/* bit0: start, bit3: auto reload */</span><br>    <span class="hljs-regexp">/* 设置中断 */</span><br>    register_irq(<span class="hljs-number">10</span>, timer_irq);<br>&#125;<br></code></pre></td></tr></table></figure><p>让后main.c函数一直循环执行 输出串口信息</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss">while (<span class="hljs-number">1</span>)<br>&#123;<br>    <span class="hljs-built_in">putchar</span>(g_Char);<br>    g_Char++;<br>    <span class="hljs-built_in">putchar</span>(g_Char3);<br>    g_Char3++;<br>    <span class="hljs-built_in">delay</span>(<span class="hljs-number">1000000</span>);<br>    <span class="hljs-comment">//printHex(TCNTO0);</span><br>&#125;<br></code></pre></td></tr></table></figure><p>定时器减到0的时候就会产生中断，start.S 跳到 0x18的地方执行</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs armasm">    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">pc</span>, irq_addr <span class="hljs-comment">/* vector 0x18 : irq */</span><br>    <span class="hljs-keyword">b</span> halt           <span class="hljs-comment">/* vector 0x1c : fiq */</span><br><span class="hljs-symbol">.align</span> <span class="hljs-number">4</span><br><br><span class="hljs-symbol">do_irq:</span><br>    <span class="hljs-comment">/* 执行到这里之前:  </span><br><span class="hljs-comment">     * 1. lr_irq保存有被中断模式中的下一条即将执行的指令的地址  </span><br><span class="hljs-comment">     * 2. SPSR_irq保存有被中断模式的CPSR  </span><br><span class="hljs-comment">     * 3. CPSR中的M4-M0被设置为10010, 进入到irq模式  </span><br><span class="hljs-comment">     * 4. 跳到0x18的地方执行程序   </span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-comment">/* sp_irq未设置, 先设置它 */</span><br>    <span class="hljs-keyword">ldr</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">=0x33d00000</span><br><br>    <span class="hljs-comment">/* 保存现场 */</span><br>    <span class="hljs-comment">/* 在irq异常处理函数中有可能会修改r0-r12, 所以先保存 */</span><br>    <span class="hljs-comment">/* lr-4是异常处理完后的返回地址, 也要保存 */</span><br>    <span class="hljs-keyword">sub</span> <span class="hljs-built_in">lr</span>, <span class="hljs-built_in">lr</span>, <span class="hljs-number">#4</span><br>    <span class="hljs-keyword">stmdb</span> <span class="hljs-built_in">sp</span>!, &#123;<span class="hljs-built_in">r0</span>-<span class="hljs-built_in">r12</span>, <span class="hljs-built_in">lr</span>&#125;  <br>        <br>    <span class="hljs-comment">/* 处理irq异常 */</span><br>    <span class="hljs-keyword">bl</span> handle_irq_c<br>        <br>    <span class="hljs-comment">/* 恢复现场 */</span><br>    <span class="hljs-keyword">ldmia</span> <span class="hljs-built_in">sp</span>!, &#123;<span class="hljs-built_in">r0</span>-<span class="hljs-built_in">r12</span>, <span class="hljs-built_in">pc</span>&#125;^  <span class="hljs-comment">/* ^会把spsr_irq的值恢复到cpsr里 */</span><br></code></pre></td></tr></table></figure><p>看看怎么处理irq</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle_irq_c</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/* 分辨中断源 */</span><br>    <span class="hljs-type">int</span> bit = INTOFFSET;<br><br>    <span class="hljs-comment">/* 调用对应的处理函数执行 */</span><br>    irq_array[bit](bit);<br>        <br>    <span class="hljs-comment">/* 清中断 : 从源头开始清 */</span><br>    SRCPND = (<span class="hljs-number">1</span>&lt;&lt;bit);<br>    INTPND = (<span class="hljs-number">1</span>&lt;&lt;bit);     <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(待修改)第011课 串口UART</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/(%E5%BE%85%E4%BF%AE%E6%94%B9)%E7%AC%AC011%E8%AF%BE_%E4%B8%B2%E5%8F%A3UART/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E4%B8%80%E6%9C%9F/(%E5%BE%85%E4%BF%AE%E6%94%B9)%E7%AC%AC011%E8%AF%BE_%E4%B8%B2%E5%8F%A3UART/</url>
    
    <content type="html"><![CDATA[<hr><p><a href="https://blog.csdn.net/m0_37671794/article/details/108416003">https://blog.csdn.net/m0_37671794&#x2F;article&#x2F;details&#x2F;108416003</a></p><p><a href="https://blog.csdn.net/qq_36521904/article/details/80595119?spm=1001.2014.3001.5501">https://blog.csdn.net/qq_36521904&#x2F;article&#x2F;details&#x2F;80595119?spm&#x3D;1001.2014.3001.5501</a></p><hr><p>UART(通用异步收发器)</p><p>串口的作用：  </p><ol><li>打印调试信息</li><li>连接各种外部设备</li></ol><p>使用串口时：1.波特率</p><p>                    2.格式：数据位、停止位、校验位、流量控制</p><p>怎么发送1Byte，比如A？（ARM----&gt;PC）</p><p>“A” 0x41 0b01000001</p><p>                    1.双方约定波特率(每一位所占据的时间)</p><p>                    2.原来是高电平，ARM拉低，保持1bit时间</p><p>                    3.拉低的瞬间，PC在低电平开始处计时</p><p>                    4.ARM根据数据驱动TXD电平：先发送最低位</p><p><img src="/image/b44ffa58c3697037869bd580c7f419d7.png" alt="b44ffa58c3697037869bd580c7f419d7.png"></p><p>一开始是高电平，要发送数据了会拉低点平，这样接收端才知道从这时开始计时</p><p>PC在数据位的中间(t0,t1)读取引脚状态 Data[0]&#x3D;RxD[t0]</p><p>以前技术不稳定，为了数据传输的可靠性，引入了校验位；校验位可以分为奇校验和偶校验，”数据位+校验位”中为1的位的个数是奇&#x2F;偶</p><p>RS232：适用于长距离传输</p><p>2440串口结构图如下：</p><p><img src="/image/20180606150226624.png" alt="20180606150226624.png"></p><p>ARM把数据发送给PC：</p><p>程序从内存中把数据写入到FIFO，在UART单元中再把数据从FIFO放入移位器(Transmit Shifter)中，逐位发送出去</p><p>PC把数据发送给ARM：</p><p>数据逐位发送到ARM的移位器(Receive Shifter)中逐位接收，然后放入FIFO，程序再把数据从FIFO中读取出来写入内存</p><p>Transmit Shifter和Receive Shifter都可在接收数据后中断CPU，由寄存器设定</p><p>波特率：115200</p><p>115200，8n1：八个数据位，没有校验位，一个停止位</p><p>每一位：t&#x3D;1&#x2F;115200</p><p>传输1Byte：需要10位(Start,Data,Stop)，t&#x3D;10&#x2F;115200</p><p>每秒能传输：1&#x2F;t&#x3D;115200&#x2F;10&#x3D;11520byte</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p><img src="/image/e4a576d3170fe05c122cdbb7bd0acf62.png" alt="e4a576d3170fe05c122cdbb7bd0acf62.png"></p><p>平时要让他处于高电平，要把它的内部上拉，因为(上面已标注)</p><p>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>编程</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* 设置引脚用于串口 */</span>    <span class="hljs-regexp">/* 使能内部上拉 */</span><br><span class="hljs-regexp">/* 设置波特率 */</span><br><span class="hljs-regexp">/* 设置数据格式 */</span><br><br>int putchar(int c)<br>&#123;<br>    <span class="hljs-regexp">/* UTRSTAT0 */</span><br>    <span class="hljs-regexp">/* UTXH0 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>判断数据是否发送出去了</p><p><img src="/image/79703a73150b11bb63e414448cafaafe.png" alt="79703a73150b11bb63e414448cafaafe.png"></p><p>把内存的数据写入UART中，用于传输</p><p><img src="/image/d48e2ff691f6dcde8ff9b10047ec5b3d.png" alt="d48e2ff691f6dcde8ff9b10047ec5b3d.png"></p><p>volatile unsigned char *</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用程序中的open()函数是怎么一步步调用到驱动程序中的open()、write()中去的</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84open()%E5%87%BD%E6%95%B0%E6%98%AF%E6%80%8E%E4%B9%88%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%B0%83%E7%94%A8%E5%88%B0%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84open()%E3%80%81write()%E4%B8%AD%E5%8E%BB%E7%9A%84/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84open()%E5%87%BD%E6%95%B0%E6%98%AF%E6%80%8E%E4%B9%88%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%B0%83%E7%94%A8%E5%88%B0%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84open()%E3%80%81write()%E4%B8%AD%E5%8E%BB%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">Linux内核只是Linux操作系统一部分。对下，它管理系统的所有硬件设备；对上，它通过系统调用，向<span class="hljs-keyword">Library</span> Routine（例如C库）或者其它应用程序提供接口。因此，其核心功能就是：管理硬件设备，供应用程序使用。<br></code></pre></td></tr></table></figure><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">操作系统的主要功能是为应用程序的运行创建良好的环境，保障每个程序都可以最大化利用硬件资源，防止非法程序破坏其它应用程序执行环境，为了达到这个目的，操作系统会将硬件的操作权限交给内核程序来管理，用户程序不能随意使用硬件，使用硬件（对硬件寄存器进行读写）时要先向操作系统发出请求，操作系统内核帮助用户程序实现其操作，也就是说用户程序不会直接操作硬件，而是提供给用户程序一些具备预定功能的内核函数，通过一组称为系统调用（<span class="hljs-keyword">system</span> <span class="hljs-keyword">call</span>)的接口呈现给用户，系统调用把应用程序的请求传给内核，调用相应的内核函数完成所需的处理，将处理结果返回给应用程序。<br></code></pre></td></tr></table></figure><p>操作系统为应用程序运行创造的良好环境，防止其被非法程序破坏，它将硬件的操作权限交给内核管理，使用户程序不能随意使用硬件。如果用户程序想使用硬件，只能通过操作系统提供的一些预先设计好功能的内核函数来间接操作硬件，这组接口就称为系统调用。系统调用会将应用程序的请求发给内核，然后调用内核函数完成处理，再返回处理结果给程序。</p><p>用户程序为什么不能访问内核？</p><p>因为用户程序运行在用户模式，用户模式运行在操作系统的用户态，它没有权限操作硬件，也不能切换模式。若它试图访问没有权限的硬件，会产生异常，所以用户模式被限制起来。因此系统调用若想实现用户程序的功能，若要调用内核函数，就必须切换到特权模式，所以系统调用就通过软件中断指令swi引发软中断操作，从而切换到管理(svc)模式下。</p><p>而open、write这些来源于库的函数（由于它们和系统调用关系紧密习惯上也称为系统调用），它们在glib库的源码中最后会产生一个swi异常(并将其对应的系统调用号保存在eax寄存器中，将传入参数保存在其他寄存器中），CPU检测到这个swi异常会跳到异常向量表(0xFFFF0000)的SWI向量(0xFFFF0008)，这个位置叫软中断处理入口，存在一条绝对跳转指令用来跳转到swi异常处理函数vector_swi（若想自定义软件中断跳转位置，可以自主在入口处根据传入的val设置跳转指令，让他跳转到自己的函数）。</p><p>在swi异常处理函数vector_swi中，进行保存现场（ 把相关的寄存器压入内核堆栈）、切换模式、获取系统调用号（ <a href="evernote:///view/18988257/s16/08611972-96c9-47fd-a1d5-4b596577d080/08611972-96c9-47fd-a1d5-4b596577d080/">系统调用号的获取</a>）、根据调用号在系统调用跳转表（sys_call_table或sys_oabi_call_table）中索引出实际要执行的系统调用函数入口并进入执行，进入后是sys_open()或sys_read()等函数，这个函数最终会调用到驱动程序中写的open函数（调用详解： <a href="evernote:///view/18988257/s16/9fd75717-0822-48a2-a9a3-a9ba3dc11c2a/9fd75717-0822-48a2-a9a3-a9ba3dc11c2a/">从sys_open()到open()</a>），open()第一次执行后最终会返回一个int型的文件句柄fd（执行详解： <a href="evernote:///view/18988257/s16/1c1aeca4-3d5b-4413-b149-78439b27b4a9/1c1aeca4-3d5b-4413-b149-78439b27b4a9/">open()第一次执行</a>），而后续的所有操作都是根据该句柄进行的，如read和write：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span></span>;<br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span></span>;<br></code></pre></td></tr></table></figure><p>对于设备文件而言这些操作直接对应于驱动程序实现的struct file_operations里的实现。<a href="evernote:///view/18988257/s16/bef446bb-9071-4711-9f44-74c71bfc9fe0/bef446bb-9071-4711-9f44-74c71bfc9fe0/">通过fd找到fops</a></p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nsis">系统调用<span class="hljs-params">system</span>_call的处理过程：<br>当系统调用发生时，通过中断机制，系统调用例程<span class="hljs-params">system</span>_call被调用。<span class="hljs-params">system</span>_call由汇编语言和C的代码构成，它的执行过程大概分为<span class="hljs-number">4</span>个步骤（注意参数的传入和返回值的传出过程）：<br><span class="hljs-number">1</span>.从寄存器中取出系统调用号（<span class="hljs-params">system</span> <span class="hljs-keyword">call</span> number）和输入参数，然后将这些寄存器的值压入kernel栈中。这一部分的代码用汇编写成。<br><span class="hljs-number">2</span>.根据系统调用号（<span class="hljs-params">system</span> <span class="hljs-keyword">call</span> number）查找系统调用分派表（<span class="hljs-params">system</span> <span class="hljs-keyword">call</span> dispatch table），找到系统调用服务例程（<span class="hljs-params">system</span> <span class="hljs-keyword">call</span> service routine ）。汇编语言。<br><span class="hljs-number">3</span>.调用查到的系统调用服务例程。这一部分用C语言写成，因为已经将输入参数保存在kernel栈中，所以在C函数的参数表中能够拿到输入参数，使得系统调用服务例程在表面上看与一个普通的C函数没有区别。<br><span class="hljs-number">4</span>.将系统调用服务例程的返回值出栈，重新保存在寄存器中。<br></code></pre></td></tr></table></figure><p><img src="/image/20180309202605116.png" alt="20180309202605116.png"></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统调用号的获取</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B7%E7%9A%84%E8%8E%B7%E5%8F%96/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B7%E7%9A%84%E8%8E%B7%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/DF11G/p/10172520.html">https://www.cnblogs.com/DF11G/p/10172520.html</a></p><p>vector_swi函数中有两个重要的宏，分别为：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">CONFIG<span class="hljs-emphasis">_OABI_COMPAT   </span><br><span class="hljs-emphasis">CONFIG_</span>AEABI<br></code></pre></td></tr></table></figure><p>OABI &#x3D; Old application binary interface</p><p>EABI &#x3D; Extended application binary interface</p><p>ABI &#x3D; 应用程序二进制接口， OABI&#x2F;EABI都是针对ARM处理器的接口，EABI也叫GNU EABI.</p><p>两者的区别：</p><ol><li><p>调用规则（参数传递，返回值传递）</p></li><li><p>系统调用数目以及应用程序怎么做系统调用</p></li><li><p>目标文件二进制个数</p></li><li><p>结构体中填充和对齐</p></li></ol><p>EABI的好处</p><ol><li><p>支持软件浮点&#x2F;硬件浮点混用</p></li><li><p>效率更高</p></li><li><p>工具兼容</p></li></ol><p>这两个宏可以在make menuconfig时进行配置</p><p>kernel features --&gt;</p><p>  [*] Use the ARM EABI to compile the kernel</p><p>  [*] Allow old ABI binary to run this kernel</p><p>两个可以同时Yes, 也可以只选一个EABI或者都不选</p><p>OABI方式系统调用</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">SWI&#123;cond&#125; immed<span class="hljs-emphasis">_24</span><br><span class="hljs-emphasis">参数：</span><br><span class="hljs-emphasis">    immed_</span>24: 24位立即数，指定了系统调用号，参数用通用寄存器传递<br></code></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">R0</span>，<span class="hljs-number">#34</span><br><span class="hljs-keyword">SWI</span> <span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p>EABI方式系统调用</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">R7</span>，<span class="hljs-number">#34</span><br><span class="hljs-keyword">SWI</span> <span class="hljs-number">0X0</span><br></code></pre></td></tr></table></figure><p>系统调用号由R7寄存器决定</p><p>在SWI异常处理程序中，得到系统调用号的方法：</p><p>-如果定义了OABI，说明存在OABI方式的调用，需要从SWI指令中获得调用号：</p><p>-如果没有定义OABI，但是定义了EABI，系此时统调用号只会存放在R7寄存器（即scno）， 不需要做任何处理</p><p>-如果没有定义OABI&#x2F;EABI，但是定义了CONFIG_ARM_THUMB</p><p>-如果OABI&#x2F;EABI&#x2F;CONFIG_ARM_THUMB都没有定义，此时保存整条SWI指令在R7，待下一步骤分解</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>未知/错误记录</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/%E6%9C%AA%E7%9F%A5-%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/%E6%9C%AA%E7%9F%A5-%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>find命令：find -name “deconfig” * -nR错误：</p><p><img src="/image/0595824c9330a78964e30a8c08cf9dbb.png" alt="0595824c9330a78964e30a8c08cf9dbb.png"></p><p>%!(EXTRA markdown.ResourceType&#x3D;, string&#x3D;, string&#x3D;)</p><p>错误记录</p><hr><p>1.drivers&#x2F;serial&#x2F;Kconfig:235:warning: multi-line strings not supported</p><p><a href="https://blog.csdn.net/daoliting5268/article/details/84503064?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param">https://blog.csdn.net/daoliting5268/article/details/84503064?utm_medium&#x3D;distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param&amp;depth_1-utm_source&#x3D;distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param</a></p><p>换了版本依旧没解决</p><p>2.无法向指定路径创建目录</p><p><img src="/image/28200b3c98ddb9803a69300cba8a57c7.png" alt="28200b3c98ddb9803a69300cba8a57c7.png"></p><p><img src="/image/9025954f241d36acc87f58e50f214395.png" alt="9025954f241d36acc87f58e50f214395.png"></p><p><img src="/image/2df7cb905914048915801cddea4ac3a4.png" alt="2df7cb905914048915801cddea4ac3a4.png"></p><p>原因：文件目录理解不够</p><p>mkdir -p &#x2F;work&#x2F;nfs_root&#x2F;first_fs是在work目录下创建，而不是我想的在&#x2F;home&#x2F;book&#x2F;work下创建</p><p>computer下有个和home同级的work目录，此处指定的绝对路径为&#x2F;work</p><p><img src="/image/8e9a996eaabb229dbbb6097bfdb60d63.png" alt="8e9a996eaabb229dbbb6097bfdb60d63.png"></p><p>注意此处~指示的是家目录，即代替了&#x2F;home&#x2F;book</p><p><img src="/image/73d0d5beedd7c9afdaaee59c36ff29ca.png" alt="73d0d5beedd7c9afdaaee59c36ff29ca.png"></p><p>而work目录下可见无~号</p><p><img src="/image/b5a208d90f8264c9bf431df804ed436f.png" alt="b5a208d90f8264c9bf431df804ed436f.png"></p><p>3.<img src="/image/31d14f6a5e85ede855518e1aeef629e2.png" alt="31d14f6a5e85ede855518e1aeef629e2.png"></p><p>因为根文件系统中找不到挂载点。这里就是文件夹没有创建</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过fd找到fops</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/%E9%80%9A%E8%BF%87fd%E6%89%BE%E5%88%B0fops/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/%E9%80%9A%E8%BF%87fd%E6%89%BE%E5%88%B0fops/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/mbuger/article/details/72123692">https://blog.csdn.net/mbuger/article/details/72123692</a></p><p><a href="https://blog.csdn.net/metersun/article/details/80513702">https://blog.csdn.net/metersun/article/details/80513702</a>（更深入）</p><p>Linux中有一个结构体task_sturct专门用来控制进程，在它的里面存放了各种关于进程的信息。</p><p>其中一个成员是一个指针：struct file_struct *file ,这个指针指向一个文件描述符表file_struct结构体，每个进程都有一个自己的文件描述符表。</p><p>文件描述符（fd）就被写在这个file_struct之中，它是文件描述表的索引，而且文件描述表中每个表项都有一个指向已打开文件的指针。</p><p>用户程序不能直接访问内核中的文件描述表，只能使用文件描述表的索引文件描述符访问，这些索引就称为文件描述符，用int型变量保存。</p><p><strong>（指向过程并不标准，从file_struct到struct file并不简单，这里只是简单介绍）</strong></p><p>在open的过程中，内核会以得到的fd为下标生成一个struct file（内核空间用struct file结构代表一个打开的文件），将新生成的struct file的指针填入表中，即</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">task</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">files</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">fdt</span>-&gt;</span>fd[fd] = filp;<br></code></pre></td></tr></table></figure><p>因此以fd的其他文件操作可以很轻易的找到其对应的struct file，进而调用f_op对应的方法。</p><p><img src="/image/20170516212621354.png" alt="20170516212621354.png"></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>驱动程序的理解</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>（一）Linux系统分层关系：</p><p>一个软件系统可以分为应用程序库，操作系统内核，驱动程序，开发人员可以专注于自己熟悉的部分，相比于相邻层只需要了解它的接口，必须关注它的实现性质，</p><p><img src="/image/20191216143504225.png" alt="20191216143504225.png"></p><p>（二）驱动程序的理解：驱动程序类似游戏mod</p><p>内核和驱动程序之间并没有界线，内核由一堆程序文件组成，而驱动程序就像给内核加入一些额外的带有设备操作信息的程序文件，通过insmod和rmmod决定是否加入到内核去，它加入内核时，会告诉内核自身在文件系统中的位置和自身的作用，然后等待被调用。由于它是直接编入内核，所以它的错误可能导致整个系统崩溃。</p><p>（三）驱动程序编写的难点：</p><p>Linux内核有大部分的驱动程序，我们去写一个驱动程序需要大量调用内核中代码，所以难点就在于弄清楚现在驱动程序的框架，合理的利用现有资源加入我们要写的驱动。同时还有其他需要注意的地方，比如驱动的并发等</p><p>（四）Linux驱动程序分类</p><p>计算机硬件系统有CPU、存储器以及外设组成，Linux驱动针对的对象是存储器和外设；Linux将驱动分为三大类：字符设备驱动、块设备驱动以及网络设备驱动。</p><ol><li>字符设备驱动：应用程序与驱动程序之间的数据交互是以字符(字节)为单位的，字符设备通常没有中间缓存。常见的字符设备有：led、key、camera、显卡、串口等</li><li>块设备驱动：应用程序与驱动程序之间的数据交互是以块为单位的，主要针对的是存储设备，通常设有中间缓存，并且带有文件系统，可以任意位置访问。常见的块设备有：U盘、eMMC、SD卡等</li><li>网络设备驱动：网络设备面向数据包的发送而设计，它并不对应于文件系统的节点。即不对应 &#x2F;dev 目录下的设备文件，应用程序最终通过套接字 socket 完成与网络设备的数据交互。常见的网络设备有网卡(无线网卡、有线网卡)。</li></ol><p>（五）编写驱动程序大致流程：</p><ol><li>查看原理图、数据手册，了解设备的操作方法。</li><li>在内核中找到相近的驱动程序，以它为模板进行开发，有时候需要从零开始。</li><li>开始编写驱动程序，实现驱动程序的初始化</li><li>编写驱动程序中供系统调用调用的函数：open、close、 read、 write 等。</li><li>实现中断服务(中断并不是每个设备驱动所必须的)。</li><li>编译该驱动程序到内核中，或者用insmod命令加载。</li><li>编写测试程序，测试驱动程序。</li><li>例：点亮led的驱动程序</li></ol><p>（1）应用程序使用库提供的open函数打开代表LED的设备文件，</p><p>（2）库根据open函数传入的参数执行swi指令,这条指令会引起CPU异常，进入内核。</p><p>（3）内核的异常处理函数，根据这些参数找到相应的驱动程序，返回一个文件句柄给库，进而返回给应用程序</p><p>（4）应用程序得到文件句柄后，使用库提供的write或ioclt函数发出控制命令</p><p>（5）库根据write或ioclt函数传入的参数执行swi指令，这条指令会引起CPU异常进入内核，这些函数依据设备号等得到swi val中的val</p><p>（6）内核的异常处理函数，根据这些参数调用驱动程序的相关函数，点亮LED。</p><p>（六）驱动中常用命令</p><ol><li>加载驱动模块insmod</li></ol><p>     将生成的驱动模块.ko文件加载，</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">insmod </span>xxx.ko<br></code></pre></td></tr></table></figure><p>     加载后就会执行xxxx_init函数</p><ol><li>卸载驱动模块rmmod</li></ol><p>     对应的卸载驱动的命令</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">rmmod xxxx 注意不用带<span class="hljs-string">.ko</span><br></code></pre></td></tr></table></figure><ol><li>查看内核中的模块信息</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">lsmod</span><br></code></pre></td></tr></table></figure><ol><li>查看模块的描述信息</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">modinfo</span> xxxx.ko<br></code></pre></td></tr></table></figure><p>     我们可以在驱动程序添加一些辅助信息，例如作者 ，驱动描述等。</p><ol><li>查看模块打印信息</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">dmesg</span><br></code></pre></td></tr></table></figure><p>     printk是内核打印函数，默认模式下在中断下无法显示（当然，可以设置成打印到终端），用dmesg可以查看一下打印到内核的信息。</p><p>（七）驱动相关的各个目录</p><ol><li>&#x2F;proc&#x2F;modules：模块加载列表,</li></ol><p>可使用lsmod命令显示有关模块的名称，大小，使用数目方面的信息</p><p>insmod（加载模块）后在此添加一行</p><ol><li>&#x2F;sys&#x2F;module：系统中所有模块的信息</li></ol><p>insmod（加载模块）后在此添加一子目录</p><ol><li>&#x2F;proc&#x2F;devices  :注册设备列表</li></ol><p>注册设备（register_chrdev_region等）后在此添加一行，它产生一个major供mknod作为参数。一般在模块加载时注册设备。</p><p>可使用cat &#x2F;proc&#x2F;devices查看已分配设备号和其对应的设备名</p><p>（1）register_chrdev_region(dev_t first, unsigned int count, char *name); name是设备的名字; 它会出现在 &#x2F;proc&#x2F;devices 和 sysfs 中。</p><p>（2）alloc_chrdev_region，因为动态分配，所以还需要读取&#x2F;proc&#x2F;devices文件以获得Linux内核分配给该设备的主设备号。</p><ol><li>&#x2F;dev&#x2F;*：包含了所有Linux系统中使用的外部设备，设备节点</li></ol><p>通过mknod手动创建（创建设备节点）或利用udev&#x2F;mdev自动创建后在此添加一子目录。</p><ol><li>额外说明</li></ol><p>（1）加载模块可能注册设备，也可能不注册设备；</p><p>（2）注册的设备（即设备驱动程序）可以对应多个设备；</p><p>（3）“加载模块的名字”可以和“注册的设备的名字”没有任何关联；只依赖于动态模块中注册设备时传入的参数name。</p><p>（4）&#x2F;proc&#x2F;devices和&#x2F;dev下的名字也可以完全不同，只依赖于“主设备号”关联二者的关系；</p><p>（5）&#x2F;dev下还有其他设备；</p><p>（八）驱动程序基本框架</p><ol><li>入口函数：</li></ol><p>（1）缺省情况下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> __init <span class="hljs-title function_">init_module</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>  加载模块时的初始化函数，也就是驱动模块的入口函数<br><span class="hljs-keyword">void</span> __exit <span class="hljs-title function_">cleanup_module</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> 卸载模块时的函数，也就是卸载某个驱动时要执行的函数<br></code></pre></td></tr></table></figure><p>（2）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">xxxx_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>  加载模块时的初始化函数，也就是驱动模块的入口函数<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __exit <span class="hljs-title function_">xxxx_exit</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>  卸载模块时的函数，也就是卸载某个驱动时要执行的函数<br></code></pre></td></tr></table></figure><p>上述两种情况相比，我们一般用第二种，因为第一种的名称是固定的，我们不能做更改，第二种我们可以改写xxxx为我们自己模块的名字。可以达到见文知义。</p><p>在用第二种模式时，我们要首先用固定格式声明一下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">module</span><span class="hljs-constructor">_init(<span class="hljs-params">xxxx_init</span>)</span>;<br><span class="hljs-keyword">module</span><span class="hljs-constructor">_exit(<span class="hljs-params">xxxx_exit</span>)</span>;<br></code></pre></td></tr></table></figure><p>用来表明加载初始化函数和卸载函数。</p><ol><li>c语言的标准函数库不能使用</li></ol><p>驱动属于内核的一部分，我们此时还无法使用类似像printf这样的c库，但是内核会提供自己的c库如(glibc)，在内核中我们用printk代替printf函数。</p><ol><li>添加LICENSE声明</li></ol><p>linux是开源的系统，那就要我们遵守一定的规范，我们一般用GPL规范，所以在驱动编写时都要声明一下</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">MODULE_LICENSE</span>(“GPL”);<br></code></pre></td></tr></table></figure><p>（九）字符驱动程序框架</p><p>概览：</p><ol><li>设备初始化</li></ol><p>（1）构建设备号</p><p>MAJOR()、MINOR()、MKDEV()</p><p>（2）注册设备号</p><p>①静态注册：register_chrdev_region()或register_chrdev()</p><p>②动态注册：alloc_chrdev_region()或register_chrdev()</p><p>③注销设备号：unregist_chrdev_region() 或unregister_chrdev()</p><p>（3）实现操作方法集</p><p>（4）初始化设备对象</p><p>①静态内存初始化：cdev_init()</p><p>②动态内存初始化：cdev_alloc()</p><ol><li>向内存注册设备对象</li></ol><p>（1）注册：cdev_add()</p><p>（2）卸载：cdev_del()</p><ol><li>创建设备文件</li></ol><p>（1）手动创建</p><p>（2）自动创建</p><ol><li>设备初始化：（内核层面）</li></ol><p>（1）构建设备号</p><p>一个字符设备或块设备都有一个主设备号major和一个次设备号minor。主设备号用来标识与设备文件相连的驱动程序，用来反映设备类型。次设备号被驱动程序用来辨别操作的是哪个设备，用来区分同类型的设备。</p><p>linux内核中，设备号用dev_t来描述，Linux也提供了一些宏来构建设备号：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">MAJOR(<span class="hljs-params">dev_t</span> <span class="hljs-params">dev</span>)</span>;     <span class="hljs-comment">//从设备号dev中提取major主设备号，传入返回值中返回</span><br><span class="hljs-constructor">MINOR(<span class="hljs-params">dev_t</span> <span class="hljs-params">dev</span>)</span>;     <span class="hljs-comment">//从设备号dev中提取minor次设备号，传入返回值中返回</span><br><span class="hljs-constructor">MKDEV(<span class="hljs-params">int</span> <span class="hljs-params">major</span>,<span class="hljs-params">int</span> <span class="hljs-params">minor</span>)</span>;    <span class="hljs-comment">//通过major和minor构建设备号，传入返回值中返回，常用devno表示设备号</span><br></code></pre></td></tr></table></figure><p>（2）注册设备号</p><p>构建设备号之后，要将这个设备号注册到内核当中，要确保这个设备号没有注册过，可通过cat &#x2F;proc&#x2F;devices列出内核现在支持的设备，查看对应的主设备号和名字</p><p>①静态注册（已有设备号）</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> register<span class="hljs-constructor">_chrdev_region(<span class="hljs-params">dev_t</span> <span class="hljs-params">from</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">count</span>, <span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">name</span>)</span><br>参数：<br>    from  设备号<br>    count  次设备的数量<br>    *name  设备号对应驱动的名称<br>返回值：成功 <span class="hljs-number">0</span>， 出错负数的错误码<br>使用举例：<br>    ret = register<span class="hljs-constructor">_chrdev_region(<span class="hljs-params">devno</span>, 1, <span class="hljs-string">&quot;xxx&quot;</span>)</span>;<br></code></pre></td></tr></table></figure><p>②动态注册（没有设备号，让系统自己构建并注册）</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> alloc<span class="hljs-constructor">_chrdev_region(<span class="hljs-params">dev_t</span> <span class="hljs-operator">*</span><span class="hljs-params">dev</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">baseminor</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">count</span>, <span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">name</span>)</span>；<br>参数：<br>    *dev 输出型参数，获得分配到的设备号<br>    baseminor 次设备号的起始.从第几个次设备号开始分配，一般为<span class="hljs-number">0</span><br>    count 申请次设备号的个数。<br>    *name 设备号对应驱动的名称<br>返回值：小于<span class="hljs-number">0</span>，则错误，自动分配设备号错误。分配得到的设备号就被第一个参数带出来。<br>使用举例：<br>    alloc<span class="hljs-constructor">_chrdev_region(&amp;<span class="hljs-params">devno</span>, 0, 1, <span class="hljs-string">&quot;xxx&quot;</span>)</span>;<br></code></pre></td></tr></table></figure><p>③注销设备号</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void unregister<span class="hljs-constructor">_chrdev_region(<span class="hljs-params">dev_t</span> <span class="hljs-params">from</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">count</span>)</span><br>参数：<br>    from  设备号<br>    count  次设备的数量<br>实例：<br>    unregister<span class="hljs-constructor">_chrdev_region(<span class="hljs-params">devno</span>, 1)</span>;<br></code></pre></td></tr></table></figure><p>（3）实现操作方法集</p><p>ops中就是一堆的操作方法。对象中必须得有方法，设备对象的方法全部都在ops当中，可以看到在源码的ops中有很多操作方法，我们只实现需要使用的。 <a href="evernote:///view/18988257/s16/2d3eab24-6e17-480b-811d-eb794ab7b395/2d3eab24-6e17-480b-811d-eb794ab7b395/">.owner与HIS_MODULE</a></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">file_operations</span> first_drv_fops = &#123;<br>    .owner  =   THIS_MODULE,  <br>    .open   =   first_drv_open,     <br>    .write  =   first_drv_write,       <br>&#125;;<br></code></pre></td></tr></table></figure><p>（4）初始化设备对象</p><p>C语言中用结构体实现一个面向对象的过程，我们需要先向内核注册一个设备号，再对应着这个设备号向内核注册一个字符设备对象，内核中每个字符设备都对应一个 cdev结构，所以我们注册一个cedv结构体</p><p>cdev结构体：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gauss">&lt;include/linux/cdev.h&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">cdev</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">kobject</span> kobj;                  <span class="hljs-comment">//内嵌的内核对象.</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">module</span> *owner;                 <span class="hljs-comment">//该字符设备所在的内核模块的对象指针.</span><br>    const <span class="hljs-keyword">struct</span> <span class="hljs-type">file_operations</span> *ops;    <span class="hljs-comment">//该结构描述了字符设备所能实现的方法，是极为关键的一个结构体.</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">list_head</span> list;                <span class="hljs-comment">//用来将已经向内核注册的所有字符设备形成链表.</span><br>    dev_t dev;                            <span class="hljs-comment">//字符设备的设备号，由主设备号和次设备号构成.</span><br>    unsigned int count;                   <span class="hljs-comment">//隶属于同一主设备号的次设备号的个数.</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>我们只关注以上编写定义的ops与dev，每一个设备号都只对应一个设备对象。</p><p>将该实现的方法都实现后，我们通过cdev_init将实现的方法和对象绑定到一起，其实就是设备对象的方法集合初始化。</p><p>一个 cdev一般它有两种定义初始化方式：静态的和动态的。使用cdev_init和cdev_alloc两个函数来初始化，两个函数完成的功能基本一致，不过使用的内存区不一样。</p><p>①静态内存定义初始化：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">struct</span> cdev my_cdev;<br>cdev<span class="hljs-constructor">_init(&amp;<span class="hljs-params">my_cdev</span>, &amp;<span class="hljs-params">first_drv_fops</span>)</span>;<br>my_cdev.owner = THIS_MODULE;    <span class="hljs-comment">//在fops中做</span><br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void cdev<span class="hljs-constructor">_init(<span class="hljs-params">struct</span> <span class="hljs-params">cdev</span> <span class="hljs-operator">*</span><span class="hljs-params">cdev</span>, <span class="hljs-params">const</span> <span class="hljs-params">struct</span> <span class="hljs-params">file_operations</span> <span class="hljs-operator">*</span><span class="hljs-params">fops</span>)</span><br>参数：<br>    cdev  字符设备对象<br>    *fops  文件操作集合<br>功能：对<span class="hljs-keyword">struct</span> cdev结构体做初始化<br></code></pre></td></tr></table></figure><p>如果你定义的是一个结构体而非指针，那么只需要使用cdev_init函数就可以了。cdev_init针对于不需要空间申请的函数。</p><p>cdev_init中使用memset，memset主要应用是初始化已经存在的某个内存空间。</p><p>②动态内存定义初始化：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xl">struct cdev *my_cdev = cdev_alloc();<br><span class="hljs-function"><span class="hljs-title">my_cdev</span>-&gt;</span>ops = &amp;first_drv_fops;<br><span class="hljs-function"><span class="hljs-title">my_cdev</span>-&gt;</span>owner = THIS_MODULE;    <span class="hljs-comment">//在fops中做</span><br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">struct</span> cdev *cdev<span class="hljs-constructor">_alloc(<span class="hljs-params">void</span>)</span><br></code></pre></td></tr></table></figure><p>如果你定义的是一个指针，那么只需要使用cdev_alloc函数并在其后做一个ops的赋值操作就可以了。kzalloc()申请一个内存空间，并把申请到的内存块初始化为0，这里相当于完成了memset的工作</p><ol><li>向内核注册设备对象（内核层面）</li></ol><p>（1）将初始化完的对象告诉内核</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> cdev<span class="hljs-constructor">_add(<span class="hljs-params">struct</span> <span class="hljs-params">cdev</span> <span class="hljs-operator">*</span><span class="hljs-params">p</span>, <span class="hljs-params">dev_t</span> <span class="hljs-params">dev</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">count</span>)</span><br>参数：<br>    p   字符设备对象<br>    dev 设备号<br>    count  次设备的数量<br>返回值：<span class="hljs-number">1</span>为失败，成功返回<span class="hljs-number">0</span><br>实例：<br>    cdev<span class="hljs-constructor">_add(<span class="hljs-params">cdev</span>, <span class="hljs-params">devno</span>, 1)</span>;<br>功能：<br>    向内核注册一个<span class="hljs-keyword">struct</span> cdev结构，将后两个参数直接复制给<span class="hljs-keyword">struct</span> cdev的dev成员和count成员<br></code></pre></td></tr></table></figure><p>（2）卸载模块对象</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void cdev<span class="hljs-constructor">_del(<span class="hljs-params">struct</span> <span class="hljs-params">cdev</span> <span class="hljs-operator">*</span><span class="hljs-params">p</span>)</span><br>参数：<br>    p   字符设备对象<br>实例：<br>    cdev<span class="hljs-constructor">_del(&amp;<span class="hljs-params">cdev</span>)</span>;<br>功能：<br>    向内核注销一个<span class="hljs-keyword">struct</span> cdev结构<br></code></pre></td></tr></table></figure><ol><li>创建设备文件，供用户调用</li></ol><p>linux中一切皆文件，驱动设备也一样。我们需要生成设备文件，供用户层调用。</p><p>（1）手动创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mknod</span> name 设备类型 主设备号 次设备号<br></code></pre></td></tr></table></figure><p>mknod做了什么事：  <a href="evernote:///view/18988257/s16/f9977171-4785-492b-93c4-7dbd8bcb37bf/f9977171-4785-492b-93c4-7dbd8bcb37bf/">mknod</a></p><p>（2）自动创建</p><p>利用udev（mdev）来实现设备文件的自动创建，首先应保证支持udev（mdev），由busybox配置。</p><p>在驱动中加入对udev 的支持主要做的就是：在驱动初始化的代码里调用class_create()为该设备创建一个类，再为每个设备调用device_create()（2.6之前版本使用的是class_device_create()）创建对应的设备（创建节点）。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static <span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *firstdrv_class;<br>static <span class="hljs-keyword">struct</span> class_device    *firstdrv_class_dev;<br><br>firstdrv_class = <span class="hljs-keyword">class</span><span class="hljs-constructor">_create(THIS_MODULE, <span class="hljs-string">&quot;firstdrv&quot;</span>)</span>;    <span class="hljs-comment">//创建类/sys/class/firstdrv</span><br>firstdrv_class_dev = <span class="hljs-keyword">class</span><span class="hljs-constructor">_device_create(<span class="hljs-params">firstdrv_class</span>, NULL, MKDEV(<span class="hljs-params">major</span>, 0)</span>, NULL, <span class="hljs-string">&quot;xyz&quot;</span>);     <span class="hljs-comment">//创建设备节点/dev/xyz</span><br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#define <span class="hljs-keyword">class</span><span class="hljs-constructor">_create(<span class="hljs-params">owner</span>, <span class="hljs-params">name</span>)</span><br>参数：<br>    owner THIS_MODULE<br>    name 名字<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">class_device</span> *<span class="hljs-built_in">class_device_create</span>(<span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span>        *cls,<br>                                         <span class="hljs-keyword">struct</span> class_device *parent,<br>                                         <span class="hljs-type">dev_t</span>               devt,<br>                                         <span class="hljs-keyword">struct</span> device       *device,<br>                                         <span class="hljs-type">const</span> <span class="hljs-type">char</span>          *fmt, ...)<br>参数：<br>    *<span class="hljs-keyword">class</span> 类<br>    *parent <span class="hljs-literal">NULL</span><br>    devt 设备号<br>    *drvdata null<br>    *fmt 名字<br></code></pre></td></tr></table></figure><p>（十）驱动相关函数</p><ol><li>应用程序中的函数：open、read、 write、ioctl、 mmap等接口函数被称为系统调用</li></ol><p>（1）来源：库(比如glibc)提供给应用程序</p><p>glibc是 linux系统中最底层的 api，几乎其它任何运行库都会依赖于glibc。</p><p>glibc还提供其他函数，比如字符串处理函数(strcpy、 strcmp 等)、输入&#x2F;输出函数(scanf、 printf 等)、数学库，还有应用程序的启动代码等。</p><p>（2）作用：它们都是设置好相关寄存器后（将系统调用号、参数保存到固定的寄存器），执行swi指令引发异常进入内核。</p><ol><li>驱动程序中的函数</li></ol><p><a href="evernote:///view/18988257/s16/8b4dbb76-689b-4590-9409-da7b4127e0fb/8b4dbb76-689b-4590-9409-da7b4127e0fb/">2.6内核char_dev.c分析</a></p><p>（十一）驱动相关结构体</p><p><a href="evernote:///view/18988257/s16/dcbd93f1-c6fa-4e74-862a-efaf88660233/dcbd93f1-c6fa-4e74-862a-efaf88660233/">几个关键结构体</a></p><p>（十二）open调用流程</p><p><a href="evernote:///view/18988257/s16/30eb24c7-21ec-45dc-9261-2b9de1d4c4f0/30eb24c7-21ec-45dc-9261-2b9de1d4c4f0/">应用程序中的open()函数是怎么一步步调用到驱动程序中的open()、write()中去的</a></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>几个关键结构体</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/zqixiao_09/article/details/50850004?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param">https://blog.csdn.net/zqixiao_09&#x2F;article&#x2F;details&#x2F;50850004?utm_medium&#x3D;distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source&#x3D;distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param</a></p><p><a href="http://blog.sina.com.cn/s/blog_7943319e01018m3w.html">http://blog.sina.com.cn/s/blog_7943319e01018m3w.html</a></p><p>用户空间使用 open() 函数打开一个字符设备 fd &#x3D; open(“&#x2F;dev&#x2F;hello”,O_RDWR) , 这一函数会调用两个数据结构 struct inode{…}与struct file{…} ，二者均在虚拟文件系统VFS处。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span></span>;<br></code></pre></td></tr></table></figure><p>（一）file文件结构体</p><p>定义在&#x2F;linux&#x2F;include&#x2F;linux&#x2F;fs.h(Linux 2.6.11内核)</p><p>file结构体指示一个已经打开的文件（设备对应于设备文件），其实系统中的每个打开的文件在内核空间都有一个相应的struct file结构体，它由内核在打开文件时创建，并传递给在文件在进行操作时需要的任何函数，直至文件被关闭。如果文件被关闭，内核就会释放相应的数据结构。</p><p>在内核源码中，struct file要么表示为file，或者为filp(意指“file pointer”), 注意区分一点，file指的是struct file本身，而filp是指向这个结构体的指针。</p><p>1.重要成员：</p><p>（1）fmode_t f_mode：设置对文件的访问模式,例如：只读，只写等。</p><p>        此文件模式通过FMODE_READ, FMODE_WRITE识别了文件为可读的，可写的，或者是二者。在open或ioctl函数中可能需要检查此域以确认文件的读&#x2F;写权限，你不必直接去检测读或写权限，因为内核在调用你的方法之前，内核本身就对其权限进行检测</p><p>（2）loff_t f_pos：表示当前读写文件的位置</p><p>        64位。如果想知道当前文件当前位置在哪，驱动可以读取这个值而不会改变其位置。对read,write来说，当其接收到一个loff_t型指针作为其最后一个参数时，他们的读写操作便作更新文件的位置，而不需要直接执行filp -&gt;f_pos操作。 这个规则的一个例外是在 llseek 方法中, 它的目的就是改变文件位置。</p><p>（3）unsigned int f_flags：文件标志，表示打开文件的权限</p><p>        如O_RDONLY, O_NONBLOCK以及O_SYNC。在驱动中应当检查O_NONBLOCK标志查看是否有非阻塞请求，其它的标志较少使用。特别地，读写权限的检查是使用f_mode而不是f_flog。所有的标志定义在头文件中</p><p>（4）struct file_operations *f_op：指向与文件关联的操作，即file_operation结构体</p><p>        当文件需要迅速进行各种操作时，内核分配这个指针作为它实现文件打开，读，写等功能的一部分。filp-&gt;f_op 其值从未被内核保存作为下次的引用，即你可以改变与文件相关的各种操作，这种方式效率非常高</p><p>        file_operation 结构体解析如下： <a href="evernote:///view/18988257/s16/5461058e-553f-4071-bae8-ec2bba99c211/5461058e-553f-4071-bae8-ec2bba99c211/">file_operation结构体解析</a></p><p>（5）void *private_data</p><p>        在驱动调用open方法之前，open系统调用设置此指针为NULL值。你可以很自由的将其做为你自己需要的一些数据域或者不管它，如，你可以将其指向一个分配好的数据，但是你必须记得在file struct被内核销毁之前在release方法中释放这些数据的内存空间。private_data用于在系统调用期间保存各种状态信息是非常有用的。</p><p>（6）struct dentry *f_dentry;</p><p>        关联到文件的目录入口( dentry )结构. 设备驱动编写者正常地不需要关心 dentry 结构, 除了作为 filp-&gt;f_dentry-&gt;d_inode 存取 inode 结构.</p><p>（二）inode结构体</p><p>inode 译成中文就是索引节点，一个索引节点就代表了一个具体的文件，在文件创建时创建文件删除时销毁，但是索引节点仅在当文件被访问时，才在内存中创建，且无论有多少个副本访问这个文件，inode只存在一份。</p><p>它与表示一个已经打开的文件描述符的结构体(即file 文件结构)是不同的，我们可以使用多个file 文件结构表示同一个文件的多个文件描述符，但此时，所有的这些file文件结构全部都必须只能指向一个inode结构体。</p><p>inode结构体包含了一大堆文件相关的信息，但是就针对驱动代码来说，我们只要关心其中的两个域即可：</p><p>(1) dev_t i_rdev;</p><p>表示设备文件的结点，这个域实际上包含了设备号。</p><p>(2) struct cdev *i_cdev;</p><p>struct cdev是内核的一个内部结构，它是用来表示字符设备的，当inode结点指向一个字符设备文件时，此域为一个指向inode结构的指针。</p><p>(3)const struct file_operations *i_fop; </p><p>文件操作方法集合，该设备文件所能拥有的所有能力。</p><p>（三）chardevs 散列表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHRDEV_MAJOR_HASH_SIZE 255</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-title">DEFINE_MUTEX</span><span class="hljs-params">(chrdevs_lock)</span></span>;<br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">char_device_struct</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">char_device_struct</span> *next; <span class="hljs-comment">// 结构体指针</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> major;              <span class="hljs-comment">// 主设备号</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> baseminor;          <span class="hljs-comment">// 次设备起始号</span><br>    <span class="hljs-type">int</span> minorct;                     <span class="hljs-comment">// 次备号个数</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">64</span>];<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">cdev</span> *cdev; <span class="hljs-comment">/* will die */</span><br>&#125; *chrdevs[CHRDEV_MAJOR_HASH_SIZE];      <span class="hljs-comment">// 只能挂255个字符主设备</span><br></code></pre></td></tr></table></figure><p>char_device_struct描述了设备号的使用情况，全局数组 chrdevs 包含了</p><p>255(CHRDEV_MAJOR_HASH_SIZE 的值)个 struct char_device_struct的元素，每一个对应一个相应的主设备号。 如果分配了一个设备号,就会创建一个 struct char_device_struct 的对象,并将其添加到 chrdevs 中；这样,通过chrdevs数组,我们就可以知道分配了哪些设备号。</p><p><img src="/image/7918efff75c9e9eeb6783d1dd21240c5.png" alt="7918efff75c9e9eeb6783d1dd21240c5.png"></p><p>设备号注册函数register_chrdev_region( )等解析如下： <a href="evernote:///view/18988257/s16/f38a8271-bd69-43bc-bf4b-2965fe9dfb17/f38a8271-bd69-43bc-bf4b-2965fe9dfb17/">register_chrdev_region( )等设备号注册函数</a></p><p>（四）cdev结构体</p><p>  在Linux内核中，使用cdev结构体来描述一个字符设备，cdev结构体的定义如下：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gauss">&lt;include/linux/cdev.h&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">cdev</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">kobject</span> kobj;                  <span class="hljs-comment">//内嵌的内核对象.</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">module</span> *owner;                 <span class="hljs-comment">//该字符设备所在的内核模块的对象指针.</span><br>    const <span class="hljs-keyword">struct</span> <span class="hljs-type">file_operations</span> *ops;    <span class="hljs-comment">//该结构描述了字符设备所能实现的方法，是极为关键的一个结构体.</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">list_head</span> list;                <span class="hljs-comment">//用来将已经向内核注册的所有字符设备形成链表.</span><br>    dev_t dev;                            <span class="hljs-comment">//字符设备的设备号，由主设备号和次设备号构成.</span><br>    unsigned int count;                   <span class="hljs-comment">//隶属于同一主设备号的次设备号的个数.</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>（1）使用cdev结构体来描述字符设备;</p><p>（2）通过其成员dev_t来定义设备号（分为主、次设备号）以确定字符设备的唯一性;</p><p>（3）通过其成员file_operations来定义字符设备驱动提供给VFS的接口函数，如常见的open()、read()、write()等;</p><p>（五）文件系统中对字符设备文件的访问</p><p>对于一个字符设备文件, 其inode-&gt;i_cdev 指向字符驱动对象cdev, 如果i_cdev为 NULL ,则说明该设备文件没有被打开.</p><p>由于多个设备可以共用同一个驱动程序.所以,通过字符设备的inode 中的i_devices 和 cdev中的list组成一个链表</p><p><img src="/image/20160310214827977.gif" alt="20160310214827977.gif"></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第005课_字符设备驱动</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/%E7%AC%AC005%E8%AF%BE_%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/%E7%AC%AC005%E8%AF%BE_%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<p>001</p><hr><p>应用程序：open，read，write</p><p>驱动程序：led_open，led_read，led_write</p><p>（最终依赖驱动程序框架来从应用程序对应到驱动程序）</p><p>内核定义了一个struct file_operations 结构体，这个结构的每一个成员的名字都对应着一个系统调用。</p><p>用户进程利用系统调用在对设备文件进行诸如读写操作时，系统调用通过设备文件的主设备号找到对应的设备驱动程序，然后读取这个数据结构对应的函数指针，接着将控制权交给该函数</p><p><img src="/image/20190929152913278.png" alt="20190929152913278.png"></p><p><img src="/image/20190929152913423.png" alt="20190929152913423.png"></p><p><img src="/image/e48346372c526da28e68d06566212cb8.png" alt="e48346372c526da28e68d06566212cb8.png"></p><p><img src="/image/o4YBAFp5ZVaAXaeqAABldKP6PmM816.jpg" alt="o4YBAFp5ZVaAXaeqAABldKP6PmM816.jpg"></p><p>002</p><hr><p>驱动程序框架：</p><ol><li>写出led_open,led_read,led_write等函数</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static <span class="hljs-built_in">int</span> first<span class="hljs-constructor">_drv_open(<span class="hljs-params">struct</span> <span class="hljs-params">inode</span> <span class="hljs-operator">*</span><span class="hljs-params">inode</span>, <span class="hljs-params">struct</span> <span class="hljs-params">file</span> <span class="hljs-operator">*</span><span class="hljs-params">file</span>)</span>&#123;&#125;<br>static ssize_t first<span class="hljs-constructor">_drv_write(<span class="hljs-params">struct</span> <span class="hljs-params">file</span> <span class="hljs-operator">*</span><span class="hljs-params">file</span>, <span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-params">__user</span> <span class="hljs-operator">*</span><span class="hljs-params">buf</span>, <span class="hljs-params">size_t</span> <span class="hljs-params">count</span>, <span class="hljs-params">loff_t</span> <span class="hljs-operator">*</span> <span class="hljs-params">ppos</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><ol><li>怎么告诉内核以上程序存在</li></ol><p>（1）定义file_operation结构</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">static struct file_oprations first_drv_fops <span class="hljs-operator">=</span> &#123;<br>    .owner <span class="hljs-operator">=</span> THIS_MODULE<span class="hljs-comment">;</span><br>    .open <span class="hljs-operator">=</span> first_drv_open<span class="hljs-comment">;    //open函数的功能是根据打开的设备文件初始化相应的io口</span><br>    .write <span class="hljs-operator">=</span> first_drv_write<span class="hljs-comment">;    //write函数的功能是根据设备文件以及向设备写入的值来操作相应的IO口做相应的动作</span><br>&#125;<br></code></pre></td></tr></table></figure><p>应用程序有什么接口，file_operation就有对应的成员</p><p>（2）把这个结构告诉内核</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">&#123;<br>    register<span class="hljs-constructor">_chrdev(<span class="hljs-params">major</span>, <span class="hljs-string">&quot;first_drv&quot;</span>, &amp;<span class="hljs-params">first_drv_fops</span>)</span>;    <span class="hljs-comment">//注册驱动程序</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（3）驱动入口函数来调用注册驱动程序</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> first<span class="hljs-constructor">_drv_init(<span class="hljs-params">void</span>)</span><br>&#123;<br>    register<span class="hljs-constructor">_chrdev(<span class="hljs-params">major</span>, <span class="hljs-string">&quot;first_drv&quot;</span>, &amp;<span class="hljs-params">first_drv_fops</span>)</span>;    <span class="hljs-comment">//注册驱动程序</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（4）内核如何知道一个驱动对应着哪个入口函数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">module</span><span class="hljs-constructor">_init(<span class="hljs-params">first_drv_init</span>)</span>;<br><span class="hljs-comment">//module_init指定了模块初始化函数，即入口函数</span><br></code></pre></td></tr></table></figure><p>当我们加载一个驱动时，内核会自动找到Module结构体，调用其中的函数指针(这里是first_dev_init)，指向了入口函数，而入口函数中就注册驱动程序，同时把mojor主设备号和file_operation这个结构告诉内核</p><p>module_init与module_exit表示在insmod与rmmod的时候内核会调用first_drv_init与first_drv_exit</p><p>应用：open(“&#x2F;dev&#x2F;xxx”)</p><p>xxx的属性：c _ _ _ _,_ _ _,major,mior</p><p>根据属性中的设备类型和主设备号来找到调用哪个file_operation</p><p>reregister_chrdev最简单的实现是在一个内核数组里面根据主设备号来将file_operationtion填充进去</p><p>完善：既然有入口函数，当然要有出口函数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> first<span class="hljs-constructor">_drv_exit(<span class="hljs-params">void</span>)</span><br>&#123;<br>    unregister<span class="hljs-constructor">_chrdev(<span class="hljs-params">major</span>, &amp;<span class="hljs-params">first_drv_fops</span>)</span>;    <span class="hljs-comment">//注销驱动程序</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对应的也要有module_exit();</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">/* Makefile */</span><br>KERN_DIR = <span class="hljs-regexp">/work/</span>system/linux<span class="hljs-number">-2.6</span><span class="hljs-number">.22</span><span class="hljs-number">.6</span>    <span class="hljs-comment">//内核</span><br><br><span class="hljs-built_in">all</span>:<br>    make -C $(KERN_DIR) M=<span class="hljs-string">`pwd`</span> modules    <br><br>clean:<br>    make -C $(KERN_DIR) M=<span class="hljs-string">`pwd`</span> modules clean<br>    rm -rf modules.order<br><br>obj-m    += first_drv.o<br></code></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">-C表示 指定进入指定的目录即KERN_DIR，是内核源代码目录，调用该目录顶层下的Makefile,目标为modules。<br>  <br>M=$(<span class="hljs-keyword">shell</span><span class="language-bash"> <span class="hljs-built_in">pwd</span>) | `<span class="hljs-built_in">pwd</span>`选项让该Makefile在构造modules目标之前返回到模块源代码目录并在当前目录生成obj-m指定的xxx.o目标模块。</span><br><br>clean这个目标表示将模块清理掉。<br><br>obj-m += xxx.o即指定当前目录要生成的目标模块，然后modules目标指向obj-m变量中设定的模块。<br></code></pre></td></tr></table></figure><p>003</p><hr><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/proc/</span>devices    <span class="hljs-regexp">//</span>可列出内核现在支持的设备：主设备号 名字<br>insmod first_drv.ko    <span class="hljs-regexp">//</span>加载驱动<br>lsmod    <span class="hljs-regexp">//</span>显示当前内核模块装载的模块<br>rmmod [模块名]    <span class="hljs-regexp">//</span>删除不需要的模块<br></code></pre></td></tr></table></figure><p>此时这个设备并不能正常打开，因为不存在这个文件”&#x2F;dev&#x2F;xxx”</p><p>创建文件结点（注意主设备号）：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mknod</span> /dev/xxx c <span class="hljs-number">111</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>正常打开</p><p>major主设备号可以通过cat &#x2F;proc&#x2F;devices查看哪里有空缺，然后在register_chrdev()自己指定一个主设备号，或者写major &#x3D; register_chrdev(0, “”, &amp;);来让系统自动分配主设备号</p><ol><li>驱动分配设备号：</li></ol><p>（1）手动</p><p>（2）自动</p><ol><li>应用打开一个设备文件：open(“&#x2F;dev&#x2F;xxx”)，这个设备文件怎么来的</li></ol><p>（1）手工建立：mknod</p><p>（2）自动创建：udev机制，此处是mdev（根据系统信息创建设备节点）</p><p>提供系统信息</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *firstdrv_class;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span> class_device    *firstdrv_class_dev;<br></code></pre></td></tr></table></figure><p>在注册函数注册进入后，在其中创建一个类，类下再创建一个设备</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static <span class="hljs-built_in">int</span> first<span class="hljs-constructor">_drv_init(<span class="hljs-params">void</span>)</span><br>&#123;<br>    major = register<span class="hljs-constructor">_chrdev(0, <span class="hljs-string">&quot;first_drv&quot;</span>, &amp;<span class="hljs-params">first_drv_fops</span>)</span>; <span class="hljs-comment">// 注册, 告诉内核</span><br><br>    firstdrv_class = <span class="hljs-keyword">class</span><span class="hljs-constructor">_create(THIS_MODULE, <span class="hljs-string">&quot;firstdrv&quot;</span>)</span>;<br><br>    firstdrv_class_dev = <span class="hljs-keyword">class</span><span class="hljs-constructor">_device_create(<span class="hljs-params">firstdrv_class</span>, NULL, MKDEV(<span class="hljs-params">major</span>, 0)</span>, NULL, <span class="hljs-string">&quot;xyz&quot;</span>); <span class="hljs-comment">/* mdev就会自动创建/dev/xyz */</span><br><br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时在出口函数删去</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static void first<span class="hljs-constructor">_drv_exit(<span class="hljs-params">void</span>)</span><br>&#123;<br>    unregister<span class="hljs-constructor">_chrdev(<span class="hljs-params">major</span>, <span class="hljs-string">&quot;first_drv&quot;</span>)</span>; <span class="hljs-comment">// 卸载</span><br><br>    <span class="hljs-keyword">class</span><span class="hljs-constructor">_device_unregister(<span class="hljs-params">firstdrv_class_dev</span>)</span>;<br>    <span class="hljs-keyword">class</span><span class="hljs-constructor">_destroy(<span class="hljs-params">firstdrv_class</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时在文件末尾加上MODULE_LICENSE(“GPL”);</p><p>从2.4.10版本内核开始，模块必须通过MODULE_LICENSE宏声明此模块的许可证，否则在加载此模块时，会收到内核被污染 “kernel tainted” 的警告。</p><p><img src="/image/dae3734d2897b620dcb829ba051f34a3.png" alt="dae3734d2897b620dcb829ba051f34a3.png"></p><p>编译运行</p><ol><li><p>在当前目录下make后编译出first_drv.ko文件</p></li><li><p>arm-linux-gcc -o first_test first_test.c编译出first_test测试程序</p></li><li><p>cp first_drv.ko first_test &#x2F;work&#x2F;nfs_root将编译出来的文件拷贝到开发板挂接的网络文件系统上</p></li><li><p>执行insmod first_drv.ko加载驱动。</p></li><li><p>.&#x2F;first_test &#x2F;dev&#x2F;leds on测试程序。</p></li></ol><p>004</p><hr><p>一个LED驱动：</p><ol><li>框架</li><li>完善硬件的操作</li></ol><p>（1）看原理图</p><p>（2）看芯片手册</p><p>（3）写代码</p><p>①单片机：物理地址</p><p>②驱动：虚拟地址（使用ioremap映射）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *gpfcon = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *gpfdat = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">first_drv_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    major = <span class="hljs-built_in">register_chrdev</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;first_drv&quot;</span>, &amp;first_drv_fops); <span class="hljs-comment">// 注册, 告诉内核</span><br><br>    firstdrv_class = <span class="hljs-built_in">class_create</span>(THIS_MODULE, <span class="hljs-string">&quot;firstdrv&quot;</span>);<br><br>    firstdrv_class_dev = <span class="hljs-built_in">class_device_create</span>(firstdrv_class, <span class="hljs-literal">NULL</span>, <span class="hljs-built_in">MKDEV</span>(major, <span class="hljs-number">0</span>), <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;xyz&quot;</span>); <span class="hljs-comment">/* /dev/xyz */</span><br><br>    gpfcon = (<span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *)<span class="hljs-built_in">ioremap</span>(<span class="hljs-number">0x56000050</span>, <span class="hljs-number">16</span>);    <span class="hljs-comment">//地址映射</span><br>    gpfdat = gpfcon + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">first_drv_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">unregister_chrdev</span>(major, <span class="hljs-string">&quot;first_drv&quot;</span>); <span class="hljs-comment">// 卸载</span><br><br>    <span class="hljs-built_in">class_device_unregister</span>(firstdrv_class_dev);<br>    <span class="hljs-built_in">class_destroy</span>(firstdrv_class);<br>    <span class="hljs-built_in">iounmap</span>(gpfcon);<br>&#125;<br></code></pre></td></tr></table></figure><p>ioremap函数重映射函数，将物理地址转换成虚拟地址：</p><p>使用物理地址的缺点：</p><ol><li>安全风险：用户操作不当直接操作了某个未知的物理地址，导致数据被改写，有可能导致那部分内存的程序或设备损坏</li><li>地址不确定：运行时，需要将程序搬到内存上执行，拷贝的实际内存地址每一次运行都是不确定的</li><li>效率低下</li></ol><p>且内核没有办法直接访问物理内存地址，必须先通过ioremap获得对应的虚拟地址</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static ssize_t first<span class="hljs-constructor">_drv_write(<span class="hljs-params">struct</span> <span class="hljs-params">file</span> <span class="hljs-operator">*</span><span class="hljs-params">file</span>, <span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-params">__user</span> <span class="hljs-operator">*</span><span class="hljs-params">buf</span>, <span class="hljs-params">size_t</span> <span class="hljs-params">count</span>, <span class="hljs-params">loff_t</span> <span class="hljs-operator">*</span> <span class="hljs-params">ppos</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>;<br><br>    <span class="hljs-comment">//printk(&quot;first_drv_write\n&quot;);</span><br><br>    copy<span class="hljs-constructor">_from_user(&amp;<span class="hljs-params">val</span>, <span class="hljs-params">buf</span>, <span class="hljs-params">count</span>)</span>;    <br><span class="hljs-comment">//用户空间向内核空间传递数据 copy_from_user(void *to,const void _user *from, unsigned long n) </span><br><span class="hljs-comment">//在这里做到了将测试函数中write()的参数val传递给first_drv_write()的val  </span><br><span class="hljs-comment">//copy_to_user();  内核空间向用户空间传递数据</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">val</span><span class="hljs-operator"> == </span><span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 点灯</span><br>        *gpfdat &amp;= ~((<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>) <span class="hljs-pattern-match">| (1&lt;&lt;5) | (1&lt;&lt;6));</span><br><span class="hljs-pattern-match">    &#125;</span><br><span class="hljs-pattern-match">    <span class="hljs-keyword">else</span></span><br><span class="hljs-pattern-match">    &#123;</span><br><span class="hljs-pattern-match">        <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 灭灯</span><br><span class="hljs-pattern-match">        <span class="hljs-operator">*</span>gpfdat |= (1&lt;&lt;4) | (1&lt;&lt;5) | (1&lt;&lt;6);</span><br><span class="hljs-pattern-match">    &#125;</span><br><span class="hljs-pattern-match">    return 0;</span><br><span class="hljs-pattern-match">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* firstdrvtest on</span><br><span class="hljs-comment"> * firstdrvtest off</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-type">int</span> val = <span class="hljs-number">1</span>;<br>    fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/xyz&quot;</span>, O_RDWR);<br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;can&#x27;t open!\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage :\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s &lt;on|off&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;on&quot;</span>) == <span class="hljs-number">0</span>)<br>    &#123;<br>        val  = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        val = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-built_in">write</span>(fd, &amp;val, <span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>次设备号的利用：用一个次设备号对应一盏灯</p><p>005</p><hr><p>驱动框架：</p><p>1.file_operation</p><p>2.实现驱动的函数</p><p>3.入口函数，出口函数</p><p>4.创建设备节点</p><p>硬件操作：</p><p>1.看原理图</p><p>2.看芯片手册</p><p>3.编程</p><p>（1）物理地址与虚拟地址</p><p>006-007 （内核相关暂时没有深究）</p><hr><p>中断方式驱动键值</p><p>1.按键按下</p><p>2.CPU发生中断，跳到异常向量入口执行</p><p>3.b 函数</p><p>（1）保存被中断的现场</p><p>（2）执行中断处理函数</p><p>（3）恢复</p><p>异常向量如何调用到异常处理函数asm_do_IRQ的？P400图20.1</p><p>（一）ARM架构Linux内核的异常处理体系结构</p><p>内核中使用trap_init()设置异常的处理函数，构造异常向量。当发生异常时CPU会自动执行这些固定位置上的指令，从而调用对应的C处理函数</p><p>ARM架构CPU的异常向量基址可以是0x00000000，也可以是0xffff0000，Linux内核使用后者。</p><p>trap_init()函数将异常向量复制到0xffff0000处：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sqf">void <span class="hljs-variable">__init</span> trap_init(void)<br>&#123;<br>    ...<br>    memcpy((void *)vectors, <span class="hljs-variable">__vectors_start</span>, <span class="hljs-variable">__vectors_end</span> - <span class="hljs-variable">__vectors_start</span>);<br>    ...   <br>&#125;<br>vectors等于<span class="hljs-number">0</span>xffff0000。<br><span class="hljs-variable">__vectors_start</span>~<span class="hljs-variable">__vectors_end</span>之间的代码就是异常向量<br></code></pre></td></tr></table></figure><p>异常向量的代码其实就是一些跳转指令，比如在__vectors_start向量里</p><p><img src="/image/8304a2d2204b4c4815c7febd0f67e6f4.png" alt="8304a2d2204b4c4815c7febd0f67e6f4.png"></p><p>例如vector_irq向量，它通过vector_stub宏来定义，这个宏的功能是：</p><p>1.计算返回地址；</p><p>2.保存现场进入管理模式；</p><p>3.根据中断的工作模式跳转比如：__irq_usr&#x2F;__irq_svc等，它们表示在何种模式下发生的异常</p><p>（1）保存现场</p><p>（2）调用irq_handler（宏）</p><p>①保存现场</p><p>②调用asm_do_IRQ</p><p><span style="background-color: #ffaaaa"><img src="/image/841c6a0d7b3992368f5b0ffe22cca6ba.png" alt="841c6a0d7b3992368f5b0ffe22cca6ba.png"></p></span><p>（二）Linux中断处理体系结构</p><p>asm_do_IRQ()：中断处理函数的总入口函数，它调用其他文件注册的中断处理函数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">asm<span class="hljs-constructor">_do_IRQ(<span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">irq</span>, <span class="hljs-params">struct</span> <span class="hljs-params">pt_regs</span> <span class="hljs-operator">*</span> <span class="hljs-params">regs</span>)</span><br></code></pre></td></tr></table></figure><p>Linux内核将所有的中断统一编号，使用一个irq_desc结构数组来描述这些中断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">irq_desc</span> &#123;<br>    <span class="hljs-type">irq_flow_handler_t</span>    handle_irq;    <span class="hljs-comment">/* 当前中断的处理函数入口 */</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">irq_chip</span>        *chip;    <span class="hljs-comment">/* 底层的硬件访问 */</span><br>    ...<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">irqaction</span>    *action;    <span class="hljs-comment">/* 用户提供的中断处理函数链表IRQ action list */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>        status;        <span class="hljs-comment">/* IRQ 状态 */</span><br>    ...<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>        *name;    <span class="hljs-comment">/* 中断名称 */</span><br>&#125; ____cacheline_internodealigned_in_smp;<br></code></pre></td></tr></table></figure><p>handle_irq是这个或这组中断的处理函数入口，发生中断时，总入口函数asm_do_IRQ将根据中断号调用相应irq_desc数组项中的handle_irq。handle_irq使用chip结构中的函数来清除、屏蔽或重新使能中断，还一一调用用户在action链表中注册的中断处理函数。</p><p>irq_chip里的成员大多用于操作底层硬件，比如设置寄存器以屏蔽中断、使能中断、清除中断等。</p><p>irqaction结构类型表示用户注册的中断处理函数，一个中断可以有多个处理函数，它们的irqaction结构链成一个链表</p><p><img src="/image/0b247590ba5e5a80455dd688743b1e70.png" alt="0b247590ba5e5a80455dd688743b1e70.png"></p><p>代码分析：</p><p>进入desc_handle_irq(irq, desc)</p><p>{</p><p>    desc-&gt;handle_irq(irq, desc);</p><p>}</p><p>其中此处的desc为上面取得的全局数组irq_desc[irq]，即调用irq_desc[irq]的handle_irq成员</p><p>handle_irq在__set_irq_handler()中被调用，__set_irq_handler()又在s3c24xx_init_irq()中被调用</p><p>这个函数中决定了struct irq_desc[irq]中的</p><p>{</p><p>chip &#x3D; s3c_irq_eint0t4; </p><p>handle_irq &#x3D; handle_edge_irq; </p><p>flag &#x3D; IRQF_VALID;</p><p>}</p><p>得出handle_irq &#x3D; handle_edge_irq;</p><p>显然中断处理asm_do_IRQ最终会调用到事先在s3c24xx_init_irq()初始化过的handle处理函数，比如handle_edge_irq</p><p>handle_edge_irq（）做了这两项：</p><p>1.desc-&gt;chip-&gt;ack(irq)：清中断</p><p>2.handle_IRQ_event：处理中断，取出action链表中的成员，执行action-&gt;handle</p><p>中断的处理流程如下：</p><ol><li>发生中断时，CPU执行异常向量vertor_irq的代码</li><li>在vector_irq里面，最终会调用中断处理的总入口函数asm_do_IRQ</li><li>在asm_do_IRQ根据中断号调用irq_desc数组项中的handle_irq。</li><li>handle_irq会使用chip成员中的函数来设置硬件，比如清除中断、禁止中断、重新使能中断等</li><li>handle_irq逐个调用用户在action链表中注册的处理函数</li></ol><p>到action-&gt;handle为止都是中断的框架，我们需要执行自己的代码，这些代码就放到action-&gt;handle中，我们需要通过request_irq告诉内核我们的处理函数是什么</p><p>（三）用户注册中断处理函数：</p><p>用户（即驱动程序）通过request_irq函数向内核注册中断处理函数，request_irq函数根据中断号找到irq_desc数组项，然后在它的action链表里添加一个表项</p><p>request_irq(irq中断号, handle处理函数, irqflags触发方式, name, dev_id)：注册中断处理程序</p><p>{</p><ol><li><p>用四个参数构造irqaction结构</p></li><li><p>调用setup_irq(irq, action)），将上面构造的action放到irq_desc[irq]下的action链表里</p></li></ol><p>}</p><p>setup_irq()</p><p>{</p><p>找到irq_desc[irq]-&gt;在action链表里加入传入的action：放到链表里</p><p>desc-&gt;chip-&gt;settype()：设置引脚功能为外部中断，设置中断的触发方式</p><p>desc-&gt;chip-&gt;startup&#x2F;enable：使能中断</p><p>}</p><p>free_irq(irq, dev_id)：卸载中断处理程序</p><p>{</p><p>出链</p><p>禁止中断</p><p>}</p><p>008</p><hr><p>third_drv_open()</p><p>配置引脚模式：request_irq</p><p>third_drv_close()</p><p>free_irq</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//引脚的描述</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pin_desc</span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> pin;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> key_val;<br>&#125;;<br><br><span class="hljs-comment">//定义了四个引脚</span><br><span class="hljs-comment">/* 它们的键值: 按下时, 0x01, 0x02, 0x03, 0x04 */</span><br><span class="hljs-comment">/* 它们的键值: 松开时, 0x81, 0x82, 0x83, 0x84 */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pin_desc</span> pins_desc[<span class="hljs-number">4</span>] = &#123;<br>    &#123;S3C2410_GPF0, <span class="hljs-number">0x01</span>&#125;,<br>    &#123;S3C2410_GPF2, <span class="hljs-number">0x02</span>&#125;,<br>    &#123;S3C2410_GPG3, <span class="hljs-number">0x03</span>&#125;,<br>    &#123;S3C2410_GPG11, <span class="hljs-number">0x04</span>&#125;,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">irqreturn_t</span> <span class="hljs-title">buttons_irq</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev_id)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pin_desc</span> * pindesc = (<span class="hljs-keyword">struct</span> pin_desc *)dev_id;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> pinval;<br>    <br>    pinval = <span class="hljs-built_in">s3c2410_gpio_getpin</span>(pindesc-&gt;pin);    <span class="hljs-comment">//读出引脚的值</span><br><br>    <span class="hljs-keyword">if</span> (pinval)<br>    &#123;<br>        <span class="hljs-comment">/* 1：松开 */</span><br>        key_val = <span class="hljs-number">0x80</span> | pindesc-&gt;key_val;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">/* 0：按下 */</span><br>        key_val = pindesc-&gt;key_val;<br>    &#125;<br><br>    ev_press = <span class="hljs-number">1</span>;                  <span class="hljs-comment">/* 表示中断发生了 */</span><br>    <span class="hljs-built_in">wake_up_interruptible</span>(&amp;button_waitq);   <span class="hljs-comment">/* 唤醒休眠的进程 */</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">IRQ_RETVAL</span>(IRQ_HANDLED);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static <span class="hljs-constructor">DECLARE_WAIT_QUEUE_HEAD(<span class="hljs-params">button_waitq</span>)</span>;<br><br><span class="hljs-comment">/* 中断事件标志, 中断服务程序将它置1，third_drv_read将它清0 */</span><br>static volatile <span class="hljs-built_in">int</span> ev_press = <span class="hljs-number">0</span>;<br><br>ssize_t third<span class="hljs-constructor">_drv_read(<span class="hljs-params">struct</span> <span class="hljs-params">file</span> <span class="hljs-operator">*</span><span class="hljs-params">file</span>, <span class="hljs-params">char</span> <span class="hljs-params">__user</span> <span class="hljs-operator">*</span><span class="hljs-params">buf</span>, <span class="hljs-params">size_t</span> <span class="hljs-params">size</span>, <span class="hljs-params">loff_t</span> <span class="hljs-operator">*</span><span class="hljs-params">ppos</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (size != <span class="hljs-number">1</span>)<br>        return -EINVAL;<br><br>    <span class="hljs-comment">/* 如果没有按键动作, ev_press为0就休眠 */</span><br>    wait<span class="hljs-constructor">_event_interruptible(<span class="hljs-params">button_waitq</span>, <span class="hljs-params">ev_press</span>)</span>;    <span class="hljs-comment">//</span><br><br>    <span class="hljs-comment">/* 如果有按键动作, 返回键值 */</span><br>    copy<span class="hljs-constructor">_to_user(<span class="hljs-params">buf</span>, &amp;<span class="hljs-params">key_val</span>, 1)</span>;<br>    ev_press = <span class="hljs-number">0</span>;<br>    <br>    return <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>009</p><hr><p>引入poll查询机制，分析内核的poll机制</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">kernel:sys_poll<br>    <span class="hljs-keyword">do</span><span class="hljs-constructor">_sys_poll(<span class="hljs-operator">...</span>.,<span class="hljs-params">timeout_jiffies</span>)</span><br>        poll<span class="hljs-constructor">_initwait(&amp;<span class="hljs-params">table</span>)</span>;    <span class="hljs-comment">//注册回调函数__pollwait</span><br>            init<span class="hljs-constructor">_poll_funcptr(&amp;<span class="hljs-params">pwq</span>-&gt;<span class="hljs-params">pt</span>, <span class="hljs-params">__pollwait</span>)</span>; &gt; table-&gt;qproc = __pollwait<br>        <span class="hljs-keyword">do</span><span class="hljs-constructor">_poll(<span class="hljs-params">nfds</span>, <span class="hljs-params">head</span>, &amp;<span class="hljs-params">table</span>, <span class="hljs-params">timeout</span>)</span><br>            <span class="hljs-keyword">for</span>(;;)    <span class="hljs-comment">//死循环</span><br>            &#123;<br>            <span class="hljs-keyword">for</span>(; pfd != pfd_end; pfd++) &#123;   <span class="hljs-comment">//查询多个驱动</span><br>                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">do</span><span class="hljs-constructor">_pollfd(<span class="hljs-params">pfd</span>, <span class="hljs-params">pt</span>)</span>)&#123;  &gt;mask = file-&gt;f_op-&gt;poll(file, pwait); return mask;<br>                                        <span class="hljs-comment">//do_pollfd调用到驱动的poll函数，驱动的poll函数调用poll_wait函数,就调用到__pollwait(filp, &amp;button_waitq, p), 把当前进程挂到button_waitq队列里去，挂入后，中断处理函数就可以唤醒队列(wake_up_....)：依据ev_press改变mask的值，触发这个进程</span><br>                    count++;    <span class="hljs-comment">//如果驱动的poll返回非0值，那么count++</span><br>                    pt = NULL;<br>                &#125;<br>            &#125;<br>                <span class="hljs-comment">//count非0，超时，有信号在等待处理</span><br>                <span class="hljs-keyword">if</span>(count<span class="hljs-operator"> || </span>!*timeout<span class="hljs-operator"> || </span>signal<span class="hljs-constructor">_pending(<span class="hljs-params">current</span>)</span>)   <br>                    break;<br><br>                <span class="hljs-comment">//设置休眠时间__timeout，唤醒条件：__timeout减为0；被驱动程序/中断处理函数唤醒</span><br>                __timeout = schedule<span class="hljs-constructor">_timeout(<span class="hljs-params">__timeout</span>)</span>;<br>            &#125;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">file_operations</span> sencod_drv_fops = &#123;<br>    .owner   =  THIS_MODULE,    <span class="hljs-comment">/* 这是一个宏，推向编译模块时自动创建的__this_module变量 */</span><br>    .open    =  forth_drv_open,     <br>    .read     =    forth_drv_read,       <br>    .release =  forth_drv_close,<br>    .poll    =  forth_drv_poll,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-title">forth_drv_poll</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, poll_table *wait)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mask = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">poll_wait</span>(file, &amp;button_waitq, wait); <br><span class="hljs-comment">//通过poll_wait来调用上面说到的__pollwait函数,只是让进程挂到button_waitq队列里，不会立即休眠</span><br><br>    <span class="hljs-keyword">if</span> (ev_press)<br>        mask |= POLLIN | POLLRDNORM;    <span class="hljs-comment">//当前有数据返回给应用程序就返回mask</span><br><br>    <span class="hljs-keyword">return</span> mask;    <span class="hljs-comment">//没有就返回0，就会进入休眠</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在来总结一下poll机制：</p><ol><li><p>poll &gt; sys_poll &gt; do_sys_poll &gt; poll_initwait，poll_initwait函数注册一下回调函数__pollwait，它就是我们的驱动程序执行poll_wait时，真正被调用的函数。</p></li><li><p>接下来执行我们驱动程序里自己实现的poll函数。</p></li></ol><p>   它会调用poll_wait把自己挂入某个队列，这个队列也是我们的驱动自己定义的；</p><p>   它还判断一下设备是否就绪。</p><ol start="3"><li><p>如果设备未就绪(无中断产生)，do_poll里会让进程休眠一定时间</p></li><li><p>进程被唤醒的条件有二：一是上面说的“一定时间”到了，二是被驱动程序唤醒。驱动程序发现条件就绪时，就把“某个队列”上挂着的进程唤醒，这个队列，就是前面通过poll_wait把本进程挂过去的队列。</p></li><li><p>如果驱动程序没有去唤醒进程(发生中断)，那么chedule_timeout(__timeou)超时后，会重复2、3动作，直到应用程序的poll调用传入的时间到达。</p></li></ol><p>应用层利用C库函数调用poll函数的时候，会通过swi软件中断进入到内核层，然后调用sys_poll系统调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* Forthdrvtest.c */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>    <span class="hljs-comment">//原</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">read</span>(fd, &amp;key_val, <span class="hljs-number">1</span>);    <span class="hljs-comment">//按键不按下，它永远不会返回</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;key_val = 0x%x\n&quot;</span>, key_val);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span>    <span class="hljs-comment">//现</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> key_val;<br>    <span class="hljs-type">int</span> ret;<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pollfd</span> fds[<span class="hljs-number">1</span>];    <span class="hljs-comment">//只查询一个驱动</span><br>    <br>    fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/buttons&quot;</span>, O_RDWR);<br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;can&#x27;t open!\n&quot;</span>);<br>    &#125;<br><br>    fds[<span class="hljs-number">0</span>].fd     = fd;<br>    fds[<span class="hljs-number">0</span>].events = POLLIN;    <span class="hljs-comment">//需要产生的事件：POLLIN有数据等待读取</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)                <span class="hljs-comment">//在一定时间内没有按键发生也返回，使用poll机制</span><br>    &#123;<br>        ret = <span class="hljs-built_in">poll</span>(fds, <span class="hljs-number">1</span>, <span class="hljs-number">5000</span>);    <span class="hljs-comment">//一个文件，5000ms;返回0表示有超时</span><br><span class="hljs-comment">//调用sys_poll系统调用，如果5S内没有产生POLLIN事件，那么返回，如果有POLLIN事件，直接返回</span><br>        <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;time out\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">read</span>(fd, &amp;key_val, <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;key_val = 0x%x\n&quot;</span>, key_val);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务器上输入man poll，可查看用法</p><p><img src="/image/9414e5a9d9866366620447e0e489a9f8.png" alt="9414e5a9d9866366620447e0e489a9f8.png"></p><p>010</p><hr><p>（一）引入</p><p>查询方式：不断查询，耗资源</p><p>中断方式：等待发生，read()函数一直不返回，一直等待</p><p>poll方式：指定超时时间</p><p>共同特点：应用程序主动去read</p><p>有没有驱动提醒触发应用程序，应用程序再去读键值--&gt;异步通知</p><p>进程之间发信号举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* signal.c */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>  <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">my_signal_fun</span><span class="hljs-params">(<span class="hljs-type">int</span> signum)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;signal = %d, %d times\n&quot;</span>, signum, ++cnt)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">signal</span>(SIGUSR1, my_signal_fun);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主函数是一个死循环，当发送信号给应用程序时就可以实现打印</p><p><img src="/image/c28a718df000bb4e154b44b1c7854717.png" alt="c28a718df000bb4e154b44b1c7854717.png"></p><p>可看到进程正在休眠，且进程pid为833，使用kill -USR1 833</p><p><img src="/image/faab9d3176425267f78abbfe8539b2dc.png" alt="faab9d3176425267f78abbfe8539b2dc.png"></p><p>可看到应用程序收到信号后立刻就调用信号处理函数执行打印</p><p>由以上得要点：</p><ol><li>注册信号处理函数</li><li>谁发</li><li>发给谁</li><li>怎么发</li></ol><p>（二）思路</p><p>目标：按下按键时，驱动通知应用程序</p><p>1.应用程序：注册信号处理函数    &#x2F;&#x2F;signal(SIGIO, my_signal_fun)</p><p>2.谁发：驱动程序    &#x2F;&#x2F;驱动程序实现</p><p>3.发给谁：app-&gt;app需要告诉驱动PID    &#x2F;&#x2F;fcntl(fd, F_SETOWN, getpid());</p><p>4.怎么发：kill_fasync</p><p>为了使设备支持异步通知机制，驱动程序中涉及以下3项工作：</p><ol><li>支持F_SETOWN命令，能在这个控制命令处理中设置filp-&gt;f_owner为对应进程ID。不过此项工作已由内核完成，设备驱动无须处理直接调用即可。</li></ol><p>应用程序会调用“fcntl(fd, F_SETOWN, pid)”这个函数，把进程的PID号告诉给驱动程序。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">fcntl</span>(fd, F_SETOWN, getpid());  <span class="hljs-comment">// 告诉内核，发给谁</span><br></code></pre></td></tr></table></figure><ol start="2"><li>支持F_SETFL命令的处理，每当FASYNC标志改变时，驱动程序中的fasync()函数将得以执行。驱动中应该实现fasync()函数。</li></ol><p>应用程序通过“F_GETFL”读出“flags”；再在flags上置上“FASYNC”位，从而改变fasync标记，设置为异步通知的flag。当改变oflag时，驱动程序的faync函数就会被调用，然后再调用fasync_helper函数初始化结构体fasync_struct：button_async</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">Oflags = <span class="hljs-keyword">fcntl</span>(fd, F_GETFL);           <span class="hljs-regexp">//</span>取得当前状态<br><span class="hljs-keyword">fcntl</span>(fd, F_SETFL, Oflags | FASYNC);   <br></code></pre></td></tr></table></figure><ol start="3"><li>在设备资源可获得时，调用kill_fasync()函数激发相应的信号</li></ol><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">kill_fasync (<span class="hljs-meta">&amp;button_async, SIGIO, POLL_IN);</span><br></code></pre></td></tr></table></figure><p>应用程序需要做的：</p><p>1.设置信号处理函数：收到信号了做什么</p><p>2.把pid发给驱动程序，你把信号发给谁</p><p>3.设置异步flag</p><p>驱动程序要做的：</p><p>1.发信号给应用程序</p><p>2.通过系统调用将button_async初始化，发信号要用</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">fasync_struct</span> *button_async;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">irqreturn_t</span> <span class="hljs-title">buttons_irq</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev_id)</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>    <span class="hljs-built_in">kill_fasync</span> (&amp;button_async, SIGIO, POLL_IN);    <span class="hljs-comment">//通过这个函数给应用程序发出一个信号</span><br>    ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">fifth_drv_fasync</span> <span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">int</span> on)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;driver: fifth_drv_fasync\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fasync_helper</span> (fd, filp, on, &amp;button_async);    <span class="hljs-comment">//③实际上是初始化button_async结构体，用于发信号</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">file_operations</span> sencod_drv_fops = &#123;<br>    .owner   =  THIS_MODULE,    <span class="hljs-comment">/* 这是一个宏，推向编译模块时自动创建的__this_module变量 */</span><br>    .open    =  fifth_drv_open,     <br>    .read     =    fifth_drv_read,       <br>    .release =  fifth_drv_close,<br>    .poll    =  fifth_drv_poll,<br>    .fasync     =  fifth_drv_fasync,<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* test */</span><br><span class="hljs-type">int</span> fd;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">my_signal_fun</span><span class="hljs-params">(<span class="hljs-type">int</span> signum)</span>    <span class="hljs-comment">//由驱动程序发生的信号触发应用程序，再去调用它的信号处理函数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> key_val;<br>    <span class="hljs-built_in">read</span>(fd, &amp;key_val, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;key_val: 0x%x\n&quot;</span>, key_val);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> key_val;<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-type">int</span> Oflags;<br><br>    <span class="hljs-built_in">signal</span>(SIGIO, my_signal_fun);    <span class="hljs-comment">//SISGIO说明是IO信号量，因为按键驱动属于IO型的；信号处理函数指向my_signal_fun </span><br>    <br>    fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/buttons&quot;</span>, O_RDWR);<br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;can&#x27;t open!\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">fcntl</span>(fd, F_SETOWN, <span class="hljs-built_in">getpid</span>());<br>    <br>    Oflags = <span class="hljs-built_in">fcntl</span>(fd, F_GETFL);<br>    <br>    <span class="hljs-built_in">fcntl</span>(fd, F_SETFL, Oflags | FASYNC);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1000</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>011</p><hr><p>目的：同一时刻，只能有一个app打开驱动程序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">驱动程序：<br><span class="hljs-keyword">static</span> int canopen = <span class="hljs-number">1</span><br><span class="hljs-title function_">open</span>(<span class="hljs-params"></span>)<br>&#123;<br>    <span class="hljs-keyword">if</span>(--canopen != <span class="hljs-number">0</span>)<br>    &#123;<br>        canopen++;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-variable constant_">EBUSY</span>；<br>    &#125;<br>    ...<br>&#125;<br><span class="hljs-title function_">close</span>(<span class="hljs-params"></span>)<br>&#123;<br>    canopen++;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>感觉这个方法正确，但里面实质上有漏洞，如上右图。</p><p>LINUX是多任务系统，A程序执行过程中，有可能被切换出去换成B程序执行这种情况。</p><p>“--canopen”在汇编里看，是被分成了3步：“读出－－修改－－写回”。这个过程不是“原子操作”。中间有被切换出去的可能。</p><p>（一）原子操作</p><p>修改代码将“canopen”定义成“原子变量”。初始值“1”。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static atomic_t canopen = <span class="hljs-constructor">ATOMIC_INIT(1)</span>;    <span class="hljs-comment">//定义原子变量</span><br><br><span class="hljs-keyword">open</span><span class="hljs-literal">()</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(!atomic<span class="hljs-constructor">_dec_and_test(&amp;<span class="hljs-params">canopen</span> )</span>)    <span class="hljs-comment">//函数：自减操作后测试是否为0，为0则返回true，否则返回false</span><br>&#125;<br><br>close<span class="hljs-literal">()</span><br>&#123;<br>    atomic<span class="hljs-constructor">_inc(&amp;<span class="hljs-params">canopen</span>)</span>;    <span class="hljs-comment">//原子变量加一</span><span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator"></span>&#125;<br></code></pre></td></tr></table></figure><p>（二）信号量</p><p>用信号量实现：</p><p>信号量（semaphore）是用于保护临界区的一种常用方法，只有得到信号量的进程才能执行临界区代码。</p><p>当获取不到信号量时，进程进入休眠等待状态。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss">static <span class="hljs-built_in">DECLARE_MUTEX</span>(button_lock);     <span class="hljs-comment">//定义互斥锁</span><br><br><span class="hljs-built_in">open</span>()<br>&#123;<br>    <span class="hljs-comment">/* 获取信号量 */</span><br>    <span class="hljs-built_in">down</span>(&amp;button_lock);    <span class="hljs-comment">//第一次执行open可以获得信号量，若另一个程序再次调用open则无法获得进入休眠状态</span><br>&#125;<br><br><span class="hljs-built_in">close</span>()<br>&#123;<br>    ...<br>    <span class="hljs-built_in">up</span>(&amp;button_lock);    <span class="hljs-comment">//第一次调用完了需要释放掉</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/a8f6cca1bd108a69d0b22e7d10b547b3.png" alt="a8f6cca1bd108a69d0b22e7d10b547b3.png"></p><p>发现第二次启动程序和第一次启动程序都在运行，且第二次启动的程序处于不可中断的睡眠态，这里就是因为down()，这个休眠只会在第一个程序释放掉信号量up()后被唤醒</p><p><img src="/image/26e8b38dedb1b805c314b085b5ba2080.png" alt="26e8b38dedb1b805c314b085b5ba2080.png"></p><p>（三）阻塞</p><p>阻塞操作    </p><p>是指在执行设备操作时若不能获得资源则挂起进程，直到满足可操作的条件后再进行操作。</p><p>被挂起的进程进入休眠状态，被从调度器的运行队列移走，直到等待的条件被满足。</p><p>非阻塞操作  </p><p>进程在不能进行设备操作时并不挂起，它或者放弃(返回错误)，或者不停地查询，直至可以进行操作为止。</p><p>判断阻塞和非阻塞：</p><p>fd &#x3D; open(“…”, O_RDWR | O_NONBLOCK)    &#x2F;&#x2F;传入O_NONBLOCK标记为非阻塞，不传入默认为阻塞</p><p>而这个标记位可以在传入参数file-&gt;f_flags中获取</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">open</span>(struct inode *inode, struct file *file)<br>&#123;<br>    <span class="hljs-built_in">if</span>(file-&gt;f_flags &amp; O_NONBLOCK)<br>    &#123;<span class="hljs-comment">//非阻塞</span><br>        <span class="hljs-built_in">if</span>(down_teylock(&amp;button_lock))<br>            return -E_BUSY<br>    &#125;<br>    else<br>    &#123;<span class="hljs-comment">//阻塞</span><br>        <span class="hljs-comment">/* 获取信号量 */</span><br>        <span class="hljs-built_in">down</span>(&amp;button_lock);<br>    &#125;<br>    ...<br>&#125;<br><br><span class="hljs-built_in">read</span>()<br>&#123;<br>    ...<br>    if (file-&gt;f_flags &amp; O_NONBLOCK)<br>    &#123;<span class="hljs-comment">//非阻塞</span><br>        if (!ev_press)        <span class="hljs-comment">//有无按键发生</span><br>            return -EAGAIN    <span class="hljs-comment">//没有按键发生再次执行</span><br>    &#125;<br>    else<br>    &#123;<span class="hljs-comment">//阻塞</span><br>        <span class="hljs-comment">/* 如果没有按键动作，休眠 */</span><br>        <span class="hljs-built_in">wait_event_interruptible</span>(button_waitq, ev_press);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>问题一：</p><p>测试程序中的open,read,write等函数通过swi软件中断进入到内核层，然后调用sys_xxxx系统调用，最终内核会定位到驱动层的open与write函数。</p><p>应用程序如何调用驱动程序，执行疑惑</p><p>问题二：</p><p>次设备号的使用：<a href="https://www.cnblogs.com/andyfly/p/9467702.html">https://www.cnblogs.com/andyfly/p/9467702.html</a></p><hr>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第004课_根文件系统</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/%E7%AC%AC004%E8%AF%BE_%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/%E7%AC%AC004%E8%AF%BE_%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p><img src="/image/4eaf080e68fbd5d9c59ec453a340da3a.png" alt="4eaf080e68fbd5d9c59ec453a340da3a.png"></p><p>001</p><hr><p>u-boot目的：启动内核</p><p>内核目的：启动应用程序-&gt;构建根文件系统</p><p>与 Windows 的 C 盘类似， Linux 也需要在一个分区上存放系统启动的必要文件，比如内核启动运行后的第一个程序（ init进程）、用于挂接文件系统的脚本、给用户提供操作界面的 shell 程序，应用程序所要依赖的库等，这些必要、基本文件的集合称为根文件系统，它们存放在一个分区中。</p><p>（一）内核如何启动第一个应用程序init进程（init_post()）？</p><p>首先要挂接根文件系统再启动</p><p>代码并不复杂，与init启动最强相关的就是run_init_process这个函数了，它运行指定的init程序，注意：一旦run_init_process运行创建进程成功，它将不会返回，而是通过操作内核栈进入用户空间。所以上面并不是运行了四个init进程，而是根据优先级，一旦某一个运行成功，就不往下继续执行了。</p><p>下面详细描述一下该函数的执行过程：</p><ol><li>打开标准输入、标准输出和标准错误设备</li></ol><p>Linux中最先打开的3个文件分别称作标准输入(stdin)、标准输出(stdout)和标准错误(stderr)，它们对应的文件描述符分别是0、1、2.。</p><p>如下代码就是执行这个操作，先打开文件&#x2F;dev&#x2F;console作为保准输入，然后将文件描述符复制给文件描述符1、2，这样使得标准输入、标准输出以及标准错误都使用&#x2F;dev&#x2F;console这个文件。注意代码上面的注释”该函数不能失败，也就是说至少&#x2F;dev&#x2F;console必须存在”。</p><p>&#x2F;dev&#x2F;console-&gt;终端&#x2F;控制台：所有打印信息，输入，输出都是从这个文件</p><p><img src="/image/0716276d130a78d9083e1ce231e178f2.png" alt="0716276d130a78d9083e1ce231e178f2.png"></p><ol><li>如果变量ramdisk_execute_command为空，则将其指向&#x2F;init程序，如果该程序存在，则运行该程序，并且进程不会返回；如果该程序不存在，则置变量ramdisk_execute_command为NULL，代码片段为：</li></ol><p><img src="/image/250977202f84525eb3f21cccaa284289.png" alt="250977202f84525eb3f21cccaa284289.png"></p><ol><li>如果变量execute_command指定了要运行的程序，则运行它，并且不会返回：</li></ol><p>uboot传给内核的命令行参数定义了init &#x3D; xxx，传递值给execute_command并启动execute_command</p><p><img src="/image/c406affa5d43148b16536729a500a587.png" alt="c406affa5d43148b16536729a500a587.png"></p><ol><li>依次尝试几个常见的init，一旦某一个成功，则不返回：</li></ol><p><img src="/image/86fea52c060c0417e1785f1df6fbb134.png" alt="86fea52c060c0417e1785f1df6fbb134.png"></p><ol><li>如果以上执行都失败，那么内核就挂了</li></ol><p><img src="/image/8c991fbc348b3090a593aeb4c132d77b.png" alt="8c991fbc348b3090a593aeb4c132d77b.png"></p><p>（二）如何通过USB设备下载根文件系统：</p><p>uboot界面输入y，再使用DNW下载映像fs_mini.yaffs2</p><p>烧写完成，在uboot界面输入b启动，等待一会进入根文件系统，用ps命令可以查看有什么应用程序</p><p>002</p><hr><p>（一）Busybox介绍：</p><p>Busybox将众多的UNIX命令集合进一个很小的可执行程序中，可以用来替代GNU fileutils、shellutils等工具集。</p><p>Busybox在编写过程中对文件大小进行了优化，并考虑了系统资源有限(比如内存等)的情况。</p><p>Busybox按模块设计，可以很容易地加入、去除某些命令，或增减命令的某些选项。</p><p>在创建根文件系统的时候，如果使用Busybox的话，只需要在&#x2F;dev目录下创建必要的设备节点，在&#x2F;etc目录下增加一些配置文件即可，当然，如果Busybox使用动态链接，那么还需要再&#x2F;lib目录下包含库文件。</p><p>（二）init进程分析</p><p>init进程是由内核启动的第一个(也是唯一一个)用户进程，init进程根据配置文件决定启动哪些程序，例如：执行某些脚本、启动shell或运行用户程序等等，init也是后续所有进程的发起者。</p><p>Busybox是ls、cp、cd等命令的主核，执行ls、cp时实际上执行的是busybox程序，即ls &#x3D; busybox ls</p><p>而“sbin&#x2F;init”实际也是到busybox的链接，所以我们想知道“sbin&#x2F;init”init进程做了什么我们需要分析busybox的源码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">猜测<span class="hljs-keyword">init</span>程序主要目的：<br><span class="hljs-number">1.</span>读取配置文件（配置文件指定了后续要执行哪些程序）<br><span class="hljs-number">2.</span>解析配置文件<br><span class="hljs-number">3.</span>根据配置文件执行用户程序<br></code></pre></td></tr></table></figure><p><img src="/image/20160914140317654.png" alt="20160914140317654.png"></p><p>busybox-&gt;init_main</p><p>parse_inittab</p><p>file &#x3D; fopen(INITTAB, “r”)    &#x2F;&#x2F;打开配置文件&#x2F;etc&#x2F;inittab-&gt;根据配置文件的内容调用new_init_action（将&#x2F;etc&#x2F;inittab里的每一条配置项做成一个init_action结构体并添加到具有相同执行时机的init_action_list）</p><p>new_init_action    &#x2F;&#x2F;没有配置文件&#x2F;etc&#x2F;inittab-&gt;调用new_init_action来构造默认配置项（同上）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">new_init_action</span><span class="hljs-params">()</span></span>做了什么<br><span class="hljs-number">1</span>. 创建结构体init_action，填充：执行时机，对应执行程序，终端<br><span class="hljs-number">2</span>. 将结构体放入链表init_action_list<br></code></pre></td></tr></table></figure><p>run_actions(SYSINIT);    &#x2F;&#x2F;运行SYSINIT这一类动作</p><p>waitfor(a, 0);    &#x2F;&#x2F;执行应用程序,等待它执行完毕</p><p>run(a)    &#x2F;&#x2F;创建子进程</p><p>waitpid(runpid, &amp;status, 0)    &#x2F;&#x2F;等待它结束</p><p>delete_init_action(a);    &#x2F;&#x2F;在init_action_list链表里删除</p><p>run_actions(WAIT);</p><p>waitfor(a, 0);    &#x2F;&#x2F;执行应用程序,等待它执行完毕</p><p>run(a)    &#x2F;&#x2F;创建子进程</p><p>waitpid(runpid, &amp;status, 0)    &#x2F;&#x2F;等待它结束</p><p>delete_init_action(a);    &#x2F;&#x2F;在init_action_list链表里删除</p><p>run_actions(ONCE);</p><p>run(a)    &#x2F;&#x2F;创建子进程</p><p>delete_init_action(a);    &#x2F;&#x2F;在init_action_list链表里删除</p><p>while(1){</p><p>run_actions(RESPAWN);</p><p>if(a-&gt;pid &#x3D;&#x3D; 0){</p><p>a-&gt;pid &#x3D; run(a);</p><p>}</p><p>run_actions(ASKFIRST);</p><p>if(a-&gt;pid &#x3D;&#x3D; 0){</p><p>a-&gt;pid &#x3D; run(a);</p><p>打印：Please press Enter to activate this console</p><p>等待回车</p><p>创建子进程</p><p>}</p><p>wpid &#x3D; wait(NULL);    &#x2F;&#x2F;等待子进程退出</p><p>while(wpid &gt; 0){</p><p>a-&gt;pid &#x3D; 0;    &#x2F;&#x2F;退出后就设置pid &#x3D; 0</p><p>}</p><p>}</p><p>inittab格式：</p><p>&lt;id&gt;:&lt;runlevels&gt;:&lt;action&gt;:&lt;process&gt;</p><ul><li>id项：&#x2F;dev&#x2F;id     用作终端（终端：stdin-printf,stdout-scanf,stderr-err）</li></ul><p>会加上一个&#x2F;dev 前缀。作为“控制终端”（controlling tty）。</p><p>id可以省略。</p><ul><li>runlevels项：完全可以忽略掉。</li><li>action项：指示程序何时执行。</li><li>process项：是应用程序或脚本。</li></ul><p>（三）最小根文件系统：</p><ol><li><p>打开终端：&#x2F;dev&#x2F;console，&#x2F;dev&#x2F;NULL（不设置inittab格式中的id(标准输入、输出和标准错误)时，就定位到&#x2F;dev&#x2F;NULL中去）</p></li><li><p>init程序：例如&#x2F;sbin&#x2F;init,来源于busybox .</p></li><li><p>需要配置文件：&#x2F;etc&#x2F;inittab</p></li><li><p>配置文件若指定了某些应用程序或执行脚本--这些必须存在，不存在会有默认的。</p></li><li><p>应用程序需要c库（fopen、fwrite等函数需要）。</p></li></ol><p>003</p><hr><p>解压busybox源码并进入目录</p><p><img src="/image/db82ecfeef99f57af86a9e669ecf947e.png" alt="db82ecfeef99f57af86a9e669ecf947e.png"></p><p>如何编译busybox：</p><p><img src="/image/ecfbf84fbaf95f0b06de8e7767b07df7.png" alt="ecfbf84fbaf95f0b06de8e7767b07df7.png"></p><ol><li>配置：make menuconfig</li></ol><p><img src="/image/722a4f2c53d27ee1ff82a18a92821608.png" alt="722a4f2c53d27ee1ff82a18a92821608.png"></p><p>（1）配置busybox</p><p>①首先是给嵌入式系统编译的，所以要有个交叉编译工具。</p><pre><code class="hljs">    - 在配置文件中没法在配置图形项\(make menuconfig\)中定义，所以就在Makefile 中定义。直接在CROSS\_COMPILE项加上前缀arm\-linux\-</code></pre><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">CROSS_COMPILE？<span class="hljs-operator">=</span>arm-linux-<br></code></pre></td></tr></table></figure><p><img src="/image/e4e6f141afbc64b99de5881f79579abd.png" alt="e4e6f141afbc64b99de5881f79579abd.png"></p><pre><code class="hljs">    - 或者：make时加上“CROSS\_COMPILE=arm\-linux\-”，即make CROSS\_COMPILE=arm\-linux\-</code></pre><p>（2）指定库<img src="/image/f1af354222758a6d5bedb6e52dc6f8b1.png" alt="f1af354222758a6d5bedb6e52dc6f8b1.png"></p><p><img src="/image/b09bed110089cc6b8c1c84437b4c7e98.png" alt="b09bed110089cc6b8c1c84437b4c7e98.png"></p><p>将BusyBox 编译成一个静态的程序时，那么那些C库也不需要了。除非用户的应用程序指定需要库。这里不选表示用动态的。C库有两种，glibc 和uclibc，如果是用glibc静态编译时，会有提示一个警告信息，可能在以后使用时出问题，所以这里不用静态编译。而用动态链接。</p><p>（3）命令补全</p><p><img src="/image/42b4378e27546c7c384fbae80cdbf74e.png" alt="42b4378e27546c7c384fbae80cdbf74e.png"></p><p><img src="/image/6e775a76802ce3a964ac4f849dbdbf93.png" alt="6e775a76802ce3a964ac4f849dbdbf93.png"></p><p>（4）压缩命令，默认已经选上</p><p><img src="/image/21e64c498acf7ce202f0a37b69c28841.png" alt="21e64c498acf7ce202f0a37b69c28841.png"></p><p>（5）模块加载命令，默认也是选上的</p><p><img src="/image/f43a9ded84a47c405ad92b35146357be.png" alt="f43a9ded84a47c405ad92b35146357be.png"></p><p>（6）支持medv</p><p><img src="/image/f984b32394baf5967eca4f827748e332.png" alt="f984b32394baf5967eca4f827748e332.png"></p><p>（7）ifconfig</p><p><img src="/image/3994b1b65cd72ae20f2a842bd174cba0.png" alt="3994b1b65cd72ae20f2a842bd174cba0.png"></p><ol><li>编译：make</li></ol><p><img src="/image/4ae452064d6ed2c5b08f3c86e1e11479.png" alt="4ae452064d6ed2c5b08f3c86e1e11479.png"></p><ol><li>安装：make install ，一定要指定安装目录，不然就破坏了我们正在使用的系统。命令混淆了。</li></ol><p>使用：make CONFIG_PREFIX&#x3D;&#x2F;work&#x2F;nfs_root&#x2F;first_fs install，指定安装目录</p><p><img src="/image/2abc1702f4660c5020bb9fcffabb7014.png" alt="2abc1702f4660c5020bb9fcffabb7014.png"></p><p><img src="/image/94e987923c10a65e49f02bd1d630f384.png" alt="94e987923c10a65e49f02bd1d630f384.png"></p><p><img src="/image/34e94d84ba0e5bb5499061bd33d3721c.png" alt="34e94d84ba0e5bb5499061bd33d3721c.png"></p><p>004</p><hr><p>（一）创建最简单的文件系统（yaffs）：</p><ol><li>创建两个设备文件：</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mkdir</span> dev<br><span class="hljs-attribute">cd</span> dev/<br><span class="hljs-attribute">sudo</span> mknod console c <span class="hljs-number">5</span> <span class="hljs-number">1</span>    //c 表示字符型设备，<span class="hljs-number">5</span> 是主设备号，<span class="hljs-number">1</span>是次设备号。<br><span class="hljs-attribute">sudo</span> mknod null c <span class="hljs-number">1</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><img src="/image/76d5759b45264de360b44ade10cd44c0.png" alt="76d5759b45264de360b44ade10cd44c0.png"></p><ol><li>.init程序本身就是busybox，所以这一步已经完成。</li><li>创建&#x2F;etc&#x2F;inittab配置文件</li></ol><p>若不构造，则使用默认的配置项（前面init进程分析）：<img src="/image/af480f33bea4a5f6c7824262da59bdaf.png" alt="af480f33bea4a5f6c7824262da59bdaf.png"></p><p>写最简单的，只写一条::askfirst:-&#x2F;bin&#x2F;sh </p><p>在first_fs目录下创建etc目录，再在etc下创建inittab文件。</p><p><img src="/image/3043cd9638e417a4c40fa2440228c35a.png" alt="3043cd9638e417a4c40fa2440228c35a.png"></p><p><img src="/image/b453f1d33a87c0864ae04d281236959a.png" alt="b453f1d33a87c0864ae04d281236959a.png"></p><p>编辑内容：console::askfirst:-&#x2F;bin&#x2F;sh</p><p><img src="/image/ed9eb2418d2cdd44263de7f44dbc4902.png" alt="ed9eb2418d2cdd44263de7f44dbc4902.png"></p><p>表示它里面只执行一个askfirst一个&#x2F;bin&#x2F;sh程序，&#x2F;bin&#x2F;sh这个程序的标准输入、输出和标准错误都定位到“&#x2F;dev&#x2F;console”里面去。</p><ol><li>配置文件指定的某些应用程序或执行脚本-&gt;没有指定用户程序，暂时没必要</li><li>安装glibc库</li></ol><p><img src="/image/442d3ac9c8255fd282bf3293b2d65ceb.png" alt="442d3ac9c8255fd282bf3293b2d65ceb.png"></p><p>将所有.so 文件拷贝过来即可。-d 是本来是个链接文件，则也保持是个链接文件。不然就拷贝成了真正的文件，这样会很大。</p><p><img src="/image/a0cab523ae5d46870743ec791f7ab377.png" alt="a0cab523ae5d46870743ec791f7ab377.png"></p><p><img src="/image/8cc040f0d6df47031648bbf2d025103c.png" alt="8cc040f0d6df47031648bbf2d025103c.png"></p><p>这是所有的库。其中.a 的文件是静态库，我们只要动态库。</p><p><img src="/image/a6d6ef84f8d03dbbaaee182c4df8faff.png" alt="a6d6ef84f8d03dbbaaee182c4df8faff.png"></p><p>libnss_dns.so是一个链接文件，链接到libnss_dns.so.2 若拷贝时不加-d ，则会libnss_dns.so拷贝成libnss_dns.so.2 的内容。这个库就会显得很大。</p><p><img src="/image/ce18fa9498f311ffe717b89ed7f66f4f.png" alt="ce18fa9498f311ffe717b89ed7f66f4f.png"></p><p>拷贝动态库文件。</p><p><img src="/image/1bfa0b2e84b200d55cab29bca8881f6b.png" alt="1bfa0b2e84b200d55cab29bca8881f6b.png"></p><p>这就是最小根文件系统（第四部未做）</p><p><img src="/image/8e96ac4e4bcee4bd45531ac8fb221c0a.png" alt="8e96ac4e4bcee4bd45531ac8fb221c0a.png"></p><p><img src="/image/fb74a46611ffe60c884bfbc0985b8ffc.png" alt="fb74a46611ffe60c884bfbc0985b8ffc.png"></p><p><img src="/image/80c0459842d8185ff2dc97be4e822874.png" alt="80c0459842d8185ff2dc97be4e822874.png"></p><p><img src="/image/450aa144b20087688ee554d30a3e4e1d.png" alt="450aa144b20087688ee554d30a3e4e1d.png"></p><p>（二）制作映像文件</p><ol><li>获取工具</li></ol><p>书上的方法是制作yaffs1的，适合小页的的NAND FLASH，每页512字节。现在大NAND是2048字节，需要使用yaff2</p><p><img src="/image/578af17cddc21d228a4daae3c4c8846c.png" alt="578af17cddc21d228a4daae3c4c8846c.png"></p><p>解压yaffs工具，得出<img src="/image/20d6efaef1b5f7b6d7414e88c09723da.png" alt="20d6efaef1b5f7b6d7414e88c09723da.png"></p><p><img src="/image/bff8fca29b49e62197bf99d3fa47a6e8.png" alt="bff8fca29b49e62197bf99d3fa47a6e8.png"></p><p><img src="/image/4a1dc991b3070e2642e44bc4c9e59da0.png" alt="4a1dc991b3070e2642e44bc4c9e59da0.png"></p><p>在&#x2F;utils目录执行make，生成mkyaffs2image工具。</p><p><img src="/image/921e4f7aa94e8da2d46d10a98ad56996.png" alt="921e4f7aa94e8da2d46d10a98ad56996.png"></p><p>将这个工具拷贝到PC机的&#x2F;usr&#x2F;local&#x2F;bin 目录下。再加上可执行属性就可以直接使用了（sudo）。</p><p><img src="/image/b7a81118a66bdf60ac37b0bb731debb0.png" alt="b7a81118a66bdf60ac37b0bb731debb0.png"></p><p><img src="/image/cecbcdfd5ea0dfe1159791a6f34a4f07.png" alt="cecbcdfd5ea0dfe1159791a6f34a4f07.png"></p><ol><li>开始制作</li></ol><p><img src="/image/2513e855635895550ec0e4cc25c288a4.png" alt="2513e855635895550ec0e4cc25c288a4.png"></p><p><img src="/image/a5bab9c083db5ea96e04aaf9b195d004.png" alt="a5bab9c083db5ea96e04aaf9b195d004.png"></p><p>得到第一个文件系统的映像文件</p><p><img src="/image/bb2c7ffd20bf31f8b0ede1d710edaa65.png" alt="bb2c7ffd20bf31f8b0ede1d710edaa65.png"></p><p><img src="/image/8742a7f32e150af40f7cc9bc1c86f737.png" alt="8742a7f32e150af40f7cc9bc1c86f737.png"></p><p>将文件拷贝到PC，进入uboot界面输入y等待烧写，再使用DNW发送到开发板中进行烧写</p><p>输入b启动，<img src="/image/e25e56215e012af2c29d36a54cca133f.png" alt="e25e56215e012af2c29d36a54cca133f.png"></p><p>输入回车启动正常。</p><p><img src="/image/f3b9934719b4739166f24e77fd337885.png" alt="f3b9934719b4739166f24e77fd337885.png"></p><p>（三）完善根文件系统</p><ol><li>挂载虚拟的根文件系统</li></ol><p>在内核中，当前有哪些应用程序在跑，这些信息如何收集。是内核提供了一个虚拟的文件系统，叫proc 文件系统，将这个proc系统挂载。</p><p>（1）创建proc目录：mkdir proc（此时ps看也没有内容）</p><p>输入mount -t proc none &#x2F;proc（手工挂载：在运行了最小根文件系统的单板上制作）</p><p><img src="/image/dff4988f290703b0007c36a8e09c83e5.png" alt="dff4988f290703b0007c36a8e09c83e5.png"></p><p><img src="/image/201135a0ab37dcb954b2820262f51c84.png" alt="201135a0ab37dcb954b2820262f51c84.png"></p><p>去&#x2F;proc 目录看下有哪些程序。</p><p><img src="/image/74c5725fd002c2c2fa5918d064df82cb.png" alt="74c5725fd002c2c2fa5918d064df82cb.png"></p><p>1表示上面PID为1的程序就是init这个程序</p><p><img src="/image/72fc5c456cc61693ef14150da8317547.png" alt="72fc5c456cc61693ef14150da8317547.png"></p><p>里面的fd就指向了&#x2F;dev&#x2F;console,三个分别是标准输入、输出和标准错误。</p><p>（2）使挂载自动配置：在使用mkyaffs2image工具制作文件系统时，也建立proc目录</p><p>-修改配置文件&#x2F;etc&#x2F;inittab，加入一个脚本”rcS”</p><p><img src="/image/76cbb4ca3cea10e5fd4d341d9f05ead3.png" alt="76cbb4ca3cea10e5fd4d341d9f05ead3.png"></p><p><img src="/image/7838c54fb219dea456f09131801be963.png" alt="7838c54fb219dea456f09131801be963.png"></p><p>-创建脚本文件rcS，在rcS中加入mount -t proc none &#x2F;proc，并加上可执行属性</p><p><img src="/image/c52bf373b607836828314019d838961e.png" alt="c52bf373b607836828314019d838961e.png"></p><p><img src="/image/87b928fda6a718a2d18bb2cf5639b527.png" alt="87b928fda6a718a2d18bb2cf5639b527.png"></p><p><img src="/image/1675aa170c37ec19d4f6ac4efe785103.png" alt="1675aa170c37ec19d4f6ac4efe785103.png"></p><p>（3）除了 mount -t….还可以直接使用 mount -a这个命令，这个命令依赖etc&#x2F;fstab 中的内容。</p><p>查看busybox的源码中fstab的说明：</p><p><img src="/image/ab7b5531dec51bd7c86ebf6eed3e45d4.png" alt="ab7b5531dec51bd7c86ebf6eed3e45d4.png"></p><p>格式说明：</p><p>-device：要挂接的设备。对于虚拟文件系统proc 格式中此处的名字可以随便写，上面写的是“proc”。</p><p>-mount-point ：是挂载到哪里去。&#x2F;proc</p><p>-type：文件系统类型。此时是“proc”虚拟文件系统。</p><p>-options：参数。</p><p>编辑&#x2F;etc&#x2F;fstab，etc&#x2F;init.d&#x2F;rcS</p><p><img src="/image/063e85b85a3a82b5cb7ac0260811289c.png" alt="063e85b85a3a82b5cb7ac0260811289c.png"></p><p><img src="/image/b6e0f35ff3f2be8fd9d501769d970f31.png" alt="b6e0f35ff3f2be8fd9d501769d970f31.png"></p><p>这时可以再mkyaffs2image first_fs first_fs.yaffs2 制作一次文件系统。烧到开发板。</p><p>在单板上执行 cat &#x2F;proc&#x2F;mounts，可以查看当前挂载的文件系统</p><p><img src="/image/308339ca928c8d98d4f4cbefad2ebe99.png" alt="308339ca928c8d98d4f4cbefad2ebe99.png"></p><p><img src="/image/b1b5d13062a2fc5cc435325a97f55397.png" alt="b1b5d13062a2fc5cc435325a97f55397.png"></p><ol><li>完善dev目录</li></ol><p>dev 目录下对应设备和驱动。一个个创建会很麻烦，使用udev机制。</p><p>udev 是linux下自动创建dev 目录下的设备节点。</p><p>busybox 中有个简化版本mdev，且busybox目录下有一个mdev.txt 有说明要做如下6项。</p><p><img src="/image/71a141302f934629e0d3681beafb462a.png" alt="71a141302f934629e0d3681beafb462a.png"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">[<span class="hljs-number">1</span>] mount -t sysfs sysfs /sys 首先挂载一个文件系统到 sys 目录中去。<br>[<span class="hljs-number">2</span>] echo <span class="hljs-regexp">/bin/m</span>dev &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/kernel/</span>hotplug<br>[<span class="hljs-number">3</span>] mdev -s<br>[<span class="hljs-number">4</span>] mount -t tmpfs mdev /dev 还要挂载一个文件系统到 dev 目录中去。<br>[<span class="hljs-number">5</span>] mkdir <span class="hljs-regexp">/dev/</span>pts<br>[<span class="hljs-number">6</span>] mount -t devpts devpts <span class="hljs-regexp">/dev/</span>pts<br></code></pre></td></tr></table></figure><p>第一步和第四部：打开&#x2F;etc&#x2F;fstab，写入以下内容</p><p><img src="/image/10d6ae2ad9ffd62d3425863a0f505568.png" alt="10d6ae2ad9ffd62d3425863a0f505568.png"></p><p>第二、三、五、六部：打开&#x2F;etc&#x2F;init.d&#x2F;rcS，写入以下内容</p><p><img src="/image/6eee005331550ae994ca89c7bea2ea54.png" alt="6eee005331550ae994ca89c7bea2ea54.png"></p><p><img src="/image/ccec79fe480464ab11013b564cc29c1e.png" alt="ccec79fe480464ab11013b564cc29c1e.png"></p><p><img src="/image/44b6e8f3d277cfb7f54508aedefe15fb.png" alt="44b6e8f3d277cfb7f54508aedefe15fb.png"></p><p>完善之前：<img src="/image/92ce7921e9e91591e668cc451aa6df87.png" alt="92ce7921e9e91591e668cc451aa6df87.png"></p><p>完善之后重新烧写会发现mdev自动创建了一堆设备文件</p><p><img src="/image/f0f7fed8f9f2655df8849a7b41eb404d.png" alt="f0f7fed8f9f2655df8849a7b41eb404d.png"></p><p><img src="/image/63778e95c4169ebf684ddf1d4347e1cb.png" alt="63778e95c4169ebf684ddf1d4347e1cb.png"></p><p>以上最小的根文件系统基本完善</p><p>（四）构建其他文件系统：jffs2</p><p>用jffs2 文件系统映象。这是一般用在NORFLASY 上的，但也可以用在NAND 上。</p><ol><li>首先编译制作工具</li></ol><p>这个mkfs.jffs2工具需要zlib压缩包，先安装zlib。找到zlib源码zlib-1.2.3.tar.gz，进行如下操作</p><p><img src="/image/01cb58b54a9ebc3845850478460b5e17.png" alt="01cb58b54a9ebc3845850478460b5e17.png"></p><p>--shared 是会编译出它的动态库</p><p>--prefix 是指安装到哪个目录</p><p>然后编译mkfs.jffs2，就生成了mkfs.jffs2这个工具</p><p><img src="/image/6c2446d56ad3c061df02d893f1620dcf.png" alt="6c2446d56ad3c061df02d893f1620dcf.png"></p><ol><li>制作映像文件</li></ol><p><img src="/image/1c239aaa13bf8c73829d48a39b8488d4.png" alt="1c239aaa13bf8c73829d48a39b8488d4.png"></p><p>-n 表示不要在每个擦除块上都加上清除标志。</p><p>-s 指明一页的大小是多少。此处NAND每页是2048字节.</p><p>-e 是一个擦除块的大小 （单位 KiB）。此处NAND是每块128KiB</p><p>-d 是制作哪个目录为文件系统</p><p>-o 是输入文件系统</p><ol><li>烧写</li></ol><p>若重启发现还是以yaffs文件系统来挂接的。<img src="/image/6c2869ff6f212e04d6f11d520c70ec29.png" alt="6c2869ff6f212e04d6f11d520c70ec29.png"></p><p>这显然不对。得指定下根文件系统的类型。不能自动识别则在命令行中强制指定。再启动。</p><p><img src="/image/873a7a31a5a7cf96042f8f219fd8a6eb.png" alt="873a7a31a5a7cf96042f8f219fd8a6eb.png"></p><p>现在正常<img src="/image/2d8749d064feb4d6138ff9cb1028a016.png" alt="2d8749d064feb4d6138ff9cb1028a016.png"></p><p>（五）nfs挂载根文件系统</p><p>改进：每改一次就要重新烧写，使用网络文件系统不用来回烧写。</p><p>网络文件系统：这个文件系统放在服务器上，内核启动时识别服务器上这个目录，将这个目录当成根文件系统。</p><p><img src="/image/7fab32ae35387f750380f038edf9803a.png" alt="7fab32ae35387f750380f038edf9803a.png"></p><p>设置同一网段，ping测试</p><p><img src="/image/2a5e0f124af1485cd340003db228a56b.png" alt="2a5e0f124af1485cd340003db228a56b.png"></p><p><img src="/image/7855bbe9a795507df565889e5a74d67f.png" alt="7855bbe9a795507df565889e5a74d67f.png"></p><ol><li>从flash上启动根文件系统，再用命令挂接NFS：</li></ol><p>-服务器允许那个目录被挂接。启动nfs 服务（在&#x2F;etc&#x2F;exports这个配置文件中定义这个目录）。</p><p><img src="/image/9a9e72a2f154a8ff58fbe824a0ff286a.png" alt="9a9e72a2f154a8ff58fbe824a0ff286a.png"></p><p>重启nfs服务</p><p><img src="/image/d959e4fe47905959f66d94b122b665ed.png" alt="d959e4fe47905959f66d94b122b665ed.png"></p><p>测试，在PC机上测试下是否可以自已挂接自已：</p><p><img src="/image/739f4ace9475b880dd7e1f2233b53a35.png" alt="739f4ace9475b880dd7e1f2233b53a35.png"></p><p><img src="/image/812534e05df2fa6cdcc954bb865e46cf.png" alt="812534e05df2fa6cdcc954bb865e46cf.png"></p><p>测试成功</p><p>-单板去挂接</p><p><img src="/image/81f95948d5a9c4a732d979ffc04176ea.png" alt="81f95948d5a9c4a732d979ffc04176ea.png"></p><p><img src="/image/03e30b6b94e518e774ec47d99d147ded.png" alt="03e30b6b94e518e774ec47d99d147ded.png"></p><p>在单板上创建一个挂接目录，再挂接。这样在服务器上改变那个目录下的文件时，单板上挂接的这个目录里也会改变。</p><p>这种方法是开发板启动之后去挂载的。</p><p>2.直接从NFS启动-&gt;修改命令行参数</p><p><img src="/image/e2e92f16a463ba9e8dedc0a1b310d1c1.png" alt="e2e92f16a463ba9e8dedc0a1b310d1c1.png"></p><p>上面是从“&#x2F;dev&#x2F;mtdblock3”启动的。</p><p>应该修改成bootargs&#x3D;noinitrd root&#x3D;&#x2F;dev&#x2F;nfs init&#x3D;&#x2F;linuxrc console&#x3D;ttySAC0</p><p>设置NFS启动参数：</p><p>1.服务器IP、目录</p><p>2.自己的IP</p><p>在linux内核的Documention\nfsroot.txt中有说明用法。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ruby">nfsroot=[&lt;server-ip&gt;<span class="hljs-symbol">:</span>]&lt;root-dir&gt;[,&lt;nfs-options&gt;]<br>ip=&lt;client-ip&gt;<span class="hljs-symbol">:&lt;server-ip&gt;</span><span class="hljs-symbol">:&lt;gw-ip&gt;</span><span class="hljs-symbol">:&lt;netmask&gt;</span><span class="hljs-symbol">:&lt;hostname&gt;</span><span class="hljs-symbol">:&lt;device&gt;</span><span class="hljs-symbol">:&lt;autoconf&gt;</span><br>noinitrd root=<span class="hljs-regexp">/dev/nfs</span> nfsroot=[&lt;server-ip&gt;<span class="hljs-symbol">:</span>]&lt;root-dir&gt;[,&lt;nfs-options&gt;]  ip=&lt;client-ip&gt;<span class="hljs-symbol">:&lt;server-ip&gt;</span><span class="hljs-symbol">:&lt;gw-ip&gt;</span><span class="hljs-symbol">:&lt;netmask&gt;</span><span class="hljs-symbol">:&lt;hostname&gt;</span><span class="hljs-symbol">:&lt;device&gt;</span><span class="hljs-symbol">:&lt;autoconf&gt;</span><br><br>[&lt;server-ip&gt;<span class="hljs-symbol">:</span>] 服务器<span class="hljs-variable constant_">IP</span>。<span class="hljs-number">192.168</span>.<span class="hljs-number">1.19</span><br>&lt;root-dir&gt; 服务器上哪个目录设置成被单板挂载。/work/nfs_root/first_fs<br>[&lt;nfs-options&gt;] 用中括号表示的参数可以省略。尖括号的不可省略。此处不设置<br>&lt;client-ip&gt; 表示单板的<span class="hljs-variable constant_">IP</span>。<span class="hljs-number">192.168</span>.<span class="hljs-number">1.11</span><br>&lt;server-ip&gt; 服务器<span class="hljs-variable constant_">IP</span>。<span class="hljs-number">192.168</span>.<span class="hljs-number">1.19</span><br>&lt;gw-ip&gt; 网关，单板和服务器同一网段。<span class="hljs-number">192.168</span>.<span class="hljs-number">1.1</span><br>&lt;netmask&gt; 子网掩码。<span class="hljs-number">255.255</span>.<span class="hljs-number">255.0</span><br>&lt;hostname&gt; 不关心这个，不要。<br>&lt;device&gt; 网卡，如 eth0\eth1。eth0<br>&lt;autoconf&gt; 自动配置，这个不需要。off<br></code></pre></td></tr></table></figure><p>输入设置命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">set</span> bootargs noinitrd <span class="hljs-attribute">root</span>=/dev/nfs <span class="hljs-attribute">nfsroot</span>=192.168.2.100:/work/nfs_root/first_fs <span class="hljs-attribute">ip</span>=192.168.2.123:192.168.2.100:192.168.2.1:255.255.255.0::eth0:off <span class="hljs-attribute">init</span>=/linuxrc <span class="hljs-attribute">console</span>=ttySAC0<br></code></pre></td></tr></table></figure><p>原来的启动参数：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">noinitrd <span class="hljs-attribute">root</span>=/dev/mtdblock2 <span class="hljs-attribute">init</span>=/linuxrc <span class="hljs-attribute">console</span>=ttySAC0 <span class="hljs-attribute">mem</span>=64M<br></code></pre></td></tr></table></figure><p>save保存，print查看参数</p><p><img src="/image/c2aeb0eb11ac66a89888452901827135.png" alt="c2aeb0eb11ac66a89888452901827135.png"></p><p><img src="/image/16366f098defc50b43c2184a0ec28325.png" alt="16366f098defc50b43c2184a0ec28325.png"></p><p>设置好输入boot启动单板，这样单板就挂接好了nfs网络文件系统了。</p><p>测试：在服务器上写一个程序hello.c，再使用arm-linux-gcc编译生成了hello文件，再到这个nfs 文件系统上启动，就可以在单板上直接运行。</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第003课_内核配置裁剪及启动流程</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/%E7%AC%AC003%E8%AF%BE_%E5%86%85%E6%A0%B8%E9%85%8D%E7%BD%AE%E8%A3%81%E5%89%AA%E5%8F%8A%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/%E7%AC%AC003%E8%AF%BE_%E5%86%85%E6%A0%B8%E9%85%8D%E7%BD%AE%E8%A3%81%E5%89%AA%E5%8F%8A%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>郝斌老师数据结构课程笔记</p><p>001</p><hr><p>两个文件：linux-2.6.22.6.tar.bz2；linux-2.6.22.6_jz2440_v1.patch</p><ol><li><p>解压缩<img src="/image/0b15a0b8a47b572f63a1d287cb9ffad1.png" alt="0b15a0b8a47b572f63a1d287cb9ffad1.png"></p></li><li><p>打补丁<img src="/image/5ab94be7d57483b65640beb6b0880e73.png" alt="5ab94be7d57483b65640beb6b0880e73.png"></p></li><li><p>配置</p><ul><li>make menuconfig：每一项都自己配置</li><li>使用默认配置，在默认配置进行修改<ul><li>在arch&#x2F;arm&#x2F;configs找到相似的配置文件XXX_defconfig<img src="/image/be0aca5d6ec88c68a9964b339d5f31c0.png" alt="be0aca5d6ec88c68a9964b339d5f31c0.png"><br>  <img src="/image/95b245b7fe35e2219c3bb976e27455e4.png" alt="95b245b7fe35e2219c3bb976e27455e4.png"></li><li>输入make XXX_defconfig-&gt;结果保存在.config里<img src="/image/d8ef5295a2c23127c05040599410b562.png" alt="d8ef5295a2c23127c05040599410b562.png"></li><li>输入make menuconfig<img src="/image/a186d0d6ab47179c924fe6e117474a9e.png" alt="a186d0d6ab47179c924fe6e117474a9e.png"></li></ul></li><li>使用厂家提供的配置文件<ul><li>输入 cp config厂家 .config<img src="/image/04dc7b4cddc71ef540b7a96f607d489e.png" alt="04dc7b4cddc71ef540b7a96f607d489e.png"></li><li>输入make menuconfig</li></ul></li></ul></li><li><p>编译：make uImage</p></li></ol><p>烧写编译好的uImage，插入usbdevice线</p><p>在uboot界面输入k：下载linux内核uImage。uboot就会等待usb发送过来的数据</p><p>用dnw.exe来发送uImage,uboot开始烧写</p><p><img src="/image/c30a5402b5abc444222a6df24c97eece.png" alt="c30a5402b5abc444222a6df24c97eece.png"></p><p>烧写完成后，输入b命令来启动。</p><p>若无文件系统，内核启动失败</p><p><img src="/image/68ed26f6690cf7ab713defcc26b95ab7.png" alt="68ed26f6690cf7ab713defcc26b95ab7.png"></p><p>004</p><hr><p>内核启动要做什么：</p><ol><li>处理uboot传入的参数：从arch&#x2F;arm&#x2F;kernel&#x2F;head.S一路分析</li></ol><p>&#x2F;* 第一阶段：处理机器ID *&#x2F;</p><p>①判断uboot是否支持这个CPU</p><p>②判断uboot是否支持这个单板（uboot启动内核时传入的机器ID）</p><p>③建立页表</p><p>④使能MMU</p><p>⑤跳转到start_kernel（内核的第一个C函数）</p><p>&#x2F;* 处理启动参数 *&#x2F;</p><p>①初始化、输出Linux版本信息</p><p>②setup_arch    &#x2F;&#x2F;解析uboot传入的启动参数</p><p>③setup_command_line    &#x2F;&#x2F;解析uboot传入的启动参数</p><p>④parse_early_param</p><p>do_easy_param</p><p>从__setup_start到__setuo_end，调用early函数</p><p>⑤unknown_bootoption</p><p>obsolete_checksetup</p><p>从__setup_start到__setup_end，调用非early函数</p><p>⑥rest_init</p><p>kernel_init</p><p>prepare_namespace</p><p>mount_root    &#x2F;&#x2F;挂接根文件系统</p><p>init_post    &#x2F;&#x2F;执行应用程序</p><p>…</p><p>挂接：根文件系统</p><p>最终目的：应用程序</p><p>root &#x3D; &#x2F;dev&#x2F;mtdblock3，而Flash无分区表，分区只能在代码中写死，可以找到代码段修改</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第002课_从0写bootloader_更深刻理解bootloader</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/%E7%AC%AC002%E8%AF%BE_%E4%BB%8E0%E5%86%99bootloader_%E6%9B%B4%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3bootloader/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/%E7%AC%AC002%E8%AF%BE_%E4%BB%8E0%E5%86%99bootloader_%E6%9B%B4%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3bootloader/</url>
    
    <content type="html"><![CDATA[<p>001</p><hr><p>uboot最终目的：启动内核-&gt;从Flash读出内核，放到SDRAM，启动内核</p><p>uboot要实现的功能：</p><ol><li><p>从Flash读出内核-&gt;写Flash从网卡或USB得到(为了开发方便)</p><ul><li>能读FLash</li><li>初始化内存&#x2F;时钟&#x2F;其它</li></ul></li><li><p>启动内核</p><ul><li>设置参数</li><li>跳转执行</li></ul></li></ol><p>最简单的bootloader的编写步骤</p><ol><li>初始化硬件：关看门狗、设置时钟、设置SDRAM、初始化NAND FLASH</li><li>如果bootloader比较大，需要重定位到SDRAM</li><li>把内核从NAND FLASH读到SDRAM</li><li>设置“要传给内核的参数”</li><li>跳转执行程序</li></ol><p>很多代码我们需要参考uboot</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* start.S */</span><br><br><span class="hljs-regexp">/* 关看门狗 */</span><br><span class="hljs-regexp">/* 设置时钟 */</span><br><span class="hljs-regexp">/* 初始化SDRAM */</span><br><span class="hljs-regexp">/* 重定位 */</span><br><span class="hljs-regexp">/* 执行main */</span><br></code></pre></td></tr></table></figure><p>.long</p><p>adr指令</p><p>栈指向最高地址，向下增长</p><p>Nand时序</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/* Init.c */</span><br><br><span class="hljs-built_in">int</span> is<span class="hljs-constructor">BootFromNorFlash(<span class="hljs-params">void</span>)</span><br><br><span class="hljs-built_in">int</span> copy<span class="hljs-constructor">_code_to_sdram(<span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">src</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">dest</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">len</span>)</span><br><br>void clear<span class="hljs-constructor">_bss(<span class="hljs-params">void</span>)</span><br><br>void nand<span class="hljs-constructor">_init(<span class="hljs-params">void</span>)</span><br><br>void nand<span class="hljs-constructor">_select(<span class="hljs-params">void</span>)</span>    <span class="hljs-comment">//选中</span><br><br>void nand<span class="hljs-constructor">_deselect(<span class="hljs-params">void</span>)</span>    <span class="hljs-comment">//取消片选</span><br><br>void nand<span class="hljs-constructor">_cmd(<span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">cmd</span>)</span>    <span class="hljs-comment">//发出命令</span><br><br>void nand<span class="hljs-constructor">_addr(<span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">addr</span>)</span>    <span class="hljs-comment">//发出地址</span><br><br>void nand<span class="hljs-constructor">_wait_ready(<span class="hljs-params">void</span>)</span>    <span class="hljs-comment">//判断状态</span><br><br>unsigned <span class="hljs-built_in">int</span> nand<span class="hljs-constructor">_data(<span class="hljs-params">void</span>)</span><br><br>void nand<span class="hljs-constructor">_read(<span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">src</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">dest</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">len</span>)</span><br><br>void uart0<span class="hljs-constructor">_init(<span class="hljs-params">void</span>)</span><br><br>void putc(unsigned <span class="hljs-built_in">char</span> c)<br><br>void puts(<span class="hljs-built_in">char</span> *str)<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* boot.lds */</span><br><br></code></pre></td></tr></table></figure><p>002</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* boot.c */</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">void</span> (*theKernel)(<span class="hljs-type">int</span> zero, <span class="hljs-type">int</span> arch, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> params);<br>    <br>    <span class="hljs-comment">/* 0. 帮内核设置串口: 内核启动的开始部分会从串口打印一些信息,但是内核一开始没有初始化串口 */</span><br><br>    <span class="hljs-comment">/* 1.从NAND FLASH里把内核读入内存 */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Copy kernel from nand\n\r&quot;</span>);<br>    <span class="hljs-built_in">nand_read</span>(<span class="hljs-number">0x60000</span>+<span class="hljs-number">64</span>, <span class="hljs-number">0x30008000</span>, <span class="hljs-number">0x200000</span>);    <span class="hljs-comment">//通过输入boot得到后两个数据</span><br>    <span class="hljs-comment">/* 2.设置参数 */</span><br>       <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Set boot params\n\r&quot;</span>);<br>    <span class="hljs-comment">/* 3. 跳转执行 */</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Boot kernel\n\r&quot;</span>);<br>    theKernel = (<span class="hljs-built_in">void</span> (*)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>))<span class="hljs-number">0x30008000</span>;<br>    <span class="hljs-built_in">theKernel</span>(<span class="hljs-number">0</span>, <span class="hljs-number">362</span>, <span class="hljs-number">0x30000100</span>);  <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     *  mov r0, #0</span><br><span class="hljs-comment">     *  ldr r1, =362</span><br><span class="hljs-comment">     *  ldr r2, =0x30000100</span><br><span class="hljs-comment">     *  mov pc, #0x30008000</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Error!\n\r&quot;</span>);<br>    <span class="hljs-comment">/* 如果一切正常, 不会执行到这里 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们写的bootloader只支持读出内核启动，不支持烧写，需要用uboot烧写(uboot可烧可读)</p><p>烧到哪？</p><p>uboot界面输入mtd，可看到kernel分区，即烧写到0x60000</p><p>烧的是什么？</p><p>uImage，uImage &#x3D; 64字节头部 + zImage；</p><p>uImage存在0x60000，zImage存在0x60000+64</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* boot.c */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;setup.h&quot;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">tag</span> *params;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setup_start_tag</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;    <span class="hljs-comment">//</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setup_memory_tags</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setup_commandline_tag</span><span class="hljs-params">(<span class="hljs-string">&quot;noinitrd root=/dev/mtdblock3 init=/linuxrc console=ttySAC0&quot;</span>)</span></span>;<br><br><span class="hljs-built_in">voidsetup_end_tag</span>(<span class="hljs-type">void</span>);<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    <span class="hljs-comment">/* 1.从NAND FLASH里把内核读入内存 */</span><br><br>    <span class="hljs-comment">/* 2.设置参数 */</span><br>    <span class="hljs-built_in">setup_start_tag</span>();<br>    <span class="hljs-built_in">setup_memory_tags</span>();<br>    <span class="hljs-built_in">setup_commandline_tag</span>(<span class="hljs-string">&quot;noinitrd root=/dev/mtdblock3 init=/linuxrc console=ttySAC0&quot;</span>);<br>    <span class="hljs-built_in">setup_end_tag</span>();<br>    <span class="hljs-comment">/* 3.跳转执行 */</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>uboot约定0x30000100放参数</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* Makefile */</span><br><br></code></pre></td></tr></table></figure><p>003</p><hr><p>004</p><hr><p>改进：</p><ol><li><p>提高CPU频率，2440最高可以跑400M</p></li><li><p>启动ICACHE</p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* start.S */</span><br><br>    <span class="hljs-regexp">/* 2.设置时钟 */</span><br>    <span class="hljs-regexp">/* 启动ICACHE */</span><br><br></code></pre></td></tr></table></figure><p>ICACHE：用于取指令</p><p>CPU中有指令CACHE，数据CACHE（Cache存储器，电脑中为高速缓冲存储器）</p><p>CPU一条一条去SDRAM取指令，然后回CPU执行，取一次就访问一次SDRAM</p><p>有了ICACHE，CPU取指令的时候同时会把一小块指令放入ICACHE，下次CPU执行时CPU会先看ICACHE有没有下一条指令，有就直接从ICACHE取出执行，没有再去内存SDRAM取</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第001课_U-boot分析与使用</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/%E7%AC%AC001%E8%AF%BE_U-boot%E5%88%86%E6%9E%90%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/%E7%AC%AC001%E8%AF%BE_U-boot%E5%88%86%E6%9E%90%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>目录</p><hr><ol><li>第001节_u-boot分析之编译体验</li><li>第002节_u-boot分析之Makefile结构分析</li><li>第003节_u-boot分析之源码第1阶段</li><li>第004节_u-boot分析之源码第2阶段</li><li>第005节_u-boot分析之u-boot命令实现</li><li>第006节_u-boot分析_uboot启动内核</li></ol><p><strong>第001节_u-boot分析之编译体验</strong></p><hr><p>PC上window系统如何启动：</p><p>PC-&gt;BIOS-&gt;引导操作系统windows-&gt;识别C、D盘-&gt;运行应用程序</p><p>嵌入式系统启动与PC如何对应：</p><p>嵌入式系统-&gt;bootloader-&gt;Linux内核-&gt;挂接根文件系统-&gt;运行应用程序</p><p>bootloader最终目的：启动内核</p><p>打补丁过程：解压缩、打补丁(patch -p？ &#x2F;…补丁文件)、配置(make 100ask24x0_config)、编译(make)</p><p>编译完成后烧写到开发板，可进入uboot的命令行</p><p>uboot最终目的：启动内核-&gt;从Flash读出内核，放到SDRAM，启动内核</p><p>uboot要实现的功能：</p><ol><li>从Flash读出内核-&gt;写Flash从网卡或USB得到(为了开发方便)</li><li>初始化SDRAM-&gt;初始化时钟,关闭看门狗(让系统运行更快)-&gt;初始化串口</li><li>启动内核</li></ol><p>通过分析Makefile来分析uboot的功能和结构</p><p><strong>第002节_u-boot分析之Makefile结构分析</strong></p><hr><p><strong>第003节_u-boot分析之源码第1阶段</strong></p><hr><p>第一阶段是硬件初始化</p><p><strong>第004节_u-boot分析之源码第2阶段</strong></p><hr><p><strong>第005节_u-boot分析之u-boot命令实现</strong></p><hr><p>lds，重定位</p><p><strong>第006节_u-boot分析_uboot启动内核</strong></p><hr><p>启动内核的两个命令：从Flash读出内核，启动内核</p><p>从哪里读？从kernel读，这是个分区</p><p>代码里写死分区，mtd查看分区，查看karnel分区从其中读出内核</p><p>Flash上存的内核：UImage（压缩过的内核：头部+真正的内核）</p><p>头部（64字节）里有in_load加载地址,in_ep入口地址等</p><p>bootn：根据头部移动到合适的地方；启动：do_bootn_linux（在启动之前，1.uboot告诉内核一些启动参数-&gt;设置启动参数；2.跳到入口地址启动内核）</p><p>1.uboot在某个地址以某种格式(TAG)保存需要给内核的数据，因为启动内核后uboot就不存在了</p><p>三个参数：0，机器ID，启动参数所存地址</p><p><img src="/image/20140522192814781.png" alt="20140522192814781.png"></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从sys_open()到open()</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/%E4%BB%8Esys_open()%E5%88%B0open()/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/%E4%BB%8Esys_open()%E5%88%B0open()/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/ZJoy/archive/2011/01/09/1931378.html">https://www.cnblogs.com/ZJoy/archive/2011/01/09/1931378.html</a></p><p><a href="https://blog.csdn.net/iteye_11495/article/details/82551098?utm_medium=distribute.pc_relevant.none-task-blog-title-2&spm=1001.2101.3001.4242">https://blog.csdn.net/iteye_11495&#x2F;article&#x2F;details&#x2F;82551098?utm_medium&#x3D;distribute.pc_relevant.none-task-blog-title-2&amp;spm&#x3D;1001.2101.3001.4242</a></p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-type">int</span> <span class="hljs-built_in">open</span>(<span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, mode_t mode);  --应用程序中的<span class="hljs-built_in">open</span>，系统调用<br>                            ||<br>                            \/<br><span class="hljs-type">long</span> <span class="hljs-title function_">sys_open</span>(<span class="hljs-keyword">const</span> <span class="hljs-type">char</span> __user *filename, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> mode)  -- fs/<span class="hljs-built_in">open</span>.<span class="hljs-property">c</span><br><span class="hljs-comment">/* 对应内核中的open接口函数 */</span><br>                            ||<br>                            \/<br><span class="hljs-type">long</span> <span class="hljs-title function_">do_sys_open</span>(<span class="hljs-type">int</span> dfd, <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> __user *filename, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> mode) --fs/<span class="hljs-built_in">open</span>.<span class="hljs-property">c</span><br><span class="hljs-comment">/* 用户空间的filename被拷贝到内核空间，获取当前可用的文件描述符 */</span><br>                            ||<br>                            \/<br><span class="hljs-keyword">static</span> struct file *<span class="hljs-title function_">do_filp_open</span>(<span class="hljs-type">int</span> dfd, <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> mode) --fs/<span class="hljs-built_in">open</span>.<span class="hljs-property">c</span><br>                            ||<br>                            \/<br><span class="hljs-type">int</span> <span class="hljs-title function_">open_namei</span>(<span class="hljs-type">int</span> dfd, <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flag,<br>  <span class="hljs-type">int</span> mode, struct nameidata *nd)<br><span class="hljs-comment">/* 获取该文件对应的nameidata结构.该函数执行完毕，接着调用下面函数。这两个函数是顺序被do_filp_open调用 */</span><br>                            ||<br>                            \/<br>struct file *<span class="hljs-title function_">nameidata_to_filp</span>(struct nameidata *nd, <span class="hljs-type">int</span> flags) --fs/<span class="hljs-built_in">open</span>.<span class="hljs-property">c</span><br><span class="hljs-comment">/* 将nameidata 结构转换为打开的struct file结构 */</span><br>                            ||<br>                            \/<br><span class="hljs-keyword">static</span> struct file *__dentry_<span class="hljs-built_in">open</span>(struct dentry *dentry, struct vfsmount *mnt, <span class="hljs-type">int</span> flags, struct file *f, <span class="hljs-built_in">int</span> (*<span class="hljs-built_in">open</span>)(struct inode *, struct file *)) --fs/<span class="hljs-built_in">open</span>.<span class="hljs-property">c</span><br>&#123;<br>    ...<br>    f-&gt;f_op = <span class="hljs-title function_">fops_get</span>(inode-&gt;i_fop);  --fs/<span class="hljs-built_in">open</span>.<span class="hljs-property">c</span><br>    ...<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">open</span> &amp;&amp; f-&gt;f_op)<br>    <span class="hljs-built_in">open</span> = f-&gt;f_op-&gt;<span class="hljs-built_in">open</span>;<br>    ...<br>&#125;<br><span class="hljs-comment">/* 以上代码完成了open系统调用时执行实际文件对应内核的open方法 */</span><br></code></pre></td></tr></table></figure><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">f</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">f_op</span> = fops_get(inode-&gt;</span>i_fop);<br><span class="hljs-comment">//使file结构体的f_op指向inode结构体中的i_fop，而i_fop实际就指向def_chr_fops</span><br>def_chr_fops定义如下：<br>const struct file_operations def_chr_fops = &#123;<br>       .open = chrdev_open,<br>       .llseek = noop_llseek,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-title">open</span> = f-&gt;</span><span class="hljs-function"><span class="hljs-title">f_op</span>-&gt;</span>open;<br><span class="hljs-comment">//实际就是将inode里i_fop成员的open方法chrdev_open()赋值给open</span><br></code></pre></td></tr></table></figure><p>到这可以看出，实际上sys_open()函数最后是去执行了chrdev_open()函数，最后再由chrdev_open()函数调用用户程序中的open函数。</p><p>chrdev_open()</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static <span class="hljs-built_in">int</span> chrdev<span class="hljs-constructor">_open(<span class="hljs-params">struct</span> <span class="hljs-params">inode</span> <span class="hljs-operator">*</span><span class="hljs-params">inode</span>, <span class="hljs-params">struct</span> <span class="hljs-params">file</span> <span class="hljs-operator">*</span><span class="hljs-params">filp</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>驱动程序中的open</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static <span class="hljs-built_in">int</span> first<span class="hljs-constructor">_drv_open(<span class="hljs-params">struct</span> <span class="hljs-params">inode</span> <span class="hljs-operator">*</span><span class="hljs-params">inode</span>, <span class="hljs-params">struct</span> <span class="hljs-params">file</span> <span class="hljs-operator">*</span><span class="hljs-params">file</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>register_chrdev_region( )等设备号分配注册函数</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/register_chrdev_region(_)%E7%AD%89%E8%AE%BE%E5%A4%87%E5%8F%B7%E5%88%86%E9%85%8D%E6%B3%A8%E5%86%8C%E5%87%BD%E6%95%B0/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/register_chrdev_region(_)%E7%AD%89%E8%AE%BE%E5%A4%87%E5%8F%B7%E5%88%86%E9%85%8D%E6%B3%A8%E5%86%8C%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/lizuobin2/article/details/52695533">https://blog.csdn.net/lizuobin2/article/details/52695533</a></p><p><a href="https://www.cnblogs.com/androidstudio/p/5296530.html">https://www.cnblogs.com/androidstudio/p/5296530.html</a></p><p><a href="https://blog.csdn.net/ecbtnrt/article/details/6686138?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">https://blog.csdn.net/ecbtnrt/article/details/6686138?utm_medium&#x3D;distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source&#x3D;distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param</a></p><p>（一）简述</p><p>内核提供了三个函数来注册一组字符设备编号，这三个函数分别是 register_chrdev()、register_chrdev_region()和alloc_chrdev_region() 。</p><ol><li>在 2.4 的内核使用 register_chrdev() 来进行字符设备设备节点的分配。这种方式每一个主设备号只能存放一种设备，它们使用相同的 file_operation 结构体，也就是说内核最多支持 255 个字符设备驱动程序。</li></ol><p>register_chrdev()可以实现静态和动态注册两种方法，主要是通过给定的主设备号是否为0来进行区别，为0的时候为动态注册。register_chrdev_region以及alloc_chrdev_region就是将上述函数的静态和动态注册设备号进行了拆分的强化。</p><ol><li>在 2.6 的内核之后，新增了一个 register_chrdev_region 函数，它支持将同一个主设备号下的次设备号进行分段，每一段供给一个字符设备驱动程序使用，使得资源利用率大大提升，同时也保留了原有的 register_chrdev 方法。且在 2.6 的内核中这两种方法都会调用到 __register_chrdev_region 函数。</li></ol><p>register_chrdev_region( ) 分配指定的设备号范围，alloc_chrdev_region( ) 动态分配设备范围，他们都主要是通过调用函数 __register_chrdev_region() 来实现的；这两个函数仅仅是注册设备号!如果要和cdev关联起来,还要调用cdev_add()。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> register<span class="hljs-constructor">_chrdev_region(<span class="hljs-params">dev_t</span> <span class="hljs-params">from</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">count</span>, <span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">name</span>)</span><br>&#123;<br>    <span class="hljs-keyword">struct</span> char_device_struct *cd;<span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator">    </span>cd = <span class="hljs-constructor">__register_chrdev_region(MAJOR(<span class="hljs-params">n</span>)</span>, <span class="hljs-constructor">MINOR(<span class="hljs-params">n</span>)</span>, next - n, name);<span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator"></span>&#125;<br><span class="hljs-comment">//register_chrdev_region最终调用的其实是__register_chrdev_region()函数</span><br></code></pre></td></tr></table></figure><p>3.Linux内核中所有已分配的字符设备编号都记录在一个名为 chrdevs 散列表里。该散列表中的每一个元素都是一个 char_device_struct 结构。</p><p>如果分配了一个设备号,就会创建一个 struct char_device_struct 的对象,并将其添加到 chrdevs中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">char_device_struct</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">char_device_struct</span> *next;  <span class="hljs-comment">// 指向散列冲突链表中的下一个元素的指针     </span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> major; 　　　　　　　 <span class="hljs-comment">// 主设备号</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> baseminor;  　　　　　<span class="hljs-comment">// 起始次设备号</span><br>    <span class="hljs-type">int</span> minorct; 　　　　　　　　　　　 <span class="hljs-comment">// 设备编号的范围大小</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name; 　　　　　　　　 <span class="hljs-comment">// 处理该设备编号范围内的设备驱动的名称     </span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">file_operations</span> *fops; 　　<span class="hljs-comment">// 没有使用</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">cdev</span> *cdev;        　　　　<span class="hljs-comment">/* will die指向字符设备驱动程序描述符的指针 */</span><br>&#125; *chrdevs[MAX_PROBE_HASH];<br></code></pre></td></tr></table></figure><p>（二）功能</p><ol><li>register_chrdev( )：用来申请指定的设备号,并且将其注册到字符设备驱动模型中,它所做的事情为:</li></ol><p>（1）注册设备号, 通过调用 __register_chrdev_region() 来实现</p><p>（2）分配一个cdev, 通过调用 cdev_alloc() 来实现</p><p>（3）将cdev添加到驱动模型中, 这一步将设备号和驱动关联了起来. 通过调用 cdev_add() 来实现</p><p>（4）将第一步中创建的 struct char_device_struct 对象的 cdev 指向第二步中分配的cdev. 由于register_chrdev()是老的接口,这一步在新的接口中并不需要。</p><ol><li>函数 __register_chrdev_region() 主要执行以下步骤：</li></ol><p>（1）分配一个新的 char_device_struct 结构，并用 0 填充。</p><p>（2）如果申请的设备编号范围的主设备号为 0，那么表示设备驱动程序请求动态分配一个主设备号。动态分配主设备号的原则是从散列表的最后一个桶向前寻找，那个桶是空的，主设备号就是相应散列桶的序号。所以动态分配的主设备号总是小于 256，如果每个桶都有字符设备编号了，那动态分配就会失败。</p><p>（3）根据参数设置 char_device_struct 结构中的初始设备号，范围大小及设备驱动名称。</p><p>（4）计算出主设备号所对应的散列桶，为新的 char_device_struct 结构寻找正确的位置。同时，如果设备编号范围有重复的话，则出错返回。</p><p>（5）将新的 char_device_struct 结构插入散列表中，并返回 char_device_struct 结构的地址</p><ol><li>不同点：</li></ol><p>register_chrdev函数在注册字符设备驱动的时候是一步完成的，而register_chrdev_region函数在注册字符设备驱动的时候是分两步完成的：</p><p>第一步：注册&#x2F;分配主次设备号</p><p>第二步：注册字符设备驱动（调用cdev_init()，cdev_add()）</p><p>（三）程序例子</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//使用alloc_chrdev_region</span><br>init<span class="hljs-literal">()</span><br>&#123;<br>    alloc<span class="hljs-constructor">_chrdev_region(&amp;<span class="hljs-params">dev</span>, 0, 1, <span class="hljs-string">&quot;hello_drv&quot;</span>)</span>;<br>    major = <span class="hljs-constructor">MAJOR(<span class="hljs-params">dev</span>)</span>;<br><br>    cdev<span class="hljs-constructor">_init(&amp;<span class="hljs-params">hello_drv_cdev</span>, &amp;<span class="hljs-params">helo_fops</span>)</span>;<br>    cdev<span class="hljs-constructor">_add(&amp;<span class="hljs-params">hello_drv_cdev</span>, <span class="hljs-params">dev</span>, 1)</span>;<br>&#125;<br><br>exit<span class="hljs-literal">()</span><br>&#123;<br>    cdev<span class="hljs-constructor">_del(&amp;<span class="hljs-params">hello_drv_cdev</span>)</span>;<br>    unregister<span class="hljs-constructor">_chrdev_region(MKDEV(<span class="hljs-params">major</span>, 0)</span>, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>使用register_chrdev<br>init()<br>&#123;<br>    major = register_chrdev(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;first_drv&quot;</span>, &amp;first_drv_fops); <span class="hljs-regexp">//</span> 注册, 告诉内核<br>&#125;<br><span class="hljs-keyword">exit</span>()<br>&#123;<br>    unregister_chrdev(major, <span class="hljs-string">&quot;first_drv&quot;</span>); <span class="hljs-regexp">//</span> 卸载<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>open()第一次执行</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/open()%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%89%A7%E8%A1%8C/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/open()%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%89%A7%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<p>要操作一个文件，除了该文件必须存在外，还需要先通过open系统调用去得到一个文件句柄，有了这个句柄后续的操作read、write才能进行。</p><p>open系统调用在C库头文件中的原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span></span>;<br></code></pre></td></tr></table></figure><p>毫无疑问open函数必须通过pathname去找到该文件对应的inode（这里假设我们的inode设备节点已经存在）。找到inode节点后，将调用inode里i_fop成员的open方法，对于字符设备而言，将调用chrdev_open函数。该函数实现如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Called every time a character special file is opened</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">// 系统调用打开字符设备的桥梁函数</span><br>static <span class="hljs-built_in">int</span> chrdev<span class="hljs-constructor">_open(<span class="hljs-params">struct</span> <span class="hljs-params">inode</span> <span class="hljs-operator">*</span><span class="hljs-params">inode</span>, <span class="hljs-params">struct</span> <span class="hljs-params">file</span> <span class="hljs-operator">*</span><span class="hljs-params">filp</span>)</span><br>&#123;<br>    <span class="hljs-keyword">struct</span> cdev *p;<br>    <span class="hljs-keyword">struct</span> cdev *<span class="hljs-keyword">new</span> = NULL;<br>    <span class="hljs-built_in">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 加锁，控制系统并发打开该字符设备时的资源竞争。</span><br>    spin<span class="hljs-constructor">_lock(&amp;<span class="hljs-params">cdev_lock</span>)</span>;<br>    <span class="hljs-comment">// 首次打开设备时inode结点的cdev结构为空</span><br>    p = inode-&gt;i_cdev;<br>    <span class="hljs-keyword">if</span> (!p) &#123;<br>        <span class="hljs-keyword">struct</span> kobject *kobj;<br>        <span class="hljs-built_in">int</span> idx;<br>        spin<span class="hljs-constructor">_unlock(&amp;<span class="hljs-params">cdev_lock</span>)</span>;<br>        <span class="hljs-comment">// 搜索cdev_map哈希链表数组，查找inode-&gt;i_rdev设备号指定的设备是否在该数组中，</span><br>        <span class="hljs-comment">// 如果存在则返回字符设备关联的kobject对象结构。</span><br>        kobj = kobj<span class="hljs-constructor">_lookup(<span class="hljs-params">cdev_map</span>, <span class="hljs-params">inode</span>-&gt;<span class="hljs-params">i_rdev</span>, &amp;<span class="hljs-params">idx</span>)</span>;<br>        <span class="hljs-keyword">if</span> (!kobj)<br>            return -ENXIO;<br>        <span class="hljs-comment">// 获取字符设备结构</span><br>        <span class="hljs-keyword">new</span> = container<span class="hljs-constructor">_of(<span class="hljs-params">kobj</span>, <span class="hljs-params">struct</span> <span class="hljs-params">cdev</span>, <span class="hljs-params">kobj</span>)</span>;<br>        spin<span class="hljs-constructor">_lock(&amp;<span class="hljs-params">cdev_lock</span>)</span>;<br>        <span class="hljs-comment">/* Check i_cdev again in case somebody beat us to it while</span><br><span class="hljs-comment">            we dropped the lock. */</span><br>        p = inode-&gt;i_cdev;<br>        <span class="hljs-keyword">if</span> (!p) &#123;<br>            <span class="hljs-comment">// 关联查找到的字符设备结构到inode设备文件结点</span><br>            inode-&gt;i_cdev = p = <span class="hljs-keyword">new</span>;<br>            <span class="hljs-comment">// 将inode添加到字符设备链表头结构中</span><br>            <span class="hljs-built_in">list</span><span class="hljs-constructor">_add(&amp;<span class="hljs-params">inode</span>-&gt;<span class="hljs-params">i_devices</span>, &amp;<span class="hljs-params">p</span>-&gt;<span class="hljs-params">list</span>)</span>;<br>            <span class="hljs-keyword">new</span> = NULL;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!cdev<span class="hljs-constructor">_get(<span class="hljs-params">p</span>)</span>)<br>            ret = -ENXIO;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!cdev<span class="hljs-constructor">_get(<span class="hljs-params">p</span>)</span>)<br>        ret = -ENXIO;<br>    spin<span class="hljs-constructor">_unlock(&amp;<span class="hljs-params">cdev_lock</span>)</span>;<br>    <span class="hljs-comment">// new为真时说明处理过程出错，减小字符设备引用计数，并释放相关资源。</span><br>    cdev<span class="hljs-constructor">_put(<span class="hljs-params">new</span>)</span>;<br>    <span class="hljs-keyword">if</span> (ret)<br>        return ret;<br><br>    ret = -ENXIO;<br>    <span class="hljs-comment">// 使用实际字符设备注册的文件操作结构替换默认的文件操作结构(def_chr_fops)</span><br>    filp-&gt;f_op = fops<span class="hljs-constructor">_get(<span class="hljs-params">p</span>-&gt;<span class="hljs-params">ops</span>)</span>;<br>    <span class="hljs-keyword">if</span> (!filp-&gt;f_op)<br>        goto out_cdev_put;<br>    <span class="hljs-comment">// 调用字符设备注册的open函数进行字符设备相关的处理操作</span><br>    <span class="hljs-keyword">if</span> (filp-&gt;f_op-&gt;<span class="hljs-keyword">open</span>) &#123;<br>        ret = filp-&gt;f_op-&gt;<span class="hljs-keyword">open</span>(inode,filp);<br>        <span class="hljs-keyword">if</span> (ret)<br>            goto out_cdev_put;<br>    &#125;<br><br>    return <span class="hljs-number">0</span>;<br><br>    out_cdev_put:<br>        cdev<span class="hljs-constructor">_put(<span class="hljs-params">p</span>)</span>;<br>        return ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数流程如下:</p><p>（1）判断inode的i_cdev成员是否为空(据我们所知，从我们mknode开始到现在还没有谁给它赋过值，因此到目前为止还是空的)。</p><p>（2）如果为空，将通过kobj_lookup与container_of的组合找出inode-&gt;i_rdev所对应的struct cdev结构。</p><p>kobj详解： <a href="evernote:///view/18988257/s16/dec39836-2ef0-4aea-accb-5b4a1491f2ce/dec39836-2ef0-4aea-accb-5b4a1491f2ce/">kobj详解</a></p><p>（3）将通过inode-&gt;i_rdev查找到的struct cdev结构指针赋值给inode-&gt;i_cdev(注意下次open时inode将不为空)，然后将inode加入struct cdev链表中。</p><p>（4）将inode-&gt;i_cdev中的i_fop赋值给由chrdev_open传递进来的filp的f_op成员。</p><p>（5）如果inode-&gt;i_cdev中的i_fop不为空，则调用其指向的open方法。</p><p>（6）open返回</p><p>执行完 chrdev_open()之后,file对象的f_op指向cdev的ops，即用cedv关联的操作方法集和赋值给新建的file结构体中的文件操作集合。并调用操作集合中的open函数，完成真正的打开操作。</p><p>open第一次执行：</p><p>1.执行swi指令，进入系统调用</p><p>2.open时会将inode和file结构体关联起来，通过一系列系统调用最终将cdev的fops赋值给file的fops，从而调用到驱动程序中的open</p><p>3.open结束后返回一个文件句柄</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mknod做了什么</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/mknod%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/mknod%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<p><a href="http://blog.chinaunix.net/uid-22720671-id-4425640.html">http://blog.chinaunix.net/uid-22720671-id-4425640.html</a></p><p>在linux系统上操作字符设备和块设备其实就是操作文件系统上的文件，而这类文件称为设备文件。</p><p>它需要我们去创建，而且需要我们提供足够的信息。</p><p>例：mknod    &#x2F;dev&#x2F;demodev    c    2</p><p>上述命令行中，mknod是创建一个设备文件(或者称设备节点)的命令，“&#x2F;dev&#x2F;demodev”是设备文件名， c表示所创建是字符设备(b则表示块设备)，2和0分别表示主设备号和次设备号。</p><p>mknod命令中的设备文件参数是如何被内核所用的？</p><p>对于任何一个已存在的文件，内核都有一个称为struct inode的结构体(定义于include&#x2F;linux&#x2F;fs.h)与之对应，对于字符设备而言，真正需要关心的只有结构体的以下三个成员：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gauss">(<span class="hljs-number">1</span>) dev_t i_rdev;<br>表示设备文件的结点，这个域实际上包含了设备号。<br>(<span class="hljs-number">2</span>) <span class="hljs-keyword">struct</span> <span class="hljs-type">cdev</span> *i_cdev;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">cdev</span>是内核的一个内部结构，它是用来表示字符设备的，当<span class="hljs-type">inode</span>结点指向一个字符设备文件时，此域为一个指向<span class="hljs-type">inode</span>结构的指针。<br>(<span class="hljs-number">3</span>)const <span class="hljs-keyword">struct</span> <span class="hljs-type">file_operations</span> *i_fop;<br>文件操作方法集合，该设备文件所能拥有的所有能力。<br></code></pre></td></tr></table></figure><p>用户空间调用了mknod命令后，内核空间会做两件事: </p><p>(1)生成一个struct inode 实体；</p><p>(2)为struct inode的部分成员做初始化工作。</p><p>在mknod的内核执行流程中的会调用一个与设备驱动程序关系密切的init_special_inode，部分函数内容如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void init<span class="hljs-constructor">_special_inode(<span class="hljs-params">struct</span> <span class="hljs-params">inode</span> <span class="hljs-operator">*</span><span class="hljs-params">inode</span>, <span class="hljs-params">umode_t</span> <span class="hljs-params">mode</span>, <span class="hljs-params">dev_t</span> <span class="hljs-params">rdev</span>)</span><br>&#123;<span class="hljs-operator"></span><br><span class="hljs-operator">       ...</span><br><span class="hljs-operator">       </span><span class="hljs-keyword">if</span> (<span class="hljs-constructor">S_ISCHR(<span class="hljs-params">mode</span>)</span>) &#123;<br>              inode-&gt;i_fop = &amp;def_chr_fops;<br>              inode-&gt;i_rdev = rdev;<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>...<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到：</p><p>（1）i_rdev初始化为rdev，rdev是由mknod中的参数构造而来的</p><p>（2）i_fop初始化为&amp;def_chr_fops</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">file_operations</span> def_chr_fops = &#123;<br>       .open = chrdev_open,<br>       .llseek = noop_llseek,<br>&#125;;<br></code></pre></td></tr></table></figure><p>（3）i_cdev没有初始化</p><p>剩下的两个成员初始化在open函数第一次调用中初始化 <a href="evernote:///view/18988257/s16/1c1aeca4-3d5b-4413-b149-78439b27b4a9/1c1aeca4-3d5b-4413-b149-78439b27b4a9/">open()第一次执行</a></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kobj详解</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/kobj%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/kobj%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/zlsh007/article/details/22291993">https://blog.csdn.net/zlsh007/article/details/22291993</a></p><p><a href="https://blog.csdn.net/qq_16777851/article/details/81368580">https://blog.csdn.net/qq_16777851&#x2F;article&#x2F;details&#x2F;81368580</a></p><p>（一）主要数据结构</p><ol><li>Kobject是基本数据类型，每个Kobject都会在”&#x2F;sys&#x2F;“文件系统中以目录的形式出现。</li><li>Ktype代表Kobject（严格地讲，是包含了Kobject的数据结构）的属性操作集合（由于通用性，多个Kobject可能共用同一个属性操作集，因此把Ktype独立出来了）。</li><li>Kset是一个特殊的Kobject（因此它也会在”&#x2F;sys&#x2F;“文件系统中以目录的形式出现），它用来集合相似的Kobject（这些Kobject可以是相同属性的，也可以不同属性的）。</li></ol><p>（二）Kobject总结</p><p>kobject是隐藏在sysfs虚拟文件系统后的机制，对于sysfs中的每一个目录，内核中都会存在一个对应的kobject。每一个kobject都输出一个或者多个属性，它们在kobject的sysfs目录中表现为文件，其中的内容由内核生成。</p><p>Kobject的核心功能是：保持一个引用计数，当该计数减为0时，自动释放（由kobject模块负责） Kobject所占用的memory空间。这就决定了Kobject必须是动态分配的（只有这样才能动态释放）。</p><p>而Kobject大多数的使用场景是内嵌在大型的数据结构中（如Kset、device_driver等），因此这些大型的数据结构，也必须是动态分配、动态释放的。他们释放的时机是是内嵌的Kobject释放时。同时Kobject的上层数据结构中实现了Ktype及其内部函数，而Ktype中的release回调函数负责释放Kobject（甚至是包含Kobject的数据结构）的内存空间，因此只有Ktype才知道Kobject嵌在哪个数据结构中，并通过Kobject指针以及自身的数据结构类型，找到需要释放的上层数据结构的指针，然后释放这些上层数据结构。</p><p>每一个内嵌Kobject的数据结构，例如kset、device、device_driver等等，都要实现一个Ktype，并定义其中的回调函数。同理，sysfs相关的操作也一样，必须经过ktype的中转，因为sysfs看到的是Kobject，而真正的文件操作的主体，是内嵌Kobject的上层数据结构！</p><p>（三）cdev_map散列表</p><p>内核中所有的字符设备都会记录在一个 cdev_map 变量中。这个cdev_map是一个struct kobj_map类型的指针，其中包含着一个struct probe指针类型、大小为255的数组，数组的每个元素指向的一个probe结构封装了一个设备号和相应的设备对象(这里就是cdev)，可见，这个cdev_map封装了系统中的所有的cdev结构和对应的设备号，最多为255个字符设备。这个结构用来快速存取所有的对象。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">kobj_map</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">probe</span> &#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">probe</span> *next;      <span class="hljs-comment">/* 这样形成了链表结构 */</span><br>        <span class="hljs-type">dev_t</span> dev;               <span class="hljs-comment">/* 设备号 */</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> range;     <span class="hljs-comment">/* 设备号的范围 */</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">module</span> *owner;<br>        <span class="hljs-type">kobj_probe_t</span> *get;       <span class="hljs-comment">/* 用来获得kobject对象 */</span><br>        <span class="hljs-built_in">int</span> (*lock) (<span class="hljs-type">dev_t</span>, <span class="hljs-type">void</span> *);<br>        <span class="hljs-type">void</span> *data;              <span class="hljs-comment">/* 指向struct cdev对象 */</span><br>    &#125; *probes[<span class="hljs-number">255</span>];<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">mutex</span> *lock;          <span class="hljs-comment">/* 互斥锁 */</span><br>&#125;    <span class="hljs-comment">//kobj_map结构体是用来管理设备号及其对应的设备的</span><br></code></pre></td></tr></table></figure><p><img src="/image/161219114048231.png" alt="161219114048231.png"></p><p>（三）功能分析</p><p>Kobject使用流程：Kobject大多数情况下（有一种例外）会嵌在其它数据结构中使用，其使用流程如下：</p><p>（1）定义一个struct kset类型的指针，并在初始化时为它分配空间，添加到内核中</p><p>（2）根据实际情况，定义自己所需的数据结构原型，该数据结构中包含有Kobject</p><p>（3）定义一个适合自己的ktype，并实现其中回调函数</p><p>（4）在需要使用到包含Kobject的数据结构时，动态分配该数据结构，并分配Kobject空间，添加到内核中</p><p>（5）每一次引用数据结构时，调用kobject_get接口增加引用计数；引用结束时，调用kobject_put接口，减少引用计数</p><p>（6）当引用计数减少为0时，Kobject模块调用ktype所提供的release接口，释放上层数据结构以及Kobject的内存空间</p><p>（四）kobj相关函数</p><p>kobj_map() 函数就是用来把字符设备编号和 cdev 结构变量一起保存到 cdev_map 这个散列表里。当后续要打开一个字符设备文件时，通过调用 kobj_lookup() 函数，根据设备编号就可以找到 cdev 结构变量，从而取出其中的 ops 字段。</p><p>kobject_init()，初始化通过kmalloc等内存分配函数获得的struct kobject指针。</p><p>kobj_unmap()找到对应设备号dev和range指定的probe对象后，退出，然后kfree释放空间</p><p>kobj_lookup()查找该结构体，然后返回对应设备号的kobject对象，利用该对象我们可以得到包含它的对象如cdev</p><p>kobject_get()和kobject_put()：每一次引用数据结构时，调用kobject_get接口增加引用计数；引用结束时，调用kobject_put接口，减少引用计数</p><p>kobj_map_init()在初始化一个kobj_map对象时，将probes指针全部指向同一个base</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>file_operation结构体解析</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/file_operation%E7%BB%93%E6%9E%84%E4%BD%93%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/file_operation%E7%BB%93%E6%9E%84%E4%BD%93%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/zqixiao_09/article/details/50850475">https://blog.csdn.net/zqixiao_09&#x2F;article&#x2F;details&#x2F;50850475</a></p><p><a href="https://blog.csdn.net/O1O1O1o/article/details/2797636?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param">https://blog.csdn.net/O1O1O1o/article/details/2797636?utm_medium&#x3D;distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param&amp;depth_1-utm_source&#x3D;distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param</a></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>file结构体详解</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/file%E7%BB%93%E6%9E%84%E4%BD%93%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/file%E7%BB%93%E6%9E%84%E4%BD%93%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><a href="http://blog.sina.com.cn/s/blog_7943319e01018m3w.html">http://blog.sina.com.cn/s/blog_7943319e01018m3w.html</a></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.6内核char_dev.c分析</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/2-6%E5%86%85%E6%A0%B8char_dev-c%E5%88%86%E6%9E%90/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/2-6%E5%86%85%E6%A0%B8char_dev-c%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/morris-tech/p/3918013.html">https://www.cnblogs.com/morris-tech&#x2F;p&#x2F;3918013.html</a></p><p>本文基于2.6内核版本</p><p>打开char_dev.c</p><p>（一）chrdev_init</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void __init chrdev<span class="hljs-constructor">_init(<span class="hljs-params">void</span>)</span><br>&#123;<br>    cdev_map = kobj<span class="hljs-constructor">_map_init(<span class="hljs-params">base_probe</span>, &amp;<span class="hljs-params">chrdevs_lock</span>)</span>;<br>    bdi<span class="hljs-constructor">_init(&amp;<span class="hljs-params">directly_mappable_cdev_bdi</span>)</span>;<br>&#125;<br><br>static <span class="hljs-keyword">struct</span> kobject *base<span class="hljs-constructor">_probe(<span class="hljs-params">dev_t</span> <span class="hljs-params">dev</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">part</span>, <span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">data</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (request<span class="hljs-constructor">_module(<span class="hljs-string">&quot;char-major-%d-%d&quot;</span>, MAJOR(<span class="hljs-params">dev</span>)</span>, <span class="hljs-constructor">MINOR(<span class="hljs-params">dev</span>)</span>) &gt; <span class="hljs-number">0</span>)<br><span class="hljs-comment">/* Make old-style 2.4 aliases work */</span><br>    request<span class="hljs-constructor">_module(<span class="hljs-string">&quot;char-major-%d&quot;</span>, MAJOR(<span class="hljs-params">dev</span>)</span>);    <span class="hljs-comment">//request_module()请求一个加载模块</span><br>    return NULL;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">struct</span> kobj_map *kobj_map_init(kobj_probe_t *base_probe, <span class="hljs-keyword">struct</span> mutex *<span class="hljs-keyword">lock</span>)<br>&#123;<br>    <span class="hljs-keyword">struct</span> kobj_map *p = kmalloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> kobj_map), GFP_KERNEL);<br>    <span class="hljs-keyword">struct</span> probe *<span class="hljs-keyword">base</span> = kzalloc(<span class="hljs-keyword">sizeof</span>(*<span class="hljs-keyword">base</span>), GFP_KERNEL);<br>    <span class="hljs-built_in">int</span> i;<br>    <span class="hljs-keyword">if</span> ((p == NULL) || (<span class="hljs-keyword">base</span> == NULL)) &#123;<br>        kfree(p);<br>        kfree(<span class="hljs-keyword">base</span>);<br>        <span class="hljs-keyword">return</span> NULL;<br>    &#125;<br>    <span class="hljs-keyword">base</span>-&gt;dev = <span class="hljs-number">1</span>;        <br>    <span class="hljs-keyword">base</span>-&gt;range = ~<span class="hljs-number">0</span>;    <span class="hljs-comment">//取反</span><br>    <span class="hljs-keyword">base</span>-&gt;<span class="hljs-keyword">get</span> = base_probe;    <span class="hljs-comment">//把函数指针指向传进来的那个回调函数</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">255</span>; i++)    <span class="hljs-comment">//用base初始化整个kobj_map.probe[255]</span><br>        p-&gt;probes[i] = <span class="hljs-keyword">base</span>;<br>    p-&gt;<span class="hljs-keyword">lock</span> = <span class="hljs-keyword">lock</span>;    <span class="hljs-comment">//将锁也传入</span><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-keyword">struct</span> kobj_map &#123;<br><span class="hljs-keyword">struct</span> probe &#123;<br>    <span class="hljs-keyword">struct</span> probe *next;<br>    dev_t dev;<br>    unsigned <span class="hljs-built_in">long</span> range;<br>    <span class="hljs-keyword">struct</span> module *owner;<br>    kobj_probe_t *<span class="hljs-keyword">get</span>;<br>    <span class="hljs-built_in">int</span> (*<span class="hljs-keyword">lock</span>)(dev_t, <span class="hljs-keyword">void</span> *);<br>    <span class="hljs-keyword">void</span> *data;<br>&#125; *probes[<span class="hljs-number">255</span>];<br>    <span class="hljs-keyword">struct</span> mutex *<span class="hljs-keyword">lock</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>chrdev_init()在系统初始化时被调用，它调用*kobj_map_init()，其中用kmalloc分配了一块内存并赋值给kobj_map结构，并初始化其成员，返回该结构指针保存在类型为kobj_map结构的cdev_map变量中。</p><p>二、字符设备结构相关的处理操作与功能</p><ol><li>使用cdev_init()、cdev_alloc()进行设备初始化</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void cdev<span class="hljs-constructor">_init(<span class="hljs-params">struct</span> <span class="hljs-params">cdev</span> <span class="hljs-operator">*</span><span class="hljs-params">cdev</span>, <span class="hljs-params">const</span> <span class="hljs-params">struct</span> <span class="hljs-params">file_operations</span> <span class="hljs-operator">*</span><span class="hljs-params">fops</span>)</span>  <br>&#123;    <br>    memset(cdev, <span class="hljs-number">0</span>, sizeof *cdev);  <span class="hljs-comment">//主要是对空间起到一个清零作用并较之cdev_alloc多了一个ops的赋值操作  </span><br>    <span class="hljs-constructor">INIT_LIST_HEAD(&amp;<span class="hljs-params">cdev</span>-&gt;<span class="hljs-params">list</span>)</span>;  <br>    kobject<span class="hljs-constructor">_init(&amp;<span class="hljs-params">cdev</span>-&gt;<span class="hljs-params">kobj</span>, &amp;<span class="hljs-params">ktype_cdev_default</span>)</span>;      <span class="hljs-comment">//初始化字符设备结构对应的kobject对象结构，kobject结构构成了linux设备模型的基础 </span><br>    cdev-&gt;ops = fops;  <br>&#125;<br><span class="hljs-comment">//此函数首先调用kobject_init初始化cdev中的kobj，然后将cdev中的ops赋值</span><br></code></pre></td></tr></table></figure><ol><li>向kobj_map结构的哈希链表数组中添加cdev结构：</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> cdev<span class="hljs-constructor">_add(<span class="hljs-params">struct</span> <span class="hljs-params">cdev</span> <span class="hljs-operator">*</span><span class="hljs-params">p</span>, <span class="hljs-params">dev_t</span> <span class="hljs-params">dev</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">count</span>)</span><br>&#123;<br>    p-&gt;dev = dev;<br>    p-&gt;count = count;    <span class="hljs-comment">//将我们之前获得设备号和设备号长度填充到cdev结构中</span><br>    return kobj<span class="hljs-constructor">_map(<span class="hljs-params">cdev_map</span>, <span class="hljs-params">dev</span>, <span class="hljs-params">count</span>, NULL, <span class="hljs-params">exact_match</span>, <span class="hljs-params">exact_lock</span>, <span class="hljs-params">p</span>)</span>;<br>&#125;<br><br><span class="hljs-built_in">int</span> kobj<span class="hljs-constructor">_map(<span class="hljs-params">struct</span> <span class="hljs-params">kobj_map</span> <span class="hljs-operator">*</span><span class="hljs-params">domain</span>, <span class="hljs-params">dev_t</span> <span class="hljs-params">dev</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">long</span> <span class="hljs-params">range</span>, 33 <span class="hljs-params">struct</span> <span class="hljs-params">module</span> <span class="hljs-operator">*</span><span class="hljs-params">module</span>, <span class="hljs-params">kobj_probe_t</span> <span class="hljs-operator">*</span><span class="hljs-params">probe</span>, 34 <span class="hljs-params">int</span> (<span class="hljs-operator">*</span><span class="hljs-params">lock</span>)</span>(dev_t, void *), void *data)&#123;&#125;<br><br><span class="hljs-comment">// 下面两个函数为调用kobj_map函数时候传递的回调函数 </span><br>static <span class="hljs-keyword">struct</span> kobject *exact<span class="hljs-constructor">_match(<span class="hljs-params">dev_t</span> <span class="hljs-params">dev</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">part</span>, <span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">data</span>)</span><br>&#123;<br>    <span class="hljs-keyword">struct</span> cdev *p = data;<br>    return &amp;p-&gt;kobj;<br>&#125;<br><br>static <span class="hljs-built_in">int</span> exact<span class="hljs-constructor">_lock(<span class="hljs-params">dev_t</span> <span class="hljs-params">dev</span>, <span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">data</span>)</span><br>&#123;<br>    <span class="hljs-keyword">struct</span> cdev *p = data;<br>    return cdev<span class="hljs-constructor">_get(<span class="hljs-params">p</span>)</span> ? <span class="hljs-number">0</span> : -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>完成的工作就是将初始化后的cdev结构添加到cdev_map指向的哈希链表数组中</p><p>当完成上述两项工作后，当系统调用打开设备时通过查找probes哈希链表数组便可以找到对应设备结构。</p><ol><li>注销字符设备</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void cdev<span class="hljs-constructor">_del(<span class="hljs-params">struct</span> <span class="hljs-params">cdev</span> <span class="hljs-operator">*</span><span class="hljs-params">p</span>)</span><br>&#123;<br>    cdev<span class="hljs-constructor">_unmap(<span class="hljs-params">p</span>-&gt;<span class="hljs-params">dev</span>, <span class="hljs-params">p</span>-&gt;<span class="hljs-params">count</span>)</span>;<br>    <span class="hljs-comment">//减小kobject对象引用计数，当引用计数为0时删除kobject对象。</span><br>    kobject<span class="hljs-constructor">_put(&amp;<span class="hljs-params">p</span>-&gt;<span class="hljs-params">kobj</span>)</span>;<br>&#125;<br><br><span class="hljs-comment">// 删除指定设备在哈希链表数组中的信息</span><br>static void cdev<span class="hljs-constructor">_unmap(<span class="hljs-params">dev_t</span> <span class="hljs-params">dev</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">count</span>)</span><br>&#123;<br>    kobj<span class="hljs-constructor">_unmap(<span class="hljs-params">cdev_map</span>, <span class="hljs-params">dev</span>, <span class="hljs-params">count</span>)</span>;    <span class="hljs-comment">//cdev_unmap()调用 kobj_unmap()来释放cdev_map散列表中的对象</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>通过inode节点打开字符设备时用到如下文件操作结构：</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * Dummy default file-operations: the only thing this does</span><br><span class="hljs-comment"> * is contain the open that then fills in the correct operations</span><br><span class="hljs-comment"> * depending on the special file...</span><br><span class="hljs-comment"> */</span> <br> <span class="hljs-comment">// 该结构关联设备文件结点与字符设备结构 </span><br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">file_operations</span> def_chr_fops = &#123;<br>    .open = chrdev_open,<br>    .llseek = noop_llseek,<br>&#125;;<br></code></pre></td></tr></table></figure><p>该结构是inode节点搜索cdev_map哈希链表数组中字符设备结构的真正桥梁，主要是open成员函数的实现，该函数功能如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Called every time a character special file is opened</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 系统调用打开字符设备的桥梁函数</span><br>static <span class="hljs-built_in">int</span> chrdev<span class="hljs-constructor">_open(<span class="hljs-params">struct</span> <span class="hljs-params">inode</span> <span class="hljs-operator">*</span><span class="hljs-params">inode</span>, <span class="hljs-params">struct</span> <span class="hljs-params">file</span> <span class="hljs-operator">*</span><span class="hljs-params">filp</span>)</span><br>&#123;<br>    <span class="hljs-keyword">struct</span> cdev *p;<br>    <span class="hljs-keyword">struct</span> cdev *<span class="hljs-keyword">new</span> = NULL;<br>    <span class="hljs-built_in">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 加锁，控制系统并发打开该字符设备时的资源竞争。</span><br>    spin<span class="hljs-constructor">_lock(&amp;<span class="hljs-params">cdev_lock</span>)</span>;<br>    <span class="hljs-comment">// 首次打开设备时inode结点的cdev结构为空</span><br>    p = inode-&gt;i_cdev;<br>    <span class="hljs-keyword">if</span> (!p) &#123;<br>        <span class="hljs-keyword">struct</span> kobject *kobj;<br>        <span class="hljs-built_in">int</span> idx;<br>        spin<span class="hljs-constructor">_unlock(&amp;<span class="hljs-params">cdev_lock</span>)</span>;<br>        <span class="hljs-comment">// 搜索cdev_map哈希链表数组，查找inode-&gt;i_rdev设备号指定的设备是否在该数组中，</span><br>        <span class="hljs-comment">// 如果存在则返回字符设备关联的kobject对象结构。</span><br>        kobj = kobj<span class="hljs-constructor">_lookup(<span class="hljs-params">cdev_map</span>, <span class="hljs-params">inode</span>-&gt;<span class="hljs-params">i_rdev</span>, &amp;<span class="hljs-params">idx</span>)</span>;<br>        <span class="hljs-keyword">if</span> (!kobj)<br>            return -ENXIO;<br>        <span class="hljs-comment">// 获取字符设备结构</span><br>        <span class="hljs-keyword">new</span> = container<span class="hljs-constructor">_of(<span class="hljs-params">kobj</span>, <span class="hljs-params">struct</span> <span class="hljs-params">cdev</span>, <span class="hljs-params">kobj</span>)</span>;<br>        spin<span class="hljs-constructor">_lock(&amp;<span class="hljs-params">cdev_lock</span>)</span>;<br>        <span class="hljs-comment">/* Check i_cdev again in case somebody beat us to it while</span><br><span class="hljs-comment">            we dropped the lock. */</span><br>        p = inode-&gt;i_cdev;<br>        <span class="hljs-keyword">if</span> (!p) &#123;<br>            <span class="hljs-comment">// 关联查找到的字符设备结构到inode设备文件结点</span><br>            inode-&gt;i_cdev = p = <span class="hljs-keyword">new</span>;<br>            <span class="hljs-comment">// 将inode添加到字符设备链表头结构中</span><br>            <span class="hljs-built_in">list</span><span class="hljs-constructor">_add(&amp;<span class="hljs-params">inode</span>-&gt;<span class="hljs-params">i_devices</span>, &amp;<span class="hljs-params">p</span>-&gt;<span class="hljs-params">list</span>)</span>;<br>            <span class="hljs-keyword">new</span> = NULL;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!cdev<span class="hljs-constructor">_get(<span class="hljs-params">p</span>)</span>)<br>            ret = -ENXIO;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!cdev<span class="hljs-constructor">_get(<span class="hljs-params">p</span>)</span>)<br>        ret = -ENXIO;<br>    spin<span class="hljs-constructor">_unlock(&amp;<span class="hljs-params">cdev_lock</span>)</span>;<br>    <span class="hljs-comment">// new为真时说明处理过程出错，减小字符设备引用计数，并释放相关资源。</span><br>    cdev<span class="hljs-constructor">_put(<span class="hljs-params">new</span>)</span>;    <span class="hljs-comment">//此函数调用kobject_put和module_put，它们的作用就是减少引用计数</span><br>    <span class="hljs-keyword">if</span> (ret)<br>        return ret;<br><br>    ret = -ENXIO;<br>    <span class="hljs-comment">// 使用实际字符设备注册的文件操作结构替换默认的文件操作结构(def_chr_fops)</span><br>    filp-&gt;f_op = fops<span class="hljs-constructor">_get(<span class="hljs-params">p</span>-&gt;<span class="hljs-params">ops</span>)</span>;<br>    <span class="hljs-keyword">if</span> (!filp-&gt;f_op)<br>        goto out_cdev_put;<br>    <span class="hljs-comment">// 调用字符设备注册的open函数进行字符设备相关的处理操作</span><br>    <span class="hljs-keyword">if</span> (filp-&gt;f_op-&gt;<span class="hljs-keyword">open</span>) &#123;<br>        ret = filp-&gt;f_op-&gt;<span class="hljs-keyword">open</span>(inode,filp);<br>        <span class="hljs-keyword">if</span> (ret)<br>            goto out_cdev_put;<br>    &#125;<br><br>    return <span class="hljs-number">0</span>;<br><br>    out_cdev_put:<br>        cdev<span class="hljs-constructor">_put(<span class="hljs-params">p</span>)</span>;<br>        return ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>（三）与设备号相关功能的代码</p><p>char_device_struct结构描述了字符设备的设备号使用情况，其同样为一个哈希链表数组，以主设备号为主键。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">char_device_struct</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">char_device_struct</span> *next;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> major;             <span class="hljs-comment">// 主设备号</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> baseminor;         <span class="hljs-comment">// 主设备号下的第一个次设备号</span><br>    <span class="hljs-type">int</span> minorct;                    <span class="hljs-comment">// 次设备号个数</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">64</span>];<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">cdev</span> *cdev;        <span class="hljs-comment">/* will die */</span><br>&#125; *chrdevs[CHRDEV_MAJOR_HASH_SIZE];<br>char_device_struct<br></code></pre></td></tr></table></figure><p>设备号注册函数</p><p><a href="evernote:///view/18988257/s16/f38a8271-bd69-43bc-bf4b-2965fe9dfb17/f38a8271-bd69-43bc-bf4b-2965fe9dfb17/">register_chrdev_region( )等设备号分配注册函数</a></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>也许我可以做一个open功能综合</title>
    <link href="/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/1/"/>
    <url>/2023/01/15/%E9%9F%A6%E4%B8%9C%E5%B1%B11.2%E6%9C%9F%E8%A1%94%E6%8E%A5/1/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码不对呀，再试一遍吧" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="7b722929dd8fbe6f8146e52b0aa7afe7e1e91530baba8041457a7d6153b57f14">4630436162ade97ba2718b7d0c4b3b639a53d7dcc288523eac4a5e93b98734ad82384608bcbe94a3e85b2b4c463d6645c6a09ec1d38f35ac91c49f93a5c5f6ed88aeca16ced611146723d2e79e72d611f82fcf4a527fa828db4fec5d3e6ed9feb53a6c8a44d5304826ca50676413f17a7afcfdafcd9ed4b960f6593634b17298a7e93ba3398676ad6006412b555c511e737f310df20cd1def4964e11e05ad4092e9f14e1a0f62d8ab36fff8693ca10e6ce2bc69d3d315816b4e08e3eb9bdfaf6f11d4b6e63d703ff411ac8c5d7789c5de0e4e9d24cfbe37ef9db54872fb2cc0b969283d3abdd1fca8512c62ff1986f3ba471b09b4b9e917a8d2a37b13d6dc9611e802c0d2999ed17280379bd141a35c12cb05e6185d227df797239ef4a2365b9357ffd1c547690e5fe8627f70010c08011dd42573452291fd395743425b7dddfd4a1c4dd3e091317456e2a7229627faa024122a642fb91060266d4bc73db8aa345934de26576d30e00b0421ec57a8a538c2aa273ad4a8af6c63ac2a6f7df0efe6816144582825abc0a8055901226a20f125d02bbf97491408c9fafcddaa9c9b1c6b9b65550c0c78dbd196409bdb01916d2f63f2ab789150e61630d651f3a5e60dba7853814d4fc9b8d9b5e32d7d471fdb1c83bf93ce639309331c47a831470c517996517afba0a1375eb9f373397200b4443f0ae94e25e08c5fad4a12bc71a04f39a2526f839e67acfe006e103ed096adb661376e4533f1869fb2df93b2c7602d26d9f722eee9919b4cd9f171a3b5f22d2fa0b1f5704982e97bd93be369aae9ddb9f0376b441f1196c637791c26080144256d23f833ea5ddf74ec81535cb65e2df98c563946f1498b729ebd06d391c73957893fccb0b1e83d1728c6b5d1d87a96432055db20f0f91a4988544bee370043c497662c122712bdeab206146076edcc27513e5000cc492a83dfd2ac681af3766e8f17305b24b4e0fec37e3fca42e6e139cd40ea0a0c870d184876eaadf3af944661e2d57f3bfd40d2d8b8e7e854ed5d0b455ea257f52aa30f8a91db42b2ee3de5f838ec1c860c3a6a7891127d9ec6d11fbe2e12068d8c728cfa4dece8b95a361a947cc7a24043f4778b397a776bc15cc6f4cf3ab645705daa528414aae67249a7450c6181ab581d4ade4f45e4188f2cc519564501973a57104c0e2a9952583a81c219ea4c6ccc1c99a84d863d35338d86d4a4c953b1488b9adb6fea383126e5e787122f17e846f5f231569abf85d635a68423c04d69cd810e717101bf229d7b99553b4ccf193caf5c40aa5877f5f27ceafaa46235dc66a5fb1a6fc8f506a0471913bed6d809eef2db19a8c55330a79a46951b6702af2dba53c3eced2a08a17436f09cf3e4c0ac4c7bf2ca7bbe5d666896bc5133b23dd77ef5b58ba66b62a6cd11c450909f019de5582e33101facb807c481a76be55a6ffbccece04c603eae15945251ac6c8d51e40d9de3377a90ba5e53d13578fb87407602810fce0dcf75b2a5eb523cbf1ba16022c3649fb8ca07ff53ac931a700872e3b46f335075bd43456208f41189b50bcdebb9598e3da6e860fe606655a4afebc483cc1df8b5ab0c3d2b29ddf29caaee2b0dffafe8b5f233f4542678a88fee14e66e3a7263841d57146313cba254d2742aca54bfaa02e77dea5dd3537c297efe57a993c703c16fefb087e3d4f01703883b4a18cc146d6d40db0135c5d61e2742cd773126cdd7dbfcee9fd660c9cc7ed7e89186abb810a5a219a58f811d3b694f53aaea84d1396008e0a4063212c0826b6fec139faa83315c8b91b08c7c65edcbd00ccc65a1d101b383130a281e0be9b4b5b391672361251983ccb5b2d2ee3d18cc00367f9b5358b6f59bb2b524148a183ab14b2f5cf96867e7666985de4ce3b9279f965450d88f183e360de632dd4264d66b3c77d2b655135262ea42a21f62dc1976a17b01dc0ab0ec47941448d5abc9ed956a79f5ae02f78499e2a9b3a024132a5d79b2536d10ac1ac90356a8df036065c5abc4d94724201f3d5b6b567a4497595a7de39b185a9500cadcc64c627d5d57cfa354e50e8769e1567efa7c3d30e761e45bd05c5b32ec8916741885a1685ff5d7f7328e8f37e5a7c641ceb61b55427e19e5ed30ecc1725c8472f1d5506d2ed1e6a1690aac00d8c1a2d9b522f6d2651247d86c1f3a4b660a00c9f7f67aee227def38ffc4eff8a2a6b43b06d1ff30477a4dc803d7022ff0ec797c170a180a0a7224bebe1618dc087f47a9ee2a9cabfa04a261df56e798327442d1b67824c9a6475f83a9d1fe119ee7c22b5af56cefbea0a244d179c89a1b6c5128bccd30ad11beaaf6892be77ec852117d25f4ed1362ab483a3e4473099d6204d0b264e368ab1275499a2ae4d7a48de0173b8dd2dcfc9eeeb8e2727041489645bce0b4ec62f8ee927b55d86a250e32d609ba3e0d61a5a6a93da66be502d71e8a412ab6176b6b9f4936896fcac5d9bf40e4e0d3f909ddcb3ec0a5e4de09d8f96d0249f8a8c9724681d24120384b4753c6e07aea0ed003c0cc03f0f3701ea1f8fc5b253a326b22f840dc98579fd5bdcc900ec20d7079bb941a090a93f413cce6f46dfffcbf5528f835262a25b2f441c1c57fdf819608837fd8c6415125030cc4bc3299d4887edb8d80b968eb7df8a2d080a2bc373a8acb86e26685236259f693a303281233729af27325b0510211a78c2b4c4e99f3e230131c8266c02518a6d7607eca0b254625c33dd8390d952af6226722cbbe0aeedf0ea0b4808fdd156a8c65c1b09f1ad2f8a56529d9003a1f63dcbebc78d3394805abb6fc3ff8a01eac9ea315bafebc5d5d550b279e110767946e57a6128a075b91e71d616206ace4b817fbb91e3a02d127275e12d25dc91a7a8e679d499ca4c4410e21adcacf2836db2c76cd6d38673534e0b73b683951d7e77cc4462a6149db7fe6df763814707bacf92370b227dfee588caa3ed27ed951166864fb9e3639fcbb4c1ff2004b269537b6b547eed72d88ff5238b8e8e2ea0d247</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-blink">      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="嗨哥们，这东西还在加工，如果你想访问，请输入密匙。">嗨哥们，这东西还在加工，如果你想访问，请输入密匙。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>伪代码</title>
    <link href="/2023/01/15/%E4%BC%AA%E4%BB%A3%E7%A0%81/%E4%BC%AA%E4%BB%A3%E7%A0%81/"/>
    <url>/2023/01/15/%E4%BC%AA%E4%BB%A3%E7%A0%81/%E4%BC%AA%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>语法规则</p><ol><li>在算法中的某些指令或子任务可以用文字来叙述，比如”将x插入L中”，这里L是一个链表。这样做的目的是为了避免因那些与主要问题无关的细节使算法本身杂乱无章。</li><li>赋值语句</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">    <span class="hljs-selector-tag">a</span>&lt;-<span class="hljs-selector-tag">b</span>；    //<span class="hljs-selector-tag">b</span>的值赋给<span class="hljs-selector-tag">a</span><br></code></pre></td></tr></table></figure><ol><li>goto语句</li></ol><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">    <span class="hljs-keyword">goto</span> <span class="hljs-keyword">label</span>（<span class="hljs-keyword">goto</span>标号）<br></code></pre></td></tr></table></figure><ol><li>分支结构</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">    <span class="hljs-keyword">if</span> i=<span class="hljs-number">10</span><br>        then xxxx<br>        <span class="hljs-keyword">else</span> xxxx                 <span class="hljs-regexp">//</span><span class="hljs-keyword">else</span> 和 then 要对齐<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">    <span class="hljs-keyword">if</span> i=<span class="hljs-number">10</span><br>        then xxxx                   <span class="hljs-regexp">//i</span>f 后面必定跟上then，<span class="hljs-keyword">else</span>后面不用跟then<br>        elseif i=<span class="hljs-number">9</span>                  <span class="hljs-regexp">//</span>elseif 要连在一起写<br>            then xxxx<br>            yyyy<br>        <span class="hljs-keyword">else</span>  xxxx             <span class="hljs-regexp">//</span><span class="hljs-keyword">else</span> 跟在elseif 的 then 对齐<br></code></pre></td></tr></table></figure><ol><li>循环结构</li></ol><p>while：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">    <span class="hljs-keyword">while</span> time&lt;<span class="hljs-number">10</span><br>        <span class="hljs-keyword">do</span>  xxxxx                  <span class="hljs-regexp">//</span><span class="hljs-keyword">while</span>后面必定要紧跟缩进的<span class="hljs-keyword">do</span><br>        xxxxx<br>        end<br></code></pre></td></tr></table></figure><p>for</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lasso">    for <span class="hljs-built_in">var</span> init <span class="hljs-keyword">to</span> limit <span class="hljs-keyword">by</span> incr <span class="hljs-keyword">do</span><br>        s<br>    end<br><br>    for i←<span class="hljs-number">0</span> <span class="hljs-keyword">to</span> <span class="hljs-number">10</span> <span class="hljs-comment">//for、while、if 后面的条件语句都不用加括号 </span><br>        <span class="hljs-keyword">do</span> <span class="hljs-params">...</span> <span class="hljs-comment">//for后面必定要紧跟缩进的do </span><br>        <span class="hljs-params">...</span><br></code></pre></td></tr></table></figure><p>这里var是变量，init、limit和incr都是算术表达式，而s是由一个或多个语句组成的语句串。初始时，var被赋予init的值。</p><p>假若incr≥0，则只要var≤limit，就执行s并且将incr加到var上。（假若incr&lt;0，则只要var≥limit，就执行s并且将incr加到var上）。incr的符号不能由s来该改变。</p><ol><li>程序的结束</li></ol><p>exit语句：用于通常的结束条件满足之前，提前结束循环。程序转向到紧接在包含exit的(最内层)循环后面一个语句继续执行。</p><p>return语句：用于指出一个算法执行的终点</p><ol><li>函数的编写</li></ol><p>函数的伪代码格式例子为：search（A，name） &#x2F;&#x2F;参数类型可以不给出，但必须在注释中说明</p>]]></content>
    
    
    <categories>
      
      <category>伪代码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>伪代码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UART（Universal Asynchronous Receiver/Transmitter）</title>
    <link href="/2023/01/15/%E9%80%9A%E4%BF%A1/UART%EF%BC%88Universal_Asynchronous_Receiver-Transmitter%EF%BC%89/"/>
    <url>/2023/01/15/%E9%80%9A%E4%BF%A1/UART%EF%BC%88Universal_Asynchronous_Receiver-Transmitter%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>一、简介</p><p>UART通用异步收发传输器，是一种通用的串行、异步、全双工总线。作为把并行信号转成串行信号的硬件设备，在嵌入式领域UART通常被集成于MCU内部，用于主机与辅助设备通信。</p><p>二、UART与USART</p><p>UART：universal asynchronous receiver and transmitter  通用异步收&#x2F;发器，即串行异步全双工收发器。</p><p>USART: universal <strong>synchronous</strong> asynchronous receiver and transmitter 通用同步&#x2F;异步收&#x2F;发器，即串行异步&#x2F;同步全双工收发器。</p><p>    USART的异步功能与UART完全相同，但USART在UART基础上增加了同步功能。在同步通信中需要时钟来出发传输，E而USART能提供主动时钟</p><p>    UART管脚定义：TX、RX、GND； USART管脚定义：TX、RX、GND、SCLK。</p><p>三、物理层</p><p>硬件连接：通常有三根线，分别为TXD，RXD（发送端），GND（接收端）。</p><p>四、协议层</p><p>一般在发送之前，收发双方都要先约定好一定的规则：传输数据的速率（每位所占据的时间，其倒数就是波特率）；数据格式（每帧包含多少位数据，包含开始位、数据位（5<del>8 bit）、校验位（可有可无）和停止位（1</del>2 bit））。</p><p>（1）波特率：数据传输速率，每秒传输的二进制位数，常用的有9600，115200等。</p><p>（2）起始位：先发出一个逻辑”0”的信号，表示传输数据的开始。</p><p>（3）数据位：5~8位逻辑”0”或”1”。一般设置为常用的8位，如ACSII码8位。</p><p>（4）校验位：数据位后加上这一位，使得”1”的位数应为偶数（偶校验）或奇数（奇校验），用来校验数据传送的正确性。如传输A（01000001）</p><p>①奇数校验：A中有两个1位，为偶数，所以奇偶校验位应为1才可构成奇数满足奇数校验。</p><p>②偶数校验：A中有两个1位，为偶数，所以奇偶校验位直接为1就满足偶数校验。</p><p>③奇偶校验位也可以去除。</p><p>（5）停止位：它是一帧数据的结束标志。可以为1位，1.5位，2位的高电平。</p><p>（6）空闲位：没有数据传输时线路上的电平状态。为逻辑1</p><p><img src="/image/0b55b319ebc4b745ba4ba63284198b118b821526.jpg" alt="0b55b319ebc4b745ba4ba63284198b118b821526.jpg"></p><p>五、数据传输流程</p><p>（1）UART的TXD通常情况处于高电平的状态</p><p>（2）UART准备传输数据的时候，TXD从高电平转变为低电平（即从1变0）并维持一位的传输时间。这样接收方在检测到TXD传输的电平有高电平变为低电平的时候准备开始接收数据。</p><p>（3）UART一帧有5，6，7，8位的数据，TXD由高电平转变为低电平并保持一位的时候开始传输数据。传输数据是一位一位的进行高低电平传输。首先发送的是低位。</p><p>（4）UART如果使用校验位时，在发送数据结束时候会紧跟着一位校验位。有两种校验方法：奇校验和偶校验</p><p>（5）最后发送停止位，TXD数据线恢复到正常状态，停止位的长度有三种。1位，1.5位，2位</p>]]></content>
    
    
    <categories>
      
      <category>通信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>通信协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SPI（Serial Peripheral interface）通信总线</title>
    <link href="/2023/01/15/%E9%80%9A%E4%BF%A1/SPI%EF%BC%88Serial_Peripheral_interface%EF%BC%89%E9%80%9A%E4%BF%A1%E6%80%BB%E7%BA%BF/"/>
    <url>/2023/01/15/%E9%80%9A%E4%BF%A1/SPI%EF%BC%88Serial_Peripheral_interface%EF%BC%89%E9%80%9A%E4%BF%A1%E6%80%BB%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<p>一、简介</p><p>SPI，串行外围设备接口,是一种高速、全双工、同步的通信总线。主要应用在EEPROM，FLASH，实时时钟，AD转换，还有数字信号处理器和数字信号解码器之间。</p><p>二、特点</p><p>2.1 控制方式</p><p>（1）SPI规定两个SPI设备之间通信必须由主设备来控制次设备</p><p>（2）一个Master可以通过提供Clock和对Slave进行片选控制多个Slave</p><p>（3）Slave的Clock必须由Master通过SCK提供给Slave，Slave本身不能产生或控制Clock，没有Clock则Slave设备不能正常工作</p><p>2.2 传输方式</p><p>同步方式传输。</p><p>Master 设备会根据将要交换的数据来产生相应的时钟脉冲(Clock Pulse),时钟脉冲组成了时钟信号(Clock Signal) ,时钟信号通过时钟极性(CPOL)和时钟相位(CPHA)控制着两个SPI设备间何时数据交换以及何时对接收到的数据进行采样,来保证数据在两个设备之间是同步传输的。</p><p>2.3 数据交换</p><p><img src="/image/03523fda32d30b8c468c8e595feaab58.jfif" alt="03523fda32d30b8c468c8e595feaab58.jfif"></p><p>2.3.1 接口</p><p>（1）SCLK：串行时钟，用来同步数据传输，由主机输出；</p><p>（2）MOSI（SDO）：主机输出从机输入数据线；</p><p>（3）MISO（SDI）：主机输入从机输出数据线；</p><p>（4）SS：片选线，低电平有效，由主机输出</p><p>2.3.2 寄存器</p><p><img src="/image/371a89bd63671adf39c93e572a2b5c55.png" alt="371a89bd63671adf39c93e572a2b5c55.png"></p><p>在SPI设备中都具有</p><ul><li>SSPBUF：SPI设备里的内部缓冲区，保存传输中的临时数据，物理上以FIFO的形式</li><li>SSPSR：SPI设备里的移位寄存器。</li><li>Controller：SPI 设备里面的控制寄存器, 可以通过配置它们来设置 SPI 总线的传输模式</li></ul><p>2.3.3 交换方式</p><p>（1）SPI规定一个SPI设备不能在数据通信中只发送或只接收，每个Clock周期内，SPI设备都会发送并接收1bit的数据（串行），所以称为“数据交换”而不是“数据传输”</p><p>（2）在一个SPI时钟周期内，会完成如下操作：</p><p>①主机通过MOSI线发送1位数据，从机通过该线读取这1位数据；</p><p>②从机通过MISO线发送1位数据，主机通过该线读取这1位数据。</p><p>主从机的移位寄存器连成一个环，随着时钟脉冲，数据按照从高位到低位的方式一次移出主机寄存器和从机寄存器，然后依次移入从机寄存器和主机寄存器。</p><p>三、工作机制</p><p>3.1 时钟极性和时钟相位</p><p>3.1.1 时钟极性：CPOL（Clock Polarity）</p><p>时钟空闲时即时钟在发送8个bit数据之前和之后的状态。时钟极性设置时钟空闲时的电平。</p><p>数据传输往往从跳变沿开始，即开始传输数据时必是下降沿或上升沿。</p><ul><li>CPOL &#x3D; 1：无数据传输时为高电平，空闲状态后第一个跳变沿为下降沿</li><li>CPOL &#x3D; 0：无数据传输时为低电平，空闲状态后第一个跳变沿为上升沿</li></ul><p>3.1.2 时钟相位：CPHA（Clock Phase）</p><p>一个时钟周期有两个跳变沿，CPHA决定数据采样在哪个边沿。</p><ul><li>CPHA &#x3D; 0：表示从第一个跳变沿（上升沿）开始采样</li><li>CPHA &#x3D; 1：表示从第二个跳变沿（下降沿）开始采样</li></ul><p>3.1.3 4种模式</p><p>（1）模式0：CPOL&#x3D;0; CPHA&#x3D;0</p><p>CPOL &#x3D; 0：空闲时是低电平，第1个跳变沿是上升沿，第2个跳变沿是下降沿 CPHA &#x3D; 0：数据在第1个跳变沿（上升沿）采样</p><p><img src="/image/579c9b550fe122161d8d197ec2e6e04b.png" alt="579c9b550fe122161d8d197ec2e6e04b.png"></p><p>（2）模式1：CPOL&#x3D;0; CPHA&#x3D;1</p><p>CPOL &#x3D; 0：空闲时是低电平，第1个跳变沿是上升沿，第2个跳变沿是下降沿</p><p>CPHA &#x3D; 1：数据在第2个跳变沿（下降沿）采样</p><p><img src="/image/988790-20200311120250511-621966252.png" alt="988790-20200311120250511-621966252.png"></p><p>（3）模式2：CPOL&#x3D;1; CPHA&#x3D;0</p><p>CPOL &#x3D; 1：空闲时是高电平，第1个跳变沿是下降沿，第2个跳变沿是上升沿</p><p>CPHA &#x3D; 0：数据在第1个跳变沿（下降沿）采样</p><p><img src="/image/988790-20200311121435779-1051725621.png" alt="988790-20200311121435779-1051725621.png"></p><p>（4）模式3：CPOL&#x3D;1; CPHA&#x3D;1</p><p>CPOL &#x3D; 1：空闲时是高电平，第1个跳变沿是下降沿，第2个跳变沿是上升沿</p><p>CPHA &#x3D; 1：数据在第2个跳变沿（上升沿）采样</p><p><img src="/image/988790-20200311121424628-840109130.png" alt="988790-20200311121424628-840109130.png"></p><p>四、优缺点</p><p>4.1 优点</p><p>全双工、操作简单、数据传输速率高</p><p>普通的串行通讯一次连续传送至少8位数据，SPI允许数据一位一位的传送，甚至允许暂停（根据时钟信号）</p><p>4.2 缺点</p><p>需要占用主机较多口线（一个从机一条片选线）</p><p>只支持单个主机</p><p>没有指定的流控制，没有应答机制确认是否收到数据</p>]]></content>
    
    
    <categories>
      
      <category>通信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>通信协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RS232、RS485通信网络/协议</title>
    <link href="/2023/01/15/%E9%80%9A%E4%BF%A1/RS232%E3%80%81RS485%E9%80%9A%E4%BF%A1%E7%BD%91%E7%BB%9C-%E5%8D%8F%E8%AE%AE/"/>
    <url>/2023/01/15/%E9%80%9A%E4%BF%A1/RS232%E3%80%81RS485%E9%80%9A%E4%BF%A1%E7%BD%91%E7%BB%9C-%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p>RS232&#x2F;RS485，是两种不同的电气协议，也就是说，是对电气特性以及物理特性的规定，作用于数据的传输通路上，它并不内含对数据的处理方式。</p><p>RS232、TTL属于逻辑电平信号；RS485、CAN属于差分电平信号（差分电平就是利用两个信号的差值来判断信息）</p><p>一、RS-232</p><p>1.1 简介</p><p>RS-232标准接口是常用的串行通信接口标准之一，由电子工业协会所制定。</p><p>在串行通讯时，要求通讯双方都采用一个标准接口，使不同的设备方便的连接起来进行通讯，实现点对点的通信。</p><p>RS-232是目前最常见的一种串行通讯接口，如RS232的9针接口：DB9</p><p><img src="/image/2755780-1G206152RJ34.jpg" alt="2755780-1G206152RJ34.jpg"></p><p>1.2 特点</p><p>（1）信号线少：采用三条信号线（RXD、TXD、GND）能简单的实现全双工通信。</p><p>（2）灵活的波特率，可以灵活适应不同速率的设备</p><p>（3）负逻辑传送，提高抗干扰能力。规定逻辑“1”的电平为-5V~-15 V，逻辑“0”的电平为+5 V～+15 V。</p><p>（4）传送距离远。</p><p>1.3 缺点</p><p>（1）接口的信号电平值较高，易损坏接口电路的芯片，又因为与TTL电平不兼容故需使用电平转换电路方能与TTL电路连接。</p><p>（2）传输速率低。最高只支持19200b&#x2F;s</p><p>（3）容易产生共模干扰。</p><p>（4）传输距离有限。</p><p>1.4 连接方式</p><p>控制器一般都内置了UART，它同外界通讯的电平信号是TTL电平信号。在不同设备之间通讯，通常还需要将TTL电平信号转换为对应的RS232或者RS485信号（RS232和RS485相对于TTL，在传输过程中，对于外界的抗干扰能力更强）。</p><p><img src="/image/a044ad345982b2b70636b5c37a485ee977099b7c.jpg" alt="a044ad345982b2b70636b5c37a485ee977099b7c.jpg"></p><p>二、RS-485</p><p>2.1 简介</p><p>RS-485是一种在工业上广泛使用的串行通信方式，数据信号采用差分传输方式，具有较强的抗干扰能力，也不需要相对于某个参照点来检测信号。它采用一对双绞线，将其中一线定义为A，另一线定义为B。</p><p>RS-485接口组成的半双工网络，一般是两线制。在RS485通信网络中一般采用的是主从通信方式，即一个主机带多个从机</p><p>2.2 特点</p><p>（1）RS-485的电气特性：逻辑“1”以两线间的电压差为+（2—6）V表示；逻辑“0”以两线间的电压差为-（2—6）V表示。接口电平比RS-232降低了，就不易损坏接口电路的芯片，且该电平与TTL电平兼容，可方便与TTL电路连接。</p><p>（2）RS-485的数据传输速率为10Mbps。</p><p>（3）抗噪声干扰好。</p><p>（4）传输距离长。</p><p>2.3 连接方式</p><p>相比较RS-232，RS-485增加了多点通信能力，允许多个发送器连接到同一条总线上。</p><p>在RS485通信网络中，使用485收发器来转换TTL电平和RS485电平。节点中的串口控制器（UART）使用RX与TX信号连接到485收发器（TTL信号传输），收发器通过差分线连接到网络总线（RS485信号传输）。</p><p>%!(EXTRA markdown.ResourceType&#x3D;, string&#x3D;, string&#x3D;)</p><p>三、TTL</p><p>指TTL电平规定</p><ul><li>逻辑信号’1’：VCC &#x3D; 3.3V或5V</li><li>逻辑信号’0’：VCC &#x3D; 0V</li></ul>]]></content>
    
    
    <categories>
      
      <category>通信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>通信协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IIC（Inter-Integrated Circuit BUS）通信总线</title>
    <link href="/2023/01/15/%E9%80%9A%E4%BF%A1/IIC%EF%BC%88Inter-Integrated_Circuit_BUS%EF%BC%89%E9%80%9A%E4%BF%A1%E6%80%BB%E7%BA%BF/"/>
    <url>/2023/01/15/%E9%80%9A%E4%BF%A1/IIC%EF%BC%88Inter-Integrated_Circuit_BUS%EF%BC%89%E9%80%9A%E4%BF%A1%E6%80%BB%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<p>一、简介</p><p>集成电路总线。用于IC之间（主控制器与从器件）通信的总线（总线即各个器件都并联接到一组公共的线路上，然后公用这条线路传输数据信息）。属于串行半双工通信。</p><p>二、软件IIC和硬件IIC</p><p>（1）软件IIC：指用单片机的两个I&#x2F;O端口模拟出来的IIC，用软件控制管脚状态以模拟I2C通信波形，软件模拟寄存器的工作方式。</p><p>（2）硬件IIC：一块硬件电路，硬件I2C对应芯片上的I2C外设，有相应I2C驱动电路，其所使用的I2C管脚也是专用的，硬件（固件）I2C是直接调用内部寄存器进行配置。</p><p>（3）硬件I2C的效率要远高于软件的，而软件I2C由于不受管脚限制，接口比较灵活。</p><p>三、物理层</p><p>（1）IIC是两线式串行总线，由数据线SDA和时钟线SCL构成。（IIC是半双工，而不是全双工）</p><p>（2）多主机总线。总线上的每一个设备都可以作为主设备或从设备，如果两个或更多的主机同时请求总线，可以通过冲突检测和仲裁防止总线数据被破坏。</p><p>（3）每一个设备都会对应一个唯一的地址（该地址是记录在芯片手册上的）。主机&#x2F;从机角色和地址可配置，主机可以作为主机发送器和主机接收器。</p><p>（4）I2C总线数据传输速率有多个不同速度的模式，通过可编程时钟来实现传输速率的调整，同时也跟所接的上拉电阻的阻值有关。（在标准模式下可达100kbit&#x2F;s，快速模式下可达400kbit&#x2F;s，高速模式下可达3.4Mbit&#x2F;s。）</p><p>（5）连接到总线的IC数量只是受到总线的最大负载电容400pf限制，如果所挂接的是相同型号的器件，则还受器件地址位的限制。</p><p>四、协议层<img src="/image/d13bd8b1b848100b81956fdb536a58bd.png" alt="d13bd8b1b848100b81956fdb536a58bd.png"></p><p>4.1 数据的有效性</p><p>在时钟的高电平周期内，SDA线上的数据必须保持稳定，数据线仅可以在时钟SCL为低电平时改变。</p><p>4.2 起始和结束条件</p><p>总线在空闲状态时，SCL和SDA都保持着高电平：</p><p>（1）起始条件：当SCL为高电平的时候，SDA线上由高到低的跳变被定义为起始条件</p><p>（2）结束条件：当SCL为高电平的时候，SDA线上由低到高的跳变被定义为停止条件</p><p>（3）起始和终止信号都是由主机发出的，连接到I2C总线上的器件，若具有I2C总线的硬件接口，则很容易检测到起始和终止信号。</p><p>（4）总线在起始条件之后，视为忙状态，在停止条件之后被视为空闲状态。</p><p>4.3 应答</p><p>每当主机向从机发送完一个字节的数据，主机总是需要等待从机给出一个应答信号，以确认从机是否成功接收到了数据，从机应答主机所需要的时钟仍是主机提供的，应答出现在每一次主机完成8个数据位传输后紧跟着的时钟周期，低电平0表示应答，1表示非应答</p><p>4.4 数据帧格式</p><p>包含：起始信号start→从机地址（7位）→数据的传送方向位（“0”表示主机发送数据（T），“1”表示主机接收数据（R））→应答信号之后开始发送数据，发送数据一字节主机就会收到一个应答信号，最终由主机产生的终止信号结束。但主机也可以继续占用总线，从而不发送终止信号，马上再发送起始信号对另一从机进行寻址。</p><p><img src="/image/ac856d54c0b6c91f472f496b401b066a.png" alt="ac856d54c0b6c91f472f496b401b066a.png"></p><p>（1）写操作（主机向从机发送数据，数据传送方向在整个传送过程中不变）：</p><p>刚开始主芯片要发出一个start信号，然后发出一个设备地址(用来确定是往哪一个芯片写数据)，方向(读&#x2F;写，0表示写，1表示读)。</p><p>回应(用来确定这个设备是否存在)，然后就可以传输数据，传输数据之后，要有一个回应信号（确定数据是否接受完成)，然后再传输下一个数据。</p><p>每传输一个数据，接受方都会有一个回应信号，数据发送完之后，主芯片就会发送一个停止信号。</p><p>白色背景：主→从</p><p>灰色背景：从→主</p><p><img src="/image/700px-Chapter19_lesson1_003.jpg" alt="700px-Chapter19_lesson1_003.jpg"></p><p>（2）读操作（主机在第一个字节后，立即从从机读数据）：</p><p>刚开始主芯片要发出一个start信号，然后发出一个设备地址(用来确定是从哪一个芯片读取数据)，方向(读&#x2F;写，0表示写，1表示读)。</p><p>回应(用来确定这个设备是否存在)，然后就可以传输数据，传输数据之后，要有一个回应信号（确定数据是否接受完成)，然后在传输下一个数据。</p><p>每传输一个数据，接受方都会有一个回应信号，数据发送完之后，主芯片就会发送一个停止信号。</p><p>白色背景：主→从</p><p>灰色背景：从→主</p><p><img src="/image/700px-Chapter19_lesson1_004.jpg" alt="700px-Chapter19_lesson1_004.jpg"></p><p>（3）在传送过程中，当需要改变传送方向时，起始信号和从机地址都被重复产生一次，但两次读&#x2F;写方向位正好反相。</p><p>三、<strong>硬件连接</strong></p><p>IIC是两线式串行总线，由数据线SDA和时钟线SCL构成</p><p>%!(EXTRA markdown.ResourceType&#x3D;, string&#x3D;, string&#x3D;)</p><p>I2C接口为漏极开路，所以也需要上拉电阻让其空闲时为高</p>]]></content>
    
    
    <categories>
      
      <category>通信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>通信协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CAN（Controller Area Network）控制器局域网络</title>
    <link href="/2023/01/15/%E9%80%9A%E4%BF%A1/CAN%EF%BC%88Controller_Area_Network%EF%BC%89%E6%8E%A7%E5%88%B6%E5%99%A8%E5%B1%80%E5%9F%9F%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/01/15/%E9%80%9A%E4%BF%A1/CAN%EF%BC%88Controller_Area_Network%EF%BC%89%E6%8E%A7%E5%88%B6%E5%99%A8%E5%B1%80%E5%9F%9F%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>通信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>未重构</tag>
      
      <tag>通信协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二级指针用法：利用二级指针作为形参改变实参指针指向地址里的值</title>
    <link href="/2023/01/15/%E5%A5%BD%E4%BB%A3%E7%A0%81/%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E7%94%A8%E6%B3%95%EF%BC%9A%E5%88%A9%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E5%BD%A2%E5%8F%82%E6%94%B9%E5%8F%98%E5%AE%9E%E5%8F%82%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E5%9C%B0%E5%9D%80%E9%87%8C%E7%9A%84%E5%80%BC/"/>
    <url>/2023/01/15/%E5%A5%BD%E4%BB%A3%E7%A0%81/%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E7%94%A8%E6%B3%95%EF%BC%9A%E5%88%A9%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E5%BD%A2%E5%8F%82%E6%94%B9%E5%8F%98%E5%AE%9E%E5%8F%82%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E5%9C%B0%E5%9D%80%E9%87%8C%E7%9A%84%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>利用二级指针作为形参改变实参指针指向地址里的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find2</span><span class="hljs-params">(<span class="hljs-type">char</span> [] array, <span class="hljs-type">char</span> search, <span class="hljs-type">char</span> ** ppa)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; *(array+i)!=<span class="hljs-number">0</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (*(array+i)==search)<br>        &#123;<br>            *ppa=array+i<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*(array+i)==<span class="hljs-number">0</span>)<br>        &#123;<br>            *ppa=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> str[]=&#123;“afsdfsdfdf\<span class="hljs-number">0</span>”&#125;;　 <span class="hljs-comment">//待 查找的字符串</span><br>    <span class="hljs-type">char</span> a=’d’;　　 <span class="hljs-comment">//设置要查找的字符</span><br>    <span class="hljs-type">char</span> * p=<span class="hljs-number">0</span>;　 <span class="hljs-comment">//如果查找到后指针p将指向字符串中查找到的第一个字符的地址。</span><br><br>    <span class="hljs-built_in">find1</span>(str,a,&amp;p);　 <span class="hljs-comment">//调用函数以实现所要操作。</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span>==p )<br>    &#123;<br>        <span class="hljs-built_in">printf</span> (“没找到！\n”);<span class="hljs-comment">//1.如果没找到则 输出此句</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(“找到了，p=%d”,p);　 <span class="hljs-comment">//如果找到则 输出此句</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Segmentation fault (core dumped)</title>
    <link href="/2023/01/15/%E7%A8%8B%E5%BA%8F%E9%94%99%E8%AF%AF/Segmentation_fault_(core_dumped)/"/>
    <url>/2023/01/15/%E7%A8%8B%E5%BA%8F%E9%94%99%E8%AF%AF/Segmentation_fault_(core_dumped)/</url>
    
    <content type="html"><![CDATA[<p><strong>错误类型：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Segmentation <span class="hljs-title function_">fault</span> <span class="hljs-params">(core dumped)</span><br></code></pre></td></tr></table></figure><p><strong>产生原因：</strong></p><p>1.你对指针进行直接操作之前，没有对它进行分配地址空间。</p><p>所以在运行的时候，它不知道在那里操作（比如赋值，取值），所以才报了这个错误。</p><p>在C语言中，定义一个指针变量时，系统不会像在定义基本数据类型一样自动为指针分配地址空间的，所以我们在定义指针变量时要手动为它分配一个地址空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d;b = %d\n&quot;</span>, a,b);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;please press:\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a,&amp;b);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d\n&quot;</span>, a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b = %d\n&quot;</span>, b);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.修改了只读存储区的变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> g_cc = <span class="hljs-number">2</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-type">int</span>* q = (<span class="hljs-type">int</span>*)&amp;g_cc;<br><br>    *q = <span class="hljs-number">3</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, g_cc);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
      <tag>程序错误</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>printf计算顺序</title>
    <link href="/2023/01/15/%E7%A8%8B%E5%BA%8F%E9%94%99%E8%AF%AF/printf%E8%AE%A1%E7%AE%97%E9%A1%BA%E5%BA%8F/"/>
    <url>/2023/01/15/%E7%A8%8B%E5%BA%8F%E9%94%99%E8%AF%AF/printf%E8%AE%A1%E7%AE%97%E9%A1%BA%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>现象：</strong></p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coq">int Pop(SeqStack *S)<br>&#123;<br>    <span class="hljs-keyword">if</span>(StackEmpty(S) == <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> S-&gt;data[S-&gt;<span class="hljs-built_in">top</span>--];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, Pop(S));<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, S-&gt;data[S-&gt;top]);<br></code></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ruby">book<span class="hljs-variable">@www</span>.100ask.<span class="hljs-symbol">org:</span>~<span class="hljs-regexp">/Works/software</span><span class="hljs-regexp">/DataStructure/</span>003_SeqStack<span class="hljs-variable">$ </span>./SeqStack<br>Please enter the elements to be placed <span class="hljs-keyword">in</span> the <span class="hljs-symbol">stack:</span><br>asdfg<br>This is the function currently <span class="hljs-symbol">implemented:</span><br><span class="hljs-number">1</span><span class="hljs-symbol">:StackEmpty</span><br><span class="hljs-number">2</span><span class="hljs-symbol">:StackFull</span><br><span class="hljs-number">3</span><span class="hljs-symbol">:Push</span><br><span class="hljs-number">4</span><span class="hljs-symbol">:Pop</span><br><span class="hljs-number">5</span><span class="hljs-symbol">:StackTop</span><br><span class="hljs-number">6</span><span class="hljs-symbol">:Break</span><br>Please select the function you want to <span class="hljs-symbol">implement:</span><span class="hljs-number">4</span><br>g<br>f<br></code></pre></td></tr></table></figure><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">printf(<span class="hljs-string">&quot;%c,%c\n&quot;</span>, Pop(S),S-&gt;data[S-&gt;<span class="hljs-built_in">top</span>]);<br></code></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ruby">book<span class="hljs-variable">@www</span>.100ask.<span class="hljs-symbol">org:</span>~<span class="hljs-regexp">/Works/software</span><span class="hljs-regexp">/DataStructure/</span>003_SeqStack<span class="hljs-variable">$ </span>./SeqStack<br>Please enter the elements to be placed <span class="hljs-keyword">in</span> the <span class="hljs-symbol">stack:</span><br>asdfg<br>This is the function currently <span class="hljs-symbol">implemented:</span><br><span class="hljs-number">1</span><span class="hljs-symbol">:StackEmpty</span><br><span class="hljs-number">2</span><span class="hljs-symbol">:StackFull</span><br><span class="hljs-number">3</span><span class="hljs-symbol">:Push</span><br><span class="hljs-number">4</span><span class="hljs-symbol">:Pop</span><br><span class="hljs-number">5</span><span class="hljs-symbol">:StackTop</span><br><span class="hljs-number">6</span><span class="hljs-symbol">:Break</span><br>Please select the function you want to <span class="hljs-symbol">implement:</span><span class="hljs-number">4</span><br>g,g<br></code></pre></td></tr></table></figure><p><strong>错误原因：</strong></p><p>C语言的编译器以压栈式存储的，所以输出时是从栈顶往栈底读取数据的，但我们看到在用printf输出时,是从右往左进行的，而且每一项可以运算，但各项的运算结果互不影响，但对变量本身来说是每次计算都会改变它的值的。</p><p>即printf中先计算S-&gt;data[S-&gt;top]，再算Pop(S)</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
      <tag>程序错误</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LinkList CreatList()</title>
    <link href="/2023/01/15/%E7%A8%8B%E5%BA%8F%E9%94%99%E8%AF%AF/LinkList_CreatList()/"/>
    <url>/2023/01/15/%E7%A8%8B%E5%BA%8F%E9%94%99%E8%AF%AF/LinkList_CreatList()/</url>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">LinkList <span class="hljs-title">CreatList</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> ch;<br>    LinkList head;<br>    ListNode *s,*r;<br>    head = (ListNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(ListNode));<br><br>    r = head;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please enter the list you want to create:\n&quot;</span>);<br>    <span class="hljs-keyword">while</span>((ch = <span class="hljs-built_in">getchar</span>()) != <span class="hljs-string">&#x27;\n&#x27;</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;aaaaaaaaaaaaaaaaa&quot;</span>);<br>        s = (ListNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(ListNode));<br>        s-&gt;data = ch;<br>        r-&gt;next = s;<br>        r = s;<br>    &#125;<br>    r-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>现象：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    LinkList head;<br>    head = <span class="hljs-built_in">CreatList</span>();<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;c);<br>    <span class="hljs-keyword">switch</span>(c)<br>    &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-built_in">PrintList</span>(head);<span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext">book@www.100ask.org:~/Works/software/DataStructure/002_LinkList$ ./LinkList<br><span class="hljs-attribute">Please enter the list you want to create</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">1</span><br><span class="hljs-attribute">Please enter the function you want to select</span><br><span class="hljs-attribute">1</span><span class="hljs-punctuation">:</span> <span class="hljs-string">CreatList</span><br><span class="hljs-attribute">2</span><span class="hljs-punctuation">:</span> <span class="hljs-string">GetLengh</span><br><span class="hljs-attribute">3</span><span class="hljs-punctuation">:</span> <span class="hljs-string">GetNode</span><br><span class="hljs-attribute">4</span><span class="hljs-punctuation">:</span> <span class="hljs-string">InsertList</span><br><span class="hljs-attribute">5</span><span class="hljs-punctuation">:</span> <span class="hljs-string">DeleteList</span><br><span class="hljs-attribute">6</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Break</span><br><span class="hljs-attribute">1</span><br><span class="hljs-attribute">This is your list</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1   </span><br></code></pre></td></tr></table></figure><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    LinkList head;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;c);<br>    <span class="hljs-keyword">switch</span>(c)<br>    &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: head = <span class="hljs-built_in">CreatList</span>();<br>                <span class="hljs-built_in">PrintList</span>(head);<span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext">book@www.100ask.org:~/Works/software/DataStructure/002_LinkList$ ./LinkList<br><span class="hljs-attribute">Please enter the function you want to select</span><br><span class="hljs-attribute">1</span><span class="hljs-punctuation">:</span> <span class="hljs-string">CreatList</span><br><span class="hljs-attribute">2</span><span class="hljs-punctuation">:</span> <span class="hljs-string">GetLengh</span><br><span class="hljs-attribute">3</span><span class="hljs-punctuation">:</span> <span class="hljs-string">GetNode</span><br><span class="hljs-attribute">4</span><span class="hljs-punctuation">:</span> <span class="hljs-string">InsertList</span><br><span class="hljs-attribute">5</span><span class="hljs-punctuation">:</span> <span class="hljs-string">DeleteList</span><br><span class="hljs-attribute">6</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Break</span><br><span class="hljs-attribute">1</span><br><span class="hljs-attribute">Please enter the list you want to create</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">This is your list</span><span class="hljs-punctuation">:</span><br></code></pre></td></tr></table></figure><p>CreatList函数放在switch的case1里发现不能停下进行输入，而放在switch上面就可以进行输入</p><p><strong>错误原因：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">LinkList <span class="hljs-title">CreatList</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> ch;<br>    LinkList head;<br>    ListNode *s,*r;<br>    head = (ListNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(ListNode));<br>    r = head;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please enter the list you want to create:\n&quot;</span>);<br>    <span class="hljs-built_in">getchar</span>();        <br>    ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch != <span class="hljs-string">&#x27;\n&#x27;</span>)<br>    &#123;<br>        s = (ListNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(ListNode));<br>        s-&gt;data = ch;<br>        r-&gt;next = s;<br>        r = s;<br>        ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    r-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    LinkList head;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;c);<br>    <span class="hljs-keyword">switch</span>(c)<br>    &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: head = <span class="hljs-built_in">CreatList</span>();<br>                <span class="hljs-built_in">PrintList</span>(head);<span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>正确输出</p><p>在输入i时，输入的是</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">i</span>+回车<br></code></pre></td></tr></table></figure><p>而i直接用于switch判断，而回车就到了创建链表的getchar()里，造成直接跳出循环，无法停下输入</p><p>所以加上getchar(),是为了捕获输入的回车，不它进入到ch &#x3D; getchar()里</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
      <tag>程序错误</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0x%08X和%p</title>
    <link href="/2023/01/15/%E7%A8%8B%E5%BA%8F%E9%94%99%E8%AF%AF/0x%2508X%E5%92%8C%25p/"/>
    <url>/2023/01/15/%E7%A8%8B%E5%BA%8F%E9%94%99%E8%AF%AF/0x%2508X%E5%92%8C%25p/</url>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span>* a = (<span class="hljs-type">int</span>*)<span class="hljs-number">1</span>;<br><br>    <span class="hljs-type">char</span>* p = (<span class="hljs-type">char</span>*)<span class="hljs-number">2</span> ;<br><br>    <span class="hljs-type">char</span>* q = (<span class="hljs-type">char</span>*)<span class="hljs-number">0x12345678</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*a = 0x%08X, *b = 0x%08X, *q = 0x%08X\n&quot;</span>, a, p, q);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*a = %p, *b = %p, *q = %p\n,&quot;</span>, a, p, q);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Test.c:<span class="hljs-number">11</span>:<span class="hljs-number">9</span>: <span class="hljs-built_in">warning</span>: <span class="hljs-keyword">format</span> ‘%X’ expects argument <span class="hljs-keyword">of</span> <span class="hljs-keyword">type</span> ‘unsigned <span class="hljs-type">int</span>’, but argument <span class="hljs-number">2</span> has <span class="hljs-keyword">type</span> ‘<span class="hljs-type">int</span> *’ [-Wformat=]<br>  printf(&quot;*a = 0x%08X, *b = 0x%08X\n, *q = 0x%08X,&quot;, a, p, q);<br>         ^<br>Test.c:<span class="hljs-number">11</span>:<span class="hljs-number">9</span>: <span class="hljs-built_in">warning</span>: <span class="hljs-keyword">format</span> ‘%X’ expects argument <span class="hljs-keyword">of</span> <span class="hljs-keyword">type</span> ‘unsigned <span class="hljs-type">int</span>’, but argument <span class="hljs-number">3</span> has <span class="hljs-keyword">type</span> ‘<span class="hljs-type">char</span> *’ [-Wformat=]<br>Test.c:<span class="hljs-number">11</span>:<span class="hljs-number">9</span>: <span class="hljs-built_in">warning</span>: <span class="hljs-keyword">format</span> ‘%X’ expects argument <span class="hljs-keyword">of</span> <span class="hljs-keyword">type</span> ‘unsigned <span class="hljs-type">int</span>’, but argument <span class="hljs-number">4</span> has <span class="hljs-keyword">type</span> ‘<span class="hljs-type">char</span> *’ [-Wformat=]<br><br>*a = <span class="hljs-number">0x00000001</span>, *b = <span class="hljs-number">0x00000002</span>, *q = <span class="hljs-number">0x12345678</span><br>*a = <span class="hljs-number">0x1</span>, *b = <span class="hljs-number">0x2</span>, *q = <span class="hljs-number">0x12345678</span><br></code></pre></td></tr></table></figure><p>0x%08X：将无符号整型数据按照八位（不够补0）表示，且加上0x</p><p>%p：将指针变量的值（即地址）表示出来，会自动加上前缀0x</p><p>若想打印指针变量的值，若其为unsigned int*，则用0x%08X;否则用%p</p><p>未解决问题：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;*a = %010p, *b = %010p, *q = %010p\n,&quot;</span>, a, p, <span class="hljs-keyword">q</span>);<br><br>Test.c:<span class="hljs-number">16</span>:<span class="hljs-number">9</span>: warning: <span class="hljs-string">&#x27;0&#x27;</span> flag used with ‘%p’ gnu_printf <span class="hljs-keyword">format</span> [-Wformat=]<br></code></pre></td></tr></table></figure><p><a href="https://www.it1352.com/358537.html">https://www.it1352.com/358537.html</a></p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
      <tag>程序错误</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>桩函数</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/%E6%A1%A9%E5%87%BD%E6%95%B0/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/%E6%A1%A9%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位操作</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/%E4%BD%8D%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>一、置位操作：</p><p>7,8位置1：将想置位的数与0xc0(1100 0000)相或</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">a <span class="hljs-string">|= 0xc0;</span><br></code></pre></td></tr></table></figure><p>但算出0xc0太麻烦，可以直接这么用</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span> |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure><p>二、清位操作：</p><p>7,8位置0：将想清位的数与0x3f(0011 1111)相与，即与0xc0的取反值相与</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">a <span class="hljs-meta">&amp;= ~(0xc0);</span><br></code></pre></td></tr></table></figure><p>但算出0x3f太麻烦，可以直接这么用</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span> &amp;= ~((<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">8</span>));<br></code></pre></td></tr></table></figure><p>三、取位操作</p><p>把第8位取出来放在b中：想取位的数与0x80相与(1000 0000)</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">b</span> = a &amp; <span class="hljs-number">0</span>x80<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>但算出0x80太麻烦，可以直接这么用</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">b</span> = a &amp; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">8</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>形如：取X的低八位</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">X <span class="hljs-meta">&amp; 0xff</span><br></code></pre></td></tr></table></figure><p>四、任意位取反</p><p>a ^&#x3D; 1&lt;&lt;17</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>条件编译指令</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理。</p><p>指令用途</p><ul><li># 空指令，无任何效果</li><li>#include 包含一个源代码文件</li><li>#define 定义宏</li><li>#undef 取消已定义的宏</li><li>#if 如果给定条件为真，则编译下面代码</li><li>#ifdef 如果宏已经定义，则编译下面代码</li><li>#ifndef 如果宏没有定义，则编译下面代码</li><li>#elif 如果前面的#if给定条件不为真，当前条件为真，则编译下面代码</li><li>#endif 结束一个#if……#else条件编译块</li><li>#error 停止编译并显示错误信息</li></ul><p>条件编译指令将决定那些代码被编译，而哪些是不被编译的。可以根据表达式的值或者某个特定的宏是否被定义来确定编译条件。</p><ol><li>#if指令</li></ol><p>#if指令检测跟在制造另关键字后的常量表达式。如果表达式为真，则编译后面的代码，知道出现#else、#elif或#endif为止；否则就不编译。</p><ol><li>#endif指令</li></ol><p>#endif用于终止#if预处理指令。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG 0</span><br><span class="hljs-built_in">main</span>()<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Debugging\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Running\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于程序定义DEBUG宏代表0，所以#if条件为假，不编译后面的代码直到#endif，所以程序直接输出Running。</p><p>如果去掉#define语句，效果是一样的。</p><ol><li>#ifdef和#ifndef</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG</span><br><span class="hljs-built_in">main</span>()<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEBUG</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;yes\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DEBUG</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;no\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined等价于#<span class="hljs-keyword">ifdef</span>; #<span class="hljs-keyword">if</span> !defined等价于#<span class="hljs-keyword">ifndef</span></span><br></code></pre></td></tr></table></figure><ol><li>#else指令</li></ol><p>#else指令用于某个#if指令之后，当前面的#if指令的条件不为真时，就编译#else后面的代码。#endif指令将中指上面的条件块。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG</span><br><span class="hljs-built_in">main</span>()<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEBUG</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Debugging\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Not debugging\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Running\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>#elif指令</li></ol><p>#elif预处理指令综合了#else和#if指令的作用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TWO</span><br><span class="hljs-built_in">main</span>()<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ONE</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined TWO</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;3\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>程序很好理解，最后输出结果是2。</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>条件编译</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<p>条件编译使用分析</p><p>使用一拨人开发一份代码，根据一份代码产生高中低三种产品</p><p>一、基本概念</p><p>条件编译的行为类似于C语言中的if..else…，但不同的是if..else…语句在运行期进行分支判断，条件编译指令在预编译期进行分支判断。预编译器根据条件编译指令有选择的删除代码，到编译器时，编译器不知道代码分支的存在。</p><p>即条件编译为预编译指示命令,用于控制是否编译某段代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> C 1</span><br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span>* s;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span>( C == 1 )</span><br>        s = <span class="hljs-string">&quot;This is first printf...\n&quot;</span>;    <span class="hljs-comment">//进入编译</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        s = <span class="hljs-string">&quot;This is second printf...\n&quot;</span>;    <span class="hljs-comment">//不进入编译</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">// printf(&quot;%s&quot;, s);</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* test.i */</span><br><span class="hljs-meta"># 1 &quot;test.c&quot;</span><br><span class="hljs-meta"># 1 &quot;&lt;built-in&gt;&quot;</span><br><span class="hljs-meta"># 1 &quot;&lt;command-<span class="hljs-keyword">line</span>&gt;&quot;</span><br><span class="hljs-meta"># 1 &quot;test.c&quot;</span><br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span>* s;<br>        s = <span class="hljs-string">&quot;This is first printf...\n&quot;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过#if #else指示预处理器保存哪段代码，判定执行的代码才留下</p><p>二、可以通过命令行定义宏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 在函数中并不定义宏C */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* s;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span>( C == 1 )</span><br>        s = <span class="hljs-string">&quot;This is first printf...\n&quot;</span>;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        s = <span class="hljs-string">&quot;This is second printf...\n&quot;</span>;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* 格式 */</span><br>gcc -Dmacro=value file.c <br><br><span class="hljs-regexp">/* 在命令行中定义宏 */</span><br>gcc -DC=<span class="hljs-number">1</span> test.c<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 定义C作为宏标识符 */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* s;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> C</span><br>        s = <span class="hljs-string">&quot;This is first printf...\n&quot;</span>;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        s = <span class="hljs-string">&quot;This is second printf...\n&quot;</span>;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">//printf(&quot;%s&quot;, s);</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>三、#include的本质</p><p>（1）</p><p>#include的本质是将已经存在的文件内容嵌入到当前文件中，但#include的间接包含同样会产生嵌入文件内容的操作，如下：</p><p><img src="/image/0d02d40684aeee981de901baa4201f04.png" alt="0d02d40684aeee981de901baa4201f04.png"></p><p>而间接包含同一个头文件会产生编译错误，因为重复包含会造成重复定义。</p><p>（2）条件编译可以解决头文件重复包含的编译错误</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#ifndef_ HEADER_ _FILE_ H_</span><br><span class="hljs-comment">#define_ HEADER_ FILE_ _H_</span><br><span class="hljs-regexp">//</span> source code<br><span class="hljs-comment">#endif</span><br></code></pre></td></tr></table></figure><p>四、条件编译的意义</p><p>条件编译使得我们可以按不同的条件编译不同的代码段，因而可以产生不同的目标代码</p><p>#if.. #else… #endif被预编译器处理,而if.. .else..语句被编译器处理,必然被编译进目标代码</p><p>实际工程中条件编译主要用于一下两种情况:</p><p>-不同的产品线共用一份代码</p><p>-区分编译产品的调试版和发布版</p><p>例：产品线区分及调试代码应用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* product.h </span><br><span class="hljs-comment"> * 文件指示了这是调试版的高端产品</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HIGH  1</span><br><br><span class="hljs-comment">/* test.c */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;product.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG    <span class="hljs-comment">//指示当前编译出来的可执行程序是调试版还是可发行版</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG(s) printf(<span class="hljs-string">&quot;[%s:%d] %s\n&quot;</span>, __FILE__, __LINE__, s)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG(s) NULL</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> HIGH    <span class="hljs-comment">//指示当前编译出来的可执行程序是高端产品还是低端产品</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is the high level product!\n&quot;</span>);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">LOG</span>(<span class="hljs-string">&quot;Enter main() ...&quot;</span>);<br>    <br>    <span class="hljs-built_in">f</span>();<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1. Query Information.\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2. Record Information.\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;3. Delete Information.\n&quot;</span>);<br>    <br>    <span class="hljs-meta">#<span class="hljs-keyword">if</span> HIGH    <span class="hljs-comment">//高端产品才有功能4，5</span></span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;4. High Level Query.\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;5. Mannul Service.\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;6. Exit.\n&quot;</span>);<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;4. Exit.\n&quot;</span>);<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <br>    <span class="hljs-built_in">LOG</span>(<span class="hljs-string">&quot;Exit main() ...&quot;</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>小结：</p><p>通过编译器命令行能够定义预处理器使用的宏</p><p>条件编译可以避免重复包含头同一个头文件</p><p>条件编译是在工程开发中可以区别不同产品线的代码</p><p>条件编译可以定义产品的发布版和调试版</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆与栈</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/%E5%A0%86%E4%B8%8E%E6%A0%88/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/%E5%A0%86%E4%B8%8E%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<p>堆与栈的比较：</p><p>1.1 申请方式：</p><ul><li>栈：系统自动分配</li><li>堆：程序员自己申请</li></ul><p>1.2 申请后系统的响应</p><ul><li>栈：只要有足够空间给你，系统就会为程序提供内存，否则报异常</li><li>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</li></ul><p>1.3 申请大小的限制</p><ul><li>栈：栈是向低地址扩展的数据结构，是一块连续的内存的区域。即栈顶的地址和栈的最大容量是系统预先规定好的</li><li>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</li></ul><p>1.4 申请效率的比较</p><ul><li>栈：系统自动分配，速度较快。但程序员无法控制。</li><li>堆：由new分配的内存，一般速度比较慢，容易产生内存碎片,不过用起来最方便。</li></ul><p>1.5 存储内容</p><ul><li>栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。</li></ul><p>当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</p><ul><li>堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。</li></ul><p>1.6 总结：</p><p>　　堆和栈的主要区别由以下几点：</p><p>　　1、管理方式不同；</p><p>　　2、空间大小不同；</p><p>　　3、能否产生碎片不同；</p><p>　　4、生长方向不同；</p><p>　　5、分配方式不同；</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">堆都是动态分配的<br>栈有2种分配方式：静态分配和动态分配。静态分配和动态分配都是编译器完成的<br></code></pre></td></tr></table></figure><p>　　6、分配效率不同；</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>断言</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/%E6%96%AD%E8%A8%80/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/%E6%96%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<p>if和断言区别：</p><p>（1）if是在最终发布的版本中真实存在的，用于处理程序运行过程中产生的错误（例如处理用户错误输入），以提高程序的健壮性。</p><p>（2）断言用于开发阶段的调试，捕捉不应该发生的非法情况，并迅速定位问题。发布的时候需要把断言去掉</p><p>背景：</p><p>写有参数的函数时，首要工作，就是要对传进来的所有参数进行合法性检查。而对于传出的参数也应该进行检查，这个动作当然应该在函数的外部，也就是说，调用完一个函数后，应该对其传出的值进行检查。这时使用assert进行调试</p><p>一、断言概况</p><p>1、断言</p><p>（1）在使用C语言编写工程代码时，我们总会对某种假设条件进行检查，断言就是用于在代码中捕捉这些假设，可以将断言看作是异常处理的一种高级形式。</p><p>（2）断言表示为一些布尔表达式，程序员相信在程序中的某个特定点该表达式值为真。可以在任何时候启用和禁用断言验证，因此可以在测试时启用断言，而在部署时禁用断言。</p><p>（3）同样，程序投入运行后，最终用户在遇到问题时可以重新起用断言。它可以快速发现并定位软件问题，同时对系统错误进行自动报警。断言可以对在系统中隐藏很深，用其它手段极难发现的问题可以用断言来进行定位，从而缩短软件问题定位时间，提高系统的可测性。实际应用时，可根据具体情况灵活地设计断言。</p><p>2、一般使用的地方</p><p>（1）在函数的入口处，使用断言检查参数的有效性（合法性）。</p><p>（2）在编写函数时，要进行反复的考查，并且自问：“我打算做哪些假定？”一旦确定了的假定，就要使用断言对假定进行检查。</p><p>（3）可以在预计正常情况下程序不会到达的地方放置断言。（如assert (0);）</p><p>（4）使用断言测试方法执行的前置条件和后置条件 。</p><p>（5）使用断言检查类的不变状态，确保任何情况下，某个变量的状态必须满足。（如某个变量的变化范围）</p><p>二、断言的使用方式</p><p>1、使用库函数中的断言</p><p>（1）assert宏的原型定义在&lt;assert.h&gt;中，其作用是先计算表达式expression，如果expression的值为假（即为0），那么它打印出错表达式，并且定位出错的文件位置以及出错行数，最后调用abort()函数，终止程序</p><p>（2）禁止断言的方法</p><p>在#include&lt;assert.h&gt;的前面加上#define NDEBUG</p><p>注意：一定是要在该头文件之前添加#define NDEBUG，在头文件之后添加是不能禁止断言的</p><p>三、例子</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs markdown">/<span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">**</span><br><span class="hljs-strong"><span class="hljs-emphasis">* using_assert.c                     *</span></span><br><span class="hljs-strong"><span class="hljs-emphasis">*                                    *</span></span><br><span class="hljs-strong"><span class="hljs-emphasis">* C语言的错误检测机制：断言          *</span></span><br><span class="hljs-strong">**</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>/<br><br><span class="hljs-section">#include <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">stdio.h</span>&gt;</span></span></span><br><span class="hljs-section">#include <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">assert.h</span>&gt;</span></span></span><br><br>int main()<br>&#123;<br>  int x;<br>  printf(&quot;请输入一个正整数：&quot;);<br>  scanf(&quot;%d&quot;, &amp;x);<br><br>  assert(x &gt; 0);<br><br>  printf(&quot;输入的数符合要求!\n&quot;);<br><br>  return 0;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">clone_string</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">char</span> *source )</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">char</span> *result;<br>        <span class="hljs-built_in">assert</span>( source != <span class="hljs-literal">NULL</span> );<br>        result = ( <span class="hljs-type">char</span>* )<span class="hljs-built_in">malloc</span>( <span class="hljs-built_in">strlen</span>(source) + <span class="hljs-number">1</span> );<br>        <span class="hljs-keyword">if</span>( result != <span class="hljs-literal">NULL</span> )<br>        &#123;<br>            <span class="hljs-built_in">strcpy</span>( result, source );<br>            <span class="hljs-built_in">assert</span>( <span class="hljs-built_in">strcmp</span>(result, source) == <span class="hljs-number">0</span> );<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>（1）注意到我对source是否为NULL是用assert检查的，但对result是不是为NULL是用if语句判断的</p><p>（2）这是因为在调用代码正确的情况下source必然不为NULL，如果断言失败，说明调用代码中有错误，需要修改；但result作为malloc的返回值则不一定，在malloc代码无误的情况下仍然可能返回NULL——当内存块不足时。</p><p>（3）最后又用assert对strcpy的结果进行检查，因为只要代码正确，无论什么情况strcpy应该正常完成复制，它没有malloc那种异常情况存在。</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变量在存储器中的存放形式</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/%E5%8F%98%E9%87%8F%E5%9C%A8%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AD%98%E6%94%BE%E5%BD%A2%E5%BC%8F/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/%E5%8F%98%E9%87%8F%E5%9C%A8%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AD%98%E6%94%BE%E5%BD%A2%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>一、不同位宽的存储器：</p><p>1.1 存储器的位宽</p><p>存储器的位宽表示</p><p>存储器位宽表示了每个地址下有多少位数据，与它的数据线根数相等；</p><p>如：32位机器一个地址下就有32位数据，即4个字节（这4个字节称为一个字，字就是机器字长）</p><p><img src="/image/aebf2a992bb87aca50c5faf53d1777fd.png" alt="aebf2a992bb87aca50c5faf53d1777fd.png"></p><p>1.2 存储器的存储器容量</p><p>存储器容量是位宽与2^N的乘积，此处单位为bit。</p><p>如：2M * 32bit的存储器中，2M个存储空间，一个空间32位数据。即2^21，21个地址线。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2M</span> * <span class="hljs-number">32</span> bit = <span class="hljs-number">8</span>MB = <span class="hljs-number">8</span> * <span class="hljs-number">2</span>^<span class="hljs-number">10</span> KB = <span class="hljs-number">8</span> * <span class="hljs-number">2</span>^<span class="hljs-number">20</span> B = <span class="hljs-number">8</span> * <span class="hljs-number">8</span> * <span class="hljs-number">2</span>^<span class="hljs-number">20</span> bit = <span class="hljs-number">32</span> * <span class="hljs-number">2</span>^<span class="hljs-number">21</span> bit<br></code></pre></td></tr></table></figure><p>即地址线为21根</p><p>1.3 寻址方式</p><p>所谓的CPU按字寻址还是按字节寻址实际上是指CPU 发出的每一个地址信号实际得到的数据是一个字节还是一个字。这并不是由CPU决定的，而是由CPU与存储器之间的连线决定的。</p><p>CPU发出的地址体现在与存储器相连的地址线上，存储器收到地址线传来的信号后，再把对应存储单元里的数据发送出去，但CPU与存储器收发都是对应位宽的数据，即使CPU想要的是一个8位数据，但它的数据线收到的还是对应存储器位宽的数据（可以看作存储器地址线收到信号，数据线读出信号）。</p><p>但一个16位的存储器，收到地址信号后发出一个16位的数据，这个数据不会直接到CPU手里，会到内存控制器这里（S3C2440），内存控制器再看看CPU实际想要多大的数据，若需要8位，它再根据存储器没有收到的地址来决定把16位数据里的哪8位给CPU。这样CPU输出一个地址，收到了一个8位数据，就可以说CPU是按字节编制的。</p><p>（1）按字寻址：字作为一个寻址单元，CPU得到了一个字</p><p><img src="/image/0b7f8205de9809573dee910458df3d88.png" alt="0b7f8205de9809573dee910458df3d88.png"></p><p><img src="/image/7a75ed64159614d23fa9c4ee59e10a37.png" alt="7a75ed64159614d23fa9c4ee59e10a37.png"></p><p>CPU发出地址 000000、000001、000010、000011，存储器收到的都是对应的000000、000001、000010、000011。存储器直接把数据发出去，内存控制器一看不需要它筛选，直接将32位数据给CPU，即CPU按字寻址。</p><p>（2）按字节寻址：字节作为一个寻址单元，CPU得到了一个字节</p><p><img src="/image/f305d9f5ccad0fca8beaa97116e81254.png" alt="f305d9f5ccad0fca8beaa97116e81254.png"></p><p><img src="/image/79c1cbf8709888869a7476f13bed3984.png" alt="79c1cbf8709888869a7476f13bed3984.png"></p><p>CPU发出地址 000000、000001、000010、000011，由于A0与A1都没接到存储器上，所以无论发出哪个地址存储器收到的都是0000，然后它把对应的32位数据给出去，内存控制器再根据A0A1判断CPU要的是32位里的哪8位（涉及到大小端），即CPU按字节寻址。</p><p>1.3 存储器的地址编号范围</p><p>存储器的地址线根数(N)决定了它的地址编号范围（2^N）</p><p>若按字节寻址：24根地址线，每一位都可以用来编号，范围为2^24 &#x3D; 16M</p><p>若按字寻址：   24根地址线，需要预留几根地址线区分每个字节的位置，若是32位设备，需要预留2根线，22根线寻址范围为2^22 &#x3D; 4M</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变量的存储位置/程序文件与程序进程中数据的位置</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/%E5%8F%98%E9%87%8F%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE-%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%BF%9B%E7%A8%8B%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BD%8D%E7%BD%AE/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/%E5%8F%98%E9%87%8F%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE-%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%BF%9B%E7%A8%8B%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BD%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>一、程序进程与程序文件：</p><p>程序进程就是程序运行时的程序（如在内存上运行）</p><p>程序文件是编译后生成的可执行文件，比如.bin文件等</p><p>二、冯诺依曼结构和哈佛结构：</p><p>2.1 简介</p><p>（1）冯诺依曼结构：提出了二进制逻辑、程序存储思想和计算机由五个部分组成。将指令存储器与数据存储器合在一起，使指令和数据共享一条总线。</p><p>指令的执行为顺序执行，无法重叠执行，只有完成一个再执行下一个，使得信息流传输成为限制性能的瓶颈。</p><p>（2）哈佛结构：将程序指令和数据分开存储，指令存储器与数据存储器采用两条独立的总线，这两条总线之间毫无关联。</p><p>中央处理器首先到指令存储器中读取程序指令内容，解码后得到数据地址，再到相应的数据存储器中读取数据，并进行下一步的操作（通常是执行）。</p><p>在指令执行时可以预先读下一条指令，取指令和存取数据分别由不同的存储空间和总线，这样也就克服了信息流传输的瓶颈。</p><p>2.2 二者区别：</p><p>区别：程序空间和数据空间是否为一体的。冯诺依曼结构的程序空间和数据空间不分开，哈佛结构数据空间和地址空间是分开的。</p><p>优缺点：哈佛结构略为复杂，对外围设备的连接与处理要求高，十分不适合外围存储器的扩展。所以早期通用CPU难以采用这种结构。而对于单片机来说，由于内部集成了所需的存储器，所以采用哈佛结构也未尝不可。现在的处理器，依托cache的存在，已经很好的将二者统一起来了（cache的出现，是为了缓解CPU和内存之间速度的不匹配问题（结构：cpu -&gt; cache -&gt; memory））。</p><p>2.3 改进型哈佛结构：</p><p>将程序指令和数据分开存储，具有一条独立的地址总线和一条独立的数据总线，利用公用地址总线访问两个存储模块（程序存储模块和数据存储模块），公用数据总线则被用来完成程序存储模块或数据存储模块与CPU之间的数据传输；两条总线由程序存储器和数据存储器分时共用。</p><p>2.4 常见芯片</p><p>Intel的x86处理器：大多为冯诺依曼结构，之所以其早期能快速占领市场，正是采用了这种实现简单、成本低的结构</p><p>51单片机：程序进程的逻辑代码段放在ROM中，而变量部分则放在RAM中，取ROM中的指令和RAM中的变量是两套总线。即数据指令存储区是分开的，总线是分时复用的，所以采用的是改进型哈佛结构。</p><p>ARM9、S3C2440：ARM9被称为是哈佛结构是从它拥有指令cache和数据cache角度来说的，实际上它现在称之为“改进的哈佛结构”，因为这两个cache是独立的，可以并行运行。</p><p>ARM：从ARM9开始以后所有的ARM处理器内核都是改进型的哈佛结构。ARM的逻辑代码和变量都是存放在RAM中的，但是，它在内存中划分了两部分的空间，其中一部分放逻辑代码，另一部分存放变量，之间不会相互干扰。</p><p>DSP：大多采用改进型哈佛结构。</p><p>2.5 从代码角度理解：</p><p>在编写程序时，可以对程序的代码分为两个部分，一部分是程序编写完成后就不再需要对其进行修改了的（也就是逻辑代码部分）另一部分就是在程序编写完毕后其内容会随着程序的运行而不断变化的部分（也就是变量数据部分）。而哈佛结构和冯诺依曼结构就是对于这个两部分代码的存储方式的区别。</p><p>哈佛结构：将程序的逻辑代码和变量分开存放，他们存放的位置可以是形同的（ARM）也可以是不同的（51），只要是分成两个部分单独访问的结构都可以叫哈佛结构。这种结构大量应用在嵌入式编程当中。</p><p>冯诺依曼结构：冯诺依曼结构则是将逻辑代码段和变量统一都存储在内存当中，他们之间一般是按照代码的执行顺序依次存储。</p><p>三、程序文件中的分区</p><p>一般情况下，一个程序本质上都是由 bss段、data段、text段三个组成的。</p><p>3.1 相关概念：</p><p>Code，RO_data，RW_data，ZI_data，RO，RW等常出现在嵌入式程序编译完成后的名词。比如Keil中</p><p><img src="/image/20150717122223189.jpg" alt="20150717122223189.jpg"></p><ul><li>Code：即代码域，也称.text段。它指的是编译器生成的机器指令。</li><li>RO_data：即只读数据域，也称.rodata段。它指程序中用到的只读数据，例如const关键字定义的全局变量、字符串字面量。</li><li>RW_data：即可读写数据域，也称.data段。它指初始化为“非0值”的可读写数据，程序刚运行时，这些数据具有非0的初始值，且运行的时候它们会常驻在RAM区，因而应用程序可以修改其内容。例如全局变量或者静态变量，且定义时赋予“非0值”给该变量进行初始化。</li><li>ZI_data：ZeroInitialie data即0初始化数据，也称.bss段。它指初始化为“0值”的可读写数据域，它与RW_data的区别是程序刚运行时这些数据初始值全都为0，而后续运行过程与RW-data的性质一样，它们也常驻在RAM区，因而应用程序可以更改其内容。包括未初始化的全局变量，和初始化为0的全局变量。并不给该段的数据分配空间，只是记录数据所需空间的大小。</li></ul><p>注：RO为只读区域，包括RO_data和code。应与RO_data区分开来。</p><p>3.2 ARM映像文件 </p><p>bin文件和hex都被称为ARM映像文件，即linux的可执行文件，被烧入到<span style="background-color: #ffaaaa">ROM（Nor,Nand）</span>中，它之中包含了Code、RO_data与RW_data。一般来说，在程序运行的最初阶段，RO中的指令完成了这两项工作</p><ol><li>将RW从ROM中搬到RAM中，因为RW是变量，变量不能存在ROM中。</li><li>将ZI所在的RAM区域全部清零，因为ZI区域并不在映像文件中，所以需要程序根据编译器给出的ZI地址及大小来将相应得RAM区域清零。ZI中也是变量，同理：变量不能存在ROM中</li></ol><p>完成了工作后C程序才能正常访问变量。否则只能运行不含变量的代码。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">从这里就可以看出<span class="hljs-meta">ARM</span>为哈佛结构，程序与代码分别在两个位置访问<br></code></pre></td></tr></table></figure><p>程序存储在ROM中时，所占用的大小为Code + RO_data + RW_data</p><p>当程序执行时，RW_data和 ZI_data在RAM中，RO_data和Code视cpu架构（51、arm、x86）处于ROM或者RAM中。</p><p>四、程序进程中的分区（假如bin直接在SRAM上运行）</p><p>程序加载运行时，.text段和.rodata段合并到一个Segment中，即代码段（text Segment），操作系统将这个Segment的页面只读保护起来，防止意外的改写。</p><p>BSS段的大小从可执行文件中(bin)得到，然后链接器得到这个大小的内存块，紧跟在数据段后面。当这个内存区进入程序的地址空间后全部清零。</p><p><img src="/image/25114105_Xc9r.jpg" alt="25114105_Xc9r.jpg"></p><ul><li>代码段：代码段（code segment&#x2F;text segment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</li><li>数据段：数据段（data segment）通常是指用来存放程序中已初始化且不为0的全局变量的一块内存区域。</li><li>BSS段：BSS段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。</li><li>堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。</li><li>栈(stack)：栈又称堆栈，用户存放程序临时创建的局部变量。在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的后进先出特点，所以栈特别方便用来保存&#x2F;恢复调用现场。</li></ul><p>五、从内存地址的角度描述变量存储位置</p><ul><li>代码区：存放二进制代码的区域</li><li>（文字）常量区：存放常量的区域，程序结束时，系统回收。const修饰的全局变量在区域中的低地址，字符串字面量紧随其后</li><li>全局&#x2F;静态存储区：存放全局变量和静态变量。全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。</li><li>堆：由程序员分配和释放，如果程序员不释放，会有内存泄漏，程序结束时，由操作系统回收。容量大, 速度慢, 无序。</li><li>栈：系统自动分配并释放，存放函数的参数值，局部变量等。容量小,速度快,有序. 栈是系统数据结构，对应线程&#x2F;进程是唯一的。</li></ul><p>这种描述方式将bss段和数据段合并在一起称呼，同时又将.rodata段从代码段中分离</p><p>六、我的观点</p><p>常量区在内存中分配的地址由编译器（链接阶段）决定，可能在全局存储区前，也可能插入全局存储区中放在数据段后bss段之前。我们也可以写lds链接脚本自己规定</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">链接脚本主要用于规定如何把输入文件内的section放入输出文件内, 并控制输出文件内各部分在程序地址空间内的布局<br>输入文件: 目标文件或链接脚本文件.<br>输出文件: 目标文件或可执行文件.<br></code></pre></td></tr></table></figure><p><img src="/image/84e7fa5e6f971cce295713ef9dd3fde2.png" alt="84e7fa5e6f971cce295713ef9dd3fde2.png"></p><p>在vc6.0中，常量区在全局存储区之前；在gcc编译器中，常量区在全局存储区中放在数据段后bss段之前。</p><hr><p><a href="https://blog.csdn.net/u014600626/article/details/81533125?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_utm_term-0&spm=1001.2101.3001.4242">https://blog.csdn.net/u014600626/article/details/81533125?utm_medium&#x3D;distribute.pc_relevant.none-task-blog-baidujs_utm_term-0&amp;spm&#x3D;1001.2101.3001.4242</a></p><p><a href="https://blog.csdn.net/zhy557/article/details/80832268?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">https://blog.csdn.net/zhy557/article/details/80832268?utm_medium&#x3D;distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;dist_request_id&#x3D;&amp;depth_1-utm_source&#x3D;distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control</a></p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>volatile</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/volatile/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/volatile/</url>
    
    <content type="html"><![CDATA[<ol><li>程序的硬件优化：</li></ol><p>（1）由于CPU处理速度远大于内存访问速度，CPU直接从内存中存取数据需要等待一定的时间，所以为了提高整体性能，在硬件上引入高速Cache。Cache保存有CPU刚用过或者循环使用的一部分数据，CPU再需要使用这些数据时直接从Cache调用，减少CPU的等待时间。</p><p>（2）在现代CPU中指令的执行并不一定严格按照顺序，没有相关性的指令可以乱序执行，以充分利用CPU的指令流水线，提高执行速度。</p><ol><li>程序的软件优化：</li></ol><p>（1）程序员优化</p><p>（2）编译器优化：</p><p>①将内存变量缓存到寄存器</p><p>②调整指令顺序优化流水线，例如重新排序读写指令</p><p>有些时候这些优化并不是程序所需要的，这时候就可以使用volatile禁止这些优化：防止优化编译器把变量从内存装入CPU寄存器中。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int obj <span class="hljs-operator">=</span> <span class="hljs-number">10</span><span class="hljs-comment">;</span><br><br>int a <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>int b <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br><br><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span> obj<span class="hljs-comment">;    //编译器认为在此之前obj没有出现在赋值号左边，值没有变化，故直接把10赋值给a</span><br><br>sleep(<span class="hljs-number">100</span>)<span class="hljs-comment">;    //有可能obj的内存空间被其他线程或某一个中断处理程序所改变，造成obj的值意外被改变</span><br><br><span class="hljs-attribute">b</span> <span class="hljs-operator">=</span> obj<span class="hljs-comment">;    //编译器认为在此之前obj没有出现在赋值号左边，值没有变化，依旧直接把10赋值给b</span><br></code></pre></td></tr></table></figure><p>volatile强制编译器对访问该变量的代码不去优化，即使它前面的指令刚刚从该处读取过数据。因为每次必须从内存中取值，所以用多了会造成程序变慢</p><p><a href="https://blog.csdn.net/qq_29350001/article/details/54024070">https://blog.csdn.net/qq_29350001&#x2F;article&#x2F;details&#x2F;54024070</a></p><p>用法一：并行设备的硬件寄存器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> GPC1CON *((volatile unsigned int*)0xE0200080)</span><br></code></pre></td></tr></table></figure><p>GPC1CON 为寄存器名称、0xE0200080 为寄存器地址、(volatile unsigned int*) 为强制类型转换。</p><p>如果不加上volatile，那在使用GPC1CON的时候就会从速度较快的寄存器中取值，而寄存器的值是来自之前访问过的GPC1CON，之前就从内存中取出GPC1CON的值保存到这个寄存器里。使用volatile就表示这个寄存器里的值是随时变化的，每次都要去内存里取它的值，不要对其做优化</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">int</span>  *<span class="hljs-keyword">output</span> = (<span class="hljs-keyword">unsigned</span>  <span class="hljs-keyword">int</span> *)<span class="hljs-number">0</span>xff800000;<span class="hljs-comment">//定义一个IO端口；</span><br><span class="hljs-keyword">int</span>   init(<span class="hljs-keyword">void</span>)<br>&#123;<br>      <span class="hljs-keyword">int</span> i;<br>      <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt; <span class="hljs-number">10</span>;i++)&#123;<br>         *<span class="hljs-keyword">output</span> = i;<br>&#125;<br>&#125;<br><br>优化后，编译器认为之前都是废话，对结果无影响<br><span class="hljs-keyword">int</span>  init(<span class="hljs-keyword">void</span>)<br>&#123;<br>      *<span class="hljs-keyword">output</span> = <span class="hljs-number">9</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>用法二：中断服务程序中会访问到的非自动变量</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">static</span> <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;     <span class="hljs-comment">//i为非自动变量</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i) <span class="hljs-built_in">dosomething</span>();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/* 中断服务程序 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ISR_2</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>      i=<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序原意在触发中断后，i的值被修改，然后dosomething。但其实编译器判断在main中没有修改过i，因此可能只执行一次将i读到某寄存器的读操作，下次再访问i的时候也是访问寄存器上的”i副本”，导致dosomething永远不会被掉用。所以应该加上volatile。</p><p>用法三：多线程中被几个任务共享的变量</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">volatile</span>  <span class="hljs-type">BOOL</span>  bStop  =  <span class="hljs-literal">FALSE</span>;  <span class="hljs-comment">//bStop  为共享全局变量</span><br>(<span class="hljs-number">1</span>) 在一个线程中：  <br>  <span class="hljs-keyword">while</span>(  !bStop  )  &#123;  ...  &#125;  <br>  bStop  =  <span class="hljs-literal">FALSE</span>;  <br>  <span class="hljs-keyword">return</span>;    <br>(<span class="hljs-number">2</span>) 在另外一个线程中，要终止上面的线程循环：  <br>  bStop  =  <span class="hljs-literal">TRUE</span>;  <br>  <span class="hljs-keyword">while</span>(  bStop  );<br></code></pre></td></tr></table></figure><p>当两个线程都用到一个变量且这个变量的值会被改变时，应该使用volatile声明。这样就不会把变量从内存装入CPU寄存器，就不会它们在访问的时候访问的不是一个地方的变量。</p><p>在访问a的时候（把a赋值给其他变量或直接使用a）认清是访问a保存在寄存器里的值，还是a在内存里的值。用volatile修饰就是访问a在内存的值。如果a有可能被中断或不同线程，或硬件改动，那就要用volatile修饰。如果a只是同一线程的一个普通变量则没必要用volatile修饰。</p><p>例：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">for ( i=0; i</span>&lt;<span class="hljs-comment">1000; i</span><span class="hljs-literal">++</span> <span class="hljs-comment">)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    a</span><span class="hljs-literal">++</span><span class="hljs-comment">;</span><br><span class="hljs-comment">&#125;</span><br></code></pre></td></tr></table></figure><p>会被优化成a+&#x3D;1000。这时就可以加上一个volatile表示这个a有可能在a++的过程中被改变，让编译器老老实实一个一个加。但其实这里只是为了防止优化</p><p><strong>问题一</strong>：一个参数既可以是const还可以是volatile吗？</p><p>答：可以，例如只读的状态寄存器。它是 volatile 因为它可能被意想不到地改变。它是 const 因为 程序不应该试图去修改它。</p><p><strong>问题二</strong>：一个指针可以是 volatile 吗？</p><p>答：可以，当一个中服务子程序修改一个指向一个 buffer 的指针时。</p><p><strong>问题三</strong>：下面的函数有什么错误？</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-built_in">int</span> square(<span class="hljs-keyword">volatile</span> <span class="hljs-built_in">int</span> *<span class="hljs-built_in">ptr</span>)<br>&#123;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-built_in">ptr</span> * *<span class="hljs-built_in">ptr</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autoit">  <span class="hljs-built_in">int</span> square(<span class="hljs-keyword">volatile</span> <span class="hljs-built_in">int</span> *<span class="hljs-built_in">ptr</span>)  <br>    &#123;<br>         <span class="hljs-built_in">int</span> a,b<span class="hljs-comment">;</span><br>         a = *<span class="hljs-built_in">ptr</span><span class="hljs-comment">;</span><br>         b = *<span class="hljs-built_in">ptr</span><span class="hljs-comment">;</span><br>         <span class="hljs-keyword">return</span> a * b<span class="hljs-comment">;</span><br>     &#125;<br></code></pre></td></tr></table></figure><p>  由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> *ptr)</span>  </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a;<br>    a = *ptr;<br>    <span class="hljs-keyword">return</span> a * a;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><p>volatile 关键字是一种类型修饰符。volatile 提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。如 果没有 volatile 关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。所以遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typedef</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/typedef/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/typedef/</url>
    
    <content type="html"><![CDATA[<p>用途：</p><p>1.定义一种类型的别名，而不只是简单的宏替换</p><p>需要注意的是int 和 unsigned int是不同的类型，需要起不同的别名</p><p>2.帮助struct声明新对象</p><p>3.用typedef来定义与平台无关的类型。</p><p>比如定义一个叫 REAL 的浮点类型，在目标平台一上，让它表示最高精度的类型为：</p><p>typedef long double REAL;</p><p>在不支持 long double 的平台二上，改为：</p><p>typedef double REAL;</p><p>在连 double 都不支持的平台三上，改为：</p><p>typedef float REAL;</p><p>也就是说，当跨平台时，只要改下 typedef 本身就行，不用对其他源码做任何修改。</p><p>例如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> int64;<br></code></pre></td></tr></table></figure><p>要给long long改名的原因是，VC6没有long long，只有__int64。于是在其它编译器写好的代码一弄到VC6里面就不能编译过了，所以在开始位置加一个</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> int64;<br></code></pre></td></tr></table></figure><p>当移到VC6中编译时，只用改成</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">typedef</span> __int64 <span class="hljs-built_in">int64</span>;<br></code></pre></td></tr></table></figure><p>4.typedef和#define</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核中的指针函数返回错误码</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E9%94%99%E8%AF%AF%E7%A0%81/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/Linux%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E9%94%99%E8%AF%AF%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>在linux内核中，一个返回指针的函数如何表示错误返回呢？</p><p>首先任何一个指针必然有三种情况：有效指针、NULL或空指针、错误指针或无效指针。显然使用一个空指针NULL是无法表示和区分各种执行错误的，应该将无效指针对应着内核中的错误号。</p><p>内核中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_ERRNO    4095    <span class="hljs-comment">/* 4k */</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IS_ERR_VALUE(x) unlikely((x) &gt;= (unsigned long)-MAX_ERRNO)  <span class="hljs-comment">/* &gt;=0xfffff001 */</span></span><br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> *<span class="hljs-title">ERR_PTR</span><span class="hljs-params">(<span class="hljs-type">long</span> error)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *) error;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> <span class="hljs-title">PTR_ERR</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *ptr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">long</span>) ptr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> <span class="hljs-title">IS_ERR</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *ptr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">IS_ERR_VALUE</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)ptr);<br>&#125;<br></code></pre></td></tr></table></figure><p>所有的驱动程序都运行在内核空间，在内核空间中的最后一个page是被保留的(假设4k一个page)，用于内核捕捉错误。比如对于32位的系统来说，内核最高地址为0xff ff ff ff，那么最后一个page就是0xff ff f0 00~0xff ff ff ff(最后一page最少为4k)。如果发现你的一个指针指向这个范围内的一个地址，那么这个指针就是个无效指针，于是内核使用IS_ERR()来判断当前指针是否在这个范围内([0xfffff001, 0xffffffff])。</p><p>而PTR_ERR(), ERR_PTR()只是强制转换一下，PTR 是单词 pointer 的缩写，ERR 是单词 errno   的缩写，PTR_ERR 即将指针转换为错误码，ERR_PTR 即将错误码转换为指针。若你只需要知道是否出错，而不在乎为什么出错，那你就可以不调用PTR_ERR()。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _ASM_GENERIC_ERRNO_BASE_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPERM        1  <span class="hljs-comment">/* Operation not permitted */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENOENT       2  <span class="hljs-comment">/* No such file or directory */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ESRCH        3  <span class="hljs-comment">/* No such process */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EINTR        4  <span class="hljs-comment">/* Interrupted system call */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EIO      5  <span class="hljs-comment">/* I/O error */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENXIO        6  <span class="hljs-comment">/* No such device or address */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> E2BIG        7  <span class="hljs-comment">/* Argument list too long */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENOEXEC      8  <span class="hljs-comment">/* Exec format error */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EBADF        9  <span class="hljs-comment">/* Bad file number */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ECHILD      10  <span class="hljs-comment">/* No child processes */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EAGAIN      11  <span class="hljs-comment">/* Try again */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENOMEM      12  <span class="hljs-comment">/* Out of memory */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EACCES      13  <span class="hljs-comment">/* Permission denied */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EFAULT      14  <span class="hljs-comment">/* Bad address */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENOTBLK     15  <span class="hljs-comment">/* Block device required */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EBUSY       16  <span class="hljs-comment">/* Device or resource busy */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EEXIST      17  <span class="hljs-comment">/* File exists */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXDEV       18  <span class="hljs-comment">/* Cross-device link */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENODEV      19  <span class="hljs-comment">/* No such device */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENOTDIR     20  <span class="hljs-comment">/* Not a directory */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EISDIR      21  <span class="hljs-comment">/* Is a directory */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EINVAL      22  <span class="hljs-comment">/* Invalid argument */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENFILE      23  <span class="hljs-comment">/* File table overflow */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EMFILE      24  <span class="hljs-comment">/* Too many open files */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENOTTY      25  <span class="hljs-comment">/* Not a typewriter */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ETXTBSY     26  <span class="hljs-comment">/* Text file busy */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EFBIG       27  <span class="hljs-comment">/* File too large */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENOSPC      28  <span class="hljs-comment">/* No space left on device */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ESPIPE      29  <span class="hljs-comment">/* Illegal seek */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EROFS       30  <span class="hljs-comment">/* Read-only file system */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EMLINK      31  <span class="hljs-comment">/* Too many links */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPIPE       32  <span class="hljs-comment">/* Broken pipe */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EDOM        33  <span class="hljs-comment">/* Math argument out of domain of func */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERANGE      34  <span class="hljs-comment">/* Math result not representable */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>page = <span class="hljs-built_in">__get_free_pages</span>(GFP_KERNEL,<span class="hljs-number">3</span>);<br><span class="hljs-keyword">if</span> (!page)&#123;<br>        <span class="hljs-comment">/*没有足够的内存：你必须处理这种错误！*/</span><br>        <span class="hljs-keyword">return</span> -ENOMEM;    <span class="hljs-comment">/* 错误码加负号 */</span><br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核代码风格</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/Linux%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/Linux%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<p>一、缩进</p><p>1.1 switch</p><p>（1）switch和case标签从属一列</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">switch</span> (suffix)&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;G&#x27;</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;g&#x27;</span>:<br>        mem &lt;&lt;= <span class="hljs-number">30</span>;<br>        <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;M&#x27;</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;m&#x27;</span>:<br>        mem &lt;&lt;= <span class="hljs-number">20</span>;<br>        <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）不要把多个语句放一行，除非想隐藏什么</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if (condition) do_this<span class="hljs-comment">;</span><br>    do_something_everytime<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>（3）不要一行放多个赋值语句，防止别人误读</p><p>1.2 长的行与字符串应该打乱</p><p>每一行的长度的限制是 80 列，长于 80 列的语句要打散成有意义的片段。</p><p>1.3 大括号和空格的放置</p><p>（1）起始大括号放在行尾，而把结束大括号放在行首，适用于所有的<strong>非函数</strong>语句块 (if, switch, for, while, do)。这种大括号的放置方式也能使空行的数量最小化。</p><p>（2）空格</p><p>①关键字后要加一个空格（除了sizeof, typeof, alignof 和 __attribute__这些更像函数的关键字）</p><p>②不要在小括号里的表达式两侧加空格</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">s</span> <span class="hljs-operator">=</span> sizeof( struct file )<span class="hljs-comment">;    //反例</span><br></code></pre></td></tr></table></figure><p>③ * 的首选使用方式是使之靠近变量名或函数名，而不是类型名</p><p>④在大多数二元和三元操作符两侧使用一个空格</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">=  +  -  &lt;  &gt;  *  /  %  |  &amp;  ^  &lt;=  &gt;=  ==  !=  ?  <span class="hljs-symbol">:</span><br></code></pre></td></tr></table></figure><p>⑤一元操作符后不要加空格</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">&amp;  *  +  -  ~  !  <span class="hljs-built_in">sizeof</span>  <span class="hljs-built_in">typeof</span>  alignof  <span class="hljs-variable">__attribute__</span>  defined<br></code></pre></td></tr></table></figure><p>⑥. 和 -&gt; 结构体成员操作符前后不加空格。</p><p>1.4 命名</p><p>不混用大小写，使用全小写简称，能够表达相关含义。且全局变量需要一个具有描述性的名字，如有一个可以计算活动用户数量的函数，你应该叫它 count_active_users() 或者类似的名字，你不应该叫它 cntuser() 。</p><p>1.5 typedef</p><p>（1）不要对结构体或指针使用typedef</p><p>（2）只在下列情况下使用：</p><p>① 清楚的整数类型</p><p>②完全不透明的对象，真的是完全没有任何共用的可访问信息。</p><p><span style="background-color: #ffaaaa">③当你使用 sparse 按字面的创建一个新类型来做类型检查的时候。</span></p><p><span style="background-color: #ffaaaa">④</span><span style="background-color: #ffaaaa">和标准 C99 类型相同的类型。</span><span style="background-color: #ffaaaa">当编辑已经使用了某个类型集的已有代码时，你应该遵循那些代码中已经做出的选择。</span></p><p><span style="background-color: #ffaaaa">⑤</span><span style="background-color: #ffaaaa">可以在用户空间安全使用的类型</span></p><span style="background-color: #ffaaaa"></span><p>1.6 函数</p><p>（1）函数应该简短而漂亮，并且只完成一件事情，函数应该可以一屏或者两屏显示完 。</p><p>（2）复杂的函数遵守前面提到的长度限制，使用辅助函数，并为之取个具描述性的名字（如果你觉得它们的性能很重要的话，可以让编译器内联它们，直接把机器码插入调用它们的地方）</p><p>（3）本地变量的数量不应超过 5－10 个</p><p><span style="background-color: #ffaaaa">（4）如果该函数需要被导出，它的 EXPORT 宏应该紧贴在它的结束大括号之下。</span></p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nsis">int <span class="hljs-params">system</span>_is_up(void)<br>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-params">system</span>_state == <span class="hljs-params">SYSTEM</span>_RUNNING<span class="hljs-comment">;</span><br>&#125;<br>EXPORT_SYMBOL(<span class="hljs-params">system</span>_is_up)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>1.7 集中的函数退出途径</p><p>当一个函数从多个位置退出，并且需要做一些类似清理的常见操作时，使用goto 语句很方便。</p><p>（1）goto需要一个描述性标签名（别去使用像 err1: 和 err2: 的 名称，因为你添加退出路径后，你就必须对它们重新编号）</p><p>（2）注意一个常见错误，先释放结构体成员，然后释放结构体</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">err:<br>        <span class="hljs-built_in">kfree</span>(foo-&gt;bar);<br>        <span class="hljs-built_in">kfree</span>(foo);<br>        return ret;<br></code></pre></td></tr></table></figure><p>这段代码的错误是，在某些退出路径上 foo 是 NULL。通常情况下，通过把它分离 成两个错误标签 err_free_bar: 和 err_free_foo: 来修复这个错误：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">err_free_bar:<br>       <span class="hljs-built_in">kfree</span>(foo-&gt;bar);err_free_foo:<br>       <span class="hljs-built_in">kfree</span>(foo);<br>       return ret;<br></code></pre></td></tr></table></figure><p>理想情况下，你应该模拟错误来测试所有退出路径。</p><p>1.8 注释</p><p>（1）告诉别人你的代码做了什么，而不是怎么做的。</p><p>（2）做一些小注释来注明或警告某些很聪明(或者槽糕)的做法，但不要加太多。</p><p>（3）把注释放在函数的头部。告诉人们它做了什么， 也可以加上它做这些事情的原因。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This is the preferred style for multi-line</span><br><span class="hljs-comment"> * comments in the Linux kernel source code.</span><br><span class="hljs-comment"> * Please use it consistently.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Description:  A column of asterisks on the left side,</span><br><span class="hljs-comment"> * with beginning and ending almost-blank lines.</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>（4）一行应只声明一个数据，对数据进行注释</p><p>1.9 宏，枚举和RTL</p><p>定义常量的宏的名字及枚举里的标签需要大写。在定义几个相关的常量时，最好用枚举。</p><p>（1）少写宏函数。</p><p>（2）依赖于一个本地名字的宏</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">FOO</span>(val) <span class="hljs-built_in">bar</span>(index, val)<br></code></pre></td></tr></table></figure><p>（3）带参数的宏避免称为左值</p><p>（4）忘记了优先级：使用表达式定义常量的宏必须将表达式置于一对小括号之内。带参数的宏也要注意此类问题</p><p>1.10 分配内存</p><p>（1）传递结构体大小的首选形式</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">p</span> = <span class="hljs-built_in">kmalloc</span>(<span class="hljs-built_in">sizeof</span>(*p), ...)<br></code></pre></td></tr></table></figure><p>（2）分配一个数组的首选形式</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">p = kmalloc<span class="hljs-constructor">_array(<span class="hljs-params">n</span>, <span class="hljs-params">sizeof</span>(<span class="hljs-operator">...</span>)</span>, ...)<br></code></pre></td></tr></table></figure><p>（3）分配一个零长数组的首选形式</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">p</span> = <span class="hljs-built_in">kmalloc</span>(n, <span class="hljs-built_in">sizeof</span>(...), ...)<br></code></pre></td></tr></table></figure><p>两种形式检查分配大小 n * sizeof(…) 的溢出，如果溢出返回 NULL。</p><p>1.11 内联弊病</p><p>inline 的过度使用会使内核变大，从而使整个系统运行速度变慢。</p><p>一个基本的原则是如果一个函数有 3 行以上，就不要把它变成内联函数。</p><p>1.12 函数返回值及命名</p><p>如果函数的名字是一个动作或者强制性的命令，那么这个函数应该返回错误代码整数。如果是一个判断，那么函数应该返回一个 “成功” 布尔值。</p><p>返回值是实际计算结果而不是计算是否成功的标志的函数不受此惯例的限制。一般的， 他们通过返回一些正常值范围之外的结果来表示出错。典型的例子是返回指针的函数， 他们使用 NULL 或者 ERR_PTR 机制来报告错误。</p><p>1.13 条件编译</p><p>只要可能，不要在.c文件里使用预处理条件(#if，#ifdef)，这样使代码更难阅读。</p><p>最好倾向于编译整个函数，而不是函数或表达式的一部分。与其放一个 ifdef 在表达式内，不如分解出部分或全部表达式，放进一个单独的辅助函数，并应用预处理条件到这个辅助函数内。</p><p>如果你有一个在特定配置中，可能变成未使用的函数或变量，编译器会警告它定义了但 未使用，把它标记为 __maybe_unused 而不是将它包含在一个预处理条件中。</p><p>在任何有意义的 #if 或 #ifdef 块的末尾 (超过几行的)，在 #endif 同一行的后面写下 注解，注释这个条件表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SOMETHING</span><br>...<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_SOMETHING */</span></span><br></code></pre></td></tr></table></figure><p>1.14 数据结构</p><p>如果一个数据结构，在创建和销毁它的单线执行环境之外可见，那么它必须要有一个引用计数器。</p><p>1.15你已经把事情弄糟了</p><p>GNU indent 和 GNU emacs</p><p>1.16 Kconfig 配置文件</p><p>1.17打印内核消息</p><p>1.18 不要重新发明内核宏</p><hr><p><a href="https://www.kernel.org/doc/html/v4.13/translations/zh_CN/coding-style.html#id2">https://www.kernel.org/doc/html/v4.13/translations/zh_CN&#x2F;coding-style.html#id2</a></p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux_C</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/Linux_C/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/Linux_C/</url>
    
    <content type="html"><![CDATA[<p>open函数属于Linux中系统IO，用于“打开”文件，代码打开一个文件意味着获得了这个文件的访问句柄。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> fd = open（参数<span class="hljs-number">1</span>，参数<span class="hljs-number">2</span>，参数<span class="hljs-number">3</span>）；<br></code></pre></td></tr></table></figure><p>包含头文件：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br></code></pre></td></tr></table></figure><p>参数1（pathname）</p><p>即将要打开的文件路径,例如：“a.txt”当前目录下的a.txt文件</p><p>参数2（flags）</p><p>flags分为两类：主类，副类</p><p>主类：O_RDONLY 以只读方式打开 &#x2F; O_WRONLY 以只写方式打开 &#x2F;O_RDWR 以可读可写方式打开</p><p>参数3（mode）</p><p>mode：如果文件被新建，指定其权限为mode</p><p>mode是八进制权限码，0777表示文件所有者 该文件用户组 其他用户都有可读可写可执行权限</p><p>打开失败返回-1</p><hr><p>int main(int argc, char **argv)</p><p>argc、argv的具体含义:argc和argv参数在用命令行编译程序时有用。</p><p>main( int argc, char* argv[], char **env ) 中</p><p>第一个参数，int型的argc，为整型，用来统计程序运行时发送给main函数的命令行参数的个数，在VS中默认值为1。</p><p>第二个参数，char*型的argv[]，为字符串数组，用来存放指向的字符串参数的指针数组，每一个元素指向一个参数。各成员含义如下：</p><p>argv[0]指向程序运行的全路径名</p><p>argv[1]指向在DOS命令行中执行程序名后的第一个字符串</p><p>argv[2]指向执行程序名后的第二个字符串</p><p>argv[3]指向执行程序名后的第三个字符串</p><p>argv[argc]为NULL</p><hr><p>链表、队列、结构体、宏定义</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gcc指令与程序的预编译编译汇编链接运行</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/gcc%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E7%BC%96%E8%AF%91%E6%B1%87%E7%BC%96%E9%93%BE%E6%8E%A5%E8%BF%90%E8%A1%8C/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/gcc%E6%8C%87%E4%BB%A4%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E7%BC%96%E8%AF%91%E6%B1%87%E7%BC%96%E9%93%BE%E6%8E%A5%E8%BF%90%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">hello.c<span class="hljs-function"><span class="hljs-params">(预处理)</span> -&gt;</span> hello.i<span class="hljs-function"><span class="hljs-params">(编译)</span> -&gt;</span> hello.s<span class="hljs-function"><span class="hljs-params">(汇编)</span> -&gt;</span> hello.o<span class="hljs-function"><span class="hljs-params">(链接)</span> -&gt;</span> hello<br></code></pre></td></tr></table></figure><p>一，预编译</p><p>1.1 操作步骤：gcc -E hello.c -o hello.i</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">使用预处理命令时，最好将c文件中的<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>注释掉，这样结果更加直观</span><br></code></pre></td></tr></table></figure><p>1.2 主要作用：处理关于 “#” 的指令</p><p>（1）删除#define，展开所有宏定义。例#define portnumber 3333</p><p>（2）处理条件预编译 #if, #ifdef, #if, #elif,#endif</p><p>（3）处理“#include”预编译指令，将包含的“.h”文件插入对应位置。这可是递归进行的，文件内可能包含其他“.h”文件。</p><p>（4）删除所有注释。&#x2F;**&#x2F;，&#x2F;&#x2F;。</p><p>（5）添加行号和文件标识符。用于显示调试信息：错误或警告的位置。</p><p>（6）保留#pragma编译器指令。（1）设定编译器状态，（2）指示编译器完成一些特定的动作。</p><p>二、编译（编译器主要做了什么）</p><p>2.1 操作步骤：gcc -s hello.c -o hello.s</p><p>2.2 主要作用：1.扫描（词法分析），2.语法分析，3.语义分析，4.源代码优化（中间语言生成），5.代码生成，目标代码优化。</p><p>（1）将源代码程序输入扫描器，将源代码的字符序列分割成一系列记号。例array[index] &#x3D;  (index + 4) * (2 + 6);</p><p>（2）基于词法分析得到的一系列记号，生成语法树。</p><p>（3）由语义分析器完成，指示判断是否合法，并不判断对错。又分静态语义：隐含浮点型到整形的转换，会报warning，</p><p>  动态语义：在运行时才能确定：例1除以3</p><p>（4）中间代码（语言）使得编译器分为前端和后端，前端产生与机器（或环境）无关的中间代码，编译器的后端将中间代码转换为目标机器代码，目的：一个前端对多个后端，适应不同平台。</p><p>（5）编译器后端主要包括：代码生成器:依赖于目标机器，依赖目标机器的不同字长，寄存器，数据类型等</p><p>    目标代码优化器:选择合适的寻址方式，左移右移代替乘除，删除多余指令。</p><p>三，汇编</p><p>操作步骤：gcc -c hello.c -o hello.o</p><p>主要作用：汇编器是将汇编代码转变成可以执行的指令，生成目标文件。</p><p><span style="background-color: #ffaaaa">四，链接（参考狄泰）</span></p><p>操作步骤：gcc hello.o -o hello</p><p>主要作用：链接过程使用链接器将该目标文件与其他目标文件、库文件、启动文件等链接起来生成可执行文件。</p><p>附加的目标文件包括静态连接库和动态连接库。</p><p>链接所完成的任务是合并段表，然后把符号表合并并且对符号表进行重定位。</p><p>所谓合并段表，源代码编译生成的a.out会包含很多段，数据段文本段bss段等等，这些段是合并出来的，在编译过程中划分出来出来的，不同的数据会对应到不同的段中，在.o文件中其实已经发生了分段。</p><p>符号表合并和重定位说的是最后只生成了一个符号表，这个符号表是由前面汇编形成的多个符号表进行合并。在这里不在同一个符号表的符号，要对他们进行重定位。链接完成以后，也就生成了我们所说的.exe文件重点内容。</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言知识补充</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/</url>
    
    <content type="html"><![CDATA[<figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs thrift"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tagPoint</span></span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-type">double</span> x;<br><span class="hljs-type">double</span> y;<br><span class="hljs-type">double</span> z;<br>&#125; Point;<br></code></pre></td></tr></table></figure><p>在上面的代码中，实际上完成了两个操作：</p><p>1、定义了一个新的结构类型，代码如下所示：</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs thrift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tagPoint</span></span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-type">double</span> x;<br><span class="hljs-type">double</span> y;<br><span class="hljs-type">double</span> z;<br>&#125; ;<br></code></pre></td></tr></table></figure><p>其中，struct 关键字和 tagPoint 一起构成了这个结构类型，无论是否存在 typedef 关键字，这个结构都存在。</p><p>2、使用 typedef 为这个新的结构起了一个别名，叫 Point，即：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">tagPoint</span> Point<br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">typedef struct tagNode<br>&#123;<br>char *pItem<span class="hljs-comment">;</span><br>pNode pNext<span class="hljs-comment">;</span><br>&#125; *pNode<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>从表面上看，上面的示例代码与前面的定义方法相同，所以应该没有什么问题。但是编译器却报了一个错误，为什么呢？莫非 C 语言不允许在结构中包含指向它自己的指针？</p><p>其实问题并非在于 struct 定义的本身，大家应该都知道，C 语言是允许在结构中包含指向它自己的指针的，我们可以在建立链表等数据结构的实现上看到很多这类例子。那问题在哪里呢？其实，根本问题还是在于 typedef 的应用。</p><p>在上面的代码中，新结构建立的过程中遇到了 pNext 声明，其类型是 pNode。这里要特别注意的是，pNode 表示的是该结构体的新别名。于是问题出现了，在结构体类型本身还没有建立完成的时候，编译器根本就不认识 pNode，因为这个结构体类型的新别名还不存在，所以自然就会报错。因此，我们要做一些适当的调整，比如将结构体中的 pNext 声明修改成如下方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">tagNode</span><br>&#123;<br><span class="hljs-type">char</span> *pItem;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">tagNode</span> *pNext;<br>&#125; *pNode;<br></code></pre></td></tr></table></figure><hr><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">    #<span class="hljs-keyword">define</span> FREE(p) if(p) &#123; \<br>                        <span class="hljs-keyword">free</span>(p)<span class="hljs-comment">; \</span><br>                        p <span class="hljs-operator">=</span> NULL<span class="hljs-comment">; \</span><br>                    &#125;<br></code></pre></td></tr></table></figure><hr><p>形参列表</p><p>虽然可以在形参列表中定义多个参数，但是，在编写程序的时候，要考虑函数模块之间的“耦合性”和“扩展性”。不要传递太多的参数。如果项目需求改动，需要修改某个参数，就会导致函数接口的改动，函数接口的改动对程序的改动很大，这种操作应该极力避免。</p><p>当学习到结构体之后，我们可以把多个参数封装到一个结构体中，函数的参数只需要传递一个结构体变量就OK了。那么，当有数据需要改动，只需要修改结构体的定义和数据，函数的接口不需要修改，那么，函数模块之间的耦合性就降低，提高程序函数模块之间的扩展性。这就是函数模块扩展性好的一个表现形式，也是定义函数时需要思考的注意点。</p><hr><p>关系运算符巧记</p><hr><p>赋值小于关系判断，小于算术运算。</p><p>关系判断大于算术运算。</p><p>++优先集相当大，仅次于（）</p><p>比如c&#x3D;getchar()&#x3D;&#x3D;’a’</p><p>这个算相当经典的了。根据上面说的。要先计算关系判断，所以相当于</p><p>c&#x3D;(getchar()&#x3D;&#x3D;’a’)</p><p>你可以找几个式子带一下，不清楚再来hi我</p><p>其次要记住这些符号的结合性。也就是从左到右还是从右到左</p><p>比如赋值。就是从右向左</p><p>x&#x3D;a&#x3D;b&#x3D;3;</p><p>相当于b&#x3D;3</p><p>a&#x3D;b</p><p>x&#x3D;a</p><p>所以最后 是x&#x3D;3</p><p><a href="https://blog.csdn.net/EI_Capitan/article/details/109533417?utm_medium=distribute.pc_relevant_bbs_down.none-task--2~all~first_rank_v2~rank_v29-1.nonecase&depth_1-utm_source=distribute.pc_relevant_bbs_down.none-task--2~all~first_rank_v2~rank_v29-1.nonecase">https://blog.csdn.net/EI_Capitan&#x2F;article&#x2F;details&#x2F;109533417?utm_medium&#x3D;distribute.pc_relevant_bbs_down.none-task--2<del>all</del>first_rank_v2<del>rank_v29-1.nonecase&amp;depth_1-utm_source&#x3D;distribute.pc_relevant_bbs_down.none-task--2</del>all<del>first_rank_v2</del>rank_v29-1.nonecase</a></p><hr><p>#include &lt;filename&gt;</p><p>尖括号是预处理到系统规定的路径中去获得这个文件（即 C 编译系统所提供的并存放在指定的子目录下的头文件）。找到文件后，用文件内容替换该语句。如stdio.h</p><p>#include“filename”</p><p>“”则是预处理我们自己第三方的文件，如程序员小刘写的Date.h，我们就可以include“Date.h”</p><hr><p>（1）一个有10个指针的数组，该指针是指向一个整型数的</p><p>（2）一个指向有10个整型数数组的指针</p><p>（3） 一个指向函数的指针，该函数有一个整型参数并返回一个整型数</p><p>（4） 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数</p><p>（1）int *a[10]; </p><p>（2）int (*a)[10]; </p><p>（3）int (*a)(int); </p><p>（4）int (*a[10])(int);</p><hr><p>数组：</p><p>1.int a[10] &#x3D; {0};这个常见的数组初始化语句其实是将数组的第一个元素初始化为0，然后数组本身的特性是将其余未初始化的数据初始化为0，故做到了将数组全部元素初始化为0</p><p>2.数组首元素的地址值虽然与数组的地址值相同，但数组首元素的地址与数组的地址是两个不同的概念。</p><p>我们常说的地址实际包含了起始地址和所占内存的长度。</p><p>数组名指向的数组名”指向”的是内存中数组首元素的起始位置，即数组名不包含数组的长度信息</p><hr><p>指针：</p><p>1.指针与指针之间只支持减法运算，且参与减法运算的指针类型必须相同。</p><p>2.只有当两个指针指向同一个数组中的元素时,指针相减才有意义,其意义为指针所指元素的下标差。若是指向两个数组的同类型指针相减则语法正确，但结果未知没有意义。</p><p>数组的边界位置：</p><p>指针可以指向数组最后一个元素后面的位置，这个位置是属于c语言的“擦边球”边界位置，在这个边界位置上我们认为这个指针是合法的，但这个位置再后面的元素都是没有意义的了</p><hr><p><strong>数组和指针的可交换性：数组并非指针</strong></p><p>一、声明和定义</p><p>定义：只能存在于一个地方。<strong>确定</strong>对象的类型并分配内存，用于创建新的对象。例如：int my_array[100]</p><p>声明：可以多次出现。<strong>描述</strong>对象的类型，<strong>用于指代</strong>其他地方定义的对象（例如在其他文件里），例：extern int my_array[]；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">文件<span class="hljs-number">1</span>：<br><span class="hljs-type">int</span> p[<span class="hljs-number">100</span>];        <span class="hljs-comment">//定义</span><br>文件<span class="hljs-number">2</span>：<br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> *p;     <span class="hljs-comment">//错误声明</span><br></code></pre></td></tr></table></figure><p>定义与声明必须匹配。</p><p>二、数组和指针的不可互换</p><p>2.1 数组和指针的引用方式</p><p>指针：间接访问，首先取得指针的内容，把它作为地址，然后从这个地址提取数据。如果指针有一个下标[I]，就把指针的内容加上I作为地址，从中提取数据</p><p>数组：直接访问数据，a[I]只是简单地以a+I为地址取得数据</p><p> 例：</p><p>每个符号的地址在编译时可知，存在符号表中。该表记录了变量和内存地址的一一对应关系。</p><p>（1）定义为数组并引用</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">char a[<span class="hljs-number">9</span>] <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcdef&quot;</span><span class="hljs-comment">;</span><br><span class="hljs-attribute">c</span> <span class="hljs-operator">=</span> a[i]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>编译器符号表中有一个地址9980</p><ul><li>运行时步骤一：取i的值，将它与9980相加</li><li>运行时步骤二：取地址（9980+i）的内容</li></ul><p>（2）定义为指针并引用</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">char *p <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcdef&quot;</span><span class="hljs-comment">;</span><br><span class="hljs-attribute">c</span> <span class="hljs-operator">=</span> *p<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>编译器符号表中有一个符号p，地址为4624</p><ul><li>运行时步骤一：取地址4624的值，得到’5081’</li><li>运行时步骤二：取地址5081的内容</li></ul><p>（3）定义为指针，但以数组方式引用</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">char *p <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcdef&quot;</span><span class="hljs-comment">;</span><br><span class="hljs-attribute">c</span> <span class="hljs-operator">=</span> p[i]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>编译器符号表中有一个符号p，地址为4624</p><ul><li>运行时步骤一：取地址4624的值，得到’5081’</li><li>运行时步骤二：取i的值，将它与5081相加</li><li>运行时步骤三：取地址（5081+i）的内容</li></ul><p>（4）定义为数组，外部文件声明为指针并引用</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">文件<span class="hljs-number">1</span>：<br>int p[<span class="hljs-number">100</span>] <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcdef&quot;</span><span class="hljs-comment">;        //定义</span><br>文件<span class="hljs-number">2</span>：<br>extern int *p<span class="hljs-comment">;     //错误声明</span><br><span class="hljs-attribute">c</span> <span class="hljs-operator">=</span> *p<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>编译器符号表中有一个符号p，地址为4624</p><ul><li>运行时步骤一：取地址4624的值，得到’a’<ul><li>原意取指针p上保存的数组地址，实际上取得了一个ASCII字符</li></ul></li><li>运行时步骤二：取地址’a’的内容<ul><li>ASCII字符解释为地址，结果未定义</li></ul></li></ul><p>故这样不能改写成指针的形式</p><p>2.2 使用字符串常量初始化</p><p>（1）定义指针时，编辑器并不为指针所指向的对象分配空间，它只分配指针自身的空间，除非在定义时同时赋给指针一个字符串常量进行初始化。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">char *p <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcdefg&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>但这个字符串常量被定义为只读，若试图通过指针修改这个字符串的值，程序就会出现未定义的行为</p><p>（2）定义数组时，也可以使用字符串常量进行初始化，且由字符串常量初始化的数组是可以修改的。</p><p>三、数组和指针可互换</p><p>3.1 “表达式中的数组名”就是指针</p><p>在表达式中，指针与数组是可以互换的，因为它们在编译器里的最终形式都是指针，且都可以进行取下标操作</p><p>3.2 C语言把数组下标作为指针的偏移量</p><p>用a[i]这样的形式对数组进行访问总是被编译器”改写”或解释为像*(a+1)这样的指针访问</p><p>3.3 “作为函数参数的数组名”等同于指针</p><p>C语言中所有非数组形式的数据实参均以传值形式（将实参做一份拷贝供函数使用修改）调用，但要拷贝整个数组需要的开销是非常大的。出于效率考虑，属于函数实参的数组在编译时被编译器改写为指针。类似的函数的返回值也不可以是个数组，而只能是指向数组或函数的指针。</p><p>（1）形参中：以下三种形式完全等同，但我们倾向于始终把参数定义为指针，因为这是编译器内部使用的形式。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">my<span class="hljs-constructor">_func(<span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">p</span>)</span>&#123;<span class="hljs-operator"> ... </span>&#125;<br>my<span class="hljs-constructor">_func(<span class="hljs-params">int</span> <span class="hljs-params">p</span>[])</span>&#123;<span class="hljs-operator"> ... </span>&#125;<br>my<span class="hljs-constructor">_func(<span class="hljs-params">int</span> <span class="hljs-params">p</span>[200])</span>&#123;<span class="hljs-operator"> ... </span>&#125;<br></code></pre></td></tr></table></figure><p>故没有办法把数组本身传递给函数，所有属于函数实参的数组在编译时被编译器改写为指针</p><p>（2）实参中：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">char my_array<span class="hljs-selector-attr">[10]</span>;<br>char *my_ptr;<br><span class="hljs-built_in">printf</span>(&quot;%s %s&quot;, my_ptr, my_array);<br></code></pre></td></tr></table></figure><p>总结：</p><p>1.用a[i]这样的形式对数组进行访问总是被编译器”改写”或解释为像*(a+1)这样的指针访问</p><p>2.指针始终不可改写成数组，当使用下标形式访问指针时，一般都是指针作为函数参数，且你知道实际传递给函数的是一个数组</p><p>3.在一个函数的调用中，作为函数参数的数组始终会被编译器修改成为指向数组第一个元素的指针</p><p>4.因此，当把一个数组定义为函数的参数时，可以选择把它定义为数组，也可以定义为指针。不管如何，函数内部事实上获得的都是一个指针</p><hr><p>.h与.c文件</p><p>在.c文件中使用全局变量记录其他文件会需要的变量，然后在.h文件中使用extern声明，这样别的文件只要包含.h文件就可以使用.c中的全局变量</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言习惯</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E4%B9%A0%E6%83%AF/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E4%B9%A0%E6%83%AF/</url>
    
    <content type="html"><![CDATA[<p>  <strong>01</strong>、版权和版本</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">版权和版本的声明位于头文件和定义文件的开头（参见示例1-1），主要内容有：<br>（1）版权信息。<br>（2）文件名称，标识符，摘要。<br>（3）当前版本号，作者/修改者，完成日期。<br>（4）版本历史信息。<br><br>/*<br><span class="hljs-bullet">* </span>Copyright (c) 2001,上海贝尔有限公司网络应用事业部<br><span class="hljs-bullet">* </span>All rights reserved.<br><span class="hljs-bullet">*</span><br><span class="hljs-bullet"></span><span class="hljs-bullet">* </span>文件名称：filename.h<br><span class="hljs-bullet">* </span>文件标识：见配置管理计划书<br><span class="hljs-bullet">* </span>摘要：简要描述本文件的内容<br><span class="hljs-bullet">*</span><br><span class="hljs-bullet"></span><span class="hljs-bullet">* </span>当前版本：1.1<br><span class="hljs-bullet">* </span>作者：输入作者（或修改者）名字<br><span class="hljs-bullet">* </span>完成日期：2001年7月20日<br><span class="hljs-bullet">*</span><br><span class="hljs-bullet"></span><span class="hljs-bullet">* </span>取代版本：1.0<br><span class="hljs-bullet">* </span>原作者：输入原作者（或修改者）名字<br><span class="hljs-bullet">* </span>完成日期：2001年5月10日<br>*/<br></code></pre></td></tr></table></figure><p>      </p><p> ** 02**、缩进、空格、换行、空行、对齐</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/eternal_yangyun/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">82936434</span><br><span class="hljs-number">1</span>.括号、运算符号前后加空格，<br><span class="hljs-number">2</span>.<span class="hljs-keyword">if</span>等条件语句判断条件多或者函数参数多，活用换行并对齐<br>iii) 换行。<br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;len; i++) &#123;<br>        <span class="hljs-keyword">if</span> ( ( a[i] &lt; <span class="hljs-string">&#x27;0&#x27;</span> || a[i] &gt; <span class="hljs-string">&#x27;9&#x27;</span> ) &amp;&amp;<br>             ( a[i] &lt; <span class="hljs-string">&#x27;a&#x27;</span> || a[i] &gt; <span class="hljs-string">&#x27;z&#x27;</span> ) ) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>函数参数多的时候，最好也换行，如：<br>    CreateProcess(<br>                  NULL,<br>                  cmdbuf,<br>                  NULL,<br>                  NULL,<br>                  bInhH,<br>                  dwCrtFlags,<br>                  envbuf,<br>                  NULL,<br>                  &amp;siStartInfo,<br>                  &amp;prInfo<br>                 );<br>    条件语句也应该在必要时换行：<br>    <span class="hljs-keyword">if</span> ( ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> || ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span> ||<br>         ch &gt;= <span class="hljs-string">&#x27;a&#x27;</span> || ch &lt;= <span class="hljs-string">&#x27;z&#x27;</span> ||<br>         ch &gt;= <span class="hljs-string">&#x27;A&#x27;</span> || ch &lt;= <span class="hljs-string">&#x27;Z&#x27;</span> )<br><br>对齐。用TAB键对齐你的一些变量的声明或注释，一样会让你的程序好看一些。如：<br>typedef struct _pt_man_t_ &#123;<br>    int     numProc;    <span class="hljs-regexp">/* Number of processes                 */</span><br>    int     maxProc;    <span class="hljs-regexp">/* Max Number of processes             */</span><br>    int     numEvnt;    <span class="hljs-regexp">/* Number of events                    */</span><br>    int     maxEvnt;    <span class="hljs-regexp">/* Max Number of events                */</span><br>    HANDLE* pHndEvnt;   <span class="hljs-regexp">/* Array of events                     */</span><br>    DWORD   timeout;    <span class="hljs-regexp">/* Time out interval                   */</span><br>    HANDLE  hPipe;      <span class="hljs-regexp">/* Namedpipe                           */</span><br>    TCHAR   usr[MAXUSR];<span class="hljs-regexp">/* User name of the process            */</span><br>    int     numMsg;     <span class="hljs-regexp">/* Number of Message                   */</span><br>    int     Msg[MAXMSG];<span class="hljs-regexp">/* Space for intro process communicate */</span><br>&#125; PT_MAN_T;<br></code></pre></td></tr></table></figure><p>       </p><p> <strong>03</strong>、程序注释</p><p>少用&#x2F;&#x2F;注释</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/**/</span>(块注释)与<span class="hljs-regexp">//</span>(行注释)嵌套使用<br>但是一些老版本的C编译器并不支持行注释，所以为了你的程序的移植性，请你还是尽量使用块注释<br><br>你也许会为块注释的不能嵌套而不爽，那么你可以用预编译来完成这个功能。使用“<span class="hljs-comment">#if 0”和“#endif”括起来的代码，将不被编译，而且还可以嵌套。</span><br></code></pre></td></tr></table></figure><p>      </p><p>  <strong>04</strong>、函数的[in][out]参数</p><p><a href="https://blog.csdn.net/z_cqupt/article/details/89153852">https://blog.csdn.net/z_cqupt&#x2F;article&#x2F;details&#x2F;89153852</a></p><p>函数名实际上是一个指针常量，即这个函数的地址。</p><p>函数的返回值经常并不是函数的输出部分，而多用于返回0或1表示是否成功。</p><p>函数的形参既可以用来输入也可以用作输出，在函数需要多个返回值的时候就使用形参进行输出。形参参数可以分为输入型参数与输出型参数，传入的普通变量就一定是输入型的参数，但只有传入的指针才可能是输出型参数。</p><p>常常在指针形参前加上一个const表示这是个输入型参数，例如const int *p表示p指向的地址可以改变，p本身不能改变，作者：“这是我的输入参数，你改我输入干嘛”</p><p><strong>05</strong>、对系统调用的返回进行判断</p><p>对于一些系统调用，调用结束后需要进行判断后再使用，比如：文件句柄、socket返回的socket号，malloc返回的内存。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">    fp = fopen(<span class="hljs-string">&quot;log.txt&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>);<br>    <span class="hljs-keyword">if</span> ( fp == <span class="hljs-literal">NULL</span> )&#123;<br>        printf(<span class="hljs-string">&quot;Error: open file error/n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>06</strong>、if 语句对出错的处理</p><p>if语句中判断条件放出错的条件，这样可以突出错误，让别人一眼看到错误条件而下意识避免错误操作</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lasso">    <span class="hljs-keyword">if</span> ( ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span> )&#123;<br>        <span class="hljs-comment">/* 输出错误信息 */</span><br>        printf(<span class="hljs-string">&quot;error ......\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> ( <span class="hljs-literal">FALSE</span> );<br>    &#125;<br>   <br>    <span class="hljs-comment">/* 正常处理代码 */</span><br>    <span class="hljs-params">...</span><span class="hljs-params">...</span><br></code></pre></td></tr></table></figure><p><strong>07</strong>、头文件中的#ifndef</p><p>在大型的软件工程中，可能有多个文件包含一个头文件，当这些文件编译链接成一个可执行文件时，就会出现大量的“重定义”错误，所以在头文件头部就使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> <span class="hljs-string">&lt;标识&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> <span class="hljs-string">&lt;标识&gt;</span></span><br>...<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>标识的命名规则一般是头文件名全大写，前后加下划线，并把文件名中的“.”也变成下划线，如：stdio.h应为_STDIO_H_</p><p><strong>08</strong>、在堆上分配内存要及时释放(malloc和free)</p><p>stack上分配的内存系统自动释放，heap上分配的内存，除非手动释放系统永远不自动释放，哪怕程序退出，那一块内存还是在那里。stack一般是静态分配内存，heap上一般是动态分配内存。</p><p>由malloc系统函数分配的内存就是从堆上分配内存。从堆上分配的内存一定要自己用free释放。不然就是术语——“内存泄露”—— Memory Leak。系统的可分配内存会随malloc越来越少，直到系统崩溃。下面是“栈内存”和“堆内存”的差别。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    栈内存分配<br>    —————<br>    <span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">AllocStrFromStack</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">char</span> pstr[<span class="hljs-number">100</span>];<br>        <span class="hljs-keyword">return</span> pstr;<br>    &#125;<br>   <br>    堆内存分配<br>    —————<br>    <span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">AllocStrFromHeap</span><span class="hljs-params">(<span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">char</span> *pstr;<br>       <br>        <span class="hljs-keyword">if</span> ( len &lt;= <span class="hljs-number">0</span> ) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> ( <span class="hljs-type">char</span>* ) <span class="hljs-built_in">malloc</span>( len );<br>    &#125;<br></code></pre></td></tr></table></figure><p>对于第一个函数，那块pstr的内存在函数返回时就被系统释放了。于是所返回的char*什么也没有。而对于第二个函数，是从堆上分配内存，所以哪怕是程序退出时，也不释放，所以第二个函数的返回的内存没有问题，可以被使用。但一定要调用free释放，不然就是Memory Leak！</p><p>在堆上分配内存很容易造成内存泄漏，这是C&#x2F;C++的最大的“克星”，如果你的程序要稳定，那么就不要出现Memory Leak。所以，我还是要在这里千叮咛万嘱付，在使用malloc系统函数（包括calloc，realloc）时千万要小心。</p><p>   </p><p>对于malloc和free的操作有以下规则：</p><p>1) 配对使用，有一个malloc，就应该有一个free。</p><p>2) 尽量在同一层上使用，不要malloc在函数中，而free在函数外。最好在同一调用层上使用这两个函数。</p><p>3) malloc分配的内存一定要初始化(malloc前，将指针置NULL，NULL指不指向任何实体)。free后的指针一定要设置为NULL(free后，将指针置NULL)。   </p><p><strong>09</strong>、变量一定要被初始化再使用(包括全局变量和静态变量)</p><p>如：</p><p>    1) 对malloc分配的内存进行memset清零操作。（可以使用calloc分配一块全零的内存）</p><p>    2) 对一些栈上分配的struct或数组进行初始化。（最好也是清零）</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs gradle">memset:<br>功 能: 将s所指向的某一块内存中的每个字节的内容全部设置为ch指定的ASCII值,块的大小由第三个参数指定,这个函数通常为新申请的内存做初始化工作<br><span class="hljs-keyword">void</span> *memset(<span class="hljs-keyword">void</span> *s,<span class="hljs-keyword">int</span> c,size_t n)<br>作用：将已开辟内存空间 s 的首 n 个字节的值设为值 c（给空间初始化）；<br>C语言需要包含头文件string.h；C++需要包含cstring 或 string.h<br><br>calloc:<br><span class="hljs-keyword">void</span>* calloc (size_t num, size_t <span class="hljs-keyword">size</span>);<br>calloc() 函数用来动态地分配 num 个长度为 <span class="hljs-keyword">size</span> 字节内存空间并初始化为 <span class="hljs-number">0</span>，分配成功返回指向该内存的地址，失败则返回 <span class="hljs-keyword">NULL</span>。<br>函数的返回值类型是 <span class="hljs-keyword">void</span> *，所以在使用 calloc() 时通常需要进行强制类型转换。<br>calloc() 与 malloc() 的一个重要区别是：calloc() 在动态分配完内存后，自动初始化该内存空间为零，而<br>malloc() 不初始化，里边数据是未知的垃圾数据。<br><br><span class="hljs-comment">// calloc() 分配内存空间并初始化 </span><br><span class="hljs-keyword">char</span> *str1 = (<span class="hljs-keyword">char</span> *)calloc(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>); <br><span class="hljs-comment">// malloc() 分配内存空间并用 memset() 初始化 </span><br><span class="hljs-keyword">char</span> *str2 = (<span class="hljs-keyword">char</span> *)malloc(<span class="hljs-number">20</span>); <br>memset(str2, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure><p>但初始化也会造成系统运行时间有一定的开销，所以，也不需要对所有的变量做初始化。如：以下这种情况，则不需要。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">        char *pstr;  <span class="hljs-regexp">/* 一个字符串 */</span><br>        pstr = ( char* ) malloc( <span class="hljs-number">50</span> );<br>        <span class="hljs-keyword">if</span> ( pstr == NULL ) <span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>        strcpy( pstr, <span class="hljs-string">&quot;Hello Wrold&quot;</span> );<br></code></pre></td></tr></table></figure><p>但如果是下面一种情况，最好进行内存初始化。（指针也一定要初始化，赋值NULL或一个有效值）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">        char **pstr;  <span class="hljs-regexp">/* 一个字符串数组 */</span><br>        pstr = ( char** ) malloc( <span class="hljs-number">50</span>*sizeof(char*) );<br>        <span class="hljs-keyword">if</span> ( pstr == NULL ) <span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>       <br>        <span class="hljs-regexp">/* 让数组中的指针都指向NULL */</span><br>        memset( pstr, <span class="hljs-number">0</span>, <span class="hljs-number">50</span>*sizeof(char*) );<br></code></pre></td></tr></table></figure><p>而对于全局变量，和静态变量，一定要声明时就初始化</p><p><strong>10</strong>、h和c文件的使用</p><p>带初始化的全局变量不要放在H文件中，会造成每个包含该头文件的文件都有这个全局变量。因为C语言的include是直接将文件嵌入到include这个地方。</p><span style="background-color: #ffaaaa"></span><p><strong>11</strong>、重要的出错信息统一处理</p><p>出错信息或是提示信息，应该统一处理。如果要管理错误信息，那就要有以下的处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-comment">/* 声明出错代码 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_NO_ERROR    0  <span class="hljs-comment">/* No error                 */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_OPEN_FILE   1  <span class="hljs-comment">/* Open file error          */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_SEND_MESG   2  <span class="hljs-comment">/* sending a message error  */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_BAD_ARGS    3  <span class="hljs-comment">/* Bad arguments            */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_MEM_NONE    4  <span class="hljs-comment">/* Memeroy is not enough    */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_SERV_DOWN   5  <span class="hljs-comment">/* Service down try later   */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_UNKNOW_INFO 6  <span class="hljs-comment">/* Unknow information       */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_SOCKET_ERR  7  <span class="hljs-comment">/* Socket operation failed  */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_PERMISSION  8  <span class="hljs-comment">/* Permission denied        */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_BAD_FORMAT  9  <span class="hljs-comment">/* Bad configuration file   */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span>     ERR_TIME_OUT   10  <span class="hljs-comment">/* Communication time out   */</span></span><br>   <br>    <span class="hljs-comment">/* 声明出错信息 */</span><br>    <span class="hljs-type">char</span>* errmsg[] = &#123;<br>        <span class="hljs-comment">/* 0 */</span>       <span class="hljs-string">&quot;No error&quot;</span>,               <br>        <span class="hljs-comment">/* 1 */</span>       <span class="hljs-string">&quot;Open file error&quot;</span>,       <br>        <span class="hljs-comment">/* 2 */</span>       <span class="hljs-string">&quot;Failed in sending/receiving a message&quot;</span>,<br>        <span class="hljs-comment">/* 3 */</span>       <span class="hljs-string">&quot;Bad arguments&quot;</span>,<br>        <span class="hljs-comment">/* 4 */</span>       <span class="hljs-string">&quot;Memeroy is not enough&quot;</span>,<br>        <span class="hljs-comment">/* 5 */</span>       <span class="hljs-string">&quot;Service is down; try later&quot;</span>,<br>        <span class="hljs-comment">/* 6 */</span>       <span class="hljs-string">&quot;Unknow information&quot;</span>,<br>        <span class="hljs-comment">/* 7 */</span>       <span class="hljs-string">&quot;A socket operation has failed&quot;</span>,<br>        <span class="hljs-comment">/* 8 */</span>       <span class="hljs-string">&quot;Permission denied&quot;</span>,<br>        <span class="hljs-comment">/* 9 */</span>       <span class="hljs-string">&quot;Bad configuration file format&quot;</span>,<br>        <span class="hljs-comment">/* 10 */</span>      <span class="hljs-string">&quot;Communication time out&quot;</span>,<br>    &#125;;<br>                             <br>    <span class="hljs-comment">/* 声明错误代码全局变量 */</span><br>    <span class="hljs-type">long</span> errno = <span class="hljs-number">0</span>;<br>   <br>    <span class="hljs-comment">/* 打印出错信息函数 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">perror</span><span class="hljs-params">( <span class="hljs-type">char</span>* info )</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> ( info )&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: %s\n&quot;</span>, info, errmsg[errno] );<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error: %s\n&quot;</span>, errmsg[errno] );<br>    &#125;<br>这个基本上是ANSI的错误处理实现细节了，于是当你程序中有错误时你就可以这样处理：<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CheckPermission</span><span class="hljs-params">( <span class="hljs-type">char</span>* userName )</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">strcpy</span>(userName, <span class="hljs-string">&quot;root&quot;</span>) != <span class="hljs-number">0</span> )&#123;<br>            errno = ERR_PERMISSION_DENIED;<br>            <span class="hljs-keyword">return</span> (FALSE);<br>        &#125;<br>        ...<br>    &#125;<br>   <br>    <span class="hljs-built_in">main</span>()<br>    &#123;<br>        ...<br>        <span class="hljs-keyword">if</span> (! <span class="hljs-built_in">CheckPermission</span>( username ) )&#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;main()&quot;</span>);<br>        &#125;<br>        ...<br>    &#125;<br></code></pre></td></tr></table></figure><p>一个即有共性，也有个性的错误信息处理，这样做有利同种错误出一样的信息，统一用户界面，而不会因为文件打开失败，A程序员出一个信息，B程序员又出一个信息。而且这样做，非常容易维护。代码也易读。</p><p>当然，物极必反，也没有必要把所有的输出都放到errmsg中，抽取比较重要的出错信息或是提示信息是其关键，但即使这样，这也包括了大多数的信息。</p><p><span style="background-color: #ffaaaa"><strong>12</strong>、常用函数和循环语句中的被计算量</span></p><p>看一下下面这个例子：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl">    <span class="hljs-function"><span class="hljs-title">for</span>( <span class="hljs-variable">i</span>=<span class="hljs-number">0</span>; <span class="hljs-variable">i</span>&lt;<span class="hljs-number">1000</span>; <span class="hljs-variable">i</span>++ )&#123;</span><br><span class="hljs-function">        <span class="hljs-title">GetLocalHostName</span>( <span class="hljs-variable">hostname</span> );</span><br><span class="hljs-function">        ...d<span class="hljs-string">&#x27;t</span></span><br><span class="hljs-string"><span class="hljs-function">    &#125;</span></span><br></code></pre></td></tr></table></figure><p>GetLocalHostName的意思是取得当前计算机名，在循环体中，它会被调用1000次啊。这是多么的没有效率的事啊。应该把这个函数拿到循环体外，这样只调用一次，效率得到了很大的提高。虽然，我们的编译器会进行优化，会把循环体内的不变的东西拿到循环外面，但是，你相信所有编译器会知道哪些是不变的吗？我觉得编译器不可靠。最好还是自己动手吧。</p><p>同样，对于常用函数中的不变量，如：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">GetLocalHostName(<span class="hljs-params">char</span><span class="hljs-operator">*</span> <span class="hljs-params">name</span>)</span><br>&#123;<br>    <span class="hljs-built_in">char</span> funcName<span class="hljs-literal">[]</span> = <span class="hljs-string">&quot;GetLocalHostName&quot;</span>;<br>   <br>    sys<span class="hljs-constructor">_log( <span class="hljs-string">&quot;%s begin......&quot;</span>, <span class="hljs-params">funcName</span> )</span>;<span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator">    </span>sys<span class="hljs-constructor">_log( <span class="hljs-string">&quot;%s end......&quot;</span>, <span class="hljs-params">funcName</span> )</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果这是一个经常调用的函数，每次调用时都要对funcName进行分配内存，这个开销很大啊。把这个变量声明成static吧，当函数再次被调用时，就会省去了分配内存的开销，执行效率也很好。</p><p><strong>13</strong>、函数名和变量名的命名</p><p>参考linux内核规范</p><p><strong>14</strong>、函数的传值和传指针</p><p>向函数传参数时，一般而言，传入非const的指针时，就表示，在函数中要修改这个指针把指内存中的数据。如果是传值，那么无论在函数内部怎么修改这个值，也影响不到传过来的值，因为传值是只内存拷贝。</p><p>什么？你说这个特性你明白了，好吧，让我们看看下面的这个例程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GetVersion</span><span class="hljs-params">(<span class="hljs-type">char</span>* pStr)</span></span><br><span class="hljs-function"></span>&#123;<br>    pStr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">strcpy</span> ( pStr, <span class="hljs-string">&quot;2.0&quot;</span> );<br>&#125;<br><span class="hljs-built_in">main</span>()<br>&#123;<br>    <span class="hljs-type">char</span>* ver = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">GetVersion</span> ( ver );<br>    ...<br>    ...<br>    <span class="hljs-built_in">free</span> ( ver );<br>&#125;<br></code></pre></td></tr></table></figure><p>我保证，类似这样的问题是一个新手最容易犯的错误。程序中妄图通过函数GetVersion给指针ver分配空间，但这种方法根本没有什么作用，原因就是——这是传值，不是传指针。你或许会和我争论，我分明传的时指针啊？再仔细看看，其实，你传的是指针其实是在传值。</p><p><strong>15</strong>、修改别人程序的修养</p><p>当你维护别人的程序时，请不要非常主观臆断的把已有的程序删除或是修改。我经常看到有的程序员直接在别人的程序上修改表达式或是语句。修改别人的程序时，请不要删除别人的程序，如果你觉得别人的程序有所不妥，请注释掉，然后添加自己的处理程序，必竟，你不可能100%的知道别人的意图，所以为了可以恢复，请不依赖于CVS或是SourceSafe这种版本控制软件，还是要在源码上给别人看到你修改程序的意图和步骤。这是程序维护时，一个有修养的程序员所应该做的。</p><p>如下所示，这就是一种比较好的修改方法：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino">    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * ----- commented by haoel 2003/04/12 ------</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *   char* p = ( char* ) malloc( 10 );</span><br><span class="hljs-comment">     *   memset( p, 0, 10 );</span><br><span class="hljs-comment">     */</span><br>    <br>    <span class="hljs-comment">/* ------ Added by haoel   2003/04/12 ----- */</span><br>     <span class="hljs-type">char</span>* p = ( <span class="hljs-type">char</span>* )<span class="hljs-built_in">calloc</span>( <span class="hljs-number">10</span>, <span class="hljs-keyword">sizeof</span> <span class="hljs-type">char</span> );<br>    <span class="hljs-comment">/* ---------------------------------------- */</span><br>    ...<br></code></pre></td></tr></table></figure><p>当然，这种方法是在软件维护时使用的，这样的方法，可以让再维护的人很容易知道以前的代码更改的动作和意图，而且这也是对原作者的一种尊敬。</p><p>以“注释 — 添加”方式修改别人的程序，要好于直接删除别人的程序。</p><p><strong>16</strong>、把相同或近乎相同的代码形成函数和宏</p><p>有人说，最好的程序员，就是最喜欢“偷懒”的程序，其中不无道理。</p><p>如果你有一些程序的代码片段很相似，或直接就是一样的，请把他们放在一个函数中。而如果这段代码不多，而且会被经常使用，你还想避免函数调用的开销，那么就把他写成宏吧。</p><p>千万不要让同一份代码或是功能相似的代码在多个地方存在，不然如果功能一变，你就要修改好几处地方，这种会给维护带来巨大的麻烦，所以，做到“一改百改”，还是要形成函数或是宏。</p><p><strong>17</strong>、表达式中的括号</p><p>如果一个比较复杂的表达式中，你并不是很清楚各个操作符的忧先级，即使是你很清楚优先级，也请加上括号，不然，别人或是自己下一次读程序时，一不小心就看走眼理解错了，为了避免这种“误解”，还有让自己的程序更为清淅，还是加上括号吧。</p><p>比如，对一个结构的成员取地址：</p><p>    GetUserAge( &amp;( UserInfo-&gt;age ) );</p><p>虽然，&amp;UserInfo-&gt;age中，-&gt;操作符的优先级最高，但加上一个括号，会让人一眼就看明白你的代码是什么意思。</p><p>再比如，一个很长的条件判断：</p><p>if ( ( ch[0] &gt;&#x3D; ‘0’ || ch[0] &lt;&#x3D; ‘9’ ) &amp;&amp;</p><p>     ( ch[1] &gt;&#x3D; ‘a’ || ch[1] &lt;&#x3D; ‘z’ ) &amp;&amp;</p><p>     ( ch[2] &gt;&#x3D; ‘A’ || ch[2] &lt;&#x3D; ‘Z’ )    )</p><p>括号，再加上空格和换行，你的代码是不是很容易读懂了？    </p><p><strong>18</strong>、函数参数中的const</p><p>对于一些函数中的指针参数，如果在函数中只读，请将其用const修饰，这样，别人一读到你的函数接口时，就会知道你的意图是这个参数是[in]，如果没有const时，参数表示[in&#x2F;out]，注意函数接口中的const使用，利于程序的维护和避免犯一些错误。</p><p>虽然，const修饰的指针，如：const char* p，在C中一点用也没有，因为不管你的声明是不是const，指针的内容照样能改，因为编译器会强制转换，但是加上这样一个说明，有利于程序的阅读和编译。因为在C中，修改一个const指针所指向的内存时，会报一个Warning。这会引起程序员的注意。</p><p>C++中对const定义的就很严格了，所以C++中要多多的使用const，const的成员函数，const的变量，这样会对让你的代码和你的程序更加完整和易读。（关于C++的const我就不多说了）</p><p><strong>19</strong>、函数的参数个数</p><p>函数的参数个数最好不要太多，一般来说6个左右就可以了，众多的函数参数会让读代码的人一眼看上去就很头昏，而且也不利于维护。如果参数众多，还请使用结构来传递参数。这样做有利于数据的封装和程序的简洁性。</p><p>也利于使用函数的人，因为如果你的函数个数很多，比如12个，调用者很容易搞错参数的顺序和个数，而使用结构struct来传递参数，就可以不管参数的顺序。</p><p>而且，函数很容易被修改，如果需要给函数增加参数，不需要更改函数接口，只需更改结构体和函数内部处理，而对于调用函数的程序来说，这个动作是透明的。</p><p><strong>20</strong>、函数的返回类型，不要省略</p><p>我看到很多程序写函数时，在函数的返回类型方面不太注意。如果一个函数没有返回值，也请在函数前面加上void的修饰。而有的程序员偷懒，在返回int的函数则什么不修饰（因为如果不修饰，则默认返回int），这种习惯很不好，还是为了原代码的易读性，加上int吧。</p><p>所以函数的返回值类型，请不要省略。</p><p>另外，对于void的函数，我们往往会忘了return，由于某些C&#x2F;C++的编译器比较敏感，会报一些警告，所以即使是void的函数，我们在内部最好也要加上return的语句，这有助于代码的编译。</p><p><strong>21</strong>、goto语句的使用</p><p>N年前，软件开发的一代宗师——迪杰斯特拉(Dijkstra)说过：“goto statment is harmful !!”，并建议取消goto语句。因为goto语句不利于程序代码的维护性。</p><p>这里我也强烈建议不要使用goto语句，除非下面的这种情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-meta">#<span class="hljs-keyword">define</span> FREE(p) <span class="hljs-keyword">if</span>(p) &#123; \</span><br><span class="hljs-meta">                        free(p); \</span><br><span class="hljs-meta">                        p = NULL; \</span><br><span class="hljs-meta">                    &#125;</span><br>    <span class="hljs-built_in">main</span>()<br>    &#123;<br>        <span class="hljs-type">char</span> *fname=<span class="hljs-literal">NULL</span>, *lname=<span class="hljs-literal">NULL</span>, *mname=<span class="hljs-literal">NULL</span>;<br>        fname = ( <span class="hljs-type">char</span>* ) <span class="hljs-built_in">calloc</span> ( <span class="hljs-number">20</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) );<br>        <span class="hljs-keyword">if</span> ( fname == <span class="hljs-literal">NULL</span> )&#123;<br>            <span class="hljs-keyword">goto</span> ErrHandle;<br>        &#125;<br>        lname = ( <span class="hljs-type">char</span>* ) <span class="hljs-built_in">calloc</span> ( <span class="hljs-number">20</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) );<br>        <span class="hljs-keyword">if</span> ( lname == <span class="hljs-literal">NULL</span> )&#123;<br>            <span class="hljs-keyword">goto</span> ErrHandle;<br>        &#125;<br>        mname = ( <span class="hljs-type">char</span>* ) <span class="hljs-built_in">calloc</span> ( <span class="hljs-number">20</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) );<br>        <span class="hljs-keyword">if</span> ( mname == <span class="hljs-literal">NULL</span> )&#123;<br>            <span class="hljs-keyword">goto</span> ErrHandle;<br>        &#125;<br>       <br>        ......<br>    <br>       <br>     ErrHandle:<br>        <span class="hljs-built_in">FREE</span>(fname);<br>        <span class="hljs-built_in">FREE</span>(lname);<br>        <span class="hljs-built_in">FREE</span>(mname);<br>        <span class="hljs-built_in">ReportError</span>(ERR_NO_MEMOEY);<br>     &#125;<br></code></pre></td></tr></table></figure><p>也只有在这种情况下，goto语句会让你的程序更易读，更容易维护。（在用嵌C来对数据库设置游标操作时，或是对数据库建立链接时，也会遇到这种结构）</p><p><strong>22</strong>、宏的使用</p><p>很多程序员不知道C中的“宏”到底是什么意思？特别是当宏有参数的时候，经常把宏和函数混淆。我想在这里我还是先讲讲“宏”，宏只是一种定义，他定义了一个语句块，当程序编译时，编译器首先要执行一个“替换”源程序的动作，把宏引用的地方替换成宏定义的语句块，就像文本文件替换一样。这个动作术语叫“宏的展开”</p><p>使用宏是比较“危险”的，因为你不知道宏展开后会是什么一个样子。例如下面这个宏：</p><p>    #define  MAX(a, b)     a&gt;b?a:b</p><p>当我们这样使用宏时，没有什么问题： MAX( num1, num2 ); 因为宏展开后变成 num1&gt;num2?num1:num2；。 但是，如果是这样调用的，MAX( 17+32, 25+21 ); 呢，编译时出现错误，原因是，宏展开后变成：17+32&gt;25+21?17+32:25+21，哇，这是什么啊？</p><p>所以，宏在使用时，参数一定要加上括号，上述的那个例子改成如下所示就能解决问题了。</p><p>    #define  MAX( (a), (b) )     (a)&gt;(b)?(a):(b)</p><p>   </p><p>即使是这样，也不这个宏也还是有Bug，因为如果我这样调用 MAX(i++, j++); ， 经过这个宏以后，i和j都被累加了两次，这绝不是我们想要的。</p><p>   </p><p>所以，在宏的使用上还是要谨慎考虑，因为宏展开是的结果是很难让人预料的。而且虽然，宏的执行很快（因为没有函数调用的开销），但宏会让源代码澎涨，使目标文件尺寸变大，（如：一个50行的宏，程序中有1000个地方用到，宏展开后会很不得了），相反不能让程序执行得更快（因为执行文件变大，运行时系统换页频繁）。</p><p>因此，在决定是用函数，还是用宏时得要小心。</p><p><strong>23</strong>、static的使用</p><p>static关键字，表示了“静态”，一般来说，他会被经常用于变量和函数。一个static的变量，其实就是全局变量，只不过他是有作用域的全局变量。比如一个函数中的static变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">char</span>*</span><br><span class="hljs-function"><span class="hljs-title">getConsumerName</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>   <br>    ....<br>    cnt++;<br>    ....<br>&#125;<br></code></pre></td></tr></table></figure><p>cnt变量的值会跟随着函数的调用次而递增，函数退出后，cnt的值还存在，只是cnt只能在函数中才能被访问。而cnt的内存也只会在函数第一次被调用时才会被分配和初始化，以后每次进入函数，都不为static分配了，而直接使用上一次的值。</p><p>对于一些被经常调用的函数内的常量，最好也声明成static（参见第12条）</p><p>但static的最多的用处却不在这里，其最大的作用的控制访问，在C中<strong>如果一个函数或是一个全局变量被声明为static，那么，这个函数和这个全局变量，将只能在这个C文件中被访问，如果别的C文件中调用这个C文件中的函数，或是使用其中的全局（用extern关键字），将会发生链接时错误。这个特性可以用于数据和程序保密。</strong></p><p><strong>24</strong>、函数中的代码尺寸</p><p>一个函数完成一个具体的功能，一般来说，一个函数中的代码最好不要超过600行左右，越少越好，最好的函数一般在100行以内，300行左右的孙函数就差不多了。有证据表明，一个函数中的代码如果超过500行，就会有和别的函数相同或是相近的代码，也就是说，就可以再写另一个函数。</p><p>另外，函数一般是完成一个特定的功能，千万<strong>忌讳在一个函数中做许多件不同的事</strong>。函数的功能<strong>越单一越好</strong>，一方面有利于函数的易读性，另一方面更有利于代码的维护和重用，功能越单一表示这个函数就越可能给更多的程序提供服务，也就是说共性就越多。</p><p>虽然函数的调用会有一定的开销，但比起软件后期维护来说，增加一些运行时的开销而换来更好的可维护性和代码重用性，是很值得的一件事。</p><p><strong>25</strong>、typedef的使用</p><p>typedef是一个给类型起别名的关键字。不要小看了它，它对于你代码的维护会有很好的作用。比如C中没有bool，于是在一个软件中，一些程序员使用int，一些程序员使用short，会比较混乱，最好就是用一个typedef来定义，如：</p><p>    typedef char bool;</p><p>   </p><p>一般来说，一个C的工程中一定要做一些这方面的工作，因为你会涉及到跨平台，不同的平台会有不同的字长，所以利用预编译和typedef可以让你最有效的维护你的代码，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SOLARIS2_5</span><br>      <span class="hljs-keyword">typedef</span> <span class="hljs-type">boolean_t</span>     BOOL_T;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      <span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span>           BOOL_T;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>   <br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">short</span>           INT16_T;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span>  UINT16_T;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span>             INT32_T;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>    UINT32_T;<br>   <br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> WIN32</span><br>      <span class="hljs-keyword">typedef</span> _int64        INT64_T;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      <span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>     INT64_T;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>   <br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">float</span>           FLOAT32_T;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span>*           STRING_T;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>   BYTE_T;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">time_t</span>          TIME_T;<br>    <span class="hljs-keyword">typedef</span> INT32_T         PID_T;<br></code></pre></td></tr></table></figure><p>   </p><p>使用typedef的其它规范是，在结构和函数指针时，也最好用typedef，这也有利于程序的易读和可维护性。如：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs elm">    typedef struct _hostinfo &#123;<br>        <span class="hljs-type">HOSTID_T</span>   host;<br>        <span class="hljs-type">INT32_T</span>    hostId;<br>        <span class="hljs-type">STRING_T</span>   hostType;<br>        <span class="hljs-type">STRING_T</span>   hostModel;<br>        <span class="hljs-type">FLOAT32_T</span>  cpuFactor;<br>        <span class="hljs-type">INT32_T</span>    numCPUs;<br>        <span class="hljs-type">INT32_T</span>    nDisks;<br>        <span class="hljs-type">INT32_T</span>    memory;<br>        <span class="hljs-type">INT32_T</span>    swap;<br>    &#125; <span class="hljs-type">HostInfo</span>;<br>    typedef <span class="hljs-type">INT32_T</span> (*<span class="hljs-type">RsrcReqHandler</span>)(<br>     void *info,<br>     <span class="hljs-type">JobArray</span> *jobs,<br>     <span class="hljs-type">AllocInfo</span> *allocInfo,<br>     <span class="hljs-type">AllocList</span> *allocList);<br></code></pre></td></tr></table></figure><p>C++中这样也是很让人易读的：</p><p>    typedef CArray&lt;HostInfo, HostInfo&amp;&gt; HostInfoArray;</p><p>于是，当我们用其定义变量时，会显得十分易读。如：</p><p>    HostInfo* phinfo;</p><p>    RsrcReqHandler* pRsrcHand;</p><p>这种方式的易读性，在函数的参数中十分明显。</p><p>关键是在程序种使用typedef后，几乎所有的程序中的类型声明都显得那么简洁和清淅，而且易于维护，这才是typedef的关键。</p><p><strong>26</strong>、为常量声明宏</p><p>最好不要在程序中出现数字式的“硬编码”，如：</p><p>    int user[120];</p><p>   </p><p>为这个120声明一个宏吧。为所有出现在程序中的这样的常量都声明一个宏吧。比如TimeOut的时间，最大的用户数量，还有其它，只要是常量就应该声明成宏。如果，突然在程序中出现下面一段代码，</p><p>    for ( i&#x3D;0; i&lt;120; i++){</p><p>        ….</p><p>    }</p><p>120是什么？为什么会是120？这种“硬编码”不仅让程序很读，而且也让程序很不好维护，如果要改变这个数字，得同时对所有程序中这个120都要做修改，这对修改程序的人来说是一个很大的痛苦。所以还是把常量声明成宏，这样，一改百改，而且也很利于程序阅读。</p><p>    #define MAX_USR_CNT 120</p><p>   </p><p>    for ( i&#x3D;0; i&lt;MAX_USER_CNT; i++){</p><p>        ….</p><p>    }</p><p>这样就很容易了解这段程序的意图了。</p><p>有的程序员喜欢为这种变量声明全局变量，其实，全局变量应该尽量的少用，全局变量不利于封装，也不利于维护，而且对程序执行空间有一定的开销，一不小心就造成系统换页，造成程序执行速度效率等问题。所以声明成宏，即可以免去全局变量的开销，也会有速度上的优势。</p><p><strong>27</strong>、不要为宏定义加分号</p><p>有许多程序员不知道在宏定义时是否要加分号，有时，他们以为宏是一条语句，应该要加分号，这就错了。当你知道了宏的原理，你会赞同我为会么不要为宏定义加分号的。看一个例子：</p><p>    #define MAXNUM 1024;</p><p>这是一个有分号的宏，如果我们这样使用：</p><p>    half &#x3D; MAXNUM&#x2F;2;</p><p>   </p><p>    if ( num &lt; MAXNUM )</p><p>等等，都会造成程序的编译错误，因为，当宏展开后，他会是这个样子的：</p><p>    half &#x3D; 1024;&#x2F;2;</p><p>   </p><p>    if ( num &lt; 1024; )</p><p>   </p><p>是的，分号也被展进去了，所以造成了程序的错误。请相信我，有时候，一个分号会让你的程序出现成百个错误。所以还是不要为宏加最后一个分号，哪怕是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-meta">#<span class="hljs-keyword">define</span> LINE    <span class="hljs-string">&quot;=================================&quot;</span></span><br>   <br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT_LINE  printf(LINE)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT_NLINE(n)  while ( n-- &gt;0 ) &#123; PRINT_LINE; &#125;</span><br></code></pre></td></tr></table></figure><p>都不要在最后加上分号，当我们在程序中使用时，为之加上分号，</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">    main()<br>    &#123;<br>        char *p <span class="hljs-operator">=</span> LINE<span class="hljs-comment">;</span><br>        PRINT_LINE<span class="hljs-comment">;</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>这一点非常符合习惯，而且，如果忘加了分号，编译器给出的错误提示，也会让我们很容易看懂的。</p><p><strong>28</strong>、||和&amp;&amp;的语句执行顺序</p><p>条件语句中的这两个“与”和“或”操作符一定要小心，它们的表现可能和你想像的不一样，这里条件语句中的有些行为需要和说一下：</p><p>    express1 || express2</p><p>       </p><p>    先执行表达式express1如果为“真”，express2将不被执行，express2仅在express1为“假”时才被执行。因为第一个表达式为真了，整个表达式都为真，所以没有必要再去执行第二个表达式了。</p><p>    express1 &amp;&amp; express2</p><p>    先执行表达式express1如果为“假”，express2将不被执行，express2仅在express1为“真”时才被执行。因为第一个表达式为假了，整个表达式都为假了，所以没有必要再去执行第二个表达式了。</p><p>于是，他并不是你所想像的所有的表达式都会去执行，这点一定要明白，不然你的程序会出现一些莫明的运行时错误。</p><p>例如，下面的程序：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lisp">    if ( <span class="hljs-name">sum</span> &gt; <span class="hljs-number">100</span> <span class="hljs-symbol">&amp;&amp;</span><br>         ( ( <span class="hljs-name">fp=fopen</span>( <span class="hljs-name">filename</span>,<span class="hljs-string">&quot;a&quot;</span> ) ) != NULL )   &#123;<br>        <br>         fprintf(<span class="hljs-name">fp</span>, <span class="hljs-string">&quot;Warring: it beyond one hundred\n&quot;</span>)<span class="hljs-comment">;</span><br>         ......<br>    &#125;<br>   <br>    fprintf( <span class="hljs-name">fp</span>, <span class="hljs-string">&quot; sum is %id \n&quot;</span>, sum )<span class="hljs-comment">;</span><br>    fclose( <span class="hljs-name">fp</span> )<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>本来的意图是，如果sum &gt; 100 ，向文件中写一条出错信息，为了方便，把两个条件判断写在一起，于是，如果sum&lt;&#x3D;100时，打开文件的操作将不会做，最后，fprintf和fclose就会发现未知的结果。</p><p>再比如，如果我想判断一个字符是不是有内容，我得判断这个字符串指针是不为空（NULL）并且其内容不能为空（Empty），一个是空指针，一个是空内容。我也许会这样写：</p><p>    if ( ( p !&#x3D; NULL ) &amp;&amp; ( strlen(p) !&#x3D; 0 ))</p><p>于是，如果p为NULL，那么strlen(p)就不会被执行，于是，strlen也就不会因为一个空指针而“非法操作”或是一个“Core Dump”了。</p><p>记住一点，条件语句中，并非所有的语句都会执行，当你的条件语句非常多时，这点要尤其注意。</p><p><strong>29</strong>、尽量用for而不是while做循环</p><p>基本上来说，for可以完成while的功能，我是建议尽量使用for语句，而不要使用while语句，特别是当循环体很大时，for的优点一下就体现出来了。</p><p>因为在for中，循环的初始、结束条件、循环的推进，都在一起，一眼看上去就知道这是一个什么样的循环。刚出学校的程序一般对于链接喜欢这样来：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">    p <span class="hljs-operator">=</span> pHead<span class="hljs-comment">;</span><br>   <br>    while ( p )&#123;<br>        ...<br>        ...<br>        p <span class="hljs-operator">=</span> p-&gt;next<span class="hljs-comment">;</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>当while的语句块变大后，你的程序将很难读，用for就好得多：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">    <span class="hljs-keyword">for</span> ( <span class="hljs-attribute">p</span>=pHead;  p; <span class="hljs-attribute">p</span>=p-&gt;next )&#123;<br>    <span class="hljs-built_in">..</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>一眼就知道这个循环的开始条件，结束条件，和循环的推进。大约就能明白这个循环要做个什么事？而且，程序维护进来很容易，不必像while一样，在一个编辑器中上上下下的捣腾。</p><p><strong>30</strong>、请sizeof类型而不是变量</p><p>许多程序员在使用sizeof中，喜欢sizeof变量名，例如：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">int score<span class="hljs-selector-attr">[100]</span>;<br>char filename<span class="hljs-selector-attr">[20]</span>;<br>struct UserInfo usr<span class="hljs-selector-attr">[100]</span>;<br></code></pre></td></tr></table></figure><p>在sizeof这三个的变量名时，都会返回正确的结果，于是许多程序员就开始sizeof变量名。这个习惯很虽然没有什么不好，但我还是建议sizeof类型。</p><p>我看到过这个的程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    pScore = (<span class="hljs-type">int</span>*) <span class="hljs-built_in">malloc</span>( SUBJECT_CNT );<br>    <span class="hljs-built_in">memset</span>( pScore, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(pScore) );<br>    ...<br></code></pre></td></tr></table></figure><p>此时，sizeof(pScore)返回的就是4（指针的长度），不会是整个数组，于是，memset就不能对这块内存进行初始化。为了程序的易读和易维护，我强烈建议使用类型而不是变量，如：</p><p>对于score：     sizeof(int) * 100   &#x2F;* 100个int *&#x2F;</p><p>对于filename：  sizeof(char) * 20   &#x2F;* 20个char *&#x2F;</p><p>对于usr：       sizeof(struct UserInfo) * 100   &#x2F;* 100个UserInfo *&#x2F;</p><p>这样的代码是不是很易读？一眼看上去就知道什么意思了。</p><p>另外一点，sizeof一般用于分配内存，这个特性特别在多维数组时，就能体现出其优点了。如，给一个字符串数组分配内存，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 分配一个有20个字符串，</span><br><span class="hljs-comment"> * 每个字符串长100的内存</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">char</span>* *p;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 错误的分配方法</span><br><span class="hljs-comment"> */</span><br>p = (<span class="hljs-type">char</span>**)<span class="hljs-built_in">calloc</span>( <span class="hljs-number">20</span>*<span class="hljs-number">100</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) );<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 正确的分配方法</span><br><span class="hljs-comment"> */</span><br>p = (<span class="hljs-type">char</span>**) <span class="hljs-built_in">calloc</span> ( <span class="hljs-number">20</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>*) );<br><span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">20</span>; i++)&#123;<br>    <span class="hljs-comment">/*p = (char*) calloc ( 100, sizeof(char) );*/</span><br>    p[i] = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">calloc</span> ( <span class="hljs-number">100</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) );<br>&#125;<br></code></pre></td></tr></table></figure><p>（注：上述语句被注释掉的是原来的，是错误的，由dasherest朋友指正，谢谢）</p><p>为了代码的易读，省去了一些判断，请注意这两种分配的方法，有本质上的差别。</p><p><strong>31</strong>、不要忽略Warning</p><p>对于一些编译时的警告信息，请不要忽视它们。虽然，这些Warning不会妨碍目标代码的生成，但这并不意味着你的程序就是好的。必竟，并不是编译成功的程序才是正确的，编译成功只是×××长征的第一步，后面还有大风大浪在等着你。从编译程序开始，不但要改正每个error，还要修正每个warning。这是一个有修养的程序员该做的事。</p><p>一般来说，一面的一些警告信息是常见的：</p><p>1). 声明了未使用的变量。（虽然编译器不会编译这种变量，但还是把它从源程序中注释或是删除吧）</p><p>2). 使用了隐晦声明的函数。（也许这个函数在别的C文件中，编译时会出现这种警告，你应该这使用之前使用extern关键字声明这个函数）</p><p>3). 没有转换一个指针。（例如malloc返回的指针是void的，你没有把之转成你实际类型而报警，还是手动的在之前明显的转换一下吧）</p><p>4). 类型向下转换。（例如：float f &#x3D; 2.0; 这种语句是会报警告的，编译会告诉你正试图把一个double转成float，你正在阉割一个变量，你真的要这样做吗？还是在2.0后面加个f吧，不然，2.0就是一个double，而不是float了）</p><p><strong>32</strong>、书写Debug版和Release版的程序</p><p>程序在开发过程中必然有许多程序员加的调试信息。我见过许多项目组，当程序开发结束时，发动群众删除程序中的调试信息，何必呢？为什么不像VC++那样建立两个版本的目标代码？一个是debug版本的，一个是Release版的。那些调试信息是那么的宝贵，在日后的维护过程中也是很宝贵的东西，怎么能说删除就删除呢？</p><p>利用预编译技术吧，如下所示声明调试函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEBUG</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TRACE</span><span class="hljs-params">(<span class="hljs-type">char</span>* fmt, ...)</span></span><br><span class="hljs-function">        </span>&#123;<br>            ......<br>        &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        <span class="hljs-meta">#<span class="hljs-keyword">define</span> TRACE(char* fmt, ...)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>于是，让所有的程序都用TRACE输出调试信息，只需要在在编译时加上一个参数“-DDEBUG”，如：</p><p>    cc -DDEBUG -o target target.c</p><p>于是，预编译器发现DEBUG变量被定义了，就会使用TRACE函数。而如果要发布给用户了，那么只需要把取消“-DDEBUG”的参数，于是所有用到TRACE宏，这个宏什么都没有，所以源程序中的所有TRACE语言全部被替换成了空。一举两得，一箭双雕，何乐而不为呢？</p><p>顺便提一下，两个很有用的系统宏，一个是“__FILE__”，一个是“__LINE__”，分别表示，所在的源文件和行号，当你调试信息或是输出错误时，可以使用这两个宏，让你一眼就能看出你的错误，出现在哪个文件的第几行中。这对于用C&#x2F;C++做的大工程非常的管用。</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言基础</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>（一）变量和数据类型</p><p>1.变量</p><p>变量的本质是一段实际连续存储空间的别名；程序中通过变量来申请并命名存储空间，通过变量的名字可以使用存储空间</p><p>2.变量的字节数：不同字长的机器的地址所占字节不同，为机器字长&#x2F;8位</p><p>char    short    int     long    long long    指针</p><p>16位平台         1          2        2         4              &#x2F;              2</p><p>32位平台         1          2        4         4             8              4</p><p>64位平台         1          2        4         8             8              8</p><p>由于实际编程需要确定的结果，而不是一般的情况，所以建议使用int8，int16，int32之类的预定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span>           <span class="hljs-type">char</span> <span class="hljs-type">int8_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-type">short</span>      <span class="hljs-type">int</span> <span class="hljs-type">int16_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span>            <span class="hljs-type">int</span> <span class="hljs-type">int32_t</span>;    <span class="hljs-comment">//此处Int为4字节</span><br><span class="hljs-meta"># <span class="hljs-keyword">if</span> __WORDSIZE == 64</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-type">long</span>       <span class="hljs-type">int</span> <span class="hljs-type">int64_t</span>;<br><span class="hljs-meta"># <span class="hljs-keyword">else</span></span><br>__extension__<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>  <span class="hljs-type">int</span> <span class="hljs-type">int64_t</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>3.有符号数无符号数</p><p>C语言中只有整数类型能够声明unsigned变量，且直接int声明时默认为带符号整型</p><p>（1）有符号数(signed)</p><p>对于有符号数，若其为负数，则存储单元中最高位必为1；若其为正数，则存储单元中最高位必为0</p><p>计算机内部用补码表示有符号数</p><p>-正数的补码为正数本身</p><p>-负数的补码为负数的绝对值各位取反后加1</p><p>例1 有符号数的加法(32位)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a,b,c,d=<span class="hljs-number">-1</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *p=(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>*)&amp;a, *q=(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>*)&amp;b, *z=(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>*)&amp;c, *v=(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>*)&amp;d;<br>   <br>    a = <span class="hljs-number">2147483647</span>;<br>    b = a + <span class="hljs-number">1</span>;<br>    c = b + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//打印abcd的值和其所在内存中的样子（十六进制表示）</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%12d,0x%08X\n&quot;</span>, a,*p);    <span class="hljs-comment">//a=  2147483647,0x7FFFFFF</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b=%12d,0x%08X\n&quot;</span>, b,*q);    <span class="hljs-comment">//b= -2147483648,0x80000000</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c=%12d,0x%08X\n&quot;</span>, c,*z);    <span class="hljs-comment">//c= -2147483647,0x80000001</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;d=%12d,0x%08X\n&quot;</span>, d,*v);    <span class="hljs-comment">//d=          -1,0xFFFFFFFF</span><br>&#125;<br>可以看到<span class="hljs-type">int</span>为<span class="hljs-number">4</span>字节，表示范围为<span class="hljs-number">-2147483648</span>~<span class="hljs-number">2147483647</span><br>当一个数达到<span class="hljs-number">2147483647</span>（<span class="hljs-number">0x7FFFFFF</span> = <span class="hljs-number">2</span>^<span class="hljs-number">31</span> - <span class="hljs-number">1</span>）时，它再加一，变成<span class="hljs-number">-2147483648</span>（<span class="hljs-number">0x80000000</span>）<br>虽然内存中末位加一变成<span class="hljs-number">0x80000000</span>，但它是有符号数，表示出来的数字不是<span class="hljs-number">0x80000000</span>对应的<span class="hljs-number">2147483648</span>，而是<span class="hljs-number">-2147483648</span><br>令这数字再加一，变成<span class="hljs-number">0x80000001</span>，它表示出来的数字不是<span class="hljs-number">0x80000001</span>对应的<span class="hljs-number">2147483649</span>，而是-(<span class="hljs-number">0x80000000</span> + <span class="hljs-number">1</span>)<span class="hljs-number">-2147483647</span><br>故：<span class="hljs-type">int</span> a，a逐渐加一，其内存里变化和表现出十进制数字如下<br><span class="hljs-number">0x0000</span> <span class="hljs-number">0000</span>        <span class="hljs-number">0x0000</span> <span class="hljs-number">0001</span>        ...        <span class="hljs-number">0x7FFF</span> FFFF    <span class="hljs-number">0x8000</span> <span class="hljs-number">0000</span>    <span class="hljs-number">0x8000</span> <span class="hljs-number">0001</span>    ...    <span class="hljs-number">0xFFFF</span> FFFF<br>     <span class="hljs-number">0</span>               <span class="hljs-number">1</span>               <span class="hljs-number">2147483647</span>     <span class="hljs-number">-2147483648</span>    <span class="hljs-number">-2147483647</span>                <span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><p>（2）无符号数(unsigned)</p><p>计算机内部用原码表示无符号数，存储单元中全部二进制位用来存放数本身</p><p>unsigned int b;    b的范围为0~65535</p><p>无符号数若为0再减一，就会变成当前字节数的最大值</p><p>有符号数和无符号数，char举例(32位)</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache">                        <span class="hljs-attribute">unsigned</span>                signed<br><span class="hljs-attribute">char</span>：<span class="hljs-number">1</span>字节    <span class="hljs-number">8</span>位    <span class="hljs-number">0000</span> <span class="hljs-number">0000</span>~<span class="hljs-number">1111</span> <span class="hljs-number">1111</span>    <span class="hljs-number">0000</span> <span class="hljs-number">0000</span>~<span class="hljs-number">1000</span> <span class="hljs-number">0000</span>~<span class="hljs-number">1000</span> <span class="hljs-number">0001</span>~<span class="hljs-number">1111</span> <span class="hljs-number">1111</span><br>                            <span class="hljs-attribute">0</span> ~ <span class="hljs-number">255</span>                <span class="hljs-number">0</span> ~ <span class="hljs-number">128</span>     ~    -<span class="hljs-number">127</span> ~ -<span class="hljs-number">1</span>   <br>                         <span class="hljs-attribute">0x00</span> ~ <span class="hljs-number">0</span>xFF<br><span class="hljs-attribute">unsigned</span> char a = <span class="hljs-number">0</span>xFF; a += <span class="hljs-number">1</span>; //a = <span class="hljs-number">0</span>x100，但char为<span class="hljs-number">1</span>字节<span class="hljs-number">8</span>位，所以它屏蔽了<span class="hljs-number">8</span>位以上的数字，读取的应该是<span class="hljs-number">0</span>x100 = <span class="hljs-number">0</span>，所以用%u打印出后是<span class="hljs-number">0</span><br>  <span class="hljs-attribute">signed</span> char a = <span class="hljs-number">0</span>x7F; a += <span class="hljs-number">1</span>; //a = <span class="hljs-number">0</span>x80，但signed char为有符号型，所以它首先读取最高位为<span class="hljs-number">1</span>，确定此为负数，然后得到此为-(<span class="hljs-number">0</span>x80) = -<span class="hljs-number">128</span>，再次+<span class="hljs-number">1</span>，为<span class="hljs-number">0</span>x80 + <span class="hljs-number">1</span> = <span class="hljs-number">0</span>x81，再次读取最高位发现为<span class="hljs-number">1</span>，即为-(<span class="hljs-number">0</span>x80) + <span class="hljs-number">0</span>x01 = -<span class="hljs-number">127</span>，再次+<span class="hljs-number">1</span>.........最后<span class="hljs-number">0</span>xFE + <span class="hljs-number">1</span> = <span class="hljs-number">0</span>xFF = -(<span class="hljs-number">0</span>x80) + <span class="hljs-number">0</span>x7F = -<span class="hljs-number">1</span>，再+<span class="hljs-number">1</span>即为<span class="hljs-number">0</span>x100 <br></code></pre></td></tr></table></figure><p>例1 当无符号数遇到有符号数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">5</span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-10</span>;    <br>    <span class="hljs-keyword">if</span>((i + j) &gt; <span class="hljs-number">0</span>)    <span class="hljs-comment">//j被看成无符号数，即1111 1111 1111 1111 1111 1111 1111 0110,若看成无符号数即为一个很大的数</span><br>        &#123;<br>             <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i + j &gt; 0\n&quot;</span>);   <br>        &#125;<br>    <span class="hljs-keyword">if</span>((i + j) &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i + j &lt;= 0\n&quot;</span>);   <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>编译结果：i + j &gt; <span class="hljs-number">0</span><br>当无符号数与有符号数混合运算的时候，会将有符号数转换成无符号数后再进行计算，结果为无符号数<br></code></pre></td></tr></table></figure><p>例2 错误使用unsigned</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">9</span>; i&gt;=<span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %u\n&quot;</span>, i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>编译结果：不停输出<br>错误点：不该用无符号类型作为循环变量，因为循环结束条件是i变成一个负数，但无符号数不可能得到负数，最小值是<span class="hljs-number">0</span>，再减一会变成最大值，然后产生死循环<br></code></pre></td></tr></table></figure><p>4.浮点数</p><p>（1）浮点数在内存的存储方式</p><p>（2）浮点数的转换（十进制浮点数转换为计算机内部浮点数）</p><p>①将浮点数转换成二进制</p><p>②用科学计数法表示二进制浮点数</p><p>③计算指数偏移后的值（float偏移量为127，double偏移量为1023）</p><p>例：实数8.25在内存中的float表示</p><p>8.25的二进制表示：1000.01</p><p>科学计数法表示：1.00001*(2^3)    &#x2F;&#x2F;此处2表示此为二进制</p><p>-符号位：0</p><p>-指数：127 + 3 → 130 → 10000010</p><p>-小数：00001</p><p>内存中8.25的float表示为：0 10000010 0000100000000000000 → 0x41040000</p><p>（3）浮点类型的秘密</p><p>int类型的范围：[-2^31,2^31-1]</p><p>float类型的范围：[-3.4*10^38,3.4*10^38]</p><p>int和float都占4个字节的内存，为什么float却比int的范围大的多？</p><p>-因为所占字节数相同，所以他们所能表示的具体数字个数是相同的</p><p>-float可表示的数字之间不是连续的，存在间隙</p><p>-float只是一种近似的表示法，所以在软件开发的时候不能作为精确数使用</p><p>-由于内存表示法相对复杂，float将一个数分成了三个位，而int只由两部分组成，所以float的运算速度比int慢的多</p><p>-同理，double与float具有相同的内存表示法，因此double也是不精确的，但由于double占用的内存较多，所能表示的精度比float高</p><p>例：float类型的不精确性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> f = <span class="hljs-number">3.1415f</span>;    <span class="hljs-comment">//浮点常数默认为double类型，后面加f表示float类型浮点常数！</span><br>        <span class="hljs-type">float</span> f1 = <span class="hljs-number">123456789</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%0.10f\n&quot;</span>, f);    <span class="hljs-comment">//预期结果3.1415f00000            实际结果3.1414999962</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%0.10f\n&quot;</span>, f);    <span class="hljs-comment">//预期结果123456789.0000000000    实际结果123456792.0000000000</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>第一个打印告诉我们：浮点数是一个不精确的表示法<br>第二个打印告诉我们：浮点数虽然表示范围比<span class="hljs-type">int</span>多，但是它是不连续的<br></code></pre></td></tr></table></figure><p>4.变量在内存中的存放形式</p><p>整型变量：见上”3.有符号数无符号数”</p><p>实型变量：浮点数在内存的存储方式为：符号位，指数，尾数</p><p><img src="/image/2e292cc73a5052dc40963d8f7b3cfd9a.png" alt="2e292cc73a5052dc40963d8f7b3cfd9a.png"></p><p>float与double类型的数据在计算机内部的表示法是相同的，但由于所占存储空间的不同，其分别能够表示的数值范围和精度不同。</p><p>字符型变量：内存中存放的是该字符的ASCII码</p><p>字符串常量：字符串中的每个字符以其ASCII码值的二进制形式存储在内存中，并且系统自动在该字符串末尾加一个字符’\0’而额外多占一个字节(ACSII值为0)</p><p>5.变量的数据类型的本质</p><p>数据类型本质就是固定内存大小的别名</p><p>数据类型相当于创建变量的模子（需要1字节内存的时候就是用char模型放在内存上ka一下）</p><p>6.变量不同类型之间的转换</p><p>（1）强制类型转换</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    <span class="hljs-built_in">long</span> l = <span class="hljs-number">800</span>;<br>    <span class="hljs-built_in">int</span> i = (<span class="hljs-built_in">int</span>)l;<br>&#125;<br></code></pre></td></tr></table></figure><p>①强制类型转换的结果</p><p>-目标类型能够容纳目标值：结果不变</p><p>-目标类型不能容纳目标值：结果将产生截断（高位省略，优先截低位）</p><p>（不是所有的强制类型转换都能成功，当不能进行强制类型转换时，编译器将产生错误信息）</p><p>例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TS</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">int</span> j;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TS</span> ts;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">short</span> s = <span class="hljs-number">0x1122</span>;<br><br>    <span class="hljs-type">char</span> c = (<span class="hljs-type">char</span>)s;<br><br>    <span class="hljs-type">int</span> i = (<span class="hljs-type">int</span>)s;<br><br>    <span class="hljs-type">int</span> j = (<span class="hljs-type">int</span>)<span class="hljs-number">3.1415</span>;<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> p = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)&amp;ts;    <span class="hljs-comment">//32位机器上全局变量占4个字节，不会截断</span><br>                                                                                <span class="hljs-comment">//64位机器上全局变量占8个字节，会截断</span><br>    <span class="hljs-type">long</span> l =(<span class="hljs-type">long</span>) ts;    <span class="hljs-comment">//error，结构体类型不能转换成基本类型</span><br><br>    ts = (<span class="hljs-keyword">struct</span> TS)l;    <span class="hljs-comment">//error，基本类型不能转换成结构体类型</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;s = %x\n&quot;</span>, s);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c = %x\n&quot;</span>, c);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %x\n&quot;</span>, i);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;j = %x\n&quot;</span>, j);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p = %x\n&quot;</span>, p);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&amp;ts = %p\n&quot;</span>, &amp;ts);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）隐式类型转换：编译器主动进行的类型转换</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int main()<br>&#123;<br>    char c <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>    <br>    short s <span class="hljs-operator">=</span> c<span class="hljs-comment">;</span><br>    int i <span class="hljs-operator">=</span> s<span class="hljs-comment">;</span><br>    long l <span class="hljs-operator">=</span> i<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意：低到高是安全的，不会产生截断；高到低是不安全的，导致不正确的结果 （低指占用字节数少）</p><p>发生点：</p><p>-算术运算式中，低类型转换为高类型</p><p>当遇到char,short时，统一转换成int来进行运算，当遇到float时，统一当作double来运算</p><p>-赋值表达式中，表达式的值转换为左边变量的类型</p><p>-函数调用时，实参转换为形参的类型</p><p>-函数返回值，return表达式转换为返回值类型</p><p>例：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> main()<br>&#123;<br>    char c = <span class="hljs-string">&#x27;a&#x27;</span>;<br>    <br>    <span class="hljs-keyword">int</span> i = c;    <span class="hljs-regexp">//sa</span>fe<br><br>    unsigned <span class="hljs-keyword">int</span> j = <span class="hljs-number">0x11223344</span>;<br><br>    short s = j;    <span class="hljs-regexp">//unsa</span>fe<br><br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;c = %c\n&quot;</span>, c);<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;i = %c\n&quot;</span>, i);<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;j = %c\n&quot;</span>, j);<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;s = %c\n&quot;</span>, s);<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;sizeof(c + s) = %d\n&quot;</span>, sieof(c + s));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>7.变量的属性</p><p>在定义变量的时候可以加上”属性”关键字，其将指明变量的特有意思</p><p>（1）语法：</p><p>property type var_name;</p><p>例：auto char i;    register int i;</p><p>（2）auto关键字</p><p>auto即C语言中局部变量的默认属性；</p><p>auto表明将被修饰的变量存储于栈上；</p><p>编译器默认所有的局部变量都是auto的；</p><p>（3）register关键字</p><p>寄存器变量的意义是请求编译器将这个变量存储于寄存器中，而不是内存中。寄存器个数是有限的，故不可能将程序中所有变量都声明为寄存器变量。所以在C语言中，register关键字只是请求，但不一定成功。</p><p>-register关键字指明将局部变量存储与寄存器中；</p><p>-register只是请求寄存器变量，但不一定成功；</p><p>-register变量的必须是CPU寄存器可以接受的值；</p><p>-不能用&amp;运算符获取register变量的地址；（取址运算符取的是内存的地址，寄存器的寻址方式跟内存不同，自然没有内存地址一说）</p><p>例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">register <span class="hljs-built_in">int</span> g_v;    <span class="hljs-comment">//error</span><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    register <span class="hljs-built_in">char</span> <span class="hljs-keyword">var</span>;<br>    print(<span class="hljs-string">&quot;0x%08X&quot;</span>, &amp;<span class="hljs-keyword">var</span>);    <span class="hljs-comment">//error</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>全局变量的生存周期是程序运行到程序结束，如果说全局变量占据了寄存器，代表从程序开始到结束都要占用这个寄存器，由于寄存器变量有限，长时间占用，会导致CPU无法正常工作。</p><p>（4）static关键字</p><p>static关键字指明变量的“静态属性”</p><p>- static修饰的局部变量存储在程序静态区。（从栈上挪到静态数据区，生命周期和全局变量相同，只是作用域是局部的）</p><p>static关键字同时具有“作用域限定符”的意义；</p><p>- static修饰的全局变量作用域只是声明的文件中；</p><p>- static修饰的函数作用域只是声明的文件中；</p><p>例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> g_v;                <span class="hljs-comment">//全局变量，程序的任意地方均能访问</span><br><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> g_vs;        <span class="hljs-comment">//静态全局变量，只有当前文件中可以访问</span><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-keyword">var</span>;            <span class="hljs-comment">//局部变量，在栈上分配空间</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> svar;    <span class="hljs-comment">//静态局部变量，在静态数据区分配空间</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>例：auto,register,static对比分析</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;<br>    r++;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;<br>    r++;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-comment">//显示声明auto属性，i为栈变量</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;      <span class="hljs-comment">//局部变量k的存储区位于静态区，作用域位于main中</span><br>    <span class="hljs-keyword">register</span> <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;    <span class="hljs-comment">//向编译器申请将j存储于寄存器中</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;i);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;k);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;j);    <span class="hljs-comment">//error</span><br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">f1</span>());<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">f2</span>());<br>    &#125;<br>&#125;<br>编译结果：<br><span class="hljs-number">0xbfcf007c</span><br><span class="hljs-number">0x804a01c</span><br>它们本是相邻定义，但此处却发现地址所差甚远，因为它们一个存储在栈上，一个存储在存储区<br></code></pre></td></tr></table></figure><p>（5）extern关键字</p><p>extern用于声明“外部”定义的变量和函数：</p><p>- extern变量在文件的其他地方分配空间；</p><p>- extern函数在文件的其他地方定义；</p><p>（告诉编译器这个变量是存在的）</p><p>extern用于“告诉”编译器用C方式编译：</p><p>       C++编译器和一些变种C编译器默认会按“自己”的方式编译函数和变量，通过extern关键字可以命令编译器“以标准C方式进行编译”。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, g_i);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> g_i;    <br>编译结果：报错与全局变量定义无关，故全局变量可以定义在任意位置<br>错误原因：全局变量有效范围从定义处开始到源程序结束，在第三行时g_i还未定义<br></code></pre></td></tr></table></figure><p>例2：我们怎么在main中调用定义在main函数下方的全局变量？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> g_i;    <span class="hljs-comment">//告诉程序我们定义了一个g_i，它是在其他地方定义的，可以放心使用</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, g_i);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> g_i;<br>编译通过！<br></code></pre></td></tr></table></figure><p>例3：在其他文件中定义全局变量g_i</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* test.c */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> g_i;    <span class="hljs-comment">//告诉程序我们定义了一个g_i，它是在其他地方定义的，可以放心使用</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, g_i);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* g.c */</span><br><span class="hljs-type">int</span> g_i;<br>编译通过<br><br><span class="hljs-comment">/* g.c */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> g_i;    <span class="hljs-comment">//static修饰的全局变量作用域只是声明的文件中</span><br>编译错误<br></code></pre></td></tr></table></figure><p>例4：调用其他文件中定义的函数</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">/* test.c */</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getI</span>()</span>;    <br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    printf(<span class="hljs-string">&quot;%d\n&quot;</span>, getI());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* g.c */</span><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">getI</span>()</span><br>&#123;<br>    <span class="hljs-keyword">return</span> g_i;<br>&#125;<br></code></pre></td></tr></table></figure><p>（二）C语言的基本语句</p><p>1.部分格式说明符</p><p>%c：一个字符</p><p>%d：有符号十进制整数</p><p>%u：无符号十进制整数</p><p>%o：八进制整数</p><p>%x(%X)：十六进制整数0f(0F)</p><p>%p：以十六进制整数方式输出指针的值，附加前缀0x</p><p>2.整数格式说明符的应用</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">PAGES=<span class="hljs-number">732</span>;<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;*%d*\n&quot;</span>,PAGES);          <span class="hljs-regexp">//</span>*<span class="hljs-number">732</span>*<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;*%2d*\n&quot;</span>,PAGES);         <span class="hljs-regexp">//</span>*<span class="hljs-number">732</span>*<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;*%10d*\n&quot;</span>,PAGES);        <span class="hljs-regexp">//</span>*       <span class="hljs-number">732</span>* <br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;*%-10d*\n&quot;</span>,PAGES);       <span class="hljs-regexp">//</span>*<span class="hljs-number">732</span>       *<br></code></pre></td></tr></table></figure><p>例：printf(“0x%08X\n”, *p);</p><p>（三）选择与循环结构程序设计</p><p>1.运算符优先级</p><p>高到低：!（非）→算术运算符→关系运算符（&#x3D;&#x3D;与!&#x3D;优先级最低，其他优先级相同）→&amp;&amp;→||→赋值运算符</p><p>2.for循环</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(i=<span class="hljs-number">0</span>; i&lt;n; i++)</span></span>    <span class="hljs-comment">//n次</span><br><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(i=<span class="hljs-number">1</span>; i&lt;n; i++)</span></span>    <span class="hljs-comment">//n-1次</span><br><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(i=<span class="hljs-number">0</span>; i&lt;=n; i++)</span></span>    <span class="hljs-comment">//n+1次</span><br><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(i=x; i&lt;=n; i++)</span></span>    <span class="hljs-comment">//n-x+1次</span><br></code></pre></td></tr></table></figure><p>3.if语句中零值比较的注意点</p><p>（1）bool型变量直接出现于条件中，不要进行比较</p><p>（2）变量和0值比较时，0值应该出现在比较符号左边（if(0 &#x3D;&#x3D; i)，为了避免写错成一个等于号，0在左边的时候若写错则可以直接找到错误位置）</p><p>（3）float型变量不能直接进行0值比较，需要定义精度</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-id">#define</span> EPSINON <span class="hljs-number">0.00000001</span><br><span class="hljs-attribute">float</span> f = <span class="hljs-number">0.0</span>;<br><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">((-EPSINON &lt;= f)</span></span> &amp;&amp;(f &lt;= EPSINON))<br>&#123;<br>    <span class="hljs-comment">//statement 1</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-comment">//statement 1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>4.switch语句</p><p>（1）case语句</p><p>①case语句中的值只能是整型或者字符型；（只能是常量）</p><p>②case语句分支必须有break，否则会导致分支重叠；</p><p>③case语句的排列顺序</p><p>-按字母或数字顺序排列</p><p>-正常情况放在前面，异常情况放在后面</p><p>（2）default语句</p><p>-必需加上，以处理特殊情况，且default后面也得加break；（为空也要加上）</p><p>-default语句只用于处理真正的默认情况，而非程序逻辑；（case无法处理时，default处理）</p><p>例：if和switch程序举例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs bash">void f1(int i)<br>&#123;<br>    <span class="hljs-keyword">if</span>( i &lt; 6 )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed!\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( (6 &lt;= i) &amp;&amp; (i &lt;= 8) )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Good!\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Perfect!\n&quot;</span>);<br>    &#125;<br>/*<br>    switch( i &lt; 6 )    //上面<span class="hljs-keyword">if</span>语句用switch写，括号里也可以是表达式<br>    &#123;<br>        <span class="hljs-keyword">case</span> 1:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed!\n&quot;</span>);<br>        default:<br>            switch( (6 &lt;= i) &amp;&amp; (i &lt;= 8) )        <br>            &#123;<br>                <span class="hljs-keyword">case</span> 1:<br>                  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Good!\n&quot;</span>);<br>                  <span class="hljs-built_in">break</span>;<br><br>                default:<br>                  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Perfect!\n&quot;</span>);<br>                  <span class="hljs-built_in">break</span>;<br>            &#125;<br>            <span class="hljs-built_in">break</span>;<br>    &#125;*/<br>&#125;<br><br>void f2(char i)<br>&#123;<br>    switch(i)<br>    &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Compile\n&quot;</span>);<br>            <span class="hljs-built_in">break</span>;   <br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Debug\n&quot;</span>);<br>            <span class="hljs-built_in">break</span>;   <br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;o&#x27;</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Object\n&quot;</span>);<br>            <span class="hljs-built_in">break</span>;   <br>         <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;r&#x27;</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Run\n&quot;</span>);<br>            <span class="hljs-built_in">break</span>;   <br>         default:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;unknown\n&quot;</span>);<br>            <span class="hljs-built_in">break</span>;   <br>    &#125;<br>/*<br>    <span class="hljs-keyword">if</span>( <span class="hljs-string">&#x27;c&#x27;</span> == i )    //上面switch语句用<span class="hljs-keyword">if</span>写，常量写在左边也是为了防止出错<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Compile\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( <span class="hljs-string">&#x27;d&#x27;</span> == i )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Debug\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( <span class="hljs-string">&#x27;o&#x27;</span> == i )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Object\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( <span class="hljs-string">&#x27;r&#x27;</span> == i )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Run\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;unknown\n&quot;</span>);<br>    &#125;  */  <br>&#125;<br><br>int <span class="hljs-function"><span class="hljs-title">main</span></span>()<br>&#123;<br>    f1(5);<br>    f1(9);<br>    f1(7);<br><br>    f2(<span class="hljs-string">&#x27;o&#x27;</span>);<br>    f2(<span class="hljs-string">&#x27;d&#x27;</span>);<br>    f2(<span class="hljs-string">&#x27;e&#x27;</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span>语句和switch语句从功能上可以互相替代，C语言在设计的时候提供了<span class="hljs-keyword">if</span>和switch两种分支语句，就是希望我们有选择地去判断使用何种语句<br></code></pre></td></tr></table></figure><p>5.if和switch语句区别</p><p>（1）if语句适用于复杂逻辑进行判断的情形；</p><p>（2）switch语句适用于对离散值进行判断的情形中；</p><p>（3）if语句和switch语句在功能上可以进行互换；</p><p>（4）if语句对于“按片”分支判断的情形更加简洁；（一个范围）</p><p>（5）switch语句对于单值多分支的情形；</p><p>6.循环语句do,while，for的区别</p><p>-do先执行，后判断；</p><p>-while先判断，后执行；适用于循环次数不定的场合</p><p>-for先判断，后执行，比while更简洁；适用于循环次数固定的场合，比如累加</p><p>7.break和continue的区别</p><p>-break表示终止循环的执行</p><p>-continue表示终止本次循环，进入下次循环</p><p>例：do和break的妙用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;malloc.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> *p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * n)<br><br>    <span class="hljs-keyword">do</span> <br>    &#123;<br>        <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == p ) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>( n &lt; <span class="hljs-number">5</span> ) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>( n &gt; <span class="hljs-number">100</span> ) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>        &#123;<br>            p[i] = i;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, p[i]);<br>        &#125;<br>        ret = <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">while</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">free</span>(p);    <span class="hljs-comment">//free函数也可以释放空指针，但实际上它什么也不执行</span><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( <span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>) )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OK&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（四）数组</p><p>1.数组初始化</p><p>int a[]&#x3D;{1,2,3,4,5};    int b[10]&#x3D;{0};</p><p>2.字符数组</p><p>C语言中没有专门的字符串变量，通常用一个字符数组来存放一个字符串。</p><p>（1）初始化：逐个给数组中各元素赋初值&#x2F;用字符串直接给字符数组赋初值</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">char</span> parr[] = <span class="hljs-string">&quot;zifuchuanshuzu&quot;</span>;    <span class="hljs-comment">//sizeof(parr) == 15</span><br><span class="hljs-type">char</span> charr[] = &#123; <span class="hljs-string">&#x27;z&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;h&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;z&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span> &#125;;    <span class="hljs-comment">//sizeof(charr) == 14</span><br></code></pre></td></tr></table></figure><p>字符串方式赋初值比逐个赋值多占一个字节，用来存放字符串结束标志\0</p><p>（2）输入与输入：</p><p>输入：scanf%s输入时字符串结束标志为空格；gets()输入时字符串结束标志为回车</p><p>输出：puts()只能输出字符串, 不能输出数值或进行格式变换。且识别到\0才停止输出，输出后会自动输出一个回车符</p><p>（可以将字符串直接写入puts()函数中。如:puts(“Hello, world！”);</p><p>（3）字符串处理函数（以下字符串指字符串常量或已赋值的字符数组名）</p><p>strlen(字符串)：测量指定字符串的长度（字符串结束标志前的所有字符的个数）</p><p>返回值：字符串的长度</p><p>strcat(字符数组名1,字符数组名2)：取消1的\0标志，将2连接到1后</p><p>返回值：字符数组1的首地址</p><p>strcpy(字符数组名,字符串)：将字符串存入到字符数组</p><p>返回值：字符数组的首地址</p><p>strcmp(字符串1,字符串2)：按ASCII码的顺序比较两个字符串，并由函数返回值返回比较结果</p><p>返回值：1&lt;2    返回小于0的整数</p><p>   1&#x3D;2    返回0</p><p>   1&gt;2    返回大于0的整数 </p><p>strupr(字符串)：将字符串中的所有小写字母转换成大写字母</p><p>返回值：替换后字符串的首地址</p><p>strlwr(字符串)：将字符串中的所有大写字母转换成小写字母</p><p>返回值：替换后字符串的首地址</p><p>（五）函数与编译预处理</p><p>1.全局变量</p><p>在程序的执行过程中始终都占用存储单元，建议不必要时不要用（如果用，尽可能地加上const）；</p><p>在同一个源文件中，全局变量与局部变量同名，则在局部变量的作用范围内，全局变量被屏蔽</p><p>2.变量的存储方式</p><p>（1）静态存储方式和动态存储方式</p><p>静态：在程序运行期间分配固定的存储空间的方式</p><p>动态：在程序运行期间根据需要进行动态地分配，使用完毕后立即释放</p><p>（2）自动变量：函数中的局部变量，如不专门声明为static存储类别，都是动态地分配存储空间的</p><p>（不赋初值的话，其值时不确定的）</p><p>（3）静态局部变量static：在结束函数调用时依然存在，每次调用函数时不用重新赋值而是保留上次函数调用结束时的值</p><p>（不赋初值的话，编译时默认自动赋值0或空字符）</p><p>（4）寄存器变量register：前面都是内存变量，都是由编译程序在内存中分配单元。而寄存器变量使用CPU中的寄存器存放数据，存取速度大于内存变量，但寄存器变量是无法取地址的。</p><p>（寄存器数目有限，C语言中设定个数以2个为宜，超出的当成自动变量处理）</p><p>（5）外部变量：在函数外部定义的全局变量。</p><p>外部变量的作用域是从变量的定义处开始，到本程序文件的结尾。在此作用域内，全局变量可为各个函数所引用。编译时将外部变量分配在静态存储区。</p><p>①extern用来声明一个变量（或函数），并指出它具有外部链接（它的名字在其他文件里是可见的，若使外部变量不可被其它文件看到则使用static），被extern修饰的变量在程序开始运行时被分配内存（静态存储区），程序运行结束才被回收。</p><p>②使用extern来引用函数：如在main.c中extern int fun (int num)，相比较包含头文件要简洁的多，也会加速程序预处理时间</p><p>③extern修饰符可用于指示C或者C＋＋函数的调用规范：比如在C＋＋中调用C库函数，就需要在C＋＋程序中用extern “C”声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同。</p><p>3.变量的存储位置<a href="https://www.cnblogs.com/yasmi/articles/4933842.html">https://www.cnblogs.com/yasmi/articles/4933842.html</a></p><p>（1）凡是在任何代码块之外声明的变量总是存储在静态内存中。不属于堆栈内存，这类变量称为静态变量。静态变量在函数运行之前创建。</p><p>（2）在代码块内部声明的变量的缺省存储类型是自动的，存储在堆栈中。</p><p>（3）对于在代码块内部声明的变量，如果给它加上 static 关键字，可以使它的存储类型由自动转变为静态。具有静态存储类型的变量在整个执行过程中一直存在。而不仅仅是它所在的代码块执行的时候存在。</p><p>（六）指针</p><p>1.定义</p><p>指针也是变量，不过它存储的是另外一个内存地址</p><p>unsigned int *ptr1;    &#x2F;&#x2F;ptr1是一个指向整型变量的指针变量，而它的值是某个整型变量的地址</p><p>                                  &#x2F;&#x2F;指针变量的值是地址，所以默认是无符号整型</p><p>（指向容易让人混淆，可以理解成将变量的地址赋值给了指针变量）</p><p>2.初始化：将一个地址或同类型(或相兼容的类型)的指针赋给它，而不管这个地址是怎么取得的</p><p>（1）采用NULL或空指针常量，如：int *p &#x3D; NULL;或 char *p &#x3D; 2-2; 或float *p &#x3D; 0;</p><p>（2）取一个对象的地址然后赋给一个指针，如：int i &#x3D; 3;  int *ip &#x3D; &amp;i；</p><p>（3）将一个指针常量（地址）赋给一个指针，如：long *p &#x3D; (long *)0xfffffff0;</p><p>（4）将一个T类型数组的名字赋给一个相同类型的指针，如：char array[100]; char *cp &#x3D; ary;</p><p>（5）将一个指针的地址赋给一个指针，如：int i &#x3D; 3;  int *ip &#x3D; &amp;i；int **pp &#x3D; &amp;ip;</p><p>（6）将一个字符串常量赋给一个字符指针，如：char *cp &#x3D; “abcdefg”;</p><p>（int *p;    *p&#x3D;7    &#x2F;&#x2F;编译无问题，但运行显示Segmentation fault (core dumped)，因为将7赋值给p指向的地址，而p并没有初始化，所以p指向的内存位置是随机的，无法赋值）</p><p>提示使用了未初始化的变量p，这里并不是使p指向7的地址，而是。）</p><p>（int* p&#x3D;1;    &#x2F;&#x2F;编译器弹出警告，告诉我们初始化来自于一个整数而不是一个地址，）</p><p>3.指针与一维数组</p><p>int *ptr &#x3D; a;</p><p>若ptr指向了一维数组a,则：数组元素a[i] &#x3D; *(a+i) &#x3D; *(ptr+i) &#x3D; ptr[i]</p><p>4.指针与多维数组</p><p>int a[3][4] &#x3D; {0};</p><p>int (*ptr)[4] &#x3D; a;</p><p>若ptr指向了二维数组a,则：a[i][j] &#x3D; *(a[i]+j) &#x3D; *(*(a+i)+j) &#x3D; (*(a+i))[j]</p><p>5.指针与函数</p><p>（1）指针作为函数的参数</p><p>使用指针类型做函数的参数，实际向函数传递的是变量的地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *pa,<span class="hljs-type">int</span> *pb)</span>    <span class="hljs-comment">//函数的形参是指针，其实际值就是地址</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a1=<span class="hljs-number">3</span>,b1=<span class="hljs-number">5</span>;<br>    <span class="hljs-type">int</span> a2=<span class="hljs-number">3</span>,b2=<span class="hljs-number">5</span>;<br>    <span class="hljs-type">int</span> *p1=&amp;a2,*p2=&amp;b2;<br>    <span class="hljs-type">int</span> a3=<span class="hljs-number">3</span>,b3=<span class="hljs-number">5</span>;<br>    <span class="hljs-built_in">swap</span>(&amp;a1,&amp;b1);    <span class="hljs-comment">//我们可以直接取变量的地址传递给函数</span><br>    <span class="hljs-built_in">swap</span>(p1,p2);    <span class="hljs-comment">//也可以使用指针指向需要传递地址的变量，然后将指针作为实参传递，因为指针实际值就是地址</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）指向函数的指针</p><p>int (*pf)() &#x3D; 函数名;</p><p>（3）指针型函数</p><p>int *pfun(int x, int y){}</p><p>返回值为一个指针，类型说明符说明返回的指针值指向的数据类型</p><p>例：[ ] </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">void fnSum(int x);<br>void (*pfnSum)(int x);<br><br>int main()<br>&#123;<br>    pfnSum = &amp;fnSum;    <span class="hljs-regexp">//</span>把两者关系当作简单的指针关系<br><span class="hljs-regexp">//</span>    pfnSum = fnSum;    <span class="hljs-regexp">//</span>直接指向<br><br>    fnSum(<span class="hljs-number">10</span>);    <span class="hljs-regexp">//</span>直接调用<br>    pfnSum(<span class="hljs-number">10</span>);    <span class="hljs-regexp">//</span>直接调用<br>    (*pfnSum)(<span class="hljs-number">10</span>);    <span class="hljs-regexp">//</span>通过函数指针变量调用fnSum<br>    (*fnSum)(<span class="hljs-number">10</span>);    <span class="hljs-regexp">//</span>函数名也可以使用这种调用模式<br>&#125;<br></code></pre></td></tr></table></figure><p>结论：</p><p>-fnSum的函数名与pfnSum函数指针都是一样的，即都是函数指针。fnSum函数名是一个函数指针常量，而pfnSum是一个函数指针变量</p><p>-函数名调用如果都得如(*fnSum)(10)这样，那书写与读起来都是不方便和不习惯的。所以C语言的设计者们才会设计成又可允许(*fnSum)(10)这种形式地调用</p><p>-为统一起见，pfnSum函数指针变量也可以FunP（10）的形式来调用</p><p>-赋值时 ，即可pfnSum&#x3D;&amp;fnSum形式，也可pfnSum&#x3D;fnSum</p><p>6.指针与字符串</p><p>（1）字符串指针变量</p><p>char *str &#x3D; “C language”;</p><p>char a[20];    *str &#x3D; a;</p><p>（2）字符指针作为函数参数</p><p>（3）指针数组与命令行参数</p><p>int main(int argc, char *argv[])：Ｃ语言规定main函数的参数只能有两个， 习惯上这两个参数写为argc和argv，其中，argc的值是在输入命令行时由系统按实际参数的个数自动赋予；而argv参数是字符串指针数组，其各元素值为命令行中各字符串(参数均按字符串处理)的首地址,指针数组的长度即为参数个数。</p><p>但main函数不能被其他函数调用，所以如果我们想给这两个形参赋值，需要运行一个此程序的可执行文件时，在DOS提示符下键入文件名，再输入实际参数即可把这些实参传送到main的形参中去。</p><p>DOS提示符下命令行的一般形式为： C:\&gt;可执行文件名 参数 参数……;如：C:\&gt;a:e24 BASIC dBASE FORTRAN，这里argc值为4（文件名a:e24本身也算一个参数）。</p><p>（七）结构体与共用体</p><p>1.结构体的定义方式</p><p>（1）最常用定义方式：定义结构体data，此时结构体相当于一个类型，比如int，如需使用此结构体，方法同int</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">data</span><br>&#123;<br>    <span class="hljs-type">char</span> aa;<br>    <span class="hljs-type">char</span> bb;<br>    <span class="hljs-type">char</span> cc;<br>    <span class="hljs-type">int</span> dd;<br>&#125;;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">data</span> sum1, sum2;<br></code></pre></td></tr></table></figure><p>（2）定义结构体data同时，定义需要使用的结构体变量sum1，sum2。如后面再需要定义结构体变量，方法同1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">data</span><br>&#123;<br>    <span class="hljs-type">char</span> aa;<br>    <span class="hljs-type">char</span> bb;<br>    <span class="hljs-type">char</span> cc;<br>    <span class="hljs-type">int</span> dd;<br>&#125;sum1, sum2;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">data</span> sum3;<br></code></pre></td></tr></table></figure><p>（3）定义结构体时，结构体名称缺省，同时定义结构体变量sum1，sum2。但后面不可再定义结构体变量！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span><br>&#123;<br>    <span class="hljs-type">char</span> aa;<br>    <span class="hljs-type">char</span> bb;<br>    <span class="hljs-type">char</span> cc;<br>    <span class="hljs-type">int</span> dd;<br>&#125;sum1, sum2;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sum3</span>;  &lt;-  编译器报错<br></code></pre></td></tr></table></figure><p>（4）使用typedef 定义结构体，定义结构体data时，使用typedef，此种形式几乎不使用，再定义结构体变量时，仍需加struct，否则编译器报错！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">data</span><br>&#123;<br>    <span class="hljs-type">char</span> aa;<br>    <span class="hljs-type">char</span> bb;<br>    <span class="hljs-type">char</span> cc;<br>    <span class="hljs-type">int</span> dd;<br>&#125;;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">data</span> sum3;<br></code></pre></td></tr></table></figure><p>（5）使用typedef定义结构体同时，给data结构体别名DATA，后续定义可不用使用struct data，直接使用DATA即可。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs fortran">typedef struct <span class="hljs-keyword">data</span><br>&#123;<br>    <span class="hljs-built_in">char</span> aa;<br>    <span class="hljs-built_in">char</span> bb;<br>    <span class="hljs-built_in">char</span> cc;<br>    <span class="hljs-built_in">int</span> dd;<br>&#125;<span class="hljs-keyword">DATA</span>;<br>    struct <span class="hljs-keyword">data</span> sum3; &lt;- 可用，但不推荐<br>    <span class="hljs-keyword">DATA</span> sum1; &lt;- 最常用方式<br></code></pre></td></tr></table></figure><p>（6）使用typedef定义结构体时，省掉结构体第一个别名data，直接在后面加DATA，使用方法同5。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    <span class="hljs-type">char</span> aa;<br>    <span class="hljs-type">char</span> bb;<br>    <span class="hljs-type">char</span> cc;<br>    <span class="hljs-type">int</span> dd;<br>&#125;DATA;<br>    DATA sum3<br></code></pre></td></tr></table></figure><p>2.结构体内存对齐</p><p>（1）结构体的第一个数据成员在偏移量为0的地址处。</p><p>（2）结构体变量的起始地址能够被其最宽的成员大小整除</p><p>（3）结构体每个成员相对于起始地址的偏移能够被其自身大小整除，如果不能则在前一个成员后面补充字节</p><p>（4）结构体总体大小能够被最宽的成员的大小整除，如不能则在后面补充字节</p><p>（5）若结构体里没有成员变量：不占用任何内存，sizeof()为0（gcc编译器）；编译出错（vc10.0编译器，bcc编译器）</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">    struct s1<br>    &#123;<br>        <span class="hljs-type">double</span> a;<br>        <span class="hljs-type">char</span> b;<br>        <span class="hljs-type">int</span> c;<br>    &#125;;<br>    printf(&quot;%d\n&quot;, sizeof(struct s1));<br><br>数据成员对齐数 = min( 编译器默认对齐数，该数据类型大小 )<br><span class="hljs-number">1.</span> <span class="hljs-type">double</span> a; // 地址从<span class="hljs-number">0</span>开始，前<span class="hljs-number">8</span>个字节存的是<span class="hljs-type">double</span><br><span class="hljs-number">2.</span> <span class="hljs-type">char</span> b; // min(<span class="hljs-number">8</span> ，<span class="hljs-number">1</span>) = <span class="hljs-number">1</span> ，此时下标是<span class="hljs-number">8</span>，<span class="hljs-number">8</span>是<span class="hljs-number">1</span>的整数倍，第<span class="hljs-number">9</span>个字节存的是<span class="hljs-type">char</span><br><span class="hljs-number">3.</span> <span class="hljs-type">int</span> c; // min(<span class="hljs-number">8</span>，<span class="hljs-number">4</span>) = <span class="hljs-number">4</span> ，此时下标是<span class="hljs-number">9</span>，<span class="hljs-number">9</span>不是<span class="hljs-number">4</span>的整数倍，补<span class="hljs-number">3</span>个字节，此时下标是<span class="hljs-number">12</span>，存入<span class="hljs-type">int</span><br><span class="hljs-number">4.</span>共存了<span class="hljs-number">8</span>+<span class="hljs-number">4</span>+<span class="hljs-number">4</span>=<span class="hljs-number">16</span>个字节，整体对齐系数 = min(<span class="hljs-number">8</span>，max( <span class="hljs-type">double</span>, <span class="hljs-type">char</span>, <span class="hljs-type">int</span> )) = <span class="hljs-number">8</span>，<span class="hljs-number">16</span>是<span class="hljs-number">8</span>的整数倍，不用补空字节，分析完成。<br>综上所述，该结构体占有<span class="hljs-number">16</span>个字节。<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">    struct s2<br>    &#123;<br>        <span class="hljs-type">char</span> a;<br>        struct s1 s11;<br>        <span class="hljs-type">double</span> b;<br>    &#125;;<br>    printf(&quot;%d\n&quot;, sizeof(struct s2));<br><br>数据成员对齐数 = min( 编译器默认对齐数，该数据类型大小 )<br><span class="hljs-number">1.</span> <span class="hljs-type">char</span> a; // 地址从<span class="hljs-number">0</span>开始，第一个字节存的是<span class="hljs-type">char</span><br><span class="hljs-number">2.</span> struct s1 s11; // min( <span class="hljs-number">8</span> ，max(<span class="hljs-type">double</span>,<span class="hljs-type">char</span>,<span class="hljs-type">int</span>)) = <span class="hljs-number">8</span> ，此时下标是<span class="hljs-number">1</span>，<span class="hljs-number">1</span>不是<span class="hljs-number">8</span>的整数倍，补<span class="hljs-number">7</span>个空字节，再存入s11（<span class="hljs-number">16</span>个字节）<br><span class="hljs-number">3.</span> <span class="hljs-type">double</span> b; // min(<span class="hljs-number">8</span>，<span class="hljs-number">8</span>) = <span class="hljs-number">8</span> ，此时下标是<span class="hljs-number">24</span>，<span class="hljs-number">24</span>是<span class="hljs-number">8</span>的整数倍，再存入<span class="hljs-type">double</span><br><span class="hljs-number">4.</span> 共存了<span class="hljs-number">1</span>+<span class="hljs-number">7</span>+<span class="hljs-number">16</span>+<span class="hljs-number">8</span>=<span class="hljs-number">32</span>个字节，整体对齐数 = min( <span class="hljs-number">8</span>，max( <span class="hljs-type">char</span>, struct s1, <span class="hljs-type">double</span> )) = <span class="hljs-number">8</span>，<span class="hljs-number">32</span>是<span class="hljs-number">8</span>的整数倍，不用补空字节，分析完成。<br>综上所述，该结构体占有<span class="hljs-number">32</span>个字节。<br></code></pre></td></tr></table></figure><p>3.结构体的成员引用</p><p>（1）一般情况下用“.”，只需要声明一个结构体。格式是，结构体类型名+结构体名。然后用结构体名加“.”加域名就可以引用域 了。因为自动分配了结构体的内存。如同 int a;一样。</p><p>（2）用“-&gt;”，则要声明一个结构体的指针，还要手动开辟一个该结构体的内存，然后把返回的指针给声明的结构体指针，才能用“-&gt;”正确引用。否则内存中只分配了指针的内存，没有分配结构体的内存，导致想要的结构体实际上是不存在。这时候用“-&gt;”引用自然出错了，因为没有结构体，自然没有结构体的域了。</p><p>4.结构体与柔性数组</p><p>-柔性数组即数组大小待定的数组。</p><p>-C语言中可以由结构体产生柔性数组；</p><p>-C语言结构体的最后一个元素可以是大小未知的数组，且柔性数组成员前面必须至少一个其它成员</p><p>-柔性数组成员只作为一个符号地址存在，sizeof返回的这种结构大小不包括柔性数组的内存</p><p>-包含柔性数组成员的结构用malloc()函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">struct</span> SoftArray<br>&#123;<br>    <span class="hljs-built_in">int</span> len;<br>    <span class="hljs-built_in">int</span> array[];<br>&#125;<br><span class="hljs-keyword">sizeof</span>( <span class="hljs-keyword">struct</span> SoftArray ) = <span class="hljs-number">4</span>    <span class="hljs-comment">//结构体中的柔性数组仅是一个待使用的标识符，不占用存储空间</span><br></code></pre></td></tr></table></figure><p>柔性数组的用法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">struct</span> SoftArray<br>&#123;<br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-type">int</span> array[];<br>&#125;<br><br><span class="hljs-keyword">struct</span> SoftArray* sa = <span class="hljs-literal">NULL</span>;<br>sa = (<span class="hljs-keyword">struct</span> SoftArray*)malloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> SoftArray) + <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">5</span>);<br>sa-&gt;len = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>r柔性数组的使用分析</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;malloc.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SoftArray</span><br>&#123;<br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-type">int</span> array[];<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SoftArray</span>* <span class="hljs-built_in">create_soft_array</span>(<span class="hljs-type">int</span> size)<br>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SoftArray</span>* ret = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span>(size &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        ret = (<span class="hljs-keyword">struct</span> SoftArray*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> SoftArray) + <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * size);<br>        ret-&gt;len = size;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">delete_soft_array</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> SoftArray* sa)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">free</span>(sa);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> SoftArray* sa)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> != sa)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;sa-&gt;len; i++)<br>        &#123;<br>            sa-&gt;array[i] = i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SoftArray</span>* sa = <span class="hljs-built_in">create_soft_array</span>(<span class="hljs-number">10</span>);<br><br>    <span class="hljs-built_in">func</span>(sa);<br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;sa-&gt;len; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, sa-&gt;array[i]);<br>    &#125;<br><br>    <span class="hljs-built_in">delete_soft_array</span>(sa);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><p>5.共用体</p><p>（1）概念</p><p>当需要把不同类型的变量存放到同一段内存单元或对同一段内存单元的数据按不同类型处理时，需要使用共用体数据结构。</p><p>（2）定义：在语法上与struct相似</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">union</span> 共用体名<br>&#123;<br>    类型说明符 成员项<span class="hljs-number">1</span>；<br>    ...<br>&#125;变量列表；<br></code></pre></td></tr></table></figure><p>（3）特点</p><p>①共用体各成员占相同的起始地址所占内存长度等于最长的成员所占内存</p><p>②只能引用共用体变量的成员，不能整体引用共用体变量</p><p>③共用体变量中起作用的成员是最后一次存放的成员</p><p>④可以对共用体变量初始化，但初始化表中只能有一个常量，即只能初始化一个成员</p><p>（4）注意事项</p><p>-union的使用受系统大小端影响</p><p>地址的高地位：有一段连续的地址：0x00、0x01、0x02、0x03，很简单，值小的就低，大的就高，那就是0x00是低地址，往右递增。</p><p>小端模式：数据的低字节存放到内存的低地址中，高字节存到高地址中。并且小端模式下优先将数据填充到内存的低地址中。（适合计算机理解）</p><p>   地址：0x00 | 0x01 | 0x02 | 0x03       内存地址从左到右由低到高</p><p>   数据：0x78 | 0x56 | 0x34 | 0x12       数据字节从左到右由低到高</p><p>大端模式：数据的低字节存放到内存的高地址中，高字节存到低地址中，且数据优先填充到高地址上。（适合人类理解）</p><p>   地址：0x00 | 0x01 | 0x02 | 0x03       内存地址从左到右由低到高</p><p>   数据：0x12 | 0x34 | 0x56 | 0x78       数据字节从左到右由高到低</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs llvm">union <span class="hljs-keyword">c</span><br>&#123;<br>    int i<span class="hljs-comment">;</span><br>    char <span class="hljs-keyword">c</span><span class="hljs-comment">;    //不管是大端还是小端，都是从低地址取数据</span><br>&#125;<span class="hljs-comment">;</span><br><span class="hljs-comment"></span><br>union C <span class="hljs-keyword">c</span><span class="hljs-comment">;</span><br><span class="hljs-comment"></span><br><span class="hljs-keyword">c</span>.i <span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-comment">;</span><br><span class="hljs-comment"></span><br>printf(<span class="hljs-string">&quot;%d\n&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">c</span>.<span class="hljs-keyword">c</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>例：编程判断系统大小端</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">system_mode</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">union</span> <span class="hljs-title class_">SM</span><br>    &#123;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-type">char</span> c;<br>    &#125;;  <br><br>    <span class="hljs-keyword">union</span> <span class="hljs-title class_">SM</span> sm;<br><br>    sm.i = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">return</span> sm.c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;System mode:%d\n&quot;</span>,<span class="hljs-built_in">system_mode</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用联合体的时候要注意系统大小端</p><p>6.枚举</p><p>（1）概念</p><p>enum是C语言中的一种自定义类型，一个被命名的整型常数的集合,</p><p>（2）定义</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs prolog">enum 枚举名&#123;<br>    标识符[=整型常数],<br>    标识符[=整型常数],<br>    ...<br>    标识符[=整型常数],<br>    &#125; 枚举变量;<br>如果枚举没有初始化, 则从第一个标识符开始, 顺次赋给标识符<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, ...（即默认值依次为<span class="hljs-number">0</span>，<span class="hljs-number">1</span>，<span class="hljs-number">2.</span>...）。<br>但当枚举中的某个成员赋值后, 其后的成员若无赋值则按依次加<span class="hljs-number">1</span>的规则确定其值。<br></code></pre></td></tr></table></figure><p>（3）特点</p><p>①枚举就是给这些常量值，规定一个名字（和define很像）</p><p>②枚举量可以直接作为值使用 </p><p>③枚举类型可以直接作为类型使用</p><p>用这个关键字来一次定义许多标记整型常量，其实它相当于定义一个整型常量的表，方便应用时查找</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">enum</span>                    <span class="hljs-comment">//无名枚举，用于定义常量</span><br>&#123;<br>    ARRAY_SIZE = <span class="hljs-number">10</span>;    <span class="hljs-comment">//定义数组大小</span><br>&#125;;<br><br><span class="hljs-built_in">int</span> <span class="hljs-built_in">array</span>[ARRAY_SIZE] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;ARRAY_SIZE; i++)<br>&#123;<br>    <span class="hljs-built_in">array</span>[i] = i + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>例：enum的用法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-keyword">enum</span>                    <br>&#123;<br>    ARRAY_SIZE = <span class="hljs-number">10</span>;            <span class="hljs-comment">//枚举用法1：定义常量</span><br>&#125;;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span><br>&#123;<br>    RED   = <span class="hljs-number">0x00FF0000</span>;        <span class="hljs-comment">//枚举用法2：定义离散的整形值内容</span><br>    GREEN = <span class="hljs-number">0x0000FF00</span>;<br>    BLUE  = <span class="hljs-number">0x000000FF</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintColor</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> Color c)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">switch</span>(c)<br>    &#123;<br>        <span class="hljs-keyword">case</span> RED:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Color:RED (0x%08X)\n&quot;</span>, c);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> GREEN:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Color:GREEN (0x%08X)\n&quot;</span>, c);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> BLUE:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Color:BLUE (0x%08X)\n&quot;</span>, c);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitArray</span><span class="hljs-params">(<span class="hljs-type">int</span> array[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;ARRAY_SIZE; i++)<br>    &#123;<br>        array[i] = i + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintArray</span><span class="hljs-params">(<span class="hljs-type">int</span> array[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;ARRAY_SIZE; i++)<br>    &#123;<br>        <span class="hljs-built_in">pritf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, array[i]);<br>    &#125;    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> c = GREEN;<br><br>    <span class="hljs-type">int</span> array[ARRAY_SIZE] = &#123;<span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-built_in">PrintArray</span>(c);<br><br>    <span class="hljs-built_in">InitArray</span>(array);<br><br>    <span class="hljs-built_in">PrintColor</span>(array);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）枚举和宏定义</p><p>枚举和宏其实非常类似：宏在预处理阶段将名字替换成对应的值，枚举在编译阶段将名字替换成对应的值。我们可以将枚举理解为编译阶段的宏。</p><p>使用宏定义看起来代码会比较松散，使用枚举时的代码更简洁紧凑。</p><p>（5）enum和const</p><p>const定义的不是真正意义上的常量，它定义的仅仅是一个只读变量</p><p>enum定义的是真正意义上的常量</p><p>（八）位运算</p><p><a href="evernote:///view/18988257/s16/6762374f-ef73-42c2-acd3-afe19171e528/6762374f-ef73-42c2-acd3-afe19171e528/">第008课_第1个ARM裸板程序及引申(部分免费)</a>006节</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>const</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/const/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/const/</url>
    
    <content type="html"><![CDATA[<p> 一、概念</p><p>const不能定义真正意义上的常量，const定义的只是一个只读变量，告诉编译器变量不能出现在赋值符号的左边，本质还是变量。</p><p>二、用法</p><p>2.1 修饰常变量</p><p>（1）用于定义常变量时，需要初始化。</p><p>（2）数据类型对于const而言是透明的</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;   等价于 <span class="hljs-built_in">int</span> <span class="hljs-keyword">const</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> *p1 = &amp;a; 等价于 <span class="hljs-built_in">int</span> <span class="hljs-keyword">const</span> *p1 = &amp;a;   但不等价于<span class="hljs-built_in">int</span> *<span class="hljs-keyword">const</span> p1=&amp;a;<br></code></pre></td></tr></table></figure><p>（3）const用于封锁直接修饰的内容，使该内容变为只读，在程序中不能作为左值（左值：放在赋值号‘&#x3D;’的左边，使用变量的写权限）</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const int a <span class="hljs-operator">=</span> <span class="hljs-number">10</span><span class="hljs-comment">;    //const封锁a</span><br><br><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span><span class="hljs-comment">;             //a作为左值，使用a的写权限，非法</span><br>int b <span class="hljs-operator">=</span> a<span class="hljs-comment">;           //使用a的读权限，合法</span><br></code></pre></td></tr></table></figure><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs smali">int<span class="hljs-built_in"> const </span>*p1 = &amp;a;<span class="hljs-built_in"></span><br><span class="hljs-built_in">const </span>int *p1 = &amp;a;     //const修饰*p1，将*p1作为左值非法，将p1作为左值合法<br><br>p1 = &amp;b;                //使用p1做左值，合法<br>*p1 = 200；             //使用*p1做左值，非法<br></code></pre></td></tr></table></figure><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smali">int *const p2 = &amp;a;     //const修饰p2,将p2作为左值非法，将*p2作为左值合法<br><br>p2 = &amp;b;                //使用p2做左值，非法<br>*p2 = 100;              //使用*p2做左值，合法<br></code></pre></td></tr></table></figure><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smali">const<span class="hljs-built_in"> int </span>*const p3 = &amp;a;    //const分别修饰*p3,p3,将*p3，p2作为左值都非法<br><br>p3 = &amp;b;                      //使用p3做左值，非法<br>*p3 = 100;                    //使用*p3做左值，非法<br></code></pre></td></tr></table></figure><p>2.2 修饰函数的参数</p><p>（1）用作函数的输入参数，防止输入内容被修改。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StringCopy</span>(<span class="hljs-params"><span class="hljs-built_in">char</span> *<span class="hljs-keyword">out</span>, <span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> *<span class="hljs-keyword">in</span></span>)</span>;<br></code></pre></td></tr></table></figure><p>其中in 是输入参数，out是输出参数。给in加上 const 修饰后，如果函数体内的语句试图改动 strSource 的内容，编译器将指出错误。</p><p>（2）防止修改指针指向的地址</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">void</span> swap ( <span class="hljs-built_in">int</span> *<span class="hljs-keyword">const</span> p1 , <span class="hljs-built_in">int</span> *<span class="hljs-keyword">const</span> p2 )<br></code></pre></td></tr></table></figure><p>指针p1和指针p2指向的地址都不能被修改。</p><p>（3）以上两种的结合</p><p>2.3 修饰函数的返回值</p><p>表示返回值不可改变，多用于返回值为指针的情形，且该返回值只能被赋给加const 修饰的同类型指针。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> * GetString(<span class="hljs-keyword">void</span>);<br><span class="hljs-built_in">char</span> *<span class="hljs-built_in">str</span> = GetString();    <span class="hljs-comment">//编译错误</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> *<span class="hljs-built_in">str</span> = GetString();    <span class="hljs-comment">//编译成功</span><br></code></pre></td></tr></table></figure><p>2.4 修饰全局变量</p><p>首先我们要尽量避免使用全局变量，它不仅在程序结束前一直占用数据段上的空间，而且可以在任何地方更改，减少软件的安全性。所以我们尽量使用const进行修饰，以防止不必要的人为修改。</p><p>三、const和编译器</p><p>早期的标准C语言编译器(bcc)中const修饰的全局变量在全局数据区分配空间，其值依然可以改变；在现代C语言编译器(如gcc,vc6.0)中，将const修饰的全局变量存储于只读存储区，无法通过指针修改其值。</p><p>四、const的变量本质</p><p>4.1 本质一</p><p>const修饰的局部变量在栈上分配空间，虽然不可通过赋值号改变其值，但可以通过指针改变其值；</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs perl">const <span class="hljs-keyword">int</span> g_cc = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">int</span> main()<br>&#123;<br>    const <span class="hljs-keyword">int</span> cc = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">int</span>* p = (<span class="hljs-keyword">int</span>*)&amp;cc;<br><br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;cc = %d\n&quot;</span>, cc);<br><br>    *p = <span class="hljs-number">3</span>;        <span class="hljs-regexp">//</span>编译通过<br>//    cc = <span class="hljs-number">3</span>;    <span class="hljs-regexp">//</span>error:assignment of <span class="hljs-keyword">read</span>-only variable <span class="hljs-string">&#x27;cc&#x27;</span><br><br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;cc = %d\n&quot;</span>, cc);<br><br>    p = (<span class="hljs-keyword">int</span>*)&amp;g_cc;<br><br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;g_cc = %d\n&quot;</span>, g_cc);<br><br>    *p = <span class="hljs-number">4</span>;    <span class="hljs-regexp">//</span>编译通过，但程序崩溃<br>               /*因为现代编译器都对const进行了优化，const修饰的全局变量会被编译进入只读存储区，一旦程序对只读存储区的内容进行修改，就会发生崩溃；但早期编译器是可以修改const全局变量的内存空间的，const修饰的全局变量没有编译进入只读存储区*<span class="hljs-regexp">/</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">    printf(&quot;g_cc = %d\n&quot;, g_cc);    /</span>/error:assignment of <span class="hljs-keyword">read</span>-only variable <span class="hljs-string">&#x27;cc&#x27;</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>-现代C编译器中的const将具有全局生命周期的变量存储于只读存储区。</p><p>（全局生命周期的变量有全局变量和static修饰的局部变量。）</p><p>4.2 本质二</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> g_array[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span>* p, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    *p = v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-type">const</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-type">const</span> array[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-built_in">modify</span>((<span class="hljs-type">int</span>*)&amp;i, <span class="hljs-number">1</span>);             <span class="hljs-comment">//ok</span><br>    <span class="hljs-built_in">modify</span>((<span class="hljs-type">int</span>*)&amp;j, <span class="hljs-number">2</span>);             <span class="hljs-comment">//error(gcc编译器)</span><br>    <span class="hljs-built_in">modify</span>((<span class="hljs-type">int</span>*)&amp;array[<span class="hljs-number">0</span>], <span class="hljs-number">3</span>);      <span class="hljs-comment">//ok</span><br>    <span class="hljs-built_in">modify</span>((<span class="hljs-type">int</span>*)&amp;g_array[<span class="hljs-number">0</span>], <span class="hljs-number">4</span>);    <span class="hljs-comment">//error(gcc编译器)</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %d\n&quot;</span>, i);    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;j = %d\n&quot;</span>, j);    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;array[0] = %d\n&quot;</span>, array[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;g_array[0] = %d\n&quot;</span>, g_array[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><p>注意：C语言中的字符串字面量（字符串常量）存储于只读存储区，在程序中需要使用const char*指针指向。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* s = <span class="hljs-string">&quot;Delphi Tanf&quot;</span><br></code></pre></td></tr></table></figure><p>（三）和宏定义define的区别：宏常量本质为字面量（字面量不占用内存）</p><p>#define指令是另一种创建名字常量的机制。例如，下面这两个声明都为50这个值创建了名字常量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_ELEMENTS 50</span><br><span class="hljs-type">int</span> <span class="hljs-type">const</span> max_elements <span class="hljs-number">50</span>;<br></code></pre></td></tr></table></figure><p>在这种情况下，使用#define比使用const变量更好。#define定义的宏常量本质为字面量（字面量不占用内存），因为只要允许使用字面值常量的地方，都可以使用前者，比如声明数组的长度。const变量只能用于允许使用变量的地方。</p><p><span style="background-color: #ffaaaa">3.编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。</span></p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>attribute</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/-attribute-/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/-attribute-/</url>
    
    <content type="html"><![CDATA[<p>本文为C语言attribute语法的记录#<br><strong>attribute</strong></p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运算符:#和##</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/%E8%BF%90%E7%AE%97%E7%AC%A6#%E5%92%8C##/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/%E8%BF%90%E7%AE%97%E7%AC%A6#%E5%92%8C##/</url>
    
    <content type="html"><![CDATA[<p>一、#运算符</p><p>#运算符用于在预处理期将宏参数转换为字符串，且#的转换作用是在预处理期完成的,因此只在宏定义中有效，编译器并不知道#的转换作用。</p><p>1.1 用法</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso">#define <span class="hljs-built_in">STRING</span>(x) #X<br>printf(<span class="hljs-string">&quot; %s\n&quot;</span>, <span class="hljs-built_in">STRING</span>(Hello World!)); .<br></code></pre></td></tr></table></figure><p>运算符的基本用法</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><br><span class="hljs-comment">#define STRING(x) #x</span><br><br><span class="hljs-keyword">int</span> main()<br>&#123;<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, STRING(Hello world!));<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, STRING(<span class="hljs-number">100</span>));<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, STRING(<span class="hljs-keyword">while</span>));<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, STRING(<span class="hljs-keyword">return</span>));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>/* test.i */<br><span class="hljs-comment"># 1 &quot;test.c&quot;</span><br><span class="hljs-comment"># 1 &quot;&lt;built-in&gt;&quot;</span><br><span class="hljs-comment"># 1 &quot;&lt;command-line&gt;&quot;</span><br><span class="hljs-comment"># 1 &quot;test.c&quot;</span><br><br><span class="hljs-keyword">int</span> main()<br>&#123;<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, <span class="hljs-string">&quot;Hello world!&quot;</span>);<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, <span class="hljs-string">&quot;100&quot;</span>);<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, <span class="hljs-string">&quot;while&quot;</span>);<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, <span class="hljs-string">&quot;return&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>1.2 运算符的妙用</p><p>打印函数名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">/* 通过#运算符将f这个函数名转换为字符串打印出来 */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CALL(f, p) (printf(<span class="hljs-string">&quot;Call function %s\n&quot;</span>, #f), f(p))</span><br>   <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> n * n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <br>    result = <span class="hljs-built_in">CALL</span>(square, <span class="hljs-number">4</span>);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;result = %d\n&quot;</span>, result);<br>    <br>    result = <span class="hljs-built_in">CALL</span>(func, <span class="hljs-number">10</span>);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;result = %d\n&quot;</span>, result);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* test.i */</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;test.c&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;&lt;built-in&gt;&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;&lt;command-line&gt;&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;test.c&quot;</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> n * n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><br>    result = (<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Call function %s\n&quot;</span>, <span class="hljs-string">&quot;square&quot;</span>), <span class="hljs-built_in">square</span>(<span class="hljs-number">4</span>));<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;result = %d\n&quot;</span>, result);<br><br>    result = (<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Call function %s\n&quot;</span>, <span class="hljs-string">&quot;func&quot;</span>), <span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>));<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;result = %d\n&quot;</span>, result);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>二、##运算符</p><p>##运算符用于在预处理期粘连两个标识符，##的连接作用是在预处理期完成的,因此只在宏定义中有效，编译器并不知道##的连接作用</p><p>2.1 用法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#define <span class="hljs-constructor">CONNECT(<span class="hljs-params">a</span>, <span class="hljs-params">b</span>)</span> a##b<br><span class="hljs-built_in">int</span> <span class="hljs-constructor">CONNECT(<span class="hljs-params">a</span>, 1)</span>;<br><span class="hljs-comment">// int al;</span><br>.a1= <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>运算符的基本用法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NAME(n) name##n</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">NAME</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;    <span class="hljs-comment">//name1</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">NAME</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;    <span class="hljs-comment">//name2</span><br>    <br>    <span class="hljs-built_in">NAME</span>(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span>;    <span class="hljs-comment">//name1 = 1;</span><br>    <span class="hljs-built_in">NAME</span>(<span class="hljs-number">2</span>) = <span class="hljs-number">2</span>;    <span class="hljs-comment">//name2 = 2;</span><br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">NAME</span>(<span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">NAME</span>(<span class="hljs-number">2</span>));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.2 运算符的工程运用</p><p>结合#define简单定义结构体</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">#include <span class="hljs-operator">&lt;</span>stdio.h<span class="hljs-operator">&gt;</span><br><br><span class="hljs-operator">/*</span> 达到两个效果，首先使用一个typedef定义一个结构体标签，然后再定义一个结构体 <span class="hljs-operator">*/</span><br>#define STRUCT(<span class="hljs-keyword">type</span>) typedef <span class="hljs-keyword">struct</span> _tag_##<span class="hljs-keyword">type</span> <span class="hljs-keyword">type</span>;\<br>                     <span class="hljs-keyword">struct</span> _tag_##<span class="hljs-keyword">type</span><br><br>STRUCT(Student)<br>&#123;<br>    char<span class="hljs-operator">*</span> name;<br>    int <span class="hljs-built_in">id</span>;<br>&#125;;<br><br><span class="hljs-operator">/*</span> test.i中上面代码<br> <span class="hljs-operator">*</span> typedef <span class="hljs-keyword">struct</span> _tag_Student Student; <br> <span class="hljs-operator">*</span> <span class="hljs-keyword">struct</span> _tag_Student<br> <span class="hljs-operator">*/</span><br><br>int main()<br>&#123;<br>    <br>    Student s1;<br>    Student s2;<br>    <br>    s1.name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;s1&quot;</span>;<br>    s1.<span class="hljs-built_in">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <br>    s2.name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;s2&quot;</span>;<br>    s2.<span class="hljs-built_in">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;s1.name = %s\n&quot;</span>, s1.name);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;s1.id = %d\n&quot;</span>, s1.<span class="hljs-built_in">id</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;s2.name = %s\n&quot;</span>, s2.name);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;s2.id = %d\n&quot;</span>, s2.<span class="hljs-built_in">id</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义结构体后使用结构体需要重复写上struct student，所以应用typedef来节省时间，但结构体数目一多，又要定义很多typedef，这时就可以使用##连接符和#define。</p><p>小结</p><p>#运算符用于在预处理期将宏参数转换为字符串</p><p>##运算符用于在预处理期粘连两个标识符</p><p>编译器不知道#和##运算符的存在</p><p>#和##运算符只在宏定义中有效.</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>宏定义:#pragma</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/%E5%AE%8F%E5%AE%9A%E4%B9%89#pragma/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/%E5%AE%8F%E5%AE%9A%E4%B9%89#pragma/</url>
    
    <content type="html"><![CDATA[<p>一、简介</p><p>#pragma用于指示编译器完成一些特定的动作。</p><p>特点：</p><ul><li><p>#pragma所定义的很多指示字是编译器特有的，在不同的编译器间不可移植。</p></li><li><p>预处理器将忽略它不认识的#pragma指令</p></li><li><p>不同的编译器可能以不同的方式解释同一条#pragma指令</p></li></ul><p>一般用法:#pragma parameter</p><p>注:不同的parameter参数语法和意义各不相同.</p><p>二、#pragma message</p><p>message参数在编译时输出消息到编译输出窗口中，类似#error和#warining。</p><p>message大多用于条件编译中可提示代码的版本信息，且message参数在大多数的编译器中都有相似的实现</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(ANDROID20)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> message(&quot;Compile Android SDK 2.0...&quot;)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> VERSION &quot;Android 2.0”</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>与#error和#warning不同，#pragma message仅仅代表一条编译消息，不代表程序错误。</p><p>例：#pragma message使用实例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(ANDROID20)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> message(<span class="hljs-string">&quot;Compile Android SDK 2.0...&quot;</span>)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> VERSION <span class="hljs-string">&quot;Android 2.0&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(ANDROID23)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> message(<span class="hljs-string">&quot;Compile Android SDK 2.3...&quot;</span>)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> VERSION <span class="hljs-string">&quot;Android 2.3&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(ANDROID40)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> message(<span class="hljs-string">&quot;Compile Android SDK 4.0...&quot;</span>)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> VERSION <span class="hljs-string">&quot;Android 4.0&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">error</span> Compile Version is not provided!</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, VERSION);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* gcc： */</span>    <br><span class="hljs-comment">#pragma message：Compile Android SDK 4.0...</span><br><span class="hljs-regexp">/* vc4.0 */</span><br>Compile Android SDK <span class="hljs-number">4.0</span>...<br><span class="hljs-regexp">/* bcc */</span><br>Compile Android SDK <span class="hljs-number">2.3</span>...<br></code></pre></td></tr></table></figure><p>#pragma message在不同的编译器实现方式不同</p><p>三、#pragma once</p><p>#pragma once用于保证头文件只被编译器包含（打开）一次，预处理器下次遇到包含此文件的命令就不会执行。但#pragma once是编译器相关的，不一定被支持</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#ifndef_ HEADER FILE_ H_</span><br><span class="hljs-comment">#define_ HEADER_ FILE_ H_</span><br><span class="hljs-regexp">//</span> source code<br><span class="hljs-comment">#endif</span><br></code></pre></td></tr></table></figure><p>VS</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br></code></pre></td></tr></table></figure><p>#ifdef的优点是一致性，但效率慢。#pragma once的优点是效率高，但不一定被编译器支持。</p><p>#ifdef在每个文件里都要通过宏的方式来判断文件是否被包含，预处理器处理了多次，效率慢</p><p>#pragma once直接告诉预处理器这个文件只编译一次，一次include后再include预处理器就不会处理。</p><p>例：#pragma once使用分析</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;global.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;global.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;g_value = %d\n&quot;</span>, g_value);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">gcc、vc2010支持<span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br>bcc不支持<span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br></code></pre></td></tr></table></figure><p>可以这样写就结合#ifdef和#pragma的优点，既保证了编译效率，又保证了一致性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _GLOBAL_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GLOBAL_H_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-type">int</span> g_value = <span class="hljs-number">1</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>四、#pragma pack</p><p>#pragma pack用于指定结构、联合和类成员的封装对齐，改变编译器的内存对齐方式。</p><p>如果未设置编译器选项，windows默认为8，linux默认为4。且指定时应注意编译器是否支持，比如gcc编译器不支持8字节对齐。</p><p>4.1 #pragma pack使用示例：</p><p>#pragma pack(1)</p><p>strust Test1</p><p>{</p><p>    char c1;</p><p>    short s;</p><p>    char c2;</p><p>    int i;</p><p>};</p><p>#pragma pack()</p><p>#pragma pack(1)</p><p>strust Test2</p><p>{</p><p>    char c1;</p><p>    char c2;</p><p>    short s;</p><p>    int i;</p><p>};</p><p>#pragma pack()</p><p>sizeof(struct Test1) &#x3D; 8，不对齐为12</p><p>sizeof(struct Test2) &#x3D; 8，不对齐为8</p><p>4.2 什么是内存对齐?</p><p>不同类型的数据在内存中按照一定的规则排列，而不一定是顺序的一一个接一个的排列</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs abnf">strust Test1<br>&#123;<br>    char c1<span class="hljs-comment">;</span><br>    short s<span class="hljs-comment">;</span><br>    char c2<span class="hljs-comment">;</span><br>    int i<span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br>strust Test2<br>&#123;<br>    char c1<span class="hljs-comment">;</span><br>    char c2<span class="hljs-comment">;</span><br>    short s<span class="hljs-comment">;</span><br>    int i<span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>Testl和Test2所占的内存空间是否相同?</p><p>不同，Test1占用12，Test2占用8</p><p><img src="/image/81457ebe9ab393c3beb307a562a51431.png" alt="81457ebe9ab393c3beb307a562a51431.png"></p><p>4.2 为什么需要内存对齐?</p><ul><li>CPU对内存的读取不是一个一个字节取出，而是根据自己的字长分成块读取的，比如32位处理器将取出4个字节的内存块进行处理，取多了也是由内存处理器帮忙完成数据挑拣再传送给CPU。</li><li>当读取操作的数据未对齐,则需要两次总线周期来访问内存,性能会大打折扣，因此CPU保证用尽量少的CPU周期将它们从内存读进来。比如下面这样就要读两次：<img src="/image/20180313012805740.png" alt="20180313012805740.png"></li><li>某些硬件平台只能从规定的相对地址处读取特定类型的数据,否则产生硬件异常</li></ul><p>4.3 struct占用的内存大小对齐规则</p><ul><li>第一个成员起始于0偏移处</li><li>每个成员按其类型大小和pack参数中较小的一个进行对齐<ul><li>偏移地址必须能被对齐参数整除</li><li>结构体成员的大小取其内部长度最大的数据成员作为其大小</li></ul></li><li>结构体总长度必须为所有对齐参数的整数倍</li></ul><p>编译器在默认情况下按照4字节对齐，即#pragma pack(4)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(2)</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test1</span><br>&#123;<br>    <span class="hljs-type">char</span>  c1;<br>    <span class="hljs-type">short</span> s;<br>    <span class="hljs-type">char</span>  c2;<br>    <span class="hljs-type">int</span>   i;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack()</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(4)</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test2</span><br>&#123;<br>    <span class="hljs-type">char</span>  c1;<br>    <span class="hljs-type">char</span>  c2;<br>    <span class="hljs-type">short</span> s;<br>    <span class="hljs-type">int</span>   i;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack()</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(Test1) = %d\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> Test1));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(Test2) = %d\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> Test2));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(8)</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S1</span><br>&#123;                <span class="hljs-comment">//对齐参数     偏移地址     大小</span><br>    <span class="hljs-type">short</span> a;     <span class="hljs-comment">//2            8           2</span><br>    <span class="hljs-type">long</span> b;      <span class="hljs-comment">//4            4           4</span><br>&#125;;  <br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S2</span><br>&#123;                <span class="hljs-comment">//对齐参数     偏移地址     大小</span><br>    <span class="hljs-type">char</span> c;      <span class="hljs-comment">//1            0           1</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">S1</span> d; <span class="hljs-comment">//4            4           8</span><br>    <span class="hljs-type">double</span> e;    <span class="hljs-comment">//9            16          9</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack()</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> S1));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> S2));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>小结</p><p>#pragma用于指示编译器完成- -些特定的动作</p><p>#pragma所定义的很多指示字是编译器特有的</p><ul><li>#pragma message用于自定义编译消息</li><li>#pragma once用于保证头文件只被编译-次</li><li>#pragma pack用于指定内存对齐方式</li></ul>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>宏定义:#error和#line</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/%E5%AE%8F%E5%AE%9A%E4%B9%89#error%E5%92%8C#line/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/%E5%AE%8F%E5%AE%9A%E4%B9%89#error%E5%92%8C#line/</url>
    
    <content type="html"><![CDATA[<p>一、#error的用法</p><p>1.1 #error用于生成一个编译错误消息</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sas">#<span class="hljs-keyword">error</span> <span class="hljs-keyword">message</span><br><span class="hljs-keyword">message</span>不需要用双弓|号包围<br></code></pre></td></tr></table></figure><p>#error编译用于自定义程序员特需的编译错误消息（一些不影响程序运行但不符合我们预期的错误）。类似的, #warning用于生成编译警告信息。</p><p>比如可用于提示编译条件是否满足</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#ifndef_ cplusplus</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">error</span> This file should be processed with C+ + compiler.</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>如果#error执行，编译器就会报错，报的错即程序员自定义的这个错，编译过程中的任意错误信息意味着无法生成最终的可执行程序。</p><p>例1：#error在条件编译中的应用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 使用宏PRODUCT来决定编译哪些程序，从而区分出高中低端产品 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> ( PRODUCT == 1 )</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is a low level product!\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> ( PRODUCT == 2 )</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is a middle level product!\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> ( PRODUCT == 3 )</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is a high level product!\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">f</span>();<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1. Query Information.\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2. Record Information.\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;3. Delete Information.\n&quot;</span>);<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> ( PRODUCT == 1 )</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;4. Exit.\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> ( PRODUCT == 2 )</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;4. High Level Query.\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;5. Exit.\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> ( PRODUCT == 3 )</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;4. High Level Query.\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;5. Mannul Service.\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;6. Exit.\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">gcc -DPRODUCT=<span class="hljs-number">2</span> test.c    <br><span class="hljs-regexp">/* 我们通过编译PRODUCT这个宏来决定属于哪个产品，但若我们忘记编译该宏，程序依旧会编译通过，并不能给我们警示信息，这样会导致我们的程序达不到我们的要求 */</span><br></code></pre></td></tr></table></figure><p>我们可以通过#error或#warning来指出错误信息，可以这么修改</p><p>①使用#error</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> ( PRODUCT == 1 )</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is a low level product!\n&quot;</span>);<br>    ...<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">error</span> The <span class="hljs-string">&quot;PRODUCT&quot;</span> is NOT defined!</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> ( PRODUCT == 1 )</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;4. Exit.\n&quot;</span>);<br>    ...<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">error</span> The <span class="hljs-string">&quot;PRODUCT&quot;</span> is NOT defined!</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>不在命令中定义宏PRODUCT，#error语句执行，程序报错，无法生成可执行程序。</p><p>②使用#warning</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> ( PRODUCT == 1 )</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is a low level product!\n&quot;</span>);<br>    ...<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">warning</span> The <span class="hljs-string">&quot;PRODUCT&quot;</span> is NOT defined!</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> ( PRODUCT == 1 )</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;4. Exit.\n&quot;</span>);<br>    ...<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">warning</span> The <span class="hljs-string">&quot;PRODUCT&quot;</span> is NOT defined!</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>不在命令中定义宏PRODUCT，#warning语句执行，程序发出警告，可执行程序依旧生成。</p><p>二、#line的用法</p><p>#line用于强制指定新的行号和编译文件名,并对源程序的代码重新编号。</p><p>2.1用法</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-meta">#line number fil ename</span><br>filename可省略<br></code></pre></td></tr></table></figure><p>#line编译指示字的本质是重定义_ LINE_（行号） 和_ FILE_（文件名）</p><p>2.2 来源</p><p>最初的C语言程序员都比较小，程序员都习惯所有代码写在一个文件中，后来逐渐开始合作。一个程序员a写a.c，另一个写b.c，写完后再放到一个程序中，但程序要出错后需要改错，谁写的谁解决，于是出现以下类似的代码。</p><p>例3：#line的使用</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs d">#include &lt;stdio.h&gt;<br><br><span class="hljs-comment">// The code section is written by A.</span><br><span class="hljs-comment">// Begin</span><br><span class="hljs-meta">#line 1 &quot;a.c&quot;</span><br><br><span class="hljs-comment">// End</span><br><br><span class="hljs-comment">// The code section is written by B.</span><br><span class="hljs-comment">// Begin</span><br><span class="hljs-meta">#line 1 &quot;b.c&quot;</span><br><br><span class="hljs-comment">// End</span><br><br><span class="hljs-comment">// The code section is written by Delphi.</span><br><span class="hljs-comment">// Begin</span><br><span class="hljs-meta">#line 1 &quot;delphi_tang.c&quot;</span><br><br><span class="hljs-keyword">int</span> main()<br>&#123;<br>    printf(<span class="hljs-string">&quot;%s : %d\n&quot;</span>, <span class="hljs-keyword">__FILE__</span>, <span class="hljs-keyword">__LINE__</span>);<br>    <br>    printf(<span class="hljs-string">&quot;%s : %d\n&quot;</span>, <span class="hljs-keyword">__FILE__</span>, <span class="hljs-keyword">__LINE__</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// End</span><br></code></pre></td></tr></table></figure><p>小结：</p><p>#error用于自定义一-条编译错误信息</p><p>#warning用于自定义一条编译警告信息</p><p>#error和#warning常应用于条件编译的情形</p><p>#line用于强制指定新的行号和编译文件名</p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo遇到的问题</title>
    <link href="/2023/01/15/Hexo/Hexo%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2023/01/15/Hexo/Hexo%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>本文记录了使用Hexo时遇到的各种问题与解决方法</p><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><p>笔记的标题中若包含’#’会在categories发现找不到该文章<br>例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-comment">#define</span><br><span class="hljs-attr">categories:</span> <span class="hljs-string">C语言</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">C</span>]<br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>现象：<br><img src="data:image/png;base64,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" alt="categories页显示异常"></p><p>解决方法：<br>title中不要以’#’开头，categories同理</p><h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><p>笔记文件的名字中若包含’#’，页面打开就会直接报错<br>例：文件命名为#define.md<br>现象：<br><img src="data:image/png;base64,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" alt="文件打开报错"></p><p>解决方法：<br>笔记文件名中不要以’#’开头</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>奇怪的问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>宏定义:#define</title>
    <link href="/2023/01/15/C%E8%AF%AD%E8%A8%80/%E5%AE%8F%E5%AE%9A%E4%B9%89#define/"/>
    <url>/2023/01/15/C%E8%AF%AD%E8%A8%80/%E5%AE%8F%E5%AE%9A%E4%B9%89#define/</url>
    
    <content type="html"><![CDATA[<p>本文为C语言#define语法的记录</p><h1 id="define"><a href="#define" class="headerlink" title="define"></a>define</h1><p>一、#define的特点：</p><p>1.#define定义的宏可以出现在程序的任意位置，且定义之后的代码都可以使用这个宏。</p><p>#define定义的宏常量可以直接使用，且宏常量本质为字面量（字面量不占用内存）</p><p>3.对于宏而言，不能说其有作用域，作用域的概念是针对变量和函数的，不针对宏，因为宏是被预处理所处理，编译器根本不知道宏定义的存在，所以也无法把作用域的概念用在宏定义上。但宏的生效范围是自定义开始直到整个文件结尾。</p><p>例1：以下宏定义是正确的吗</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* test.c */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR -1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PATH1 <span class="hljs-string">&quot;D:\test\test.c&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PATH2 D:\test\test.c    <span class="hljs-comment">//宏用来替代路径很好用</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PATH3 D:\test\    <span class="hljs-comment">/* 由于&#x27;\&#x27;出现在宏定义的最后一个字符，因此&#x27;\&#x27;变为了接续符 */</span></span><br>test.<span class="hljs-function">c</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> err = ERROR;<br>    <span class="hljs-type">char</span>* p1 = PATH1;<br>    <span class="hljs-type">char</span>* p2 = PATH2;<br>    <span class="hljs-type">char</span>* p3 = PATH3;<br>&#125;<br><br><span class="hljs-comment">/* test.i */</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;test.c&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;&lt;built-in&gt;&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;&lt;command-line&gt;&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;test.c&quot;</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> err = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">char</span>* p1 = <span class="hljs-string">&quot;D:\test\test.c&quot;</span>;<br>    <span class="hljs-type">char</span>* p2 = D:\test\test.c;<br>    <span class="hljs-type">char</span>* p3 = D:\testtest.c;<br>&#125;<br></code></pre></td></tr></table></figure><p>答：宏定义是正确的，但只能通过预编译，不能通过编译。因为预处理器只进行文本替换而不进行语法检查的，语法检查由编译器执行。替换后编译器发现不符合语法规则后才报错。</p><p>二、宏定义表达式</p><p>#define表达式的使用类似函数调用，但更容易出错且可读性极差（因为预处理器直接进行文本替换，结果就可能和我们预想的不一样），一般都不会用define定义函数。但#define表达式也可以比函数更强大，比如实现求数组大小。</p><p>例2：下面的宏定义表达式正确吗？</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/* test.c */</span><br>#define <span class="hljs-constructor">_SUM_(<span class="hljs-params">a</span>, <span class="hljs-params">b</span>)</span> (a) + (b)<br>#define <span class="hljs-constructor">_MIN_(<span class="hljs-params">a</span>, <span class="hljs-params">b</span>)</span> ((a) &lt; (b) ? (a) : (b))<br>#define <span class="hljs-constructor">_DIM_(<span class="hljs-params">a</span>)</span> sizeof(a)/sizeof(*a)    <span class="hljs-comment">//求一个数组的大小</span><br><br><span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span><br>&#123;<br>    <span class="hljs-built_in">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">int</span> b = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">int</span> c<span class="hljs-literal">[<span class="hljs-number">4</span>]</span> = &#123;<span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-built_in">int</span> s1 = <span class="hljs-constructor">_SUM_(<span class="hljs-params">a</span>, <span class="hljs-params">b</span>)</span>;<br>    <span class="hljs-built_in">int</span> s2 = <span class="hljs-constructor">_SUM_(<span class="hljs-params">a</span>, <span class="hljs-params">b</span>)</span><span class="hljs-operator"> * </span><span class="hljs-constructor">_SUM_(<span class="hljs-params">a</span>, <span class="hljs-params">b</span>)</span>;<br>    <span class="hljs-built_in">int</span> m = <span class="hljs-constructor">_MIN_(<span class="hljs-params">a</span><span class="hljs-operator">++</span>, <span class="hljs-params">b</span>)</span>;<br>    <span class="hljs-built_in">int</span> d = <span class="hljs-constructor">_DIM_(<span class="hljs-params">c</span>)</span>;<br><br>     printf(<span class="hljs-string">&quot;s1 = %d\n&quot;</span>, s1);    <span class="hljs-comment">//3</span><br>     printf(<span class="hljs-string">&quot;s2 = %d\n&quot;</span>, s2);    <span class="hljs-comment">//5</span><br>     printf(<span class="hljs-string">&quot;m = %d\n&quot;</span>, m);      <span class="hljs-comment">//2</span><br>     printf(<span class="hljs-string">&quot;d = %d\n&quot;</span>, d);      <span class="hljs-comment">//4</span><br><br>    return <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* test.i */</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;test.c&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;&lt;built-in&gt;&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;&lt;command-line&gt;&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;test.c&quot;</span><br><br><span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span><br>&#123;<br>    <span class="hljs-built_in">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">int</span> b = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">int</span> c<span class="hljs-literal">[<span class="hljs-number">4</span>]</span> = &#123;<span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-built_in">int</span> s1 = (a) + (b);<br>    <span class="hljs-built_in">int</span> s2 = (a) + (b)<span class="hljs-operator"> * </span>(a) + (b);        <span class="hljs-comment">//所以说比函数更容易出错</span><br>    <span class="hljs-built_in">int</span> m = ((a++) &lt; (b) ? (a++) : (b));   <span class="hljs-comment">//所以说比函数更容易出错</span><br>    <span class="hljs-built_in">int</span> d = sizeof(c)/sizeof(*c);<br><br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>三、宏表达式和函数的对比</p><p>宏表达式被预处理器处理，编译器不知道宏表达式的存在。</p><p>宏表达式用“实参”完全替代形参（文本替换），不进行任何运算。</p><p>优势：宏表达式没有任何的“调用”开销，函数则需要参数布栈布置返回地址等开销。</p><p>因为宏只是简单的替换，所以宏不需要考虑类型的因素，甚至可以用类型名做参数。</p><p>宏表达式中不能出现递归定义，函数可以有递归函数。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#define <span class="hljs-constructor">_SUM_(<span class="hljs-params">n</span>)</span> ((n&gt;<span class="hljs-number">0</span>)?(<span class="hljs-constructor">_SUM_(<span class="hljs-params">n</span>-1)</span>+n):<span class="hljs-number">0</span>)    <span class="hljs-comment">//error</span><br><span class="hljs-built_in">int</span> s = <span class="hljs-constructor">_SUM_(10)</span>;<br></code></pre></td></tr></table></figure><p>例3：宏定义的常量或表达式是否有作用域限制</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">/* test.c */</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">def</span>()</span><br>&#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> PI 3.1415926</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> AREA(r) r * r * PI</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">double</span> <span class="hljs-title">area</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> r</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> AREA(r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    <span class="hljs-built_in">double</span> r = area(<span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// printf(&quot;PI = %f\n&quot;, PI);</span><br>    <span class="hljs-comment">// printf(&quot;d = 5; a = %f\n&quot;, r);</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>答：对于宏而言，不能说其有作用域，作用域的概念是针对变量和函数的，不针对宏，因为宏是被预处理所处理，编译器根本不知道宏定义的存在，所以也无法把作用域的概念用在宏定义上。但宏的生效范围是自定义开始直到整个文件结尾。</p><p>四、强大的内置宏</p><p><img src="/image/Slide10.PNG" alt="Slide10.PNG"></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;stdio.h&gt;<br>#<span class="hljs-keyword">include</span> &lt;malloc.h&gt;<br><br>#define <span class="hljs-constructor">MALLOC(<span class="hljs-params">type</span>, <span class="hljs-params">x</span>)</span> (<span class="hljs-keyword">type</span>*)malloc(sizeof(<span class="hljs-keyword">type</span>)*x)    <span class="hljs-comment">//用来向堆空间申请一个数组</span><br><br>#define <span class="hljs-constructor">FREE(<span class="hljs-params">p</span>)</span> (free(p), p=NULL)    <span class="hljs-comment">//释放堆空间，指针指向空</span><br><br><span class="hljs-comment">/* 打印当前时间，当前文件名，当前行号，字符串s */</span><br>#define <span class="hljs-constructor">LOG(<span class="hljs-params">s</span>)</span> printf(<span class="hljs-string">&quot;[%s] &#123;%s:%d&#125; %s \n&quot;</span>, __DATE__, __FILE__, __LINE__, s)<br><br><span class="hljs-comment">/* 一个for循环 */</span><br>#define <span class="hljs-constructor">FOREACH(<span class="hljs-params">i</span>, <span class="hljs-params">m</span>)</span> <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>#define BEGIN &#123;<br>#define END   &#125;<br><br><span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span><br>&#123;<br>    <span class="hljs-built_in">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span>* p = <span class="hljs-constructor">MALLOC(<span class="hljs-params">int</span>, 5)</span>;    <span class="hljs-comment">//C语言是不能将一个类型作为参数调用的</span><br>    <br>    <span class="hljs-constructor">LOG(<span class="hljs-string">&quot;Begin to run main code...&quot;</span>)</span>;    <span class="hljs-comment">//日志宏</span><br>    <br>    <span class="hljs-constructor">FOREACH(<span class="hljs-params">x</span>, 5)</span><br>    BEGIN<br>        p<span class="hljs-literal">[<span class="hljs-identifier">x</span>]</span> = x;<br>    END<br>    <br>    <span class="hljs-constructor">FOREACH(<span class="hljs-params">x</span>, 5)</span><br>    BEGIN<br>        printf(<span class="hljs-string">&quot;%d\n&quot;</span>, p<span class="hljs-literal">[<span class="hljs-identifier">x</span>]</span>);<br>    END<br>    <br>    <span class="hljs-constructor">FREE(<span class="hljs-params">p</span>)</span>;<br>    <br>    <span class="hljs-constructor">LOG(<span class="hljs-string">&quot;End&quot;</span>)</span>;    <span class="hljs-comment">//日志宏</span><br>    <br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>小结：</p><p>预处理器直接对宏进行文本替换</p><p>宏使用的参数不会进行求值和运算</p><p>预处理器不会对宏定义进行语法检查，所有define出来的宏都是正确的</p><p>宏定义时出现的语法错误只能被编译器检测</p><p>宏定义的效率高于函数调用</p><p>宏的使用会带来一定的副作用</p><p>五、在工程中的发现</p><p>5.1 一个宏用于多个宏</p><p>使用宏描述一位引脚</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-attr">#define Bit0</span>            <span class="hljs-comment">((u8)</span><span class="hljs-number">0</span>x<span class="hljs-number">01</span>)<br><span class="hljs-attr">#define Bit1</span>            <span class="hljs-comment">((u8)</span><span class="hljs-number">0</span>x<span class="hljs-number">02</span>)<br><span class="hljs-attr">#define Bit2</span>            <span class="hljs-comment">((u8)</span><span class="hljs-number">0</span>x<span class="hljs-number">04</span>)<br><span class="hljs-attr">#define Bit3</span>            <span class="hljs-comment">((u8)</span><span class="hljs-number">0</span>x<span class="hljs-number">08</span>)<br><span class="hljs-attr">#define Bit4</span>            <span class="hljs-comment">((u8)</span><span class="hljs-number">0</span>x<span class="hljs-number">10</span>)<br><span class="hljs-attr">#define Bit5</span>            <span class="hljs-comment">((u8)</span><span class="hljs-number">0</span>x<span class="hljs-number">20</span>)<br><span class="hljs-attr">#define Bit6</span>            <span class="hljs-comment">((u8)</span><span class="hljs-number">0</span>x<span class="hljs-number">40</span>)<br><span class="hljs-attr">#define Bit7</span>            <span class="hljs-comment">((u8)</span><span class="hljs-number">0</span>x<span class="hljs-number">80</span>)<br></code></pre></td></tr></table></figure><p>然后分别再用宏描述GPIOABCD实际连接上的设备</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//GPIOA</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> WaterIn       Bit1            <span class="hljs-comment">//水位输入，1为水满</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PA2           Bit2            <span class="hljs-comment">//引脚悬空，配置为悬浮输出低电平</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CompEn        Bit3            <span class="hljs-comment">//压机使能位,推挽输出</span></span><br><br><span class="hljs-comment">//GPIOB</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FanEn         Bit7        <span class="hljs-comment">//风扇使能位</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PumpEn        Bit6        <span class="hljs-comment">//水泵使能位</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SDA           Bit5        <span class="hljs-comment">//I2C数据线</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SCL           Bit4        <span class="hljs-comment">//I2C时钟线</span></span><br></code></pre></td></tr></table></figure><p><img src="/./image/7a423e1363130fffc12ff536a9e7e961.png" alt="7a423e1363130fffc12ff536a9e7e961.png"></p>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>未重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>enex转换为md格式</title>
    <link href="/2023/01/15/%E6%9D%82/enex%E8%BD%AC%E6%8D%A2%E4%B8%BAmd%E6%A0%BC%E5%BC%8F/"/>
    <url>/2023/01/15/%E6%9D%82/enex%E8%BD%AC%E6%8D%A2%E4%B8%BAmd%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>本文记录了将印象笔记导出格式.enex转换为.md格式的方法</p><h2 id="下载大哥的转换工具"><a href="#下载大哥的转换工具" class="headerlink" title="下载大哥的转换工具"></a>下载大哥的转换工具</h2><p><a href="%5B%E7%BD%91%E7%AB%99%E7%BD%91%E5%9D%80%5D(https://github.com/wormi4ok/evernote2md/tags)">evernote2md</a></p><h2 id="格式转化"><a href="#格式转化" class="headerlink" title="格式转化"></a>格式转化</h2><ol><li>将下载下来的文件解压后会得到一个evernote2md.exe</li><li>在evernote2md.exe目录下进入windows cmd</li><li>输入指令<font color=orange><code>evernote2md [inputFile] [outputDir]</code></font> 来转换格式<blockquote><p>不指定<font color=orange><code>[outputDir]</code></font>就会建立一个默认的文件夹notes来存放输出文件<br>evernote2md *.enex 转换目录下的所有enex文件</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>杂</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作流程</tag>
      
      <tag>杂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 超时解决</title>
    <link href="/2023/01/15/Git/%E5%A5%87%E6%80%AA%E7%9A%84%E9%97%AE%E9%A2%98/Git%E8%B6%85%E6%97%B6%E8%A7%A3%E5%86%B3/"/>
    <url>/2023/01/15/Git/%E5%A5%87%E6%80%AA%E7%9A%84%E9%97%AE%E9%A2%98/Git%E8%B6%85%E6%97%B6%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<p>本文记录了两种解决Git超时的方法</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><blockquote><p>有时能用，有时会报Fail to connect to ….,，这时候去换另一种方法吧</p></blockquote><h3 id="Step1-取消代理"><a href="#Step1-取消代理" class="headerlink" title="Step1:取消代理"></a>Step1:取消代理</h3><p><font color=orange><code>git config --global --unset http.proxy</code></font><br><font color=orange><code>git config --global --unset https.proxy</code></font></p><h3 id="Step2-更新DNS"><a href="#Step2-更新DNS" class="headerlink" title="Step2:更新DNS"></a>Step2:更新DNS</h3><p><font color=orange><code>ipconfig /flushdns</code></font> </p><h3 id="Step3-设置代理"><a href="#Step3-设置代理" class="headerlink" title="Step3:设置代理"></a>Step3:设置代理</h3><p><font color=orange><code>git config --global http.proxy  http://127.0.0.1:7890</code></font><br><font color=orange><code>git config --global https.proxy https://127.0.0.1:7890</code></font></p><blockquote><p>127地址与端口号自行查看本地</p></blockquote><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>打开魔法</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
      <category>奇怪的问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>奇怪的问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>标日初上01_单词</title>
    <link href="/2023/01/08/%E6%97%A5%E8%AF%AD/%E6%97%A5%E8%AF%AD%E8%AF%BE%E7%A8%8B/%E6%A0%87%E5%87%86%E6%97%A5%E8%AF%AD%E5%88%9D%E7%BA%A7_%E4%B8%8A%E5%86%8C/%E6%A0%87%E6%97%A5%E5%88%9D%E4%B8%8A01_%E5%8D%95%E8%AF%8D/"/>
    <url>/2023/01/08/%E6%97%A5%E8%AF%AD/%E6%97%A5%E8%AF%AD%E8%AF%BE%E7%A8%8B/%E6%A0%87%E5%87%86%E6%97%A5%E8%AF%AD%E5%88%9D%E7%BA%A7_%E4%B8%8A%E5%86%8C/%E6%A0%87%E6%97%A5%E5%88%9D%E4%B8%8A01_%E5%8D%95%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="生词表1：国家相关"><a href="#生词表1：国家相关" class="headerlink" title="生词表1：国家相关"></a>生词表1：国家相关</h2><table><thead><tr><th align="center">假名</th><th align="center">声调</th><th align="center">日语书写形式</th><th align="center">释义</th></tr></thead><tbody><tr><td align="center">ちゅう　ごく</td><td align="center">1</td><td align="center">中国</td><td align="center">中国</td></tr><tr><td align="center">に　ほん</td><td align="center">2</td><td align="center">日本</td><td align="center">日本</td></tr><tr><td align="center">かん　こく</td><td align="center">1</td><td align="center">韓国</td><td align="center">韩国</td></tr><tr><td align="center">アメリカ</td><td align="center">0</td><td align="center">アメリカ</td><td align="center">美国america</td></tr><tr><td align="center">フランス</td><td align="center">0</td><td align="center">フランス</td><td align="center">法国France</td></tr></tbody></table><h2 id="生词表2：职业相关"><a href="#生词表2：职业相关" class="headerlink" title="生词表2：职业相关"></a>生词表2：职业相关</h2><table><thead><tr><th align="center">假名</th><th align="center">声调</th><th align="center">日语书写形式</th><th align="center">释义</th></tr></thead><tbody><tr><td align="center">がく　せい</td><td align="center">0</td><td align="center">学生</td><td align="center">学生</td></tr><tr><td align="center">せん　せい</td><td align="center">3</td><td align="center">先生</td><td align="center">先生</td></tr><tr><td align="center">りゅう　がく　せい</td><td align="center">3</td><td align="center">留学生</td><td align="center">留学生</td></tr><tr><td align="center">きょう　じゅ</td><td align="center">0</td><td align="center">教授</td><td align="center">教授</td></tr><tr><td align="center">しゃ　いん</td><td align="center">1</td><td align="center">社員</td><td align="center">普通职员</td></tr><tr><td align="center">かい　しゃ　いん</td><td align="center">3</td><td align="center">会社員</td><td align="center">上班族</td></tr></tbody></table><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul><li><p>学生がくせい</p><ul><li>广义：指学生这种身份</li><li>狭义：专指大学生</li></ul></li><li><p>先生せんせい<br>可以前加名字，称呼老师，医生作家，画家，律师等</p></li><li><p>社員しゃいん<br>日语的社員类似于员工的意思，一般前接公司名，仅仅表示属于某公司的人</p></li><li><p>会社員かいしゃいん<br>日语的会社員表示一种职业，类似医生，工程师，意思是公司职员，在公司工作的人</p></li></ul><h1 id="生词表3：职业相关"><a href="#生词表3：职业相关" class="headerlink" title="生词表3：职业相关"></a>生词表3：职业相关</h1><table><thead><tr><th align="center">假名</th><th align="center">声调</th><th align="center">日语书写形式</th><th align="center">释义</th></tr></thead><tbody><tr><td align="center">てん　いん</td><td align="center">0</td><td align="center">店員</td><td align="center">店员</td></tr><tr><td align="center">けん　しゅう　せい</td><td align="center">3</td><td align="center">研修生</td><td align="center">进修生</td></tr><tr><td align="center">か　ちょう</td><td align="center">0</td><td align="center">課長</td><td align="center">科长</td></tr><tr><td align="center">しゃ　ちょう</td><td align="center">0</td><td align="center">社長</td><td align="center">总经理 社长</td></tr><tr><td align="center">き　ぎょう</td><td align="center">1</td><td align="center">企業</td><td align="center">企业</td></tr></tbody></table><h3 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h3><ul><li>研修生けんしゅうせい<br>外国人在留资格的一种。一边在企业等地方工作，一边学习技能和知识</li></ul><h2 id="生词表4：人称指代"><a href="#生词表4：人称指代" class="headerlink" title="生词表4：人称指代"></a>生词表4：人称指代</h2><table><thead><tr><th align="center">假名</th><th align="center">声调</th><th align="center">日语书写形式</th><th align="center">释义</th></tr></thead><tbody><tr><td align="center">わたし</td><td align="center">0</td><td align="center">私わたし</td><td align="center">我</td></tr><tr><td align="center">あなた</td><td align="center">2</td><td align="center">あなた</td><td align="center">你</td></tr><tr><td align="center">ちち</td><td align="center">0</td><td align="center">父</td><td align="center">(我)父亲</td></tr><tr><td align="center">おう</td><td align="center">1</td><td align="center">王</td><td align="center">中国人姓氏</td></tr><tr><td align="center">ちょう</td><td align="center">1</td><td align="center">張</td><td align="center">中国人姓氏</td></tr><tr><td align="center">もり</td><td align="center">0</td><td align="center">森</td><td align="center">日本人姓氏</td></tr><tr><td align="center">はやし</td><td align="center">0</td><td align="center">林</td><td align="center">日本人姓氏</td></tr><tr><td align="center">おの</td><td align="center">0</td><td align="center">小野</td><td align="center">日本人姓氏</td></tr></tbody></table><h3 id="补充-2"><a href="#补充-2" class="headerlink" title="补充"></a>补充</h3><ul><li><p>私わたし</p><ul><li>わたし：第一人称我，男女都可以用，比较正式，对话中经常忽略</li><li>僕　ぼく：男性的自称，用于熟人间</li><li>俺　おれ：男性的自称，用于和平辈，或比自己级别低的人说话时</li></ul></li><li><p>あなた</p><ul><li>あなた：多用于妻子对自己丈夫的称呼。或用于不知道对方的姓名又必须打招呼的时候</li><li>君　きみ：你，对男女都可以用，用于上对下，比自己年龄小的人之间</li><li>俺 おれ：男性的自称，用于和平辈，或比自己级别低的人说话时</li><li>お前　おまえ：一种不礼貌的说法，上对下才用</li></ul></li><li><p>父ちち</p><ul><li>ちち：用作和别人谈到自己父亲的时候，是自谦的说法</li><li>お父さん：称呼别人父亲的时候，或家里叫自己父亲的时候，表示尊敬的说法</li></ul></li></ul><h2 id="生词表5：人称指代"><a href="#生词表5：人称指代" class="headerlink" title="生词表5：人称指代"></a>生词表5：人称指代</h2><table><thead><tr><th align="center">假名</th><th align="center">声调</th><th align="center">日语书写形式</th><th align="center">释义</th></tr></thead><tbody><tr><td align="center">よし　だ</td><td align="center">0</td><td align="center">吉田</td><td align="center">吉田</td></tr><tr><td align="center">た　なか</td><td align="center">0</td><td align="center">田中</td><td align="center">田中</td></tr><tr><td align="center">なか　むら</td><td align="center">0</td><td align="center">中村</td><td align="center">中村</td></tr><tr><td align="center">た　ろう</td><td align="center">1</td><td align="center">太郎</td><td align="center">太郎</td></tr><tr><td align="center">キム</td><td align="center">1</td><td align="center">金　キム</td><td align="center">金</td></tr><tr><td align="center">デョポン</td><td align="center">1</td><td align="center">デョポン</td><td align="center">迪蓬</td></tr><tr><td align="center">スミス</td><td align="center">1</td><td align="center">スミス</td><td align="center">史密斯</td></tr><tr><td align="center">ジョンソン</td><td align="center">1</td><td align="center">ジョンソン</td><td align="center">约翰逊</td></tr></tbody></table><h2 id="生词表6：专有名词"><a href="#生词表6：专有名词" class="headerlink" title="生词表6：专有名词"></a>生词表6：专有名词</h2><table><thead><tr><th align="center">假名</th><th align="center">声调</th><th align="center">日语书写形式</th><th align="center">释义</th></tr></thead><tbody><tr><td align="center">とう　きょう　だい　がく</td><td align="center">5</td><td align="center">東京大学</td><td align="center">东京大学</td></tr><tr><td align="center">ぺきんだいがく</td><td align="center">5</td><td align="center">北京大学</td><td align="center">北京大学</td></tr><tr><td align="center">ジェー　シー　きがく</td><td align="center">5</td><td align="center">JC企画</td><td align="center">假名未分开：能否与汉字对应存疑</td></tr><tr><td align="center">ぺ　きん　りょ　こう　しゃ</td><td align="center">5</td><td align="center">北京旅行社</td><td align="center">北京旅行社</td></tr><tr><td align="center">につ　ちゅう　しょう　じ</td><td align="center">5</td><td align="center">日中商事</td><td align="center"></td></tr></tbody></table><h2 id="生词表7：其他"><a href="#生词表7：其他" class="headerlink" title="生词表7：其他"></a>生词表7：其他</h2><table><thead><tr><th align="center">假名</th><th align="center">声调</th><th align="center">日语书写形式</th><th align="center">释义</th></tr></thead><tbody><tr><td align="center">だい　がく</td><td align="center">0</td><td align="center">大学</td><td align="center">大学</td></tr><tr><td align="center">で　むがえ</td><td align="center">0</td><td align="center">出　迎え</td><td align="center">迎接</td></tr><tr><td align="center">あのひと</td><td align="center">2</td><td align="center">あの人</td><td align="center">那个人</td></tr><tr><td align="center">どうも</td><td align="center">1</td><td align="center">どうも</td><td align="center">非常，很</td></tr><tr><td align="center">はい</td><td align="center">1</td><td align="center">はい</td><td align="center">是的，哎</td></tr><tr><td align="center">いいえ</td><td align="center">3</td><td align="center">いいえ</td><td align="center">不是，不对</td></tr><tr><td align="center">あつ</td><td align="center">～</td><td align="center">あつ</td><td align="center">哎，哎呀</td></tr></tbody></table><h2 id="惯用语1"><a href="#惯用语1" class="headerlink" title="惯用语1"></a>惯用语1</h2><table><thead><tr><th align="center">假名</th><th align="center">声调</th><th align="center">释义</th></tr></thead><tbody><tr><td align="center">こんにちは</td><td align="center">5</td><td align="center">你好</td></tr><tr><td align="center">すみません</td><td align="center">4</td><td align="center">对不起，不好意思</td></tr><tr><td align="center">どうぞ</td><td align="center">1</td><td align="center">请</td></tr><tr><td align="center">よろしく　おねがいいたします</td><td align="center">0&#x2F;6</td><td align="center">请多关照</td></tr><tr><td align="center">はじめまして</td><td align="center">4</td><td align="center">初次见面</td></tr><tr><td align="center">こちらこそ</td><td align="center">4</td><td align="center">我才要…</td></tr><tr><td align="center">そうです</td><td align="center">1</td><td align="center">是的，没错</td></tr><tr><td align="center">ちがいます</td><td align="center">4</td><td align="center">不对，不是这样</td></tr><tr><td align="center">わかりません</td><td align="center">5</td><td align="center">不知道</td></tr><tr><td align="center">どうも　すみません</td><td align="center">～</td><td align="center">太对不起了</td></tr></tbody></table><h2 id="国家-x2F-人-x2F-语言"><a href="#国家-x2F-人-x2F-语言" class="headerlink" title="国家&#x2F;人&#x2F;语言"></a>国家&#x2F;人&#x2F;语言</h2><p>“人” 读音 “じん”<br>“語” 读音 “ご”</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
      <category>日语课程</category>
      
      <category>标准日本语初级_上册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日语</tag>
      
      <tag>日语单词</tag>
      
      <tag>上课笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>标日初上01_语法</title>
    <link href="/2023/01/08/%E6%97%A5%E8%AF%AD/%E6%97%A5%E8%AF%AD%E8%AF%BE%E7%A8%8B/%E6%A0%87%E5%87%86%E6%97%A5%E8%AF%AD%E5%88%9D%E7%BA%A7_%E4%B8%8A%E5%86%8C/%E6%A0%87%E6%97%A5%E5%88%9D%E4%B8%8A01_%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/01/08/%E6%97%A5%E8%AF%AD/%E6%97%A5%E8%AF%AD%E8%AF%BE%E7%A8%8B/%E6%A0%87%E5%87%86%E6%97%A5%E8%AF%AD%E5%88%9D%E7%BA%A7_%E4%B8%8A%E5%86%8C/%E6%A0%87%E6%97%A5%E5%88%9D%E4%B8%8A01_%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h2><h3 id="は"><a href="#は" class="headerlink" title="は"></a>は</h3><p>は是日语中常见的助词，没有实际意思，主要接在名词后面起语法作用，用来凸显提示一句话的主题和话题<br>は做助词时，应读作”わ(wa)”</p><blockquote><p>わたしは森です。</p></blockquote><h3 id="です"><a href="#です" class="headerlink" title="です"></a>です</h3><p>助动词，表示肯定的判断，是句子的谓语部分。在这里相当于文中的”是”</p><blockquote><p>わたしは森です。</p></blockquote><h3 id="か"><a href="#か" class="headerlink" title="か"></a>か</h3><p>助词，疑问句的标志。<br>日语中，在非疑问句末尾加上”か”，就可以表达疑问的意思。且日语的问句不以“？”结束，而以”。”结束。</p><blockquote><p>森さんはジエーシー企画の社員ですか。</p></blockquote><h3 id="の"><a href="#の" class="headerlink" title="の"></a>の</h3><p>名1 <code>の</code> 名2<br>助词，助词连接名词和名词，表示前面名词是后面名词从属的机构、国家、属性等。又是相当于中文的”的”</p><blockquote><p>森さんはジエーシー企画の社員です。</p></blockquote><h2 id="词组"><a href="#词组" class="headerlink" title="词组"></a>词组</h2><h3 id="称谓：-さん"><a href="#称谓：-さん" class="headerlink" title="称谓：~さん"></a>称谓：~さん</h3><p>接在姓氏后面，不分男女，表示礼貌尊敬<br>还可以接在职业的词后，同样表示礼貌尊敬，比如:学生さん<br>日本人对话时，一般不用”あなた”，而是习惯称呼对方的姓氏，在其后加さん</p><h3 id="称谓：-ちゃん-君"><a href="#称谓：-ちゃん-君" class="headerlink" title="称谓：~ちゃん(君)"></a>称谓：~ちゃん(君)</h3><p>称呼小朋友可以使用ちゃん<br>朋友或熟人之间，称呼和自己年龄相仿的男性还可以使用”君”(くん)</p><h2 id="句型"><a href="#句型" class="headerlink" title="句型"></a>句型</h2><h3 id="判断句-名1-は-名2-です-名1是名2"><a href="#判断句-名1-は-名2-です-名1是名2" class="headerlink" title="判断句: 名1 は 名2 です　(名1是名2)"></a>判断句: 名1 <code>は</code> 名2 <code>です</code>　(名1是名2)</h3><blockquote><p>日语的语序</p><blockquote><p>日语的谓语和宾语位置与中文不同，日语的谓语永远在句末<br>吉田さんは学生です<br>主语(主题)宾语谓语</p></blockquote></blockquote><h3 id="判断句-名1-は-名2-ではありません-名1不是名2"><a href="#判断句-名1-は-名2-ではありません-名1不是名2" class="headerlink" title="判断句: 名1 は 名2 ではありません　(名1不是名2)"></a>判断句: 名1 <code>は</code> 名2 <code>ではありません</code>　(名1不是名2)</h3><p>ではありません是です的否定形式，相当于”不是”。<br>口语中，”では”可以用”じゃ”代替 </p><h3 id="一般疑问句：名1-は-名2-ですか-名1是名2吗？"><a href="#一般疑问句：名1-は-名2-ですか-名1是名2吗？" class="headerlink" title="一般疑问句：名1 は 名2 ですか　(名1是名2吗？)"></a>一般疑问句：名1 <code>は</code> 名2 <code>ですか</code>　(名1是名2吗？)</h3><h3 id="一般疑问句的应答-あの人は田中さんですか。"><a href="#一般疑问句的应答-あの人は田中さんですか。" class="headerlink" title="一般疑问句的应答:あの人は田中さんですか。"></a>一般疑问句的应答:あの人は田中さんですか。</h3><p>对一般疑问句的应答必须先回答”はい”或”いいえ”</p><h4 id="肯定回答"><a href="#肯定回答" class="headerlink" title="肯定回答"></a>肯定回答</h4><p>肯定回答后，把谓语重复一遍</p><ul><li>はい、田中さんです。</li></ul><p>或者直接使用”そう”，”そう”的意思是”那样”，即对方提到的情况</p><ul><li>はい、そうです。</li></ul><h4 id="否定回答"><a href="#否定回答" class="headerlink" title="否定回答"></a>否定回答</h4><p>否定回答后，把谓语重复一遍</p><ul><li>いいえ、田中さんではありません。</li></ul><p>或者直接使用”ちがいます”</p><ul><li>いいえ、ちがいます。</li></ul><h4 id="我不清楚"><a href="#我不清楚" class="headerlink" title="我不清楚"></a>我不清楚</h4><ul><li>すっみません、わかりません。</li></ul>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
      <category>日语课程</category>
      
      <category>标准日本语初级_上册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日语</tag>
      
      <tag>上课笔记</tag>
      
      <tag>日语语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日语发音</title>
    <link href="/2023/01/08/%E6%97%A5%E8%AF%AD/%E6%9D%82/%E6%97%A5%E8%AF%AD%E5%8F%91%E9%9F%B3/"/>
    <url>/2023/01/08/%E6%97%A5%E8%AF%AD/%E6%9D%82/%E6%97%A5%E8%AF%AD%E5%8F%91%E9%9F%B3/</url>
    
    <content type="html"><![CDATA[<p>本文指出了日语中的一些需要特别注意的发音方式</p><h2 id="辅音的发音"><a href="#辅音的发音" class="headerlink" title="辅音的发音"></a>辅音的发音</h2><h3 id="长音"><a href="#长音" class="headerlink" title="长音"></a>长音</h3><p>a段假名加元音a读作长音<br>i段假名加元音i读作长音<br>u段假名加元音u读作长音<br>e段假名加元音e&#x2F;i读作长音<br>o段假名加元音u&#x2F;o读作长音<br>外来语的长音:加一</p><h3 id="促音"><a href="#促音" class="headerlink" title="促音"></a>促音</h3><p>前面的音发完后，做好发下一个音的嘴型，即空占一拍不发音<br>但是在位于さ行假名之前，需要漏发出s的音</p><h2 id="日语的声调"><a href="#日语的声调" class="headerlink" title="日语的声调"></a>日语的声调</h2><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ul><li>平板型：第一拍低，之后全高    桥はし</li><li>头高型：第一拍高，之后全低箸はし</li><li>中高型：第一拍低，第二个以后的某个音节降下来</li><li>尾高型：第一拍低，之后全高，知道后续助词的地方才降下来</li></ul><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>第一个音节必定和第二个音节发音相反</li><li>一个单词的声调中，或没有下降，或只有一处下降</li></ul><blockquote><p>复合名词的音调</p><blockquote><p>复合名词的音调遵循一定的规律<br>一般是在第二个词的第一个假名后开始降调<br>ぺきん|だいがく|ぺきんだ<sub>下降</sub>いがく<br>东京|大学|东京大学</p></blockquote></blockquote><blockquote><p>发拗音时认为拗音是一个音节</p></blockquote><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>せんせい：音调为3,即<br>1<sub>下降</sub>2<sup>上升</sup>3<sup>上升</sup>4<sub>下降</sub><br>せ<sub>下降</sub>ん<sup>上升</sup>せ<sup>上升</sup>い<sub>下降</sub></p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
      <category>杂</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日语</tag>
      
      <tag>发音</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用中文键盘打日语</title>
    <link href="/2023/01/08/%E6%97%A5%E8%AF%AD/%E6%9D%82/%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87%E9%94%AE%E7%9B%98%E6%89%93%E6%97%A5%E8%AF%AD/"/>
    <url>/2023/01/08/%E6%97%A5%E8%AF%AD/%E6%9D%82/%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87%E9%94%AE%E7%9B%98%E6%89%93%E6%97%A5%E8%AF%AD/</url>
    
    <content type="html"><![CDATA[<p>本文指出了使用中文键盘拼写日语时的一些拼写方法</p><h2 id="五十音的拼写"><a href="#五十音的拼写" class="headerlink" title="五十音的拼写"></a>五十音的拼写</h2><p>んnn<br>をwo </p><h2 id="小写五十音的拼写"><a href="#小写五十音的拼写" class="headerlink" title="小写五十音的拼写"></a>小写五十音的拼写</h2><p>l+任意一个可小写的五十音&#x3D;小写的五十音<br>比如：ltu &#x3D;　っ</p><blockquote><p>拼写不出来，就是没有这个写法</p></blockquote><h2 id="促音"><a href="#促音" class="headerlink" title="促音"></a>促音</h2><p>只要促音后的五十音连敲两个，就可以拼出促音<br>学校　がっこう　gakkou</p><h2 id="浊音，半浊音"><a href="#浊音，半浊音" class="headerlink" title="浊音，半浊音"></a>浊音，半浊音</h2><p>虽然じぢ、ずづ发音相同，但是输入时还是需要这样输入<br>ざza じzi ずzu ぜze ぞzo<br>だda ぢdi づdu でde どdo</p><h2 id="长音"><a href="#长音" class="headerlink" title="长音"></a>长音</h2><p>‘ー’即输入’-‘<br>比如：ノート no-to</p><h2 id="拗音"><a href="#拗音" class="headerlink" title="拗音"></a>拗音</h2><p>きゃkya きゅkyu きょkyo</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
      <category>杂</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作流程</tag>
      
      <tag>日语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MakeDown语法</title>
    <link href="/2023/01/08/%E8%A7%84%E8%8C%83/MakeDown%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/01/08/%E8%A7%84%E8%8C%83/MakeDown%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>本文为使用Hexo时，笔记中使用的MakeDown语法的记录。</p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><h3 id="一号标题"><a href="#一号标题" class="headerlink" title="一号标题"></a>一号标题</h3><pre><code class="hljs"># 内容</code></pre><h3 id="二号标题"><a href="#二号标题" class="headerlink" title="二号标题"></a>二号标题</h3><pre><code class="hljs">## 内容</code></pre><h3 id="三号标题"><a href="#三号标题" class="headerlink" title="三号标题"></a>三号标题</h3><pre><code class="hljs">### 内容</code></pre><h3 id="四号标题"><a href="#四号标题" class="headerlink" title="四号标题"></a>四号标题</h3><pre><code class="hljs">#### 内容</code></pre><h3 id="五号标题"><a href="#五号标题" class="headerlink" title="五号标题"></a>五号标题</h3><pre><code class="hljs">##### 内容</code></pre><h3 id="六号标题"><a href="#六号标题" class="headerlink" title="六号标题"></a>六号标题</h3><pre><code class="hljs">###### 内容</code></pre><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><pre><code class="hljs">---- 或 **** (大于三个)</code></pre><h2 id="文字设置"><a href="#文字设置" class="headerlink" title="文字设置"></a>文字设置</h2><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><pre><code class="hljs">*内容*</code></pre><p>样式：<font size=6 face="黑体"><em>内容</em></font></p><h3 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a>粗体</h3><pre><code class="hljs">**内容**</code></pre><p>样式：<font size=6 face="黑体"><strong>内容</strong></font></p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><pre><code class="hljs">~~内容~~</code></pre><p>样式：<font size=6 face="黑体"><del>内容</del></font></p><h3 id="颜色字号字体"><a href="#颜色字号字体" class="headerlink" title="颜色字号字体"></a>颜色字号字体</h3><pre><code class="hljs">&lt;font color=red size=6 face=&quot;黑体&quot;&gt;红色6号黑体&lt;/font&gt;</code></pre><p>样式：<font color=red size=6 face="黑体">红色6号黑体</font></p><h3 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h3><pre><code class="hljs">2&lt;sup&gt;2&lt;/sup&gt;</code></pre><p>样式：2<sup>2</sup></p><h3 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h3><pre><code class="hljs">H&lt;sub&gt;2&lt;/sub&gt;O</code></pre><p>样式：H<sub>2</sub>O</p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><pre><code class="hljs">[超链接显示名](网站网址)</code></pre><p>样式：<a href="http://localhost:4000/">超链接显示名</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><pre><code class="hljs">![图片显示名](图片Base64字符串或图片网址)</code></pre><blockquote><p>使用Base64工具将图片转为Base64字符串:<a href="https://base64.us/">Base64 在线编码解码</a><br>样式：<img src="data:image/png;base64,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" alt="Git Error 10054"></p></blockquote><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>单个-、+或*符号(加空格)代表无序列表，可嵌套</p><pre><code class="hljs">+ 一层    - 二层        * 三层            + 四层</code></pre><p>样式：</p><ul><li>一层<ul><li>二层<ul><li>三层<ul><li>四层</li></ul></li></ul></li></ul></li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>使用1.(加空格)表示有序列表，可嵌套。</p><pre><code class="hljs">1. 一层    1.  二层        1. 三层            1. 四层    2. 一层</code></pre><p>样式：</p><ol><li>一层<ol><li>二层<ol><li>三层<ol><li>四层</li></ol></li></ol></li><li>一层</li></ol></li></ol><h2 id="文字引用"><a href="#文字引用" class="headerlink" title="文字引用"></a>文字引用</h2><p>使用多个&gt;(加空格)表示，多个&gt;代表多层</p><blockquote><p>一般写注释内容</p><blockquote><p>注释的注释<br>直接在&gt;&gt;后一行用&gt;没办法分离出来</p></blockquote></blockquote><blockquote><p>必须空一行再加&gt;就可以分离出来了</p></blockquote><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><h3 id="行内代码块"><a href="#行内代码块" class="headerlink" title="行内代码块"></a>行内代码块</h3><pre><code class="hljs">`ctrl + c`</code></pre><p>样式：<code>ctrl + c</code></p><h3 id="任意代码块"><a href="#任意代码块" class="headerlink" title="任意代码块"></a>任意代码块</h3><p>四个空格或一个制表符</p><h4 id="代码高亮以及行数表示"><a href="#代码高亮以及行数表示" class="headerlink" title="代码高亮以及行数表示"></a>代码高亮以及行数表示</h4><p>使用&#96;&#96;&#96;来标记，可以在它后面加上源代码语言的标记，比如C、C++、java、javascript、Markdown等</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino">三个`<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span></span><br><span class="hljs-function"></span>&#123;<br>System.out.<span class="hljs-built_in">println</span>( <span class="hljs-string">&quot;Hello,world&quot;</span> );<br>&#125;<br>&#125;<br>三个`<br></code></pre></td></tr></table></figure><blockquote></blockquote><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><pre><code class="hljs">|售卖商品|数量|单价||:-|:-:|-:||苹果|10|\$1||电脑|1|\$1000|</code></pre><table><thead><tr><th align="left">售卖商品</th><th align="center">数量</th><th align="right">单价</th></tr></thead><tbody><tr><td align="left">苹果</td><td align="center">10</td><td align="right">$1</td></tr><tr><td align="left">电脑</td><td align="center">1</td><td align="right">$1000</td></tr></tbody></table><blockquote><p>:-左对齐、:-:居中、-:右对齐<br>更多内容参考:<em><a href="https://www.cnblogs.com/lxd-koi/p/16996368.html">https://www.cnblogs.com/lxd-koi/p/16996368.html</a></em></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>规范</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MakeDown语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MakeDown笔记标准</title>
    <link href="/2023/01/08/%E8%A7%84%E8%8C%83/MakeDown%E7%AC%94%E8%AE%B0%E6%A0%87%E5%87%86/"/>
    <url>/2023/01/08/%E8%A7%84%E8%8C%83/MakeDown%E7%AC%94%E8%AE%B0%E6%A0%87%E5%87%86/</url>
    
    <content type="html"><![CDATA[<p>本文为使用写作MakeDown笔记时，个人的标准手册。</p><h2 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h2><p>笔记开始加上hexo固定内容与笔记简单概括</p><blockquote><p>MakeDown真不错，调查发现它已经固定了很多排版。<br>虽然可选择性少了，但是它给的排版即省事又美观。</p></blockquote><h2 id="语法使用"><a href="#语法使用" class="headerlink" title="语法使用"></a>语法使用</h2><h3 id="表达键盘操作或键入内容"><a href="#表达键盘操作或键入内容" class="headerlink" title="表达键盘操作或键入内容"></a>表达键盘操作或键入内容</h3><pre><code class="hljs">&lt;font color=orange&gt;`Ctrl + C`&lt;/font&gt; </code></pre><p>样式： <font color=orange><code>Ctrl + C</code></font></p><h3 id="表达对某段内容的解释"><a href="#表达对某段内容的解释" class="headerlink" title="表达对某段内容的解释"></a>表达对某段内容的解释</h3><pre><code class="hljs">&gt; 大概就是&quot;PS:&quot;的感觉</code></pre><p>样式：</p><blockquote><p>大概就是”PS:”的感觉</p></blockquote><h3 id="直接表示链接"><a href="#直接表示链接" class="headerlink" title="直接表示链接"></a>直接表示链接</h3><pre><code class="hljs">*https://blog.csdn.net/weixin_41978699/article/details/126261808*</code></pre><p>样式：<em><a href="https://blog.csdn.net/weixin_41978699/article/details/126261808">https://blog.csdn.net/weixin_41978699/article/details/126261808</a></em></p>]]></content>
    
    
    <categories>
      
      <category>规范</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>MakeDown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo使用笔记</title>
    <link href="/2023/01/08/Hexo/Hexo%20%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/01/08/Hexo/Hexo%20%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>本文为Hexo Fluid风格博客的个人使用方法笔记<br>具体官方引导请参照：<a href="https://hexo.fluid-dev.com/docs/">Hexo Fluid 用户手册</a></p><h2 id="上传更新笔记"><a href="#上传更新笔记" class="headerlink" title="上传更新笔记"></a>上传更新笔记</h2><h3 id="新建笔记"><a href="#新建笔记" class="headerlink" title="新建笔记"></a>新建笔记</h3><p>本地博客目录下\source_posts 中新建MakeDown笔记</p><h3 id="Git-Bash"><a href="#Git-Bash" class="headerlink" title="Git Bash"></a>Git Bash</h3><p>本地博客目录下右键打开 Git Bash Here 命令窗口</p><h3 id="静态部署"><a href="#静态部署" class="headerlink" title="静态部署"></a>静态部署</h3><ol><li><p>输入 <font color=orange><code>hexo clean</code></font> 清除缓存文件和静态文件</p></li><li><p>再输入 <font color=orange><code>hexo g</code></font> 生成网站静态文件到默认设置的 public 文件夹</p></li></ol><h3 id="启用Hexo服务"><a href="#启用Hexo服务" class="headerlink" title="启用Hexo服务"></a>启用Hexo服务</h3><ol><li><p>输入 <font color=orange><code>hexo clean</code></font> 清除缓存文件和静态文件</p></li><li><p>再输入 <font color=orange><code>hexo s</code></font> 启动本地服务器</p></li><li><p>预览主题: <em><a href="http://localhost:4000/">http://localhost:4000/</a></em></p></li></ol><blockquote><p>预览的同时可以修改文章内容或主题代码，保存后刷新页面即可；</p></blockquote><blockquote><p>对 Hexo 根目录 _config.yml 的修改，需要重启本地服务器后才能预览效果。</p></blockquote><h3 id="部署仓库"><a href="#部署仓库" class="headerlink" title="部署仓库"></a>部署仓库</h3><ol><li>使用 <font color=orange><code>ctrl + c</code></font> 结束服务器预览</li><li>输入 <font color=orange><code>hexo d</code></font> 自动生成网站静态文件，并部署到设定的仓库。<blockquote><p>有时会报如下错误<br><img src="data:image/png;base64,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" alt="Git Error 10054"><br>解决办法：等会重试一遍(蛮随机的)，或者用魔法</p></blockquote></li></ol><h4 id="查看效果"><a href="#查看效果" class="headerlink" title="查看效果"></a>查看效果</h4><p>访问<a href="https://godxqi.github.io/">GODXQI Hexo 主页</a></p><blockquote><p>结果可能会延迟</p></blockquote><blockquote><p>命令简化:使用’|’串联多个命令<br>如：<font color=orange><code>hexo clean|hexo g|hexo clean|hexo s</code></font><br>虽然报错了，但看起来能用</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作流程</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
